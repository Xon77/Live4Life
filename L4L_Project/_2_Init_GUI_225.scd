(

// { // à décommenter pour mesurer la rapidité d'affichage de la GUI et réorganistion des sons

// var serverFXV, nameFXV, portFXV;
// if ( ~serverFX == 0, { }, { /*serverFXV = serverFX; nameFXV = nameFX; portFXV = portFX;*/ } );

"Waiting for GUI loading !!!".postln;



~prevLemurConnected1 = ~lemurConnected1; // Pour éviter d'avoir à reconnecter le Lemur quand on relance la GUI
~prevLemurConnected2 = ~lemurConnected2;
~lemurConnected1 = 0; ~lemurConnected2 = 0;
/*~prevTwister = ~twister;
~twister = nil;*/



if (~server2.notNil, {~nbOfServers = 2}, {~nbOfServers = 1} );



// Répétition du code dans Init Buffer Synths au cas où la résolution ait été modifié entre temps
~windowHeight = Window.screenBounds.height/*.asInteger*/; // ~windowHeight = Window.availableBounds.height/*.asInteger*/;
~windowWidth = Window.screenBounds.width/*.asInteger*/;
if (Platform.architecture == \x86_64, {~windowTopMargin = 0; ~windowUpperMargin = 6}, {~windowTopMargin = 26; ~windowUpperMargin = 0}); // ~windowUpperMargin devrait être associé non pas à la hauteur, mais au système -> Mac 10.14, mais il s'avérait que j'utilisais une hauteur de 1200 pour cette configuration



if (~autoScaleGUI == 1, {
	~mulsize = min(~windowWidth/1920, ~windowHeight/1200);
	~xSizeMul = ~mulsize; ~ySizeMul = ~mulsize; ~fontSizeMul = ~mulsize;
	if (~mulsize < 1, {
		~mulsize = min(~windowWidth/1920, ~windowHeight/(1200+(20*~mulsize.reciprocal))); // +20 pour l'automationWindow et l'agrandissement du Server Info on IDE - a surtout un impact sur les anciennes résolutions graphiques sur Mac OS 10.14
	});
});
~xSizeMul = ~mulsize; ~ySizeMul = ~mulsize; ~fontSizeMul = ~mulsize;



// Réorganisation de l'ordre des Buffers dans les dossiers
// prend quelques secondes

// Additional sorting for strings to reflect buffer OSX folders
// http://new-supercollider-mailing-lists-forums-use-these.2681727.n2.nabble.com/String-sorting-td4221351.html#a4221432
// http://new-supercollider-mailing-lists-forums-use-these.2681727.n2.nabble.com/naturalCompare-question-again-td6189140.html#a6189155
/*
["1_bass.aif", "10_file.wav", "2_sn.wav", "11_etc.aif"].sort{|x, y| x.naturalCompare(y)<0}
("1_ponyther".naturalCompare("0_ponytherb")<0)
("ponyther".naturalCompare("ponytherb")<0)
["hallb", "halla", "hallo", "hallz", "hallu", "hall"].sort{|x, y| x.compareRight(y)<0}
["hallb", "halla", "hallo", "hallz", "hallu", "hall"].sort{|x, y| x.compareLeft(y)<0}
*/

/*
~soundm['ins'][1][0].asString.split($/)[8].split($.)[0]
~soundm['Inflatable Bass Samples'][1][0].asString.split($/)[9].split($.)[0]
~soundm['Antique Saw Samples'][1][0].asString.split($/)[9].split($.)[0]
~soundm['4 Kik'].asString.split($/)[8].split($.)[0]
~soundm['4 Kik'].asString.split($/)[9]
~soundm['4 Kik'].asString.split($/)[10]

~soundsFolder.split($/).size +1

// tri classique des Buffers selon SC
~soundm['4 Kik'].collect { |i| i[0].asString.split($/)[9].split($.)[0].postln }
// tri des Buffers selon le classement OSX
~soundm['4 Kik'].collect { |i| i[0].asString.split($/)[9].split($.)[0]}.sort{|x, y| x.naturalCompare(y) < 0}
Post << ~soundm['4 Kik']

Post << ~soundm['7 Special'].sort{|x, y| x[0].asString.split($/)[9].split($.)[0].naturalCompare(y[0].asString.split($/)[9].split($.)[0]) < 0}
Post << ~soundm['7 Special'].sort{|x, y| x[0].asString.split($/)[9].split($.)[0] < y[0].asString.split($/)[9].split($.)[0]}
*/



// Pour faire un tri sur les fichiers sons peu importe l'emplacement du dossier son - 9 à l'origine
~soundsFilesPos = ~soundsFolder.split($/).size; // + 0 au lieu de + 1 en plus à cause du retrait de "/" dans ~soundm et le chargement des fichiers sons



// tri des Buffers selon le classement OSX // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// 1_bass.aif, 2_sn.wav, ..., 10_file.wav, 11_etc.aif

/*~soundsFolderDict.keys.do {|f|
~soundm[f].sort{|x, y| x.asString.split($/)[~soundsFilesPos]/*.split($.)[0]*/.naturalCompare(y.asString.split($/)[~soundsFilesPos]/*.split($.)[0]*/) < 0};
}; "Buffers order Reorganization".postln;*/




// tri classique des Buffers selon SC // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// 1_bass.aif, 10_file.wav, 11_etc.aif, 2_sn.wav, ...

/*~soundsFolderDict.keys.do {|f|
~soundm[f].sort{|x, y| x[0].asString.split($/)[~soundsFilesPos]/*.split($.)[0]*/ < y[0].asString.split($/)[~soundsFilesPos]/*.split($.)[0]*/};
}; "Buffers order Reorganization".postln;*/




~foldersStructureFunction = { |server|
	// .as(Set).as(Array) ou removeDups (wslib) pour les symbols
	~kindOfFolders = ~arrayOfFolderNames.collect {|i| i.split($ )[0] }.as(Set).as(Array).sort;

	~soundmSpecificSoundFiles = List.new ! ~kindOfFolders.size;
	~kindOfFolders.do { |atem, a| ~arrayOfFolderNames.do { |item, i| if (item.split($ )[0] == atem, { ~soundmSpecificSoundFiles[a].add(~soundm[server][item.asSymbol]) }) } };
	// Post << ~soundmSpecificSoundFiles[0]

	~kindOfFolders2 = ~kindOfFolders.collect {|i| i[1] }.as(Set).as(Array).sort;
	~soundmSpecificSoundFiles2 = List.new ! ~kindOfFolders2.size;
	~kindOfFolders2.do { |atem, a| ~arrayOfFolderNames.do { |item, i| if (item.split($ )[0][1] == atem, { ~soundmSpecificSoundFiles2[a].add(~soundm[server][item.asSymbol]) }) } };
	~kindOfFolders2 = ~kindOfFolders2.collect {|i| "2"+i };

	~kindOfFolders3 = ~kindOfFolders.collect {|i| i[0] }.as(Set).as(Array).sort;
	~soundmSpecificSoundFiles3 = List.new ! ~kindOfFolders3.size;
	~kindOfFolders3.do { |atem, a| ~arrayOfFolderNames.do { |item, i| if (item.split($ )[0][0] == atem, { ~soundmSpecificSoundFiles3[a].add(~soundm[server][item.asSymbol]) }) } };
	~kindOfFolders3 = ~kindOfFolders3.collect {|i| "1"+i };

	~kindOfFolders = ~kindOfFolders ++ ~kindOfFolders2 ++ ~kindOfFolders3;
	~soundmSpecificSoundFiles = ~soundmSpecificSoundFiles ++ ~soundmSpecificSoundFiles2 ++ ~soundmSpecificSoundFiles3;
	~kindOfFolders.do { |item, i| ~soundmSpecificSoundFiles[i] = ~soundmSpecificSoundFiles[i].asArray.flatten };

	~kindOfFoldersStructure = ~arrayOfFolderNames.collect {|i| i.split($ )[0] } ++ ~kindOfFolders ++ ["All"]; // Comment faire pour le convertir en de simples chiffres
};




~sortingClassicFunc = [
	{ |server|
		// tri des Buffers selon le classement OSX
		~soundsFolderDict.keys.do {|f|
			// if (f == 'ins', {
			// Chemin et séparation différente pour le dossier Insultes
			// ~soundm[f].sort{|x, y| x.asString.split($/)[8].split($.)[0].naturalCompare(y.asString.split($/)[8].split($.)[0]) < 0};

			~soundm[server][f].sort{|x, y| x.asString.split($/)[~soundsFilesPos]/*.split($.)[0]*/.naturalCompareWithSpaces(y.asString.split($/)[~soundsFilesPos]/*.split($.)[0]*/, ignoreCase: true) < 0};
		};
		~soundmAllSoundFiles = ~arrayOfFolderNames.collect { |item, i| ~soundm[server][~arrayOfFolderNames[i].asSymbol]}.flatten;
		// ~soundmKikHitSoundFiles = ~soundm['4 Kik'] ++ ~soundm['3 Hit'];

		if (~foldersStructure == 1, { ~foldersStructureFunction.(server) });

		"Buffers order Reorganization".postln;
	}, { |server|
		// tri classique des Buffers selon SC
		~soundsFolderDict.keys.do {|f|
			~soundm[server][f].sort{|x, y| x[0].asString.split($/)[~soundsFilesPos]/*.split($.)[0]*/ < y[0].asString.split($/)[~soundsFilesPos]/*.split($.)[0]*/};
		};
		~soundmAllSoundFiles = ~arrayOfFolderNames.collect { |item, i| ~soundm[server][~arrayOfFolderNames[i].asSymbol]}.flatten;

		if (~foldersStructure == 1, { ~foldersStructureFunction.(server) });

		"Buffers order Reorganization".postln;
	}, { |server|
		// tri classique des Buffers selon Windows
		~soundsFolderDict.keys.do {|f|
			~soundm[server][f].sort{|x, y| x[0].asString.split($\\)[~soundsFilesPos]/*.split($.)[0]*/ < y[0].asString.split($\\)[~soundsFilesPos]/*.split($.)[0]*/};
		};
		~soundmAllSoundFiles = ~arrayOfFolderNames.collect { |item, i| ~soundm[server][~arrayOfFolderNames[i].asSymbol]}.flatten;

		if (~foldersStructure == 1, { ~foldersStructureFunction.(server) });

		"Buffers order Reorganization".postln;
	}
];


Platform.case(
	\osx, {
		if (~server2.notNil, {
			~sortingClassicFunc[0].value(0); ~sortingClassicFunc[0].value(1); // 0 -> OSX / 1 -> SC
			// ~soundm['RE CigalesTam'][0].asString.split($/)[~soundsFilesPos-2] // -> Users
		},{
			~sortingClassicFunc[0].value(0);
		});

	},
	\linux,     {
		if (~server2.notNil, {
			~sortingClassicFunc[0].value(0); ~sortingClassicFunc[0].value(1); // 0 -> OSX / 1 -> SC
		},{
			~sortingClassicFunc[0].value(0);
		});

	},
	\windows,   { // car la méthode naturalCompareWithSpaces pose apparemment problème
		if (~server2.notNil, {
			~sortingClassicFunc[2].value(0); ~sortingClassicFunc[2].value(1); // 0 -> OSX / 1 -> SC / 2 -> Windows
		},{
			~sortingClassicFunc[2].value(0);
		});
		~windowTopMargin = 26; ~windowUpperMargin = 0
	}
);





/*
y = [6, 2, 1, 7, 5];
y.sort({ arg a, b; a < b });

z = [0, 4, 1, 3, 11]

The result I would like to obtain is :
[6, 1, 2, 7, 5]

y[z.copy.sort.collect(z.indexOf(_))]

z.copy.sort.collect(z.indexOf(_))
z.copy.sort.collect({ |i| z.indexOf(i)})

y[z.order]
*/











// Récupération des données du batch processing - Check SMIR file pour plus de détails

~collectSMIRData = {
	~soundData = ~soundsFolderDict.collect { |dir|
		(dir +/+ "*").pathMatch/*.sort*/.collect { |path|
			var getData;
			getData = SCMIRAudioFile.newFromZ("/Users/Xon77/Documents/Projets/ConsProject3_BeatCut2011/WithMathis/SMIR/Sounds2013-2-Cons/" ++ path.split($/)[~soundsFilesPos-1] ++ "/" ++ (path.splitext[0].basename ++".scmirZ"));
			// ~test.featuredata;
			// ~test.gatherFeaturesBySegments([0]).flatten
			// Nécessité du if .notNil pour mettre à 0 les fichiers en dessous d'une taille de fenêtre de 1024
			getData.basename.postln;
			if ((getData.featuredata[0]).notNil, {
				getData.gatherFeaturesBySegments([0]); // Besoin de l'évaluer 2x pour que celà soit effectif
				// [getData.basename.asString, getData.gatherFeaturesBySegments([0])] }, {[0]} ).flat; // flat permet d'éviter les FloatArray mais découpe le nom du fichier audio -> Symbol
				[getData.basename.asSymbol, getData.gatherFeaturesBySegments([0])].flat }, {[getData.basename.asSymbol, 0!15].flat} );
		}
	}
};

/*
~collectSMIRData.value;
~soundData.cs;
~soundData['4 Kik'][0] // le 1er fichier du dossier Hit
~soundData['4 Kik'][1]
*/



// tri des Buffers selon données SCMIR

// [[MFCC, 1],[Chromagram, 1],[Loudness],[Tartini],[SpecCentroid],[SpecPcile, 0.95],[SpecPcile, 0.8],[SpecFlatness],[FFTCrest],[FFTCrest, 0, 2000], [FFTCrest, 2000, 10000],[FFTSpread],[FFTSlope],[SensoryDissonance]]

/*
~typeOfSorting = 0 // MFCC
~typeOfSorting = 1 // Chromagram
~typeOfSorting = 2 // Loudness
~typeOfSorting = 3 // Tartini Freq
~typeOfSorting = 4 // Tartini HasFreq
~typeOfSorting = 5 // SpecCentroid
~typeOfSorting = 6 // SpecPcile 0.95
~typeOfSorting = 7 // SpecPcile 0.8
~typeOfSorting = 8 // SpecFlatness
~typeOfSorting = 9 // FFTCrest
~typeOfSorting = 10 // FFTCrest (0, 2000)
~typeOfSorting = 11 // FFTCrest (2000, 10000)
~typeOfSorting = 12 // FFTSpread
~typeOfSorting = 13 // FFTSlope
~typeOfSorting = 14 // SensoryDissonance
*/

/*
Those adjectives can be represented in different ways.
"Noisiness" is sometimes represented using spectral flatness (see SpecFlatness.kr) or spectral crest (see FFTCrest.kr in sc3-plugins).
"Brightness" is commonly represented using spectral centroid (see SpecCentroid.kr) although there are others.
*/



// ~soundm = ~soundsFolderDict.collect { |dir| var subfolder = dir.asAbsolutePath.split($/)[~soundsFilesPos-1].asSymbol; ~soundm[subfolder][~soundData[subfolder].flop[~typeOfSorting+1].order] };

~sortingSMIRFunc =
{ | sortType, server|
	~sortingClassicFunc[1].value;

	~soundm[server] = ~soundsFolderDict.collect { |dir|
		var subfolder = dir.asAbsolutePath.split($/)[~soundsFilesPos-1].asSymbol;
		~soundm[server][subfolder][~soundData[subfolder].flop[sortType+1].order] };

	~orderAllSoundFiles = ~arrayOfFolderNames.collect { |item, i| ~soundData[~arrayOfFolderNames[i].asSymbol]}.flatten.flop[~typeOfSorting+1].order;
	~soundmAllSoundFiles = ~arrayOfFolderNames.collect { |item, i| ~soundm[server][~arrayOfFolderNames[i].asSymbol]}.flatten;
	~soundmAllSoundFiles = ~soundmAllSoundFiles[~orderAllSoundFiles];

	~orderKikHitSoundFiles = ['4 Kik', '3 Hit'].collect { |item, i| ~soundData[~arrayOfFolderNames[i].asSymbol]}.flatten.flop[~typeOfSorting+1].order;
	~soundmKikHitSoundFiles = ~soundm[server]['4 Kik'] ++ ~soundm[server]['3 Hit'];
	~soundmKikHitSoundFiles = ~soundmKikHitSoundFiles[~orderKikHitSoundFiles];
};

/*
~typeOfSorting = 5; // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
~sortingSMIRFunc.value(~typeOfSorting);
*/



// Comment trier les sous-dossiers qui n'ont pas de données ??????

/*~soundsFolderDict.keys.do {|f|
if (f == 'ins', {
// Chemin et séparation différente pour le dossier Insultes
~soundm[f] = ~soundm[f][~soundData[f][~typeOfSorting].order];
~soundData2[f] = ~soundData[f][~typeOfSorting].sort
}, {
~soundm[f] = ~soundm[f][~soundData[f][~typeOfSorting].order];
~soundData2[f] = ~soundData[f][~typeOfSorting].sort
});
}; "Buffers order Reorganization".postln;*/































// ServerMeter

~visualizeServerMeter = { |server, left, width|
	// ServerMeter - Appremment affichage jusqu'à +6 et non 0 -> l'avant dernière marque infique le 0 ?
	// depuis SC 3.13 -> en GUI server.meter.serverMeter.window -> serverMeter rajouté
	if (server == ~server1, { ~levelsWindow = server.meter.serverMeter.window.alwaysOnTop_(true).bounds = Rect(left, 0, width, 220); // Affichage des niveaux
	},{
		~levelsWindow2 = server.meter.serverMeter.window.alwaysOnTop_(true).bounds = Rect(left, 0, width, 220);
	});
	// s.meter; // ServerMeterView
};

// ~levelsWindow.close;



// Spatioscope

// supply locations by hand - 1@1 is left bottom.
// z = SpatioScope([ -0.5 @ -0.5, 0.5 @ -0.5, 0.0 @ -0.5, 0.5 @ 0.5, -0.5 @ 0.5 ], bounds: Rect(-200, 50, 200, 200)); // Attention - ne pas faire de décalage sinon les speakers n'apparaissent pas
// z = SpatioScope.new([ -0.5 @ -0.5, 0.5 @ -0.5, 0.0 @ -0.5, 0.5 @ 0.5, -0.5 @ 0.5 ], s, ~patComp[t][s], Rect(50, 50, 80, 80)); // n'accepte pas les CompositeView ???
// z = SpatioScope.new([ -0.5 @ -0.5, 0.5 @ -0.5, 0.0 @ -0.5, 0.5 @ 0.5, -0.5 @ 0.5 ], s, w, Rect(5, 900, 200, 200)); fait bouger seulement la structure des speakers ???

// voir la possibilité de suivre un pattern sur le spatioscope car d'origine regarde sur le serveur ????
(
~visualizeSpatioScope = { | sizeMul = 1 |

	if (~visualizeLevels == "SpatioScope" and: { ~numChannelsConfig != "2" }, {
		~spatioScopeWindow = Window("Spatioscope", Rect(0, 0 /*960*/, 10+(250*sizeMul), 20+(250*sizeMul))).alwaysOnTop_(true).front;
		~controlWindowTopLeft = 260;
	}, {
		~controlWindowTopLeft = /*280*/ /*(297 + ~windowHeight - 1200 + ~windowUpperMargin)*/ 230-~windowUpperMargin;
	});

	// à créer le 7 sorties et rien pour le 2 sorties

	case

	{~numChannelsConfig == "2"} {
		// Version Stéréo
		// ~spatioScopePlayer = SpatioScope([ -0.5 @ -0.5, 0.5 @ -0.5 ], parent:~spatioScopeWindow , bounds: Rect(0, 0, 250, 250));
		if (~nbOfServers == 2, {
			if (~numChannelsFX == 16, {~visualizeServerMeter.value(~server2, 0, 390)}, {~visualizeServerMeter.value(~server2, 70, 140)});
		});
		if (~numChannelsFX == 16, {~visualizeServerMeter.value(~server1, 0, 390)}, {~visualizeServerMeter.value(~server1, 0, 140)});
		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "4"} {
		if (~visualizeLevels == "SpatioScope", {
			// Version Quadriphonie
			~spatioScopePlayer = SpatioScope([ -0.5 @ -0.5, 0.5 @ -0.5, 0.5 @ 0.5, -0.5 @ 0.5 ], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
		}, { if (~nbOfServers == 2, { ~visualizeServerMeter.value(~server2, 102, 170); }); // Affichage des niveaux
			~visualizeServerMeter.value(~server1, 0, 170);
		});
		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "5-Centre"} {
		if (~visualizeLevels == "SpatioScope", {
			// Version 5.(1) - Clockwise sauf Centre = 3 XXXXXX
			~spatioScopePlayer = SpatioScope([ -0.5 @ -0.5, 0.5 @ -0.5, 0.0 @ -0.5, 0.5 @ 0.5, -0.5 @ 0.5 ], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
		}, { ~visualizeServerMeter.value(~server1, 0, 190) });
		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "5-Clock"} {
		if (~visualizeLevels == "SpatioScope", {
			// Version 5.(1) - Clockwise à partir du Centre
			~spatioScopePlayer = SpatioScope.ring(num: 5, radius: 0.7, angleOffset: 1.5pi, server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
		}, { ~visualizeServerMeter.value(~server1, 0, 190) });
		~linksChannel = 5; ~rightChannel = 2;
	} // Version Ring avec 1 au centre & attribution clockwise

	{~numChannelsConfig == "7"} {
		if (~visualizeLevels == "SpatioScope", {
			// Version 7.(1)
			~spatioScopePlayer = SpatioScope.ring(num: 7, radius: 0.7, angleOffset: 1.5pi, server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
		}, { ~visualizeServerMeter.value(~server1, 0, 220) });
		~linksChannel = 7; ~rightChannel = 2;
	} // Version Ring avec 1 au centre & attribution clockwise

	{~numChannelsConfig == "8-Centre"} {
		if (~visualizeLevels == "SpatioScope", {
			// Version Octo Centre avec 1 au centre & attribution clockwise
			~spatioScopePlayer = SpatioScope.ring(num: 8, radius: 0.7, angleOffset: 1.5pi, server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
		}, { ~visualizeServerMeter.value(~server1, 0, 240) });
		~linksChannel = 7; ~rightChannel = 2;
	}

	{~numChannelsConfig == "8-PairClock"} {
		if (~visualizeLevels == "SpatioScope", {
			// Version Octo Paire avec 1 à gauche & attribution clockwise
			// ~spatioScopePlayer = SpatioScope([ -0.3 @ -0.7, 0.3 @ -0.7, 0.7 @ -0.3, 0.7 @ 0.3, 0.3 @ 0.7, -0.3 @ 0.7, -0.7 @ 0.3, -0.7 @ -0.3 ], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
			if (~serverFX == 0, {
				~spatioScopePlayer = SpatioScope([ -0.3 @ -0.7, 0.3 @ -0.7, 0.7 @ -0.3, 0.7 @ 0.3, 0.3 @ 0.7, -0.3 @ 0.7, -0.7 @ 0.3, -0.7 @ -0.3 ], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
			},{
				~spatioScopePlayer = SpatioScope([ -0.3 @ -0.7, 0.3 @ -0.7, 0.7 @ -0.3, 0.7 @ 0.3, 0.3 @ 0.7, -0.3 @ 0.7, -0.7 @ 0.3, -0.7 @ -0.3 ], server:~serverFX1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
			});
		}, {
			// ~visualizeServerMeter.value(~server1, 0, 240)
			(
				~levelsWindow = Window.new("Server Levels",  Rect(0, 0, /*303*/ 315, 194), scroll:true).background_(Color.grey(0.6)).alwaysOnTop_(true).front; // 315
				if (~serverFX == 0, {
					~serverLevels1 = ServerMeterViewCL.new(~server1, ~levelsWindow, -15@0, 0, 10, 20, 7); // auparavant Classe ServerMeterView1 sans les 2 derniers meterWidth & gapWidth
				},{
					~serverLevels1 = ServerMeterViewCL.new(~serverFX1, ~levelsWindow, -15@0, 0, 10, 20, 7);
				});
				if (~nbOfServers == 2, {
					if (~serverFX == 0, {
						~serverLevels2 = ServerMeterViewCL.new(~server2, ~levelsWindow, -15@95, 0, 10, 20, 7);
					},{
						~serverLevels2 = ServerMeterViewCL.new(~serverFX2, ~levelsWindow, -15@95, 0, 10, 20, 7);
					});
				});
			)
		});
		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "8-PairPair"} {
		if (~visualizeLevels == "SpatioScope", {
			// Version Octo Paire - config par paire de gauche à droite
			~spatioScopePlayer = SpatioScope([ -0.3 @ -0.7, 0.3 @ -0.7, -0.7 @ -0.3, 0.7 @ -0.3, -0.7 @ 0.3, 0.7 @ 0.3, -0.3 @ 0.7, 0.3 @ 0.7 ], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
		}, { ~visualizeServerMeter.value(~server1, 0, 240) });
		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "16-PairClock"} {
		// Version 16 Pistes Octo Paire avec 1 à gauche & attribution clockwise
		// ~visualizeServerMeter.value(~server1, 0, 390)
		// ~spatioScopePlayer = SpatioScope.ring(num: 16, radius: 0.7, angleOffset: 1.5pi, parent:~spatioScopeWindow , bounds: Rect(0, 0, 250, 250))
		~spatioScopePlayer = SpatioScope.ring(num: 16, radius: 0.7, angleOffset: (1.5 - (1/16)) * pi, server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant
		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "16-Dome-8-6-2-Pair"} {
		// Version 16 Pistes - Dome avec 1 à gauche & attribution clockwise
		// ~visualizeServerMeter.value(~server1, 0, 390)
		~spatioScopePlayer = SpatioScope([ -0.3 @ -0.7, 0.3 @ -0.7, -0.7 @ -0.3, 0.7 @ -0.3, -0.7 @ 0.3, 0.7 @ 0.3, -0.3 @ 0.7, 0.3 @ 0.7, -0.3 @ -0.3, 0.3 @ -0.3, -0.3 @ 0.3, 0.3 @ 0.3, 0 @ -0.45, 0 @ 0.45, -0.15 @ 0, 0.15 @ 0 ], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant
		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "16-Dome-8-6-2-Clock" or: {~numChannelsConfig == "16-UsineC-2Octo"}} {
		if (~visualizeLevels == "SpatioScope", {
			// Version 16 Pistes - Dome avec 1 à gauche & attribution clockwise
			if (~serverFX == 0, {
				~spatioScopePlayer = SpatioScope.rings(nums: [8, 6, 2], radii: [0.8, 0.5, 0.15], angleOffsets: [(1.5 - (1/8)) * pi, /*(1.5 - (1/6)) * pi*/ 1.5pi, (1.5 - (1/2)) * pi], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant
			},{
				~spatioScopePlayer = SpatioScope.rings(nums: [8, 6, 2], radii: [0.8, 0.5, 0.15], angleOffsets: [(1.5 - (1/8)) * pi, /*(1.5 - (1/6)) * pi*/ 1.5pi, (1.5 - (1/2)) * pi], server:~serverFX1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
			});
		},{
			// ~visualizeServerMeter.value(~server1, 0, 390)
			(
				~levelsWindow = Window.new("Server Levels",  Rect(0, 0, /*303*/ 315, 194), scroll:true).background_(Color.grey(0.6)).alwaysOnTop_(true).front; // 315
				if (~serverFX == 0, {
					~serverLevels1 = ServerMeterViewCL.new(~server1, ~levelsWindow, -15@0, 0, 18, 14, 1); // auparavant Classe ServerMeterView2 sans les 2 derniers meterWidth & gapWidth
				},{
					~serverLevels1 = ServerMeterViewCL.new(~serverFX1, ~levelsWindow, -15@0, 0, 18, 14, 1);
				});
				if (~nbOfServers == 2, {
					if (~serverFX == 0, {
						~serverLevels2 = ServerMeterViewCL.new(~server2, ~levelsWindow, -15@95, 0, 18, 14, 1);
					},{
						~serverLevels2 = ServerMeterViewCL.new(~serverFX2, ~levelsWindow, -15@95, 0, 18, 14, 1);
					});
				});
			)
		});
		~linksChannel = 1; ~rightChannel = 2;
	}


	{~numChannelsConfig == "16-Dome-8-6-2-Clock-CC"} {
		if (~visualizeLevels == "SpatioScope", {
			// Version 16 Pistes - Dome avec 1 à gauche & attribution clockwise
			if (~serverFX == 0, {
				~spatioScopePlayer = SpatioScope.rings(nums: [8, 6, 2], radii: [0.8, 0.5, 0.15], angleOffsets: [(1.5 - (1/8)) * pi, /*(1.5 - (1/6)) * pi*/ 1.5pi, (1.5 - (1/2)) * pi], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant
			},{
				~spatioScopePlayer = SpatioScope.rings(nums: [8, 6, 2], radii: [0.8, 0.5, 0.15], angleOffsets: [(1.5 - (1/8)) * pi, /*(1.5 - (1/6)) * pi*/ 1.5pi, (1.5 - (1/2)) * pi], server:~serverFX1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
			});
		},{
			// ~visualizeServerMeter.value(~server1, 0, 390)
			(
				~levelsWindow = Window.new("Server Levels",  Rect(0, 0, /*303*/ 315, 194), scroll:true).background_(Color.grey(0.6)).alwaysOnTop_(true).front; // 315
				if (~serverFX == 0, {
					~serverLevels1 = ServerMeterViewCL.new(~server1, ~levelsWindow, -15@0, 0, 20, 14, 1); // auparavant Classe ServerMeterView2 sans les 2 derniers meterWidth & gapWidth
				},{
					~serverLevels1 = ServerMeterViewCL.new(~serverFX1, ~levelsWindow, -15@0, 0, 20, 14, 1);
				});
				if (~nbOfServers == 2, {
					if (~serverFX == 0, {
						~serverLevels2 = ServerMeterViewCL.new(~server2, ~levelsWindow, -15@95, 0, 20, 14, 1);
					},{
						~serverLevels2 = ServerMeterViewCL.new(~serverFX2, ~levelsWindow, -15@95, 0, 20, 14, 1);
					});
				});
			)
			// ~serverLevels1.start
		});
		~linksChannel = 1; ~rightChannel = 2;
	}


	{~numChannelsConfig == "24-UsineC-3Octo"} {
		/*if (~visualizeLevels == "SpatioScope", {
		// Version 24 Pistes - TO DO - Dome avec 1 à gauche & attribution clockwise
		if (~serverFX == 0, {
		~spatioScopePlayer = SpatioScope.rings(nums: [8, 6, 2], radii: [0.8, 0.5, 0.15], angleOffsets: [(1.5 - (1/8)) * pi, /*(1.5 - (1/6)) * pi*/ 1.5pi, (1.5 - (1/2)) * pi], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant
		},{
		~spatioScopePlayer = SpatioScope.rings(nums: [8, 6, 2], radii: [0.8, 0.5, 0.15], angleOffsets: [(1.5 - (1/8)) * pi, /*(1.5 - (1/6)) * pi*/ 1.5pi, (1.5 - (1/2)) * pi], server:~serverFX1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
		});
		},{*/
		// ~visualizeServerMeter.value(~server1, 0, 390)
		(
			~levelsWindow = Window.new("Server Levels",  Rect(0, 0, /*303*/ 315, 194), scroll:true).background_(Color.grey(0.6)).alwaysOnTop_(true).front; // 315
			if (~serverFX == 0, {
				~serverLevels1 = ServerMeterViewCL.new(~server1, ~levelsWindow, -15@0, 0, 27, 12, -1); // auparavant Classe ServerMeterView5 sans les 2 derniers meterWidth & gapWidth
			},{
				~serverLevels1 = ServerMeterViewCL.new(~serverFX1, ~levelsWindow, -15@0, 0, 27, 12, -1);
			});
			if (~nbOfServers == 2, {
				if (~serverFX == 0, {
					~serverLevels2 = ServerMeterViewCL.new(~server2, ~levelsWindow, -15@95, 0, 27, 12, -1);
				},{
					~serverLevels2 = ServerMeterViewCL.new(~serverFX2, ~levelsWindow, -15@95, 0, 27, 12, -1);
				});
			});
		);
		// ~serverLevels1.start
		// });
		~linksChannel = 1; ~rightChannel = 2;
	}


	{~numChannelsConfig == "32-Dome-12-10-8-2"} {
		if (~visualizeLevels == "SpatioScope", {
			// Version 32 Pistes - Dome avec 1 à gauche & attribution clockwise
			// ~visualizeServerMeter.value(~server1, 0, 390)
			if (~serverFX == 0, {
				~spatioScopePlayer = SpatioScope.rings(nums: [12, 10, 8, 2], radii: [0.9, 0.65, 0.4, 0.15], angleOffsets: [(1.5 - (1/12)) * pi, (1.5 - (1/10)) * pi, (1.5 - (1/8)) * pi, (1.5 - (1/2)) * pi], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant
			},{
				~spatioScopePlayer = SpatioScope.rings(nums: [12, 10, 8, 2], radii: [0.9, 0.65, 0.4, 0.15], angleOffsets: [(1.5 - (1/12)) * pi, (1.5 - (1/10)) * pi, (1.5 - (1/8)) * pi, (1.5 - (1/2)) * pi], server:~serverFX1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
			});
		},{
			(
				~levelsWindow = Window.new("Server Levels",  Rect(0, 0, /*303*/ 310, 197), scroll:true).background_(Color.grey(0.6)).alwaysOnTop_(true).front; // 315
				if (~serverFX == 0, {
					~serverLevels1 = ServerMeterViewCL.new(~server1, ~levelsWindow, -15@0, 0, 34, 11, -2); // auparavant Classe ServerMeterView3 sans les 2 derniers meterWidth & gapWidth
				},{
					~serverLevels1 = ServerMeterViewCL.new(~serverFX1, ~levelsWindow, -15@0, 0, 34, 11, -2);
				});

				if (~nbOfServers == 2, {
					if (~serverFX == 0, {
						~serverLevels2 = ServerMeterViewCL.new(~server2, ~levelsWindow, -15@95, 0, 34, 11, -2);
					},{
						~serverLevels2 = ServerMeterViewCL.new(~serverFX2, ~levelsWindow, -15@95, 0, 34, 11, -2);
					})
				});
			)
		});
		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "32-Dome-12-10-8-2-Motu"} {
		// Version 32 Pistes - Dome avec 1 à gauche & attribution clockwise
		// ~visualizeServerMeter.value(~server1, 0, 390)
		// ~spatioScopePlayer = SpatioScope.rings(nums: [12, 10, 8, 2], radii: [0.9, 0.65, 0.4, 0.15], angleOffsets: [(1.5 - (1/12)) * pi, (1.5 - (1/10)) * pi, (1.5 - (1/8)) * pi, (1.5 - (1/2)) * pi], parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant
		~linksChannel = 1; ~rightChannel = 2;
		// ~spatioScopePlayer.locations.cs
		~spatioScopePlayer = SpatioScope([ Point(-0.23293714059227, -0.86933324366016), Point(0.23293714059227, -0.86933324366016), Point(0.63639610306789, -0.63639610306789), Point(0.86933324366016, -0.23293714059227), Point(0.86933324366016, 0.23293714059227), Point(0.63639610306789, 0.63639610306789), Point(0.23293714059227, 0.86933324366016), Point(-0.23293714059227, 0.86933324366016), Point(-0.63639610306789, 0.63639610306789), Point(-0.86933324366016, 0.23293714059227), Point(-0.86933324366016, -0.23293714059227), Point(-0.63639610306789, -0.63639610306789), Point(-0.20086104634372, -0.61818673559185), Point(0.20086104634372, -0.61818673559185), Point(0.52586104634372, -0.38206041399011), Point(0.65, -1.5920408388916e-16), Point(0.52586104634372, 0.38206041399011), Point(0.20086104634372, 0.61818673559185), Point(-0.20086104634372, 0.61818673559185), Point(-0.52586104634372, 0.38206041399011), Point(-0.65, 2.3880612583373e-16), Point(-0.52586104634372, -0.38206041399011), Point(-0.15307337294604, -0.36955181300451), Point(0.15307337294604, -0.36955181300451), Point(0.36955181300451, -0.15307337294604), Point(0.36955181300451, 0.15307337294604), Point(0.15307337294604, 0.36955181300451), Point(-0.15307337294604, 0.36955181300451), Point(-0.36955181300451, 0.15307337294604), Point(-0.36955181300452, -0.15307337294604), Point(-0.15, 1.836970198721e-17), Point(0.15, -3.6739403974421e-17) ][/*~outsOrganization*/ [11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 21, 22, 13, 14, 15, 16, 17, 18, 19, 20, 25, 26, 27, 28, 29, 30, 31, 32, 23, 24 ].order], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));

		/*[ Point(-0.23293714059227, -0.86933324366016), Point(0.23293714059227, -0.86933324366016), Point(0.63639610306789, -0.63639610306789), Point(0.86933324366016, -0.23293714059227), Point(0.86933324366016, 0.23293714059227), Point(0.63639610306789, 0.63639610306789), Point(0.23293714059227, 0.86933324366016), Point(-0.23293714059227, 0.86933324366016), Point(-0.63639610306789, 0.63639610306789), Point(-0.86933324366016, 0.23293714059227), Point(-0.86933324366016, -0.23293714059227), Point(-0.63639610306789, -0.63639610306789), Point(-0.20086104634372, -0.61818673559185), Point(0.20086104634372, -0.61818673559185), Point(0.52586104634372, -0.38206041399011), Point(0.65, -1.5920408388916e-16), Point(0.52586104634372, 0.38206041399011), Point(0.20086104634372, 0.61818673559185), Point(-0.20086104634372, 0.61818673559185), Point(-0.52586104634372, 0.38206041399011), Point(-0.65, 2.3880612583373e-16), Point(-0.52586104634372, -0.38206041399011), Point(-0.15307337294604, -0.36955181300451), Point(0.15307337294604, -0.36955181300451), Point(0.36955181300451, -0.15307337294604), Point(0.36955181300451, 0.15307337294604), Point(0.15307337294604, 0.36955181300451), Point(-0.15307337294604, 0.36955181300451), Point(-0.36955181300451, 0.15307337294604), Point(-0.36955181300452, -0.15307337294604), Point(-0.15, 1.836970198721e-17), Point(0.15, -3.6739403974421e-17) ][/*~outsOrganization*/ [11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 21, 22, 13, 14, 15, 16, 17, 18, 19, 20, 25, 26, 27, 28, 29, 30, 31, 32, 23, 24 ].order]*/
	}

	{~numChannelsConfig == "32-Dome-UQAM-11-11-9-1"} {
		if (~visualizeLevels == "SpatioScope", {
			// Version 32 Pistes - Dome avec 1 à gauche & attribution clockwise
			// ~visualizeServerMeter.value(~server1, 0, 390)
			if (~serverFX == 0, {
				~spatioScopePlayer = SpatioScope.rings(nums: [11, 11, 9, 1], radii: [0.8, 0.65, 0.35, 0.05], angleOffsets: [(1.5 - (1/11)) * pi, (1.6 - (1/11)) * pi, (1.5 - (1/9)) * pi, (1.5 - (1)) * pi], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant
			},{
				~spatioScopePlayer = SpatioScope.rings(nums: [11, 11, 9, 1], radii: [0.8, 0.65, 0.35, 0.05], angleOffsets: [(1.5 - (1/11)) * pi, (1.6 - (1/11)) * pi, (1.5 - (1/9)) * pi, (1.5 - (1)) * pi], server:~serverFX1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul));
			});
		},{
			(
				~levelsWindow = Window.new("Server Levels",  Rect(0, 0, /*303*/ 310, 197), scroll:true).background_(Color.grey(0.6)).alwaysOnTop_(true).front; // 315
				if (~serverFX == 0, {
					~serverLevels1 = ServerMeterViewCL.new(~server1, ~levelsWindow, -15@0, 0, 32, 10, -1); // auparavant Classe ServerMeterView6 sans les 2 derniers meterWidth & gapWidth
				},{
					~serverLevels1 = ServerMeterViewCL.new(~serverFX1, ~levelsWindow, -15@0, 0, 32, 10, -1);
				});

				if (~nbOfServers == 2, {
					if (~serverFX == 0, {
						~serverLevels2 = ServerMeterViewCL.new(~server2, ~levelsWindow, -15@95, 0, 32, 10, -1);
					},{
						~serverLevels2 = ServerMeterViewCL.new(~serverFX2, ~levelsWindow, -15@95, 0, 32, 10, -1);
					})
				});
			)
		});
		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "22-8+Dome-8-4-2-Pair"} {
		// Version 16 Pistes - Dome avec 1 à gauche & attribution clockwise
		// ~visualizeServerMeter.value(~server1, 0, 390)
		// ~spatioScopePlayer = SpatioScope.rings(nums: [8, 4, 2], radii: [0.8, 0.5, 0.15], angleOffsets: [(1.5 - (1/8)) * pi, /*(1.5 - (1/6)) * pi*/ 1.5pi, (1.5 - (1/2)) * pi], parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant
		~spatioScopePlayer = SpatioScope([ -0.3 @ -0.7, 0.3 @ -0.7, -0.7 @ -0.3, 0.7 @ -0.3, -0.7 @ 0.3, 0.7 @ 0.3, -0.3 @ 0.7, 0.3 @ 0.7, -0.3 @ -0.3, 0.3 @ -0.3, -0.3 @ 0.3, 0.3 @ 0.3, -0.15 @ 0, 0.15 @ 0, -0.15 @ 0.9, 0.15 @ 0.9, -0.4 @ 0.9, 0.4 @ 0.9, -0.65 @ 0.9, 0.65 @ 0.9, -0.9 @ 0.9, 0.9 @ 0.9 ], server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant
		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "64-CentreClock"} {

		if (~visualizeLevels == "SpatioScope", {
			~spatioScopePlayer = SpatioScope.ring(num: 64, radius: 0.7, angleOffset: (1.5 - (1/64)) * pi, server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant

		},{

			(
				~levelsWindow = Window.new("Server Levels",  Rect(0, 0, /*303*/ 315, 194), scroll:true).background_(Color.grey(0.6)).alwaysOnTop_(true).front; // 315
				~serverLevels1 = ServerMeterViewCL.new(~server1, ~levelsWindow, -15@0, 0, 64, 9, -4); // auparavant Classe ServerMeterView4 sans les 2 derniers meterWidth & gapWidth
				if (~nbOfServers == 2, {
					~serverLevels2 = ServerMeterViewCL.new(~server2, ~levelsWindow, -15@95, 0, 64, 9, -4);
				});
			)

		});

		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "96-CentreClock"} {

		if (~visualizeLevels == "SpatioScope", {
			~spatioScopePlayer = SpatioScope.ring(num: 96, radius: 0.7, angleOffset: (1.5 - (1/96)) * pi, server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant

		},{

			(
				~levelsWindow = Window.new("Server Levels",  Rect(0, 0, /*303*/ 315, 194), scroll:true).background_(Color.grey(0.6)).alwaysOnTop_(true).front; // 315
				~serverLevels1 = ServerMeterViewCL.new(~server1, ~levelsWindow, -10@0, 0, 96, 9, -4); // auparavant Classe ServerMeterView4 sans les 2 derniers meterWidth & gapWidth
				if (~nbOfServers == 2, {
					~serverLevels2 = ServerMeterViewCL.new(~server2, ~levelsWindow, -10@95, 0, 96, 9, -4);
				});
			)

		});

		~linksChannel = 1; ~rightChannel = 2;
	}

	{~numChannelsConfig == "128-CentreClock"} {

		if (~visualizeLevels == "SpatioScope", {
			~spatioScopePlayer = SpatioScope.ring(num: 128, radius: 0.7, angleOffset: (1.5 - (1/128)) * pi, server:~server1, parent:~spatioScopeWindow, bounds: Rect(0, 0, 250*sizeMul, 250*sizeMul)); // avec 1.5, le 1er HP est devant

		},{

			(
				~levelsWindow = Window.new("Server Levels",  Rect(0, 0, /*303*/ 315, 194), scroll:true).background_(Color.grey(0.6)).alwaysOnTop_(true).front; // 315
				~serverLevels1 = ServerMeterViewCL.new(~server1, ~levelsWindow, -10@0, 0, 128, 9, -4); // auparavant Classe ServerMeterView4 sans les 2 derniers meterWidth & gapWidth
				if (~nbOfServers == 2, {
					~serverLevels2 = ServerMeterViewCL.new(~server2, ~levelsWindow, -10@95, 0, 128, 9, -4);
				});
			)

		});

		~linksChannel = 1; ~rightChannel = 2;
	};

};
);

~visualizeSpatioScope.value(1);


// Pour affichage du SpatioScope en plus grand -> fonction ci-dessous à déclencher XXXXXXXXXXXXXXXXXXXXXXXX
/*
(
~spatioScopeWindow.view.removeAll; ~spatioScopeWindow.close; ~spatioScopePlayer.stop; ~spatioScopePlayer.proxy.clear;
~visualizeSpatioScope.(2);
)
*/

/*
Pour la construction d'un ring dans le sens des aiguilles d'une montre
.rings (pour le construction d'anneaux concentriques
.ring(num, radius, angleOffset, server, parent, bounds)
z = SpatioScope.ring(5, 0.5, 1.5pi);	// radius, rotate location clockwise -> top
z = SpatioScope.ring(7, 0.5, 1.5pi);	// radius, rotate location clockwise -> top


in SpeakersCorner Quark - see also MasterFX class to add switchable master effects on the main outputs,  e.g. using SpeakerAdjust, limiters, etc.
4 chans of sound
{ LFDNoise3.ar([2, 3, 5, 8] * 1000) * LFNoise2.kr([5, 8, 13, 21] * 0.1).max(0); }.play;
4 chans of sound ( qui tournent dans le sns des aiguilles d'une montre puis de l'autre côté)
{ PanAz.ar(4, ClipNoise.ar, LFSaw.kr(SinOsc.ar(0.03) * 1), 0.1) }.play;
test with several sources
{ { Ringz.ar(Dust2.ar(5), exprand(300, 10000), exprand(0.03, 0.1)) }.dup(12) }.play;
*/










// Pour checker les interruptions potentielles du Server

if (~server2.notNil, {
	ServerBoot.add({ "Server 1 has booted".postln }, ~server1); ServerQuit.add({ "Server 1 has quit".postln; ~server1.serverRunning.postln; }, ~server1);
	ServerBoot.add({ "Server 2 has booted".postln }, ~server2); ServerQuit.add({ "Server 2 has quit".postln; ~server2.serverRunning.postln; }, ~server2);
},{
	ServerBoot.add({ "Server 1 has booted".postln }, ~server1); ServerQuit.add({ "Server 1 has quit".postln; ~server1.serverRunning.postln; }, ~server1);
});
// Mais le lancement d'un pattern très rapide ou d'un EQ qui pourrait provoquer une surcharge du langage provoque des déconnexions du serveur et un blocage du synthé & des valeurs du Nodeproxy & des nodes temporaires lorsque trigger action sur le bus 5 ???
// if(s.serverRunning/*.not*/,{"server running".postln}, {"server not running".postln })
// s.serverRunning






























// Declaration of global variables

~nbOfTracks = 8; // Change the nb of tracks available XXXXXX
// ~nbOfSeqs = 40; // Change the nb of sequences available XXXXXX - défini à l'initialisation

~nbOfTracksX2 = ~nbOfTracks * 2;

~tracks = (0.. ((~nbOfTracks*2)-1)); // pour la création des arrays
~tracksList = (0.. ((~nbOfTracks)-1)); // pour la création des listes
~seqs = (0.. (~nbOfSeqs-1));

~patterns = [\a_one, \b_two, \c_three, \d_four, \e_five, \f_six, \g_seven, \h_height, \i_nine, \j_ten, \k_eleven, \l_twelve, \m_thirteen, \n_fourteen, \o_fifteen, \p_sixteen ];
~patterns2 = [\a_one, \a_one, \b_two, \b_two, \c_three, \c_three, \d_four, \d_four, \e_five, \e_five, \f_six, \f_six, \g_seven, \g_seven, \h_height, \h_height ];

~lastEvent = 0 ! ~nbOfTracksX2; // pour le collect du pattern

~modes = [\jump, \drag];

// Bus de contrôle
// ~numberOfControlBus = /*6*/ 20; // mis à l'initialisation
// ~controlBus = 0 ! ~numberOfControlBus; // Le collect est fait dans le pattern
// ~controlBusSynth = 0 ! ~numberOfControlBus; // Le collect est fait dans le pattern
~controlBusNames = ~nbOfControlBus.collect { |i| "Bus"++i };
// ~controlBusNames01 = ~numberOfControlBus.collect { |i| "Bus"++i++"1" }; // Test
// ~controlBusNames0R = ~numberOfControlBus.collect { |i| "Bus"++i++"R" }; // Test
~controlBusSynthGUIContainerCheck = 0;



// Déclaration Position GUI - 5 Containers verticaux
// hauteur = 212 * 5;
~multiSliderHeight5 = 116*~ySizeMul;

~viewPos5 = Rect(2*~xSizeMul, (2+16)*~ySizeMul, 333*~xSizeMul, 116*~ySizeMul);
~posViewPos5 = Rect(7*~xSizeMul, 2*~ySizeMul, 333*~xSizeMul, 16*~ySizeMul);
~readViewPos5 = Rect(2*~xSizeMul, 2*~ySizeMul, 333*~xSizeMul, 16*~ySizeMul);

~rangeViewPos5 = Rect(337*~xSizeMul, (2+16)*~ySizeMul, 30*~xSizeMul, 100*~ySizeMul);
~rangeModePos5 = Rect(337*~xSizeMul, (102+16)*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul);
~mulViewPos5 = Rect(367*~xSizeMul, (2+16)*~ySizeMul, 30*~xSizeMul, 116*~ySizeMul);

~seqViewPos5 = Rect(2*~xSizeMul, (138+16)*~ySizeMul, 333*~xSizeMul, 22*~ySizeMul);
~indexViewPos5 = Rect(2*~xSizeMul, (160+16)*~ySizeMul, 333*~xSizeMul, 16*~ySizeMul);

~roundViewPos5 = Rect(2*~xSizeMul, (120+16)*~ySizeMul, 100*~xSizeMul, 16*~ySizeMul);
~randViewPos5 = Rect(104*~xSizeMul, (120+16)*~ySizeMul, 35*~xSizeMul, 16*~ySizeMul);
~seqAllViewPos5 = Rect(141*~xSizeMul, (120+16)*~ySizeMul, 35*~xSizeMul, 16*~ySizeMul);
~seqModePos5 = Rect(178*~xSizeMul, (120+16)*~ySizeMul, 35*~xSizeMul, 16*~ySizeMul);

~copyAViewPos5 = Rect(215*~xSizeMul, (120+16)*~ySizeMul, 22*~xSizeMul, 16*~ySizeMul);
~pasteAViewPos5 = Rect(237*~xSizeMul, (120+16)*~ySizeMul, 22*~xSizeMul, 16*~ySizeMul);
~pasteMViewPos5 = Rect(259*~xSizeMul, (120+16)*~ySizeMul, 22*~xSizeMul, 16*~ySizeMul);
~defaultViewPos5 = Rect(281*~xSizeMul, (120+16)*~ySizeMul, 22*~xSizeMul, 16*~ySizeMul);

~rangePresetViewPos5 = Rect(304*~xSizeMul, (120+16)*~ySizeMul, 54*~xSizeMul, 16*~ySizeMul);
~mulPresetViewPos5 = Rect(358*~xSizeMul, (120+16)*~ySizeMul, 40*~xSizeMul, 16*~ySizeMul);

~displayPos5 = Rect(2*~xSizeMul, (178+16)*~ySizeMul, 300*~xSizeMul, 19*~ySizeMul);

~dirViewPos5 = Rect(302*~xSizeMul, (180+16)*~ySizeMul, 16*~xSizeMul, 16*~ySizeMul);
~patViewPos5 = Rect(320*~xSizeMul, (180+16)*~ySizeMul, 24*~xSizeMul, 16*~ySizeMul);
~patSelViewPos5 = Rect(346*~xSizeMul, (180+16)*~ySizeMul, 52*~xSizeMul, 16*~ySizeMul);

~miniSlider1Pos5 = Rect(338*~xSizeMul, 156*~ySizeMul, 60*~xSizeMul, 18*~ySizeMul);
~miniSlider2Pos5 = Rect(338*~xSizeMul, 174*~ySizeMul, 60*~xSizeMul, 18*~ySizeMul);

~nameModPos = Rect(145*~xSizeMul, 18*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul); // Position of Names of Modules
~nameModPos2 = Rect(155*~xSizeMul, 18*~ySizeMul, 70*~xSizeMul, 20*~ySizeMul); // Position of Names of Modules for RAT...



// View Harmonisation Multiple
~viewHarPos5 = Rect(2*~xSizeMul, 2*~ySizeMul, 303*~xSizeMul, 116*~ySizeMul);

~rangeViewHarPos5 = Rect(307*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 100*~ySizeMul);
~rangeModeHarPos5 = Rect(307*~xSizeMul, 102*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul);
~mulViewHarPos5 = Rect(367*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 116*~ySizeMul);

~seqViewHarPos5 = Rect(2*~xSizeMul, 138*~ySizeMul, 303*~xSizeMul, 22*~ySizeMul);

~roundViewHarPos5 = Rect(2*~xSizeMul, 120*~ySizeMul, 100*~xSizeMul, 16*~ySizeMul);
~randViewHarPos5 = Rect(104*~xSizeMul, 120*~ySizeMul, 35*~xSizeMul, 16*~ySizeMul);
~seqAllViewHarPos5 = Rect(141*~xSizeMul, 120*~ySizeMul, 35*~xSizeMul, 16*~ySizeMul);
~seqModeHarPos5 = Rect(178*~xSizeMul, 120*~ySizeMul, 35*~xSizeMul, 16*~ySizeMul);
~defaultViewHarPos5 = Rect(246*~xSizeMul, 120*~ySizeMul, 22*~xSizeMul, 16*~ySizeMul);

~rangePresetViewHarPos5 = Rect(269*~xSizeMul, 120*~ySizeMul, 69*~xSizeMul, 16*~ySizeMul);

~displayHarPos5 = Rect(2*~xSizeMul, 162*~ySizeMul, 300*~xSizeMul, 30*~ySizeMul);

~nameModHarPos = Rect(135*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul); // Position of Names of Modules
// ~nameModHarPos2 = Rect(155, 2, 70, 20); // Position of Names of Modules for RAT...



// Déclaration Couleurs GUI sliders & containers

/*
~alphaColor = 0.8;
~seqCompColor = Color.red;
~patCompColor = Color(0.2, 0.1, 0.5, ~alphaColor);
~rtmCompColor = Color(0.2, 0.1, 0.5, ~alphaColor);
~compColor1 = Color(0.6, 0.2, 0.2, ~alphaColor);
~compColor2 = Color(0.5, 0.2, 0.3, ~alphaColor);
~strCompColor = Color(0.5, 0.3, 0.2, ~alphaColor);
~panCompColor = Color(0.2, 0.2, 0.6, ~alphaColor);
~fxCompColor = Color(0.2, 0.6, 0.2, ~alphaColor);
*/

// extension wslib
// deep_sky_blue,  sky_blue, light_sky_blue, dodger_blue, royal_blue
// orange, orange_red, tomato, sandy_brown, chocolate, dark_red
// dark_golden_rod, golden_rod, gold, peru
// forest_green, green
/*~seqCompColor = Color.web.peru;
~patCompColor = Color.web.peru;*/

~seqCompColor = Color.grey(0.2);
~patCompColor = Color.grey(0.2);
~rtmCompColor = Color.web.indigo.alpha_(0.7);
// ~rtmCompColor = Color.grey(0.3);

~compColor1 = Color.web.brown.alpha_(0.2).desaturate; // Color.new255(255, 130, 71);
~compColor2 = Color.web.brown.alpha_(0.2).desaturate; // 0.3 avant
~strCompColor = Color.web.brown.alpha_(0.2).desaturate;

~panCompColor = Color.web./*royal_blue*/dark_blue.alpha_(0.5);
// ~fxCompColor = Color.web.forest_green.alpha_(0.5);
~fxCompColor = Color(0,0.39,0).alpha_(0.5);

~multiRtmCompColor = Color.black(0.7);
~multiCompColor1 = Color.black(0.7);
~multiCompColor2 = Color.black(0.7);
~multiStrCompColor = Color.black(0.7);
~multiPanCompColor = Color.black(0.7);
~multiFxCompColor = Color.black(0.7);

/*
~sliderBackgroundColor = Color.grey(0.5); // + clairs
~sliderHilightNoColor = Color.grey(0.4);
~sliderHilightColor = Color.new255(0, 0, 200);
*/
~sliderBackgroundColor = Color.grey(0.5);
~sliderBackgroundColor2 = Color.grey(0.3);
~sliderHilightNoColor = /*Color.grey(0.3)*/ Color.blue(0.2, 0.3);
~sliderHilightColor = Gradient( Color.red.alpha_(1), Color.blue.alpha_(1), \v );

~border = 1;
~borderColor = Color.yellow/*grey(0)*//*red*/;

~popUpMenuBackgroundColor = Color.grey(0.8);
~popUpMenuStringColor = Color.black;



~multiSliderIndex = false;
~readViewThumbSize = 15*~xSizeMul; // Minimum Size of knob of ReadView Slider
~rtmThumbSizeValue = max((333 / 4)*~xSizeMul, ~readViewThumbSize) ! ~nbOfSeqs ! ~nbOfTracksX2; // Pour modif du ThumbSize du ReadViewSlider dans le Tab Global






























// Skinning systems for wslib

// Once the skin is set it remains there for all future RoundButtons. It can be removed by setting it to nil. Another way is to "push" a skin, via pushSkin. This works the same way as pushing an Environment, i.e. the current skin is stored and a new skin is added. When calling popSkin after this the previous skin will surface again.
// Attention -> augmente le chargement de la GUI de 2s max avec 8 tracks x 8 seqs
RoundButton.skin = (
	radius: 7,
	border: 1, // Avant Border 2
	focusColor: Color.clear, // Important pour ne pas voir l'auréole autour du bouton
	// background: Gradient( Color.white, Color.gray(0.7), \v ),
	// hiliteColor: Color.blue(0.75).alpha_(0.5),
	// font: Font( Font.defaultMonoFace, 9 ),
	// stringColor: Color.blue(0.5),
	// align: \center,
	// scroll_step: 0.01

	// view specific
	//'SmoothSlider': (focusColor: Color.red) // ne marche pas ???
);

// Possibilité de pusher d'autres skins et de revenir à l'ancienne avec popSkin
// RoundButton.popSkin;
// RoundButton.skin = nil;

// Examples of Skinning systems
// Check examples for applying skins at the end of RoundButton - Possibilité d'utiliser plusieurs modèles

/*
( // In this case the properties in the skin are applied to all views. There is an option to single out on a specific type of view. In this example some properties apply to all, and some are overridden for specific view types:
RoundButton.pushSkin( (

// global properties
radius: 4,
border: 1,
background: Gradient( Color.white, Color.gray(0.7), \v ),
hiliteColor: Color.web16.purple.alpha_(0.5),
font: Font( Font.defaultMonoFace, 9 ),
stringColor: Color.web16.purple.brightness( -0.33 ),
align: \center,
focusColor: Color.clear,

// view specific
'RoundNumberBox': (scroll_step: 0.01, //additional
normalColor: Color.web16.purple.brightness( -0.33 ),
clipLo: 0,
clipHi: 1 ),

'RoundButton': ( 	font: Font( Font.defaultSansFace, 9 ).boldVariant ), // override

'RoundRangeSlider': ( 	background: Gradient( Color.white.alpha_(0), Color.gray(0.7), \h ),
knobColor: Gradient( Color.white, Color.gray(0.1), \h ),
stringAlignToKnob: true,
minRange: 0.1
)
)
);

w = Window( "round skin system" ).front;
w.addFlowLayout;

10.do({ |i|
RoundButton( w, 20@20 ).label_( i.asString.dup );
RoundNumberBox( w, 40@20 ).value_((1/(i+1)).round(0.01));
RoundRangeSlider( w, 320@20 )
.value_(0.5 + ([-0.5,0.5] /(i+1)))
.string_( i.asString );
});

RoundButton.popSkin;
)
*/


/*
( // And the final way to skin is by doing it directly to the RoundButton itself, via applySkin. This is the best way if the skin is only meant for a few objects in between others.
w = Window( "RoundButton skins" ).front;
w.addFlowLayout;

// the skin
z = ( 	radius: 3,
border: 1,
extrude: false,
background: Gradient( Color.white, Color.gray(0.7), \v ),
font: Font( Font.defaultSansFace, 11 ).boldVariant,
stringColor: Color.red(0.25)
);

a = RoundButton( w, 60@18 ).label_( "normal" );
b = RoundButton( w, 60@18 ).label_( "skinned" ).applySkin( z );
c = RoundButton( w, 120@18 ).label_( "normal again" );
)
*/






























// Load functions

~makeRandFunction = { | envir, funcName, data, multiView, dataDur, durData, seqView, seqStart, seqStop, seqSpec, seqVSpec, readView |

	envir[funcName] = { | tr, seq |
		var dur = envir[dataDur][~tracksValue][~seqsValue].size;

		if (envir[seqView].range == 1 || envir[data][~tracksValue][~seqsValue].size != dur, {
			envir[data][~tracksValue][~seqsValue] = {rrand(0.0,1.0)} ! dur;
			envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue]);
		}, {
			envir[multiView].valueAction_( envir[data][~tracksValue][~seqsValue].putEach((envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]), {rrand(0.0,1.0)} ! envir[durData][~tracksValue][~seqsValue]) );
		});

		envir[seqSpec][tr][seq] = ControlSpec(0, envir[dataDur][tr][seq].size, \lin, 1, 1);
		envir[seqVSpec][tr][seq] = ControlSpec(0, envir[dataDur][tr][seq].size-1, \lin, 1, 1);
		envir[readView].thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / envir[dataDur][tr][seq].size));
		envir[seqView].step_(1/(dur))
		.minRange_(1/(dur))
		.valueAction_(envir[seqView].value) // Léger bug visuel quand le nb de valeurs dans le multislider change et est inférieur -> OK maintenant
		.doAction; // nécessaire sinon toujours bug visuel quand le nb de valeurs dans le multislider change et est supérieur et pas de mise à jour si range = 1
	}
};

/*~synthese = { | track, seq | var dur = ~dur[~tracksValue][~seqsValue].size;
/*~syn[track][seq] = { rrand(~synMin[track][seq], ~synMax[track][seq]).round(1) } ! ~dur[track][seq].size;
~syn[track][seq] = ~synSpec[track][seq].unmap(~syn[track][seq]);
~synView.valueAction_(~syn[track][seq]);*/ // agissait sur toute la séquence - maintenant seulement sur la séquence sélectionnée sauf si SeqView.range == 1

if (~synSeqView.range == 1 || ~syn[~tracksValue][~seqsValue].size != dur, {
~syn[~tracksValue][~seqsValue] = {rrand(0.0,1.0)} ! dur;
~synView.valueAction_(~syn[~tracksValue][~seqsValue]);
}, {
~synView.valueAction_( ~syn[~tracksValue][~seqsValue].putEach((~synSeqStart[~tracksValue][~seqsValue]..~synSeqStop[~tracksValue][~seqsValue]), {rrand(0.0,1.0)} ! ~seqDurSyn[~tracksValue][~seqsValue]) );
});

~synSeqSpec[track][seq] = ControlSpec(0, ~dur[track][seq].size, \lin, 1, 1);
~synSeqVSpec[track][seq] = ControlSpec(0, ~dur[track][seq].size-1, \lin, 1, 1);
~synReadView.thumbSize_(max(~readViewThumbSize, 333 / ~dur[track][seq].size));
~synSeqView.step_(1/(dur))
.minRange_(1/(dur))
// .valueAction_([0,~syn[track][seq].size]-1) // pour englober toute la séquence, -> rupture quand rand
.valueAction_(~synSeqView.value) // Léger bug visuel quand le nb de valeurs dans le multislider change et est inférieur -> OK maintenant
.doAction; // nécessaire sinon toujours bug visuel quand le nb de valeurs dans le multislider change et est supérieur et pas de mise à jour si range = 1
};*/


/*~buffer = { | track, seq | var dur = ~dur[~tracksValue][~seqsValue].size;
/*~buf[track][seq] = { rrand(~bufMin[track][seq], ~bufMax[track][seq]).round(1) } ! ~dur[track][seq].size;
~buf[track][seq] = ~bufSpec[track][seq].unmap(~buf[track][seq]);
~bufView.valueAction_(~buf[track][seq]);*/ // agissait sur toute la séquence - maintenant seulement sur la séquence sélectionnée sauf si SeqView.range == 1

// Comparaison des performances -> pratiquement identique entre 1 action sur toute la séquence ou une partie de la séquence
/*
{~buf[~tracksValue][~seqsValue] = { rrand(~bufMin[~tracksValue][~seqsValue], ~bufMax[~tracksValue][~seqsValue]).round(1) } ! ~dur[~tracksValue][~seqsValue].size;
~buf[~tracksValue][~seqsValue] = ~bufSpec[~tracksValue][~seqsValue].unmap(~buf[~tracksValue][~seqsValue]);
~bufView.valueAction_(~buf[~tracksValue][~seqsValue]) }.bench;

{~bufView.valueAction_( ~buf[~tracksValue][~seqsValue].putEach((~bufSeqStart[~tracksValue][~seqsValue]..~bufSeqStop[~tracksValue][~seqsValue]), {rrand(0.0,1.0)} ! ~seqDurBuf[~tracksValue][~seqsValue]) ) }.bench;

{if (~bufSeqView.range == 1, {
~buf[~tracksValue][~seqsValue] = {rrand(0.0,1.0)} ! ~dur[~tracksValue][~seqsValue].size;
~bufView.valueAction_(~buf[~tracksValue][~seqsValue]);
}, {
~bufView.valueAction_( ~buf[~tracksValue][~seqsValue].putEach((~bufSeqStart[~tracksValue][~seqsValue]..~bufSeqStop[~tracksValue][~seqsValue]), {rrand(0.0,1.0)} ! ~seqDurBuf[~tracksValue][~seqsValue]) );
}) }.bench;
*/

if (~bufSeqView.range == 1 || ~buf[~tracksValue][~seqsValue].size != dur, {
~buf[~tracksValue][~seqsValue] = {rrand(0.0,1.0)} ! dur;
~bufView.valueAction_(~buf[~tracksValue][~seqsValue]);
}, {
~bufView.valueAction_( ~buf[~tracksValue][~seqsValue].putEach((~bufSeqStart[~tracksValue][~seqsValue]..~bufSeqStop[~tracksValue][~seqsValue]), {rrand(0.0,1.0)} ! ~seqDurBuf[~tracksValue][~seqsValue]) );
});

~bufSeqSpec[track][seq] = ControlSpec(0, ~dur[track][seq].size, \lin, 1, 1);
~bufSeqVSpec[track][seq] = ControlSpec(0, ~dur[track][seq].size-1, \lin, 1, 1);
~bufReadView.thumbSize_(max(~readViewThumbSize, 333 / ~dur[track][seq].size));
~bufSeqView.step_(1/dur)
.minRange_(1/dur)
// .valueAction_([0,~buf[track][seq].size]-1) // pour englober toute la séquence, -> rupture quand rand
.valueAction_(~bufSeqView.value) // Léger bug visuel quand le nb de valeurs dans le multislider change et est inférieur -> OK maintenant
.doAction; // nécessaire sinon toujours bug visuel quand le nb de valeurs dans le multislider change et est supérieur et pas de mise à jour si range = 1
};*/


~makePasteMFunction = { | envir, funcName, data, multiView, dataSpec, multiTemp, seqSpec, multiSeqSpecTemp, seqView, multiSeqStartTemp, multiSeqStopTemp |

	envir[funcName] = { | tr, seq |
		if (envir[multiTemp].isNil, {"You need to copy data !!!".postln}, {
			envir[seqSpec][tr][seq] = envir[multiSeqSpecTemp];
			envir[seqView].step_(1/(envir[multiTemp].size))
			.minRange_(1/(envir[multiTemp].size))
			.valueAction_([envir[multiSeqSpecTemp].unmap(envir[multiSeqStartTemp]), envir[multiSeqSpecTemp].unmap(envir[multiSeqStopTemp]+1)])
			.doAction;
			// BUG si ~rtm[track][seq] = ~multiTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			envir[data][tr][seq] = Array.newClear(envir[multiTemp].size);
			envir[multiView].valueAction_(envir[dataSpec][tr][seq].unmap(envir[dataSpec][tr][seq].map(envir[multiTemp])))} );
	};
};

/*~rtmPasteM = { | track, seq |
if (~multiTemp.isNil, {"You need to copy data !!!".postln}, {
~rtmSeqSpec[track][seq] = ~multiSeqSpecTemp;
~rtmSeqView.step_(1/(~multiTemp.size))
.minRange_(1/(~multiTemp.size))
.valueAction_([~multiSeqSpecTemp.unmap(~multiSeqStartTemp), ~multiSeqSpecTemp.unmap(~multiSeqStopTemp+1)])
.doAction;
// BUG si ~rtm[track][seq] = ~multiTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
~dur[track][seq] = 0 ! ~multiTemp.size;
~rtmView.valueAction_(~rtmSpec[track][seq].unmap(~rtmSpec[track][seq].map(~multiTemp)))} );
};*/










{ // Fonction Value pour les Fonctions pour éviter ERROR: Selector table too big: too many classes, method selectors or function definitions in this function

	// Load functions - A intégrer les copies des petits sliders et boutons

	// RTM

	// for generating Rhythm

	~duration2 = { | track, seq | [~nbTotalBeats[track][seq].asInteger, [
		[~pBeat[track][seq][0].asInteger, ~sumBeat[track][seq][0].asInteger.partition(~nbBeat[track][seq][0].asInteger, ~minSumBeat[track][seq][0].asInteger)],
		[~pBeat[track][seq][1].asInteger, ~sumBeat[track][seq][1].asInteger.partition(~nbBeat[track][seq][1].asInteger, ~minSumBeat[track][seq][1].asInteger)],
		[~pBeat[track][seq][2].asInteger, ~sumBeat[track][seq][2].asInteger.partition(~nbBeat[track][seq][2].asInteger, ~minSumBeat[track][seq][2].asInteger)],
		[~pBeat[track][seq][3].asInteger, ~sumBeat[track][seq][3].asInteger.partition(~nbBeat[track][seq][3].asInteger, ~minSumBeat[track][seq][3].asInteger)],
		[~pBeat[track][seq][4].asInteger, ~sumBeat[track][seq][4].asInteger.partition(~nbBeat[track][seq][4].asInteger, ~minSumBeat[track][seq][4].asInteger)],
		[~pBeat[track][seq][5].asInteger, ~sumBeat[track][seq][5].asInteger.partition(~nbBeat[track][seq][5].asInteger, ~minSumBeat[track][seq][5].asInteger)]/*,
		[~pBeat[track][seq][6].asInteger, ~sumBeat[track][seq][6].asInteger.partition(~nbBeat[track][seq][6].asInteger, ~minSumBeat[track][seq][6].asInteger)],
		[~pBeat[track][seq][7].asInteger, ~sumBeat[track][seq][7].asInteger.partition(~nbBeat[track][seq][7].asInteger, ~minSumBeat[track][seq][7].asInteger)]*/
	] ]};

	// Pour éviter de polluer la formule ConvertRythm - ne marche pas ???
	/*~duration2 = { | track, seq | [~nbTotalBeats[track][seq].asInteger, [
	"if (~pBeat[track][seq][0].asInteger != 0, { [~pBeat[track][seq][0].asInteger, ~sumBeat[track][seq][0].asInteger.partition(~nbBeat[track][seq][0].asInteger, ~minSumBeat[track][seq][0].asInteger)] } )".interpret ++ "," ++
	"if (~pBeat[track][seq][1].asInteger != 0, { [~pBeat[track][seq][1].asInteger, ~sumBeat[track][seq][1].asInteger.partition(~nbBeat[track][seq][1].asInteger, ~minSumBeat[track][seq][1].asInteger)] } )".interpret ++ "," ++
	"if (~pBeat[track][seq][2].asInteger != 0, { [~pBeat[track][seq][2].asInteger, ~sumBeat[track][seq][2].asInteger.partition(~nbBeat[track][seq][2].asInteger, ~minSumBeat[track][seq][2].asInteger)] } )".interpret ++ "," ++
	"if (~pBeat[track][seq][3].asInteger != 0, { [~pBeat[track][seq][3].asInteger, ~sumBeat[track][seq][3].asInteger.partition(~nbBeat[track][seq][3].asInteger, ~minSumBeat[track][seq][3].asInteger)] } )".interpret ++ "," ++
	"if (~pBeat[track][seq][4].asInteger != 0, { [~pBeat[track][seq][4].asInteger, ~sumBeat[track][seq][4].asInteger.partition(~nbBeat[track][seq][4].asInteger, ~minSumBeat[track][seq][4].asInteger)] } )".interpret ++ "," ++
	"if (~pBeat[track][seq][5].asInteger != 0, { [~pBeat[track][seq][5].asInteger, ~sumBeat[track][seq][5].asInteger.partition(~nbBeat[track][seq][5].asInteger, ~minSumBeat[track][seq][5].asInteger)] } )".interpret
	] ]};*/


	// Load nested function calling ~duration2 for showing & declaring ~dur[track][seq]
	/*~duration2show = { | track, seq |
	~dura[track][seq] = ~duration2.value(track, seq);
	("~dur["+track+"]["+seq+"] ="+~dura[track][seq].asCompileString+".convertRhythm;")/*.postln*/; // .asCompileString pour tout afficher dans le post window
	~dur[track][seq] = ~dura[track][seq].convertRhythm;
	("~dur["+track+"]["+seq+"] ="+~dur[track][seq].asCompileString+";")/*.postln;(" ").postln*/;

	~dur[track][seq] = ~dur[track][seq].curvelin(~rtmRound[track][seq], ~nbTotalBeats[track][seq], 0, 1, 4);
	~rtmView.size_(~rtmView.size);
	~rtmView.thumbSize_(~rtmView.bounds.width / (~dur[track][seq].size));
	~rtmView.valueAction_(~dur[track][seq]);
	~rtmView.fillColor_(Color.red);
	~rtmSeqView.controlSpec_(ControlSpec(0, ~dur[track][seq].size-1, \lin, 1, 1));
	~rtmSeqView.valueAction_([0,~dur[track][seq].size]-1);
	~rtmSeqIndexView.controlSpec_(ControlSpec(0, ~dur[track][seq].size-1, \lin, 1, 1));
	~rtmSpec[track][seq] = ControlSpec(~rtmRound[track][seq], ~nbTotalBeats[track][seq], 4, ~rtmRound[track][seq]); // ~rtmRound[track][seq] à vérifier l'allocation à 2 endroits ???
	~rtmIndexView.controlSpec_(ControlSpec(0.01, ~nbTotalBeats[track][seq], 4, ~rtmRound[track][seq]));

	// };*/


	~seqBlock  = 0 ! ~nbOfTracksX2; // Pour recalculer \prepseq quand la durée de la séquence a changé et non quand le preset change (pour le pattern)

	~duration2show = { | track, seq | // à checker les étapes XXXXXXXXX
		var timeOnset, dur, prevdur;

		prevdur = ~dur[track][seq].size; // Pour recalculer \prepseq quand la durée de la séquence a changé et non quand le preset change (pour le pattern)

		~dura[track][seq] = ~duration2.value(track, seq);
		("~dur["+track+"]["+seq+"] ="+~dura[track][seq].asCompileString+".convertRhythm;")/*.postln*/; // .asCompileString pour tout afficher dans le post window
		~dur[track][seq] = ~dura[track][seq].convertRhythm;
		("~dur["+track+"]["+seq+"] ="+~dur[track][seq].asCompileString+";")/*.postln;(" ").postln*/;

		// Protection mulSlider - Mise en place d'une sécurité avec une multiplication selon le timeOnset
		// peut déclencher des lates -> peut-être multiplier par 2 encore ???
		timeOnset = (~nbTotalBeats[track][seq] / ~toTempo) / /*~seqDurRtm*/~dur[track][seq].size/*.postln*/;
		~rtmMulSpec[track][seq] = ControlSpec(timeOnset * (20 * ~rtmMulMinProtect / (timeOnset / 0.01).squared), 10, 4, 0.001, 1);
		// ~rtmMulSpec[track][seq].postln;
		/*
		-> 0.0025 * 0.8 -> * 320 // Quand l'un augmente de x2, l'autre est /4
		-> 0.005 * 0.4 -> * 80
		-> 0.01 * 0.2 -> * 20
		-> 0.02 * 0.1 -> * 5
		-> 0.04 * 0.05 -> * 1.25
		x = 0.5 x * (20 / (x / 0.01).squared)
		x = (~nbTotalBeats[~tracksValue][~seqsValue] / ~toTempo) / /*~seqDurRtm*/~dur[~tracksValue][~seqsValue].size; x * (20 / (x / 0.01).squared)
		*/

		dur = ~dur[track][seq].size;

		// Pour recalculer \prepseq quand la durée de la séquence a changé et non quand le preset change (pour le pattern)
		if (dur != prevdur, {~seqBlock[track] = 1});

		~rtmSeqSpec[track][seq] = ControlSpec(0, ~dur[track][seq].size, \lin, 1, 1);
		~rtmSeqVSpec[track][seq] = ControlSpec(0, ~dur[track][seq].size-1, \lin, 1, 1);
		~rtmReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / ~dur[track][seq].size));
		~rtmThumbSizeValue[track][seq] = (max(~readViewThumbSize, (333*~xSizeMul) / ~dur[track][seq].size)); // Pour ThumbSize du Tab global
		~rtmSeqView.step_(1/dur)
		.minRange_(1/dur)
		// .valueAction_([0,~dur[track][seq].size]-1) // pour englober toute la séquence, -> rupture quand rand
		.valueAction_(~rtmSeqView.value) // Léger bug visuel quand le nb de valeurs dans le multislider change et est inférieur -> OK maintenant
		.doAction; // nécessaire sinon toujours bug visuel quand le nb de valeurs dans le multislider change et est supérieur et pas de mise à jour si range = 1
		~rtmMax[track][seq] = ~dur[track][seq].maxItem * 2;
		~rtmRangeView.valueAction_(~rtmRangeSpec[~tracksValue][~seqsValue].unmap([0, ~rtmMax[~tracksValue][~seqsValue]]));
		~rtmSpec[track][seq] = ControlSpec(~rtmMin[track][seq], ~rtmMax[track][seq], \lin, ~rtmRound[track][seq]);
		~dur[track][seq] = ~rtmSpec[track][seq].unmap(~dur[track][seq]);
		~rtmView.valueAction_(~dur[~tracksValue][~seqsValue]);

		/* Check durée
		~rtmSpec[0][0].map(~dur[0][0]);
		~rtmSpec[0][0].map(~dur[0][0]).sum;
		~dur[0][0];
		~dur[0][0].sum;
		~rtmMax[0][0];
		*/

		// utilisation de .asCompileString pour pouvoir afficher toute une array
		// ~displayRhythm[track][seq] = (("~rtmView.valueAction_("+~dura[track][seq].asCompileString+".convertRhythm.linlin(0,"+ ~rtmMax[track][seq]+", 0, 1));")).asString;
		// Pas possible de modifier le nb d'évènements - A faire ?????????????????????????????????????????????????????????????????
		~displayRhythm[track][seq] = (("~rhythmChange["+track+"]["+seq+"] = "+~dura[track][seq].asCompileString+"; ~rtmRangeView.valueAction_(~rtmRangeSpec["+track+"]["+seq+"].unmap([0, "+"~rhythmChange["+track+"]["+seq+"].convertRhythm.maxItem * 2])); ~rtmView.valueAction_("+"~rhythmChange["+track+"]["+seq+"].convertRhythm.linlin(0, ~rtmMax["+track+"]["+seq+"], 0, 1));")).asString;
		~displayRhythmView.string_(~displayRhythm[track][seq]); // ~displayRhythmView.setFont((Font("arial",1)), 4, 75);

		~gblSeqIndexSpec[track][seq] = ControlSpec(0,dur, \lin, 1);
		~gblSeqIndexView.string = "At : %".format(~gblSeqIndex[~tracksValue][~seqsValue]);
		~gblSeqIndexView.step_(1/dur); // Le doAction provoque le changement de sélection de toutes les séquences ???

		~gblSeqSpec[track][seq] = ControlSpec(0, ~dur[track][seq].size, \lin, 1);
		~gblSeqStop[track][seq] = ~dur[track][seq].size -1;
		~gblSeqView.string = ("% to % (Dur :"+(~gblSeqStop[~tracksValue][~seqsValue] - ~gblSeqStart[~tracksValue][~seqsValue] + 1)+")").format(~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]);
		~gblSeqView.step_(1/dur);
		~gblSeqView.minRange_(1/dur);
	};

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~rtmCopyA = { | track, seq |
		// pour le PasteA
		~rtmRoundViewTemp = ~rtmRoundView.value.copy;
		~rtmRangeSpecTemp = ~rtmRangeSpec[track][seq].copy;
		~rtmSpecTemp = ~rtmSpec[track][seq].copy;
		~rtmMinTemp = ~rtmMin[track][seq].copy;
		~rtmMaxTemp = ~rtmMax[track][seq].copy;
		~rtmTemp = ~dur[track][seq].copy;
		~rtmMulTemp = ~rtmMul[track][seq].copy;
		~rtmSeqSpecTemp = ~rtmSeqSpec[track][seq].copy;
		~rtmSeqStartTemp = ~rtmSeqStart[track][seq].copy;
		~rtmSeqStopTemp = ~rtmSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~dur[track][seq].copy;
		~multiSeqSpecTemp = ~rtmSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~rtmSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~rtmSeqStop[track][seq].copy;
	};

	~rtmPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~rtmTemp.isNil, {"You need to copy ~rtm data !!!".postln}, {
			~rtmRoundView.valueAction_(~rtmRoundViewTemp);
			~rtmSeqSpec[track][seq] = ~rtmSeqSpecTemp;
			~rtmSeqView.step_(1/(~rtmTemp.size))
			.minRange_(1/(~rtmTemp.size))
			.valueAction_([~rtmSeqSpecTemp.unmap(~rtmSeqStartTemp), ~rtmSeqSpecTemp.unmap(~rtmSeqStopTemp+1)])
			.doAction;
			// BUG si ~rtm[track][seq] = ~rtmTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~dur[track][seq] = Array.newClear(~rtmTemp.size);
			~rtmRangeSpec[track][seq] = ~rtmRangeSpecTemp;
			~rtmSpec[track][seq] = ~rtmSpecTemp;
			~rtmView.valueAction_(~rtmTemp);
			~rtmRangeView.valueAction_(~rtmRangeSpecTemp.unmap([~rtmMinTemp, ~rtmMaxTemp]));
			~rtmMulView.valueAction_(~rtmMulSpec[track][seq].unmap(~rtmMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \rtmPasteM, \dur, \rtmView, \rtmSpec, \multiTemp, \rtmSeqSpec, \multiSeqSpecTemp, \rtmSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~rtmDefault = { | track, seq |
		~rtmRoundView.valueAction_(0);
		// ~rtmRangePresetView.valueAction_(2);
		~rtmMulPresetView.valueAction_(11);
		~rtmSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		~duration2show.value(track, seq);
		// ~rtmView.valueAction_(0.5 ! ~dur[track][seq].size);
		~rtmSeqMode.valueAction_(1);
		~rtmRangeMode.valueAction_(0);
		~rtmTypeView.valueAction_(0);
		~rtmDirView.valueAction_(0);
		~rtmPatView.valueAction_(0);
		~rtmPatSelView.valueAction_(0);
	};










	// PRO

	~probability = { | track, seq | var dur = ~dur[~tracksValue][~seqsValue].size;
		/*~pro[track][seq] = { rrand(~proMin[track][seq], ~proMax[track][seq]).round(~proRound[track][seq]) } ! ~dur[track][seq].size;
		~pro[track][seq] = ~proSpec[track][seq].unmap(~pro[track][seq]);
		~proView.valueAction_(~pro[track][seq]);*/ // agissait sur toute la séquence - maintenant seulement sur la séquence sélectionnée sauf si SeqView.range == 1

		if (~proSeqView.range == 1 || ~pro[~tracksValue][~seqsValue].size != dur, {
			~pro[~tracksValue][~seqsValue] = {rrand(0.0,1.0)} ! dur;
			~proView.valueAction_(~pro[~tracksValue][~seqsValue]);
		}, {
			~proView.valueAction_( ~pro[~tracksValue][~seqsValue].putEach((~proSeqStart[~tracksValue][~seqsValue]..~proSeqStop[~tracksValue][~seqsValue]), {rrand(0.0,1.0)} ! ~seqDurPro[~tracksValue][~seqsValue]) );
		});

		~proSeqSpec[track][seq] = ControlSpec(0, ~dur[track][seq].size, \lin, 1, 1);
		~proSeqVSpec[track][seq] = ControlSpec(0, ~dur[track][seq].size-1, \lin, 1, 1);
		~proReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / ~dur[track][seq].size));
		~proSeqView.step_(1/dur)
		.minRange_(1/dur)
		// .valueAction_([0,~pro[track][seq].size]-1) // pour englober toute la séquence, -> rupture quand rand
		.valueAction_(~proSeqView.value) // Léger bug visuel quand le nb de valeurs dans le multislider change et est inférieur -> OK maintenant
		.doAction; // nécessaire sinon toujours bug visuel quand le nb de valeurs dans le multislider change et est supérieur et pas de mise à jour si range = 1

		// Pour la rythmique euclidienne
		~proBjorSpec[track][seq] = ControlSpec(0, ~dur[track][seq].size, \lin, 1);
		if (~proPatSel[~tracksValue][~seqsValue] > 18, {
			~proBjorView.step_(0.001); ~proBjor2View.step_(0.001); ~proBjor3View.step_(0.001); ~proBjor4View.step_(0.001);
		},{
			~proBjorView.step_(1/dur); ~proBjor2View.step_(1/dur); ~proBjor3View.step_(dur); ~proBjor4View.step_(dur);
		});
		~proBjorView.doAction;
		~proBjor2View.doAction;
		~proBjor3View.doAction;
		~proBjor4View.doAction;
		~proBjor[track][seq] = ~dur[track][seq].size;
		~proBjor2[track][seq] = ~dur[track][seq].size;
		~proBjor3[track][seq] = ~dur[track][seq].size;
		~proBjor4[track][seq] = ~dur[track][seq].size;
	};

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~proCopyA = { | track, seq |
		// pour le PasteA
		~proRoundViewTemp = ~proRoundView.value.copy;
		~proRangeSpecTemp = ~proRangeSpec[track][seq].copy;
		~proSpecTemp = ~proSpec[track][seq].copy;
		~proMinTemp = ~proMin[track][seq].copy;
		~proMaxTemp = ~proMax[track][seq].copy;
		~proTemp = ~pro[track][seq].copy;
		~proMulTemp = ~proMul[track][seq].copy;
		~proSeqSpecTemp = ~proSeqSpec[track][seq].copy;
		~proSeqStartTemp = ~proSeqStart[track][seq].copy;
		~proSeqStopTemp = ~proSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~pro[track][seq].copy;
		~multiSeqSpecTemp = ~proSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~proSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~proSeqStop[track][seq].copy;
	};

	~proPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~proTemp.isNil, {"You need to copy ~pro data !!!".postln}, {
			~proRoundView.valueAction_(~proRoundViewTemp);
			~proSeqSpec[track][seq] = ~proSeqSpecTemp;
			~proSeqView.step_(1/(~proTemp.size))
			.minRange_(1/(~proTemp.size))
			.valueAction_([~proSeqSpecTemp.unmap(~proSeqStartTemp), ~proSeqSpecTemp.unmap(~proSeqStopTemp+1)])
			.doAction;
			// BUG si ~pro[track][seq] = ~proTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~pro[track][seq] = Array.newClear(~proTemp.size);
			~proRangeSpec[track][seq] = ~proRangeSpecTemp;
			~proSpec[track][seq] = ~proSpecTemp;
			~proView.valueAction_(~proTemp);
			~proRangeView.valueAction_(~proRangeSpecTemp.unmap([~proMinTemp, ~proMaxTemp]));
			~proMulView.valueAction_(~proMulSpec.unmap(~proMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \proPasteM, \pro, \proView, \proSpec, \multiTemp, \proSeqSpec, \multiSeqSpecTemp, \proSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~proDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~proRoundView.valueAction_(0);
		~proRangePresetView.valueAction_(2);
		~proMulPresetView.valueAction_(10);

		~proSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~proSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~proReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~proSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~proSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		~pro[track][seq] = /*~proSpec[track][seq].unmap(1)*/ 1 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~proView.valueAction_(~pro[~tracksValue][~seqsValue]);

		~proSeqMode.valueAction_(1);
		~proRangeMode.valueAction_(0);
		~proBjorView.valueAction_(1);
		~proBjor2View.valueAction_(1);
		~proBjor3View.valueAction_(1);
		~proBjor4View.valueAction_(1);
		~proWeightView.valueAction_(1);
		~proDirView.valueAction_(0);
		~proPatView.valueAction_(0);
		~proPatSelView.valueAction_(13);

		// Pour la rythmique euclidienne
		~proBjorSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1);
		~proBjorView.step_(1/~dur[~tracksValue][~seqsValue].size);
		~proBjor2View.step_(1/~dur[~tracksValue][~seqsValue].size);
		// ~proBjor4View.step_(1/~dur[~tracksValue][~seqsValue].size);
		~proBjorView.doAction;
		~proBjor2View.doAction;
		// ~proBjor4View.doAction;
		~proBjor[track][seq] = seqDur;
		~proBjor2[track][seq] = seqDur;
		~proBjor3[track][seq] = seqDur;
		~proBjor4[track][seq] = seqDur;
	};










	// SYN

	~makeRandFunction.(currentEnvironment, \synthese, \syn, \synView, \dur, \seqDurSyn, \synSeqView, \synSeqStart, \synSeqStop, \synSeqSpec, \synSeqVSpec, \synReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~synCopyA = { | track, seq |
		// pour le PasteA
		~synRangeSpecTemp = ~synRangeSpec[track][seq].copy;
		~synSpecTemp = ~synSpec[track][seq].copy;
		~synMinTemp = ~synMin[track][seq].copy;
		~synMaxTemp = ~synMax[track][seq].copy;
		~synTemp = ~syn[track][seq].copy;
		~synMulTemp = ~synMul[track][seq].copy;
		~synSeqSpecTemp = ~synSeqSpec[track][seq].copy;
		~synSeqStartTemp = ~synSeqStart[track][seq].copy;
		~synSeqStopTemp = ~synSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~syn[track][seq].copy;
		~multiSeqSpecTemp = ~synSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~synSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~synSeqStop[track][seq].copy;
	};

	~synPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~synTemp.isNil, {"You need to copy ~syn data !!!".postln}, {
			~synSeqSpec[track][seq] = ~synSeqSpecTemp;
			~synSeqView.step_(1/(~synTemp.size))
			.minRange_(1/(~synTemp.size))
			.valueAction_([~synSeqSpecTemp.unmap(~synSeqStartTemp), ~synSeqSpecTemp.unmap(~synSeqStopTemp+1)])
			.doAction;
			// BUG si ~syn[track][seq] = ~synTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~syn[track][seq] = Array.newClear(~synTemp.size);
			~synRangeSpec[track][seq] = ~synRangeSpecTemp;
			~synSpec[track][seq] = ~synSpecTemp;
			~synView.valueAction_(~synTemp);
			~synRangeView.valueAction_(~synRangeSpecTemp.unmap([~synMinTemp, ~synMaxTemp]));
			~synMulView.valueAction_(~synMulSpec.unmap(~synMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \synPasteM, \syn, \synView, \synSpec, \multiTemp, \synSeqSpec, \multiSeqSpecTemp, \synSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~synDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~synRangePresetView.valueAction_(~synRangePresetView.items.size -1);
		~synMulPresetView.valueAction_(10);

		~synSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~synSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~synReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~synSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~synSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		~syn[track][seq] = /*~synSpec[track][seq].unmap(0)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~synView.valueAction_(~syn[~tracksValue][~seqsValue]);

		~synSeqMode.valueAction_(1);
		~synRangeMode.valueAction_(0);
		~synTypeView.valueAction_(0);
		~offRateSecondBufView.valueAction_(0.5);
		~offRateRandSecondBufView.valueAction_(0);
		~synDirView.valueAction_(0);
		~synPatView.valueAction_(0);
		~synPatSelView.valueAction_(4);
	};










	// SPA

	~makeRandFunction.(currentEnvironment, \spatialisation, \spa, \spaView, \dur, \seqDurSpa, \spaSeqView, \spaSeqStart, \spaSeqStop, \spaSeqSpec, \spaSeqVSpec, \spaReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~spaCopyA = { | track, seq |
		// pour le PasteA
		~spaRangeSpecTemp = ~spaRangeSpec[track][seq].copy;
		~spaSpecTemp = ~spaSpec[track][seq].copy;
		~spaMinTemp = ~spaMin[track][seq].copy;
		~spaMaxTemp = ~spaMax[track][seq].copy;
		~spaTemp = ~spa[track][seq].copy;
		~spaMulTemp = ~spaMul[track][seq].copy;
		~spaSeqSpecTemp = ~spaSeqSpec[track][seq].copy;
		~spaSeqStartTemp = ~spaSeqStart[track][seq].copy;
		~spaSeqStopTemp = ~spaSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~spa[track][seq].copy;
		~multiSeqSpecTemp = ~spaSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~spaSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~spaSeqStop[track][seq].copy;
	};

	~spaPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~spaTemp.isNil, {"You need to copy ~spa data !!!".postln}, {
			~spaSeqSpec[track][seq] = ~spaSeqSpecTemp;
			~spaSeqView.step_(1/(~spaTemp.size))
			.minRange_(1/(~spaTemp.size))
			.valueAction_([~spaSeqSpecTemp.unmap(~spaSeqStartTemp), ~spaSeqSpecTemp.unmap(~spaSeqStopTemp+1)])
			.doAction;
			// BUG si ~spa[track][seq] = ~spaTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~spa[track][seq] = Array.newClear(~spaTemp.size);
			~spaRangeSpec[track][seq] = ~spaRangeSpecTemp;
			~spaSpec[track][seq] = ~spaSpecTemp;
			~spaView.valueAction_(~spaTemp);
			~spaRangeView.valueAction_(~spaRangeSpecTemp.unmap([~spaMinTemp, ~spaMaxTemp]));
			~spaMulView.valueAction_(~spaMulSpec.unmap(~spaMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \spaPasteM, \spa, \spaView, \spaSpec, \multiTemp, \spaSeqSpec, \multiSeqSpecTemp, \spaSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~spaDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~spaRangePresetView.valueAction_(~spaRangePresetItems.size -1);
		~spaMulPresetView.valueAction_(10);

		~spaSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~spaSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~spaReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~spaSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~spaSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~spaRoundView.valueAction_(0);
		~spa[track][seq] = /*~spaSpec[track][seq].unmap(0)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~spaView.valueAction_(~spa[~tracksValue][~seqsValue]);

		~spaSeqMode.valueAction_(1);
		~spaRangeMode.valueAction_(0);
		~spaDirView.valueAction_(0);
		~spaPatView.valueAction_(0);
		~spaPatSelView.valueAction_(4);
	};










	// LEG

	~makeRandFunction.(currentEnvironment, \legato, \leg, \legView, \dur, \seqDurLeg, \legSeqView, \legSeqStart, \legSeqStop, \legSeqSpec, \legSeqVSpec, \legReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~legCopyA = { | track, seq |
		// pour le PasteA
		~legRoundViewTemp = ~legRoundView.value.copy;
		~legRangeSpecTemp = ~legRangeSpec[track][seq].copy;
		~legSpecTemp = ~legSpec[track][seq].copy;
		~legMinTemp = ~legMin[track][seq].copy;
		~legMaxTemp = ~legMax[track][seq].copy;
		~legTemp = ~leg[track][seq].copy;
		~legMulTemp = ~legMul[track][seq].copy;
		~legSeqSpecTemp = ~legSeqSpec[track][seq].copy;
		~legSeqStartTemp = ~legSeqStart[track][seq].copy;
		~legSeqStopTemp = ~legSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~leg[track][seq].copy;
		~multiSeqSpecTemp = ~legSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~legSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~legSeqStop[track][seq].copy;
	};

	~legPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~legTemp.isNil, {"You need to copy ~leg data !!!".postln}, {
			~legRoundView.valueAction_(~legRoundViewTemp);
			~legSeqSpec[track][seq] = ~legSeqSpecTemp;
			~legSeqView.step_(1/(~legTemp.size))
			.minRange_(1/(~legTemp.size))
			.valueAction_([~legSeqSpecTemp.unmap(~legSeqStartTemp), ~legSeqSpecTemp.unmap(~legSeqStopTemp+1)])
			.doAction;
			// BUG si ~leg[track][seq] = ~legTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~leg[track][seq] = Array.newClear(~legTemp.size);
			~legRangeSpec[track][seq] = ~legRangeSpecTemp;
			~legSpec[track][seq] = ~legSpecTemp;
			~legView.valueAction_(~legTemp);
			~legRangeView.valueAction_(~legRangeSpecTemp.unmap([~legMinTemp, ~legMaxTemp]));
			~legMulView.valueAction_(~legMulSpec.unmap(~legMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \legPasteM, \leg, \legView, \legSpec, \multiTemp, \legSeqSpec, \multiSeqSpecTemp, \legSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~legDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~legRoundView.valueAction_(0);
		~legRangePresetView.valueAction_(2);
		~legMulPresetView.valueAction_(10);

		~legSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~legSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~legReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~legSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~legSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		~leg[track][seq] = /*~legSpec[track][seq].unmap(1)*/ 0.5 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~legView.valueAction_(~leg[~tracksValue][~seqsValue]);

		~legSeqMode.valueAction_(1);
		~legRangeMode.valueAction_(0);
		~legDirView.valueAction_(0);
		~legPatView.valueAction_(0);
		~legPatSelView.valueAction_(4);
	};










	// ENV

	~makeRandFunction.(currentEnvironment, \enveloppe, \env, \envView, \dur, \seqDurEnv, \envSeqView, \envSeqStart, \envSeqStop, \envSeqSpec, \envSeqVSpec, \envReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~envCopyA = { | track, seq |
		// pour le PasteA
		~envRangeSpecTemp = ~envRangeSpec[track][seq].copy;
		~envSpecTemp = ~envSpec[track][seq].copy;
		~envMinTemp = ~envMin[track][seq].copy;
		~envMaxTemp = ~envMax[track][seq].copy;
		~envTemp = ~env[track][seq].copy;
		~envMulTemp = ~envMul[track][seq].copy;
		~envSeqSpecTemp = ~envSeqSpec[track][seq].copy;
		~envSeqStartTemp = ~envSeqStart[track][seq].copy;
		~envSeqStopTemp = ~envSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~env[track][seq].copy;
		~multiSeqSpecTemp = ~envSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~envSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~envSeqStop[track][seq].copy;
	};

	~envPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~envTemp.isNil, {"You need to copy ~env data !!!".postln}, {
			~envSeqSpec[track][seq] = ~envSeqSpecTemp;
			~envSeqView.step_(1/(~envTemp.size))
			.minRange_(1/(~envTemp.size))
			.valueAction_([~envSeqSpecTemp.unmap(~envSeqStartTemp), ~envSeqSpecTemp.unmap(~envSeqStopTemp+1)])
			.doAction;
			// BUG si ~env[track][seq] = ~envTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~env[track][seq] = Array.newClear(~envTemp.size);
			~envRangeSpec[track][seq] = ~envRangeSpecTemp;
			~envSpec[track][seq] = ~envSpecTemp;
			~envView.valueAction_(~envTemp);
			~envRangeView.valueAction_(~envRangeSpecTemp.unmap([~envMinTemp, ~envMaxTemp]));
			~envMulView.valueAction_(~envMulSpec.unmap(~envMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \envPasteM, \env, \envView, \envSpec, \multiTemp, \envSeqSpec, \multiSeqSpecTemp, \envSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~envDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~envRangePresetView.valueAction_(~envRangePresetView.items.size -1);
		~envMulPresetView.valueAction_(10);

		~envSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~envSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~envReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~envSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~envSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~envRoundView.valueAction_(0);
		~env[track][seq] = /*~envSpec[track][seq].unmap(0)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~envView.valueAction_(~env[~tracksValue][~seqsValue]);

		~envSeqMode.valueAction_(1);
		~envRangeMode.valueAction_(0);

		~envNum.do { |i|
			~atkView[i].valueAction_(~atkSpec[i].default);
			~relView[i].valueAction_(~relSpec[i].default);
			~atkCurveView[i].valueAction_(~atkCurveSpec[i].default);
			~relCurveView[i].valueAction_(~relCurveSpec[i].default);
		};
		~w1View.valueAction_(~w1Spec.default);
		~w2View.valueAction_(~w2Spec.default);

		~envDirView.valueAction_(0);
		~envPatView.valueAction_(0);
		~envPatSelView.valueAction_(4);
	};










	// BUF

	~makeRandFunction.(currentEnvironment, \buffer, \buf, \bufView, \dur, \seqDurBuf, \bufSeqView, \bufSeqStart, \bufSeqStop, \bufSeqSpec, \bufSeqVSpec, \bufReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~bufCopyA = { | track, seq |
		// pour le PasteA
		~bufRangeSpecTemp = ~bufRangeSpec[track][seq].copy;
		~bufSpecTemp = ~bufSpec[track][seq].copy;
		~bufMinTemp = ~bufMin[track][seq].copy;
		~bufMaxTemp = ~bufMax[track][seq].copy;
		~bufTemp = ~buf[track][seq].copy;
		~bufMulTemp = ~bufMul[track][seq].copy;
		~bufSeqSpecTemp = ~bufSeqSpec[track][seq].copy;
		~bufSeqStartTemp = ~bufSeqStart[track][seq].copy;
		~bufSeqStopTemp = ~bufSeqStop[track][seq].copy;
		~bufFolderValueTemp = ~bufFolderValue[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~buf[track][seq].copy;
		~multiSeqSpecTemp = ~bufSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~bufSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~bufSeqStop[track][seq].copy;
	};

	~bufPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~bufTemp.isNil, {"You need to copy ~buf data !!!".postln}, {
			~bufFolderView.valueAction_(~bufFolderValueTemp);
			~bufSeqSpec[track][seq] = ~bufSeqSpecTemp;
			~bufSeqView.step_(1/(~bufTemp.size))
			.minRange_(1/(~bufTemp.size))
			.valueAction_([~bufSeqSpecTemp.unmap(~bufSeqStartTemp), ~bufSeqSpecTemp.unmap(~bufSeqStopTemp+1)])
			.doAction;
			// BUG si ~buf[track][seq] = ~bufTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~buf[track][seq] = Array.newClear(~bufTemp.size);
			~bufRangeSpec[track][seq] = ~bufRangeSpecTemp;
			~bufSpec[track][seq] = ~bufSpecTemp;
			~bufView.valueAction_(~bufTemp);
			~bufRangeView.valueAction_(~bufRangeSpecTemp.unmap([~bufMinTemp, ~bufMaxTemp]));
			~bufMulView.valueAction_(~bufMulSpec.unmap(~bufMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \bufPasteM, \buf, \bufView, \bufSpec, \multiTemp, \bufSeqSpec, \multiSeqSpecTemp, \bufSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~bufDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~bufMulPresetView.valueAction_(10);
		// Remise à 0 du ~defaultFolder
		// ~bufFolderView.valueAction_(/*4*/ ~defaultFolder); // ATTENTION -> Protection à mettre si le nombre de sous-dossiers est inférieur -> OK paramètre extérieur
		~bufRangeView.valueAction_([0, 1]);

		~bufSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~bufSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~bufReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~bufSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~bufSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		~buf[track][seq] = /*~bufSpec[track][seq].unmap(0)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~bufView.valueAction_(~buf[~tracksValue][~seqsValue]);

		~bufSeqMode.valueAction_(1);
		~bufRangeMode.valueAction_(0);
		~bufDirView.valueAction_(0);
		~bufPatView.valueAction_(0);
		~bufPatSelView.valueAction_(4);
	};










	// OFF

	~makeRandFunction.(currentEnvironment, \offset, \off, \offView, \dur, \seqDurOff, \offSeqView, \offSeqStart, \offSeqStop, \offSeqSpec, \offSeqVSpec, \offReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~offCopyA = { | track, seq |
		// pour le PasteA
		~offRoundViewTemp = ~offRoundView.value.copy;
		~offRangeSpecTemp = ~offRangeSpec[track][seq].copy;
		~offSpecTemp = ~offSpec[track][seq].copy;
		~offMinTemp = ~offMin[track][seq].copy;
		~offMaxTemp = ~offMax[track][seq].copy;
		~offTemp = ~off[track][seq].copy;
		~offMulTemp = ~offMul[track][seq].copy;
		~offSeqSpecTemp = ~offSeqSpec[track][seq].copy;
		~offSeqStartTemp = ~offSeqStart[track][seq].copy;
		~offSeqStopTemp = ~offSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~off[track][seq].copy;
		~multiSeqSpecTemp = ~offSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~offSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~offSeqStop[track][seq].copy;
	};

	~offPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~offTemp.isNil, {"You need to copy ~off data !!!".postln}, {
			~offRoundView.valueAction_(~offRoundViewTemp);
			~offSeqSpec[track][seq] = ~offSeqSpecTemp;
			~offSeqView.step_(1/(~offTemp.size))
			.minRange_(1/(~offTemp.size))
			.valueAction_([~offSeqSpecTemp.unmap(~offSeqStartTemp), ~offSeqSpecTemp.unmap(~offSeqStopTemp+1)])
			.doAction;
			// BUG si ~off[track][seq] = ~offTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~off[track][seq] = Array.newClear(~offTemp.size);
			~offRangeSpec[track][seq] = ~offRangeSpecTemp;
			~offSpec[track][seq] = ~offSpecTemp;
			~offView.valueAction_(~offTemp);
			~offRangeView.valueAction_(~offRangeSpecTemp.unmap([~offMinTemp, ~offMaxTemp]));
			~offMulView.valueAction_(~offMulSpec.unmap(~offMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \offPasteM, \off, \offView, \offSpec, \multiTemp, \offSeqSpec, \multiSeqSpecTemp, \offSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~offDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~offRoundView.valueAction_(0);
		~offRangePresetView.valueAction_(2);
		~offMulPresetView.valueAction_(10);

		~offSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~offSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~offReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~offSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~offSeqView.valueAction_([0, 1]);
		// ~offView.valueAction_(~offSpec[track][seq].unmap(0) ! ~off[track][seq].size);
		~off[track][seq] = /*~offSpec[track][seq].unmap(0)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~offView.valueAction_(~off[~tracksValue][~seqsValue]);

		~offSeqMode.valueAction_(1);
		~offRangeMode.valueAction_(0);
		~offThreshView.valueAction_(0.4);
		~offDirView.valueAction_(0);
		~offPatView.valueAction_(0);
		~offPatSelView.valueAction_(4);
	};










	// OFF 2

	~makeRandFunction.(currentEnvironment, \offset2, \off2, \off2View, \dur, \seqDurOff2, \off2SeqView, \off2SeqStart, \off2SeqStop, \off2SeqSpec, \off2SeqVSpec, \off2ReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~off2CopyA = { | track, seq |
		// pour le PasteA
		~off2RoundViewTemp = ~off2RoundView.value.copy;
		~off2RangeSpecTemp = ~off2RangeSpec[track][seq].copy;
		~off2SpecTemp = ~off2Spec[track][seq].copy;
		~off2MinTemp = ~off2Min[track][seq].copy;
		~off2MaxTemp = ~off2Max[track][seq].copy;
		~off2Temp = ~off2[track][seq].copy;
		~off2MulTemp = ~off2Mul[track][seq].copy;
		~off2SeqSpecTemp = ~off2SeqSpec[track][seq].copy;
		~off2SeqStartTemp = ~off2SeqStart[track][seq].copy;
		~off2SeqStopTemp = ~off2SeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~off2[track][seq].copy;
		~multiSeqSpecTemp = ~off2SeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~off2SeqStart[track][seq].copy;
		~multiSeqStopTemp = ~off2SeqStop[track][seq].copy;
	};

	~off2PasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~off2Temp.isNil, {"You need to copy ~off data !!!".postln}, {
			~off2RoundView.valueAction_(~off2RoundViewTemp);
			~off2SeqSpec[track][seq] = ~off2SeqSpecTemp;
			~off2SeqView.step_(1/(~off2Temp.size))
			.minRange_(1/(~off2Temp.size))
			.valueAction_([~off2SeqSpecTemp.unmap(~off2SeqStartTemp), ~off2SeqSpecTemp.unmap(~off2SeqStopTemp+1)])
			.doAction;
			// BUG si ~off[track][seq] = ~offTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~off2[track][seq] = Array.newClear(~offTemp2.size);
			~off2RangeSpec[track][seq] = ~off2RangeSpecTemp;
			~off2Spec[track][seq] = ~off2SpecTemp;
			~off2View.valueAction_(~off2Temp);
			~off2RangeView.valueAction_(~off2RangeSpecTemp.unmap([~off2MinTemp, ~off2MaxTemp]));
			~off2MulView.valueAction_(~off2MulSpec.unmap(~off2MulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \off2PasteM, \off2, \off2View, \off2Spec, \multiTemp, \off2SeqSpec, \multiSeqSpecTemp, \off2SeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~off2Default = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~off2RoundView.valueAction_(0);
		~off2RangePresetView.valueAction_(2);
		~off2MulPresetView.valueAction_(10);

		~off2SeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~off2SeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~off2ReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~off2SeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~off2SeqView.valueAction_([0, 1]);
		// ~offView.valueAction_(~offSpec[track][seq].unmap(0) ! ~off[track][seq].size);
		~off2[track][seq] = /*~offSpec[track][seq].unmap(0)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~off2View.valueAction_(~off2[~tracksValue][~seqsValue]);

		~off2SeqMode.valueAction_(1);
		~off2RangeMode.valueAction_(0);
		// ~off2ThreshView.valueAction_(0.4);
		~off2DirView.valueAction_(0);
		~off2PatView.valueAction_(0);
		~off2PatSelView.valueAction_(4);
	};










	// OFF 3

	~makeRandFunction.(currentEnvironment, \offset3, \off3, \off3View, \dur, \seqDurOff3, \off3SeqView, \off3SeqStart, \off3SeqStop, \off3SeqSpec, \off3SeqVSpec, \off3ReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~off3CopyA = { | track, seq |
		// pour le PasteA
		~off3RoundViewTemp = ~off3RoundView.value.copy;
		~off3RangeSpecTemp = ~off3RangeSpec[track][seq].copy;
		~off3SpecTemp = ~off3Spec[track][seq].copy;
		~off3MinTemp = ~off3Min[track][seq].copy;
		~off3MaxTemp = ~off3Max[track][seq].copy;
		~off3Temp = ~off3[track][seq].copy;
		~off3MulTemp = ~off3Mul[track][seq].copy;
		~off3SeqSpecTemp = ~off3SeqSpec[track][seq].copy;
		~off3SeqStartTemp = ~off3SeqStart[track][seq].copy;
		~off3SeqStopTemp = ~off3SeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~off3[track][seq].copy;
		~multiSeqSpecTemp = ~off3SeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~off3SeqStart[track][seq].copy;
		~multiSeqStopTemp = ~off3SeqStop[track][seq].copy;
	};

	~off3PasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~off3Temp.isNil, {"You need to copy ~off data !!!".postln}, {
			~off3RoundView.valueAction_(~off3RoundViewTemp);
			~off3SeqSpec[track][seq] = ~off3SeqSpecTemp;
			~off3SeqView.step_(1/(~off3Temp.size))
			.minRange_(1/(~off3Temp.size))
			.valueAction_([~off3SeqSpecTemp.unmap(~off3SeqStartTemp), ~off3SeqSpecTemp.unmap(~off3SeqStopTemp+1)])
			.doAction;
			// BUG si ~off[track][seq] = ~offTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~off3[track][seq] = Array.newClear(~offTemp3.size);
			~off3RangeSpec[track][seq] = ~off3RangeSpecTemp;
			~off3Spec[track][seq] = ~off3SpecTemp;
			~off3View.valueAction_(~off3Temp);
			~off3RangeView.valueAction_(~off3RangeSpecTemp.unmap([~off3MinTemp, ~off3MaxTemp]));
			~off3MulView.valueAction_(~off3MulSpec.unmap(~off3MulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \off3PasteM, \off3, \off3View, \off3Spec, \multiTemp, \off3SeqSpec, \multiSeqSpecTemp, \off3SeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~off3Default = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~off3RoundView.valueAction_(0);
		~off3RangePresetView.valueAction_(2);
		~off3MulPresetView.valueAction_(10);

		~off3SeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~off3SeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~off3ReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~off3SeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~off3SeqView.valueAction_([0, 1]);
		// ~offView.valueAction_(~offSpec[track][seq].unmap(0) ! ~off[track][seq].size);
		~off3[track][seq] = /*~offSpec[track][seq].unmap(0)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~off3View.valueAction_(~off3[~tracksValue][~seqsValue]);

		~off3SeqMode.valueAction_(1);
		~off3RangeMode.valueAction_(0);
		// ~offThreshView.valueAction_(0.4);
		~off3DirView.valueAction_(0);
		~off3PatView.valueAction_(0);
		~off3PatSelView.valueAction_(4);
	};










	// OFF 4

	~makeRandFunction.(currentEnvironment, \offset4, \off4, \off4View, \dur, \seqDurOff4, \off4SeqView, \off4SeqStart, \off4SeqStop, \off4SeqSpec, \off4SeqVSpec, \off4ReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~off4CopyA = { | track, seq |
		// pour le PasteA
		~off4RoundViewTemp = ~off4RoundView.value.copy;
		~off4RangeSpecTemp = ~off4RangeSpec[track][seq].copy;
		~off4SpecTemp = ~off4Spec[track][seq].copy;
		~off4MinTemp = ~off4Min[track][seq].copy;
		~off4MaxTemp = ~off4Max[track][seq].copy;
		~off4Temp = ~off4[track][seq].copy;
		~off4MulTemp = ~off4Mul[track][seq].copy;
		~off4SeqSpecTemp = ~off4SeqSpec[track][seq].copy;
		~off4SeqStartTemp = ~off4SeqStart[track][seq].copy;
		~off4SeqStopTemp = ~off4SeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~off4[track][seq].copy;
		~multiSeqSpecTemp = ~off4SeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~off4SeqStart[track][seq].copy;
		~multiSeqStopTemp = ~off4SeqStop[track][seq].copy;
	};

	~off4PasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~off4Temp.isNil, {"You need to copy ~off data !!!".postln}, {
			~off4RoundView.valueAction_(~off4RoundViewTemp);
			~off4SeqSpec[track][seq] = ~off4SeqSpecTemp;
			~off4SeqView.step_(1/(~off4Temp.size))
			.minRange_(1/(~off4Temp.size))
			.valueAction_([~off4SeqSpecTemp.unmap(~off4SeqStartTemp), ~off4SeqSpecTemp.unmap(~off4SeqStopTemp+1)])
			.doAction;
			// BUG si ~off[track][seq] = ~offTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~off4[track][seq] = Array.newClear(~offTemp4.size);
			~off4RangeSpec[track][seq] = ~off4RangeSpecTemp;
			~off4Spec[track][seq] = ~off4SpecTemp;
			~off4View.valueAction_(~off4Temp);
			~off4RangeView.valueAction_(~off4RangeSpecTemp.unmap([~off4MinTemp, ~off4MaxTemp]));
			~off4MulView.valueAction_(~off4MulSpec.unmap(~off4MulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \off4PasteM, \off4, \off4View, \off4Spec, \multiTemp, \off4SeqSpec, \multiSeqSpecTemp, \off4SeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~off4Default = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~off4RoundView.valueAction_(0);
		~off4RangePresetView.valueAction_(2);
		~off4MulPresetView.valueAction_(10);

		~off4SeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~off4SeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~off4ReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~off4SeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~off4SeqView.valueAction_([0, 1]);
		// ~offView.valueAction_(~offSpec[track][seq].unmap(0) ! ~off[track][seq].size);
		~off4[track][seq] = /*~offSpec[track][seq].unmap(0)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~off4View.valueAction_(~off4[~tracksValue][~seqsValue]);

		~off4SeqMode.valueAction_(1);
		~off4RangeMode.valueAction_(0);
		// ~offThreshView.valueAction_(0.4);
		~off4DirView.valueAction_(0);
		~off4PatView.valueAction_(0);
		~off4PatSelView.valueAction_(4);
	};










	// RAT

	~makeRandFunction.(currentEnvironment, \rate, \rat, \ratView, \dur, \seqDurRat, \ratSeqView, \ratSeqStart, \ratSeqStop, \ratSeqSpec, \ratSeqVSpec, \ratReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~ratCopyA = { | track, seq |
		// pour le PasteA
		~ratRoundViewTemp = ~ratRoundView.value.copy;
		~ratRangeSpecTemp = ~ratRangeSpec[track][seq].copy;
		~ratSpecTemp = ~ratSpec[track][seq].copy;
		~ratMinTemp = ~ratMin[track][seq].copy;
		~ratMaxTemp = ~ratMax[track][seq].copy;
		~ratTemp = ~rat[track][seq].copy;
		~ratMulTemp = ~ratMul[track][seq].copy;
		~ratSeqSpecTemp = ~ratSeqSpec[track][seq].copy;
		~ratSeqStartTemp = ~ratSeqStart[track][seq].copy;
		~ratSeqStopTemp = ~ratSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~rat[track][seq].copy;
		~multiSeqSpecTemp = ~ratSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~ratSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~ratSeqStop[track][seq].copy;
	};

	~ratPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~ratTemp.isNil, {"You need to copy ~rat data !!!".postln}, {
			~ratRoundView.valueAction_(~ratRoundViewTemp);
			~ratSeqSpec[track][seq] = ~ratSeqSpecTemp;
			~ratSeqView.step_(1/(~ratTemp.size))
			.minRange_(1/(~ratTemp.size))
			.valueAction_([~ratSeqSpecTemp.unmap(~ratSeqStartTemp), ~ratSeqSpecTemp.unmap(~ratSeqStopTemp+1)])
			.doAction;
			// BUG si ~rat[track][seq] = ~ratTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~rat[track][seq] = Array.newClear(~ratTemp.size);
			~ratRangeSpec[track][seq] = ~ratRangeSpecTemp;
			~ratSpec[track][seq] = ~ratSpecTemp;
			~ratView.valueAction_(~ratTemp);
			~ratRangeView.valueAction_(~ratRangeSpecTemp.unmap([~ratMinTemp, ~ratMaxTemp]));
			~ratMulView.valueAction_(~ratMulSpec.unmap(~ratMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \ratPasteM, \rat, \ratView, \ratSpec, \multiTemp, \ratSeqSpec, \multiSeqSpecTemp, \ratSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~ratDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~ratRoundView.valueAction_(0);
		~ratRangePresetView.valueAction_(3);
		~ratMulPresetView.valueAction_(10);

		~ratSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~ratSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~ratReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~ratSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~ratSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~ratView.valueAction_(~ratSpec[track][seq].unmap(1) ! ~rat[track][seq].size);
		~rat[track][seq] = /*~ratSpec[track][seq].unmap(1)*/ 0.5 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~ratView.valueAction_(~rat[~tracksValue][~seqsValue]);

		~ratSeqMode.valueAction_(1);
		~ratRangeMode.valueAction_(0);
		~freqRatView.valueAction_(/*~freqRatSpec.unmap(0)*/ 0);
		~fAmpView.valueAction_(/*~fAmpSpec.unmap(0)*/ 0);
		~ratDirView.valueAction_(0);
		~ratPatView.valueAction_(0);
		~ratPatSelView.valueAction_(4);
	};










	// RAT 2

	~makeRandFunction.(currentEnvironment, \rate2f, \rat2, \rat2View, \dur, \seqDurRat2, \rat2SeqView, \rat2SeqStart, \rat2SeqStop, \rat2SeqSpec, \rat2SeqVSpec, \rat2ReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~rat2CopyA = { | track, seq |
		// pour le PasteA
		~rat2RoundViewTemp = ~rat2RoundView.value.copy;
		~rat2RangeSpecTemp = ~rat2RangeSpec[track][seq].copy;
		~rat2SpecTemp = ~rat2Spec[track][seq].copy;
		~rat2MinTemp = ~rat2Min[track][seq].copy;
		~rat2MaxTemp = ~rat2Max[track][seq].copy;
		~rat2Temp = ~rat2[track][seq].copy;
		~rat2MulTemp = ~rat2Mul[track][seq].copy;
		~rat2SeqSpecTemp = ~rat2SeqSpec[track][seq].copy;
		~rat2SeqStartTemp = ~rat2SeqStart[track][seq].copy;
		~rat2SeqStopTemp = ~rat2SeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~rat2[track][seq].copy;
		~multiSeqSpecTemp = ~rat2SeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~rat2SeqStart[track][seq].copy;
		~multiSeqStopTemp = ~rat2SeqStop[track][seq].copy;
	};

	~rat2PasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~rat2Temp.isNil, {"You need to copy ~rat2 data !!!".postln}, {
			~rat2RoundView.valueAction_(~rat2RoundViewTemp);
			~rat2SeqSpec[track][seq] = ~rat2SeqSpecTemp;
			~rat2SeqView.step_(1/(~rat2Temp.size))
			.minRange_(1/(~rat2Temp.size))
			.valueAction_([~rat2SeqSpecTemp.unmap(~rat2SeqStartTemp), ~rat2SeqSpecTemp.unmap(~rat2SeqStopTemp+1)])
			.doAction;
			// BUG si ~rat2[track][seq] = ~rat2Temp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~rat2[track][seq] = Array.newClear(~rat2Temp.size);
			~rat2RangeSpec[track][seq] = ~rat2RangeSpecTemp;
			~rat2Spec[track][seq] = ~rat2SpecTemp;
			~rat2View.valueAction_(~rat2Temp);
			~rat2RangeView.valueAction_(~rat2RangeSpecTemp.unmap([~rat2MinTemp, ~rat2MaxTemp]));
			~rat2MulView.valueAction_(~rat2MulSpec.unmap(~rat2MulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \rat2PasteM, \rat2, \rat2View, \rat2Spec, \multiTemp, \rat2SeqSpec, \multiSeqSpecTemp, \rat2SeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~rat2Default = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~rat2RoundView.valueAction_(0);
		~rat2RangePresetView.valueAction_(3);
		~rat2MulPresetView.valueAction_(10);

		~rat2SeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~rat2SeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~rat2ReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~rat2SeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~rat2SeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~rat2View.valueAction_(~rat2Spec[track][seq].unmap(1) ! ~rat2[track][seq].size);
		~rat2[track][seq] = /*~rat2Spec[track][seq].unmap(1)*/ 0.5 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~rat2View.valueAction_(~rat2[~tracksValue][~seqsValue]);

		~rat2SeqMode.valueAction_(1);
		~rat2RangeMode.valueAction_(0);
		// ~freqRat2View.valueAction_(/*~freqRat2Spec.unmap(0)*/ 0);
		// ~fAmp2View.valueAction_(/*~fAmpSpec.unmap(0)*/ 0);
		~rat2DirView.valueAction_(0);
		~rat2PatView.valueAction_(0);
		~rat2PatSelView.valueAction_(4);
	};










	// AMP

	~makeRandFunction.(currentEnvironment, \amplitude, \amp, \ampView, \dur, \seqDurAmp, \ampSeqView, \ampSeqStart, \ampSeqStop, \ampSeqSpec, \ampSeqVSpec, \ampReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~ampCopyA = { | track, seq |
		// pour le PasteA
		~ampRoundViewTemp = ~ampRoundView.value.copy;
		~ampRangeSpecTemp = ~ampRangeSpec[track][seq].copy;
		~ampSpecTemp = ~ampSpec[track][seq].copy;
		~ampMinTemp = ~ampMin[track][seq].copy;
		~ampMaxTemp = ~ampMax[track][seq].copy;
		~ampTemp = ~amp[track][seq].copy;
		~ampMulTemp = ~ampMul[track][seq].copy;
		~ampSeqSpecTemp = ~ampSeqSpec[track][seq].copy;
		~ampSeqStartTemp = ~ampSeqStart[track][seq].copy;
		~ampSeqStopTemp = ~ampSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~amp[track][seq].copy;
		~multiSeqSpecTemp = ~ampSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~ampSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~ampSeqStop[track][seq].copy;
	};

	~ampPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~ampTemp.isNil, {"You need to copy ~amp data !!!".postln}, {
			~ampRoundView.valueAction_(~ampRoundViewTemp);
			~ampSeqSpec[track][seq] = ~ampSeqSpecTemp;
			~ampSeqView.step_(1/(~ampTemp.size))
			.minRange_(1/(~ampTemp.size))
			.valueAction_([~ampSeqSpecTemp.unmap(~ampSeqStartTemp), ~ampSeqSpecTemp.unmap(~ampSeqStopTemp+1)])
			.doAction;
			// BUG si ~amp[track][seq] = ~ampTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~amp[track][seq] = Array.newClear(~ampTemp.size);
			~ampRangeSpec[track][seq] = ~ampRangeSpecTemp;
			~ampSpec[track][seq] = ~ampSpecTemp;
			~ampView.valueAction_(~ampTemp);
			~ampRangeView.valueAction_(~ampRangeSpecTemp.unmap([~ampMinTemp, ~ampMaxTemp]));
			~ampMulView.valueAction_(~ampMulSpec.unmap(~ampMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \ampPasteM, \amp, \ampView, \ampSpec, \multiTemp, \ampSeqSpec, \multiSeqSpecTemp, \ampSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~ampDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~ampRoundView.valueAction_(0);
		~ampRangePresetView.valueAction_(2);
		~ampMulPresetView.valueAction_(10);

		~ampSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~ampSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~ampReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~ampSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~ampSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~ampView.valueAction_(~ampSpec[track][seq].unmap(0.8) ! ~amp[track][seq].size);
		~amp[track][seq] = ~ampSpec[track][seq].unmap(/*0.8*/ 1 ) ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~ampView.valueAction_(~amp[~tracksValue][~seqsValue]);

		~ampSeqMode.valueAction_(1);
		~ampRangeMode.valueAction_(0);
		~ampRatView.valueAction_(/*~ampRatSpec.unmap(0)*/ 0);
		~aAmpView.valueAction_(/*~aAmpSpec.unmap(0)*/ 0);
		~ampDirView.valueAction_(0);
		~ampPatView.valueAction_(0);
		~ampPatSelView.valueAction_(4);
	};










	// STR

	~makeRandFunction.(currentEnvironment, \stretching, \str, \strView, \dur, \seqDurStr, \strSeqView, \strSeqStart, \strSeqStop, \strSeqSpec, \strSeqVSpec, \strReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~strCopyA = { | track, seq |
		// pour le PasteA
		~strRoundViewTemp = ~strRoundView.value.copy;
		~strRangeSpecTemp = ~strRangeSpec[track][seq].copy;
		~strSpecTemp = ~strSpec[track][seq].copy;
		~strMinTemp = ~strMin[track][seq].copy;
		~strMaxTemp = ~strMax[track][seq].copy;
		~strTemp = ~str[track][seq].copy;
		~strMulTemp = ~strMul[track][seq].copy;
		~strSeqSpecTemp = ~strSeqSpec[track][seq].copy;
		~strSeqStartTemp = ~strSeqStart[track][seq].copy;
		~strSeqStopTemp = ~strSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~str[track][seq].copy;
		~multiSeqSpecTemp = ~strSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~strSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~strSeqStop[track][seq].copy;
	};

	~strPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~strTemp.isNil, {"You need to copy ~str data !!!".postln}, {
			~strRoundView.valueAction_(~strRoundViewTemp);
			~strSeqSpec[track][seq] = ~strSeqSpecTemp;
			~strSeqView.step_(1/(~strTemp.size))
			.minRange_(1/(~strTemp.size))
			.valueAction_([~strSeqSpecTemp.unmap(~strSeqStartTemp), ~strSeqSpecTemp.unmap(~strSeqStopTemp+1)])
			.doAction;
			// BUG si ~str[track][seq] = ~strTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~str[track][seq] = Array.newClear(~strTemp.size);
			~strRangeSpec[track][seq] = ~strRangeSpecTemp;
			~strSpec[track][seq] = ~strSpecTemp;
			~strView.valueAction_(~strTemp);
			~strRangeView.valueAction_(~strRangeSpecTemp.unmap([~strMinTemp, ~strMaxTemp]));
			~strMulView.valueAction_(~strMulSpec.unmap(~strMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \strPasteM, \str, \strView, \strSpec, \multiTemp, \strSeqSpec, \multiSeqSpecTemp, \strSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~strDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~strRoundView.valueAction_(0);
		~strRangePresetView.valueAction_(3);
		~strMulPresetView.valueAction_(10);

		~strSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~strSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~strReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~strSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~strSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~strView.valueAction_(~strSpec[track][seq].unmap(1) ! ~str[track][seq].size);
		~str[track][seq] = /*~strSpec[track][seq].unmap(1)*/ 0.5 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~strView.valueAction_(~str[~tracksValue][~seqsValue]);

		~strSeqMode.valueAction_(1);
		~strRangeMode.valueAction_(0);
		~psPitchDispersView.valueAction_(~psPitchDispersSpec.unmap(~psPitchDispersSpec.default));
		~psTimeDispersView.valueAction_(~psTimeDispersSpec.unmap(~psTimeDispersSpec.default));
		~strDirView.valueAction_(0);
		~strPatView.valueAction_(0);
		~strPatSelView.valueAction_(4);
	};










	// STR 2

	~makeRandFunction.(currentEnvironment, \stretching2, \str2, \str2View, \dur, \seqDurStr2, \str2SeqView, \str2SeqStart, \str2SeqStop, \str2SeqSpec, \str2SeqVSpec, \str2ReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~str2CopyA = { | track, seq |
		// pour le PasteA
		~str2RoundViewTemp = ~str2RoundView.value.copy;
		~str2RangeSpecTemp = ~str2RangeSpec[track][seq].copy;
		~str2SpecTemp = ~str2Spec[track][seq].copy;
		~str2MinTemp = ~str2Min[track][seq].copy;
		~str2MaxTemp = ~str2Max[track][seq].copy;
		~str2Temp = ~str2[track][seq].copy;
		~str2MulTemp = ~str2Mul[track][seq].copy;
		~str2SeqSpecTemp = ~str2SeqSpec[track][seq].copy;
		~str2SeqStartTemp = ~str2SeqStart[track][seq].copy;
		~str2SeqStopTemp = ~str2SeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~str2[track][seq].copy;
		~multiSeqSpecTemp = ~str2SeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~str2SeqStart[track][seq].copy;
		~multiSeqStopTemp = ~str2SeqStop[track][seq].copy;
	};

	~str2PasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~str2Temp.isNil, {"You need to copy ~str2 data !!!".postln}, {
			~str2RoundView.valueAction_(~str2RoundViewTemp);
			~str2SeqSpec[track][seq] = ~str2SeqSpecTemp;
			~str2SeqView.step_(1/(~str2Temp.size))
			.minRange_(1/(~str2Temp.size))
			.valueAction_([~str2SeqSpecTemp.unmap(~str2SeqStartTemp), ~str2SeqSpecTemp.unmap(~str2SeqStopTemp+1)])
			.doAction;
			// BUG si ~str2[track][seq] = ~str2Temp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~str2[track][seq] = Array.newClear(~str2Temp.size);
			~str2RangeSpec[track][seq] = ~str2RangeSpecTemp;
			~str2Spec[track][seq] = ~str2SpecTemp;
			~str2View.valueAction_(~str2Temp);
			~str2RangeView.valueAction_(~str2RangeSpecTemp.unmap([~str2MinTemp, ~str2MaxTemp]));
			~str2MulView.valueAction_(~str2MulSpec.unmap(~str2MulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \str2PasteM, \str2, \str2View, \str2Spec, \multiTemp, \str2SeqSpec, \multiSeqSpecTemp, \str2SeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~str2Default = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~str2RoundView.valueAction_(0);
		~str2RangePresetView.valueAction_(3);
		~str2MulPresetView.valueAction_(10);

		~str2SeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~str2SeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~str2ReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~str2SeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~str2SeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~str2View.valueAction_(~str2Spec[track][seq].unmap(1) ! ~str2[track][seq].size);
		~str2[track][seq] = /*~str2Spec[track][seq].unmap(1)*/ 0.5 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~str2View.valueAction_(~str2[~tracksValue][~seqsValue]);

		~str2SeqMode.valueAction_(1);
		~str2RangeMode.valueAction_(0);
		~str2DirView.valueAction_(0);
		~str2PatView.valueAction_(0);
		~str2PatSelView.valueAction_(4);
	};










	// CEN

	~makeRandFunction.(currentEnvironment, \center, \cen, \cenView, \dur, \seqDurCen, \cenSeqView, \cenSeqStart, \cenSeqStop, \cenSeqSpec, \cenSeqVSpec, \cenReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~cenCopyA = { | track, seq |
		// pour le PasteA
		~cenRoundViewTemp = ~cenRoundView.value.copy;
		~cenRangeSpecTemp = ~cenRangeSpec[track][seq].copy;
		~cenSpecTemp = ~cenSpec[track][seq].copy;
		~cenMinTemp = ~cenMin[track][seq].copy;
		~cenMaxTemp = ~cenMax[track][seq].copy;
		~cenTemp = ~cen[track][seq].copy;
		~cenMulTemp = ~cenMul[track][seq].copy;
		~cenSeqSpecTemp = ~cenSeqSpec[track][seq].copy;
		~cenSeqStartTemp = ~cenSeqStart[track][seq].copy;
		~cenSeqStopTemp = ~cenSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~cen[track][seq].copy;
		~multiSeqSpecTemp = ~cenSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~cenSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~cenSeqStop[track][seq].copy;
	};

	~cenPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~cenTemp.isNil, {"You need to copy ~cen data !!!".postln}, {
			~cenRoundView.valueAction_(~cenRoundViewTemp);
			~cenSeqSpec[track][seq] = ~cenSeqSpecTemp;
			~cenSeqView.step_(1/(~cenTemp.size))
			.minRange_(1/(~cenTemp.size))
			.valueAction_([~cenSeqSpecTemp.unmap(~cenSeqStartTemp), ~cenSeqSpecTemp.unmap(~cenSeqStopTemp+1)])
			.doAction;
			// BUG si ~cen[track][seq] = ~cenTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~cen[track][seq] = Array.newClear(~cenTemp.size);
			~cenRangeSpec[track][seq] = ~cenRangeSpecTemp;
			~cenSpec[track][seq] = ~cenSpecTemp;
			~cenView.valueAction_(~cenTemp);
			~cenRangeView.valueAction_(~cenRangeSpecTemp.unmap([~cenMinTemp, ~cenMaxTemp]));
			~cenMulView.valueAction_(~cenMulSpec.unmap(~cenMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \cenPasteM, \cen, \cenView, \cenSpec, \multiTemp, \cenSeqSpec, \multiSeqSpecTemp, \cenSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~cenDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~cenRoundView.valueAction_(11);
		~cenRangePresetView.valueAction_(12);
		~cenMulPresetView.valueAction_(10);

		~cenSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~cenSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~cenReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~cenSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~cenSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~cenView.valueAction_(~cenSpec[track][seq].unmap(30) ! ~cen[track][seq].size);
		~cen[track][seq] = ~cenSpec[track][seq].unmap(60) ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~cenView.valueAction_(~cen[~tracksValue][~seqsValue]);

		~cenSeqMode.valueAction_(1);
		~cenRangeMode.valueAction_(0);
		~psWindowSizeView.valueAction_(~psWindowSizeSpec.unmap(~psWindowSizeSpec.default))/*.doAction*/;
		~cenDirView.valueAction_(0);
		~cenPatView.valueAction_(0);
		~cenPatSelView.valueAction_(4);
	};










	// CEN 2

	~makeRandFunction.(currentEnvironment, \center2, \cen2, \cen2View, \dur, \seqDurCen2, \cen2SeqView, \cen2SeqStart, \cen2SeqStop, \cen2SeqSpec, \cen2SeqVSpec, \cen2ReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~cen2CopyA = { | track, seq |
		// pour le PasteA
		~cen2RoundViewTemp = ~cen2RoundView.value.copy;
		~cen2RangeSpecTemp = ~cen2RangeSpec[track][seq].copy;
		~cen2SpecTemp = ~cen2Spec[track][seq].copy;
		~cen2MinTemp = ~cen2Min[track][seq].copy;
		~cen2MaxTemp = ~cen2Max[track][seq].copy;
		~cen2Temp = ~cen2[track][seq].copy;
		~cen2MulTemp = ~cen2Mul[track][seq].copy;
		~cen2SeqSpecTemp = ~cen2SeqSpec[track][seq].copy;
		~cen2SeqStartTemp = ~cen2SeqStart[track][seq].copy;
		~cen2SeqStopTemp = ~cen2SeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~cen2[track][seq].copy;
		~multiSeqSpecTemp = ~cen2SeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~cen2SeqStart[track][seq].copy;
		~multiSeqStopTemp = ~cen2SeqStop[track][seq].copy;
	};

	~cen2PasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~cen2Temp.isNil, {"You need to copy ~cen2 data !!!".postln}, {
			~cen2RoundView.valueAction_(~cen2RoundViewTemp);
			~cen2SeqSpec[track][seq] = ~cen2SeqSpecTemp;
			~cen2SeqView.step_(1/(~cen2Temp.size))
			.minRange_(1/(~cen2Temp.size))
			.valueAction_([~cen2SeqSpecTemp.unmap(~cen2SeqStartTemp), ~cen2SeqSpecTemp.unmap(~cen2SeqStopTemp+1)])
			.doAction;
			// BUG si ~cen2[track][seq] = ~cen2Temp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~cen2[track][seq] = Array.newClear(~cen2Temp.size);
			~cen2RangeSpec[track][seq] = ~cen2RangeSpecTemp;
			~cen2Spec[track][seq] = ~cen2SpecTemp;
			~cen2View.valueAction_(~cen2Temp);
			~cen2RangeView.valueAction_(~cen2RangeSpecTemp.unmap([~cen2MinTemp, ~cen2MaxTemp]));
			~cen2MulView.valueAction_(~cen2MulSpec.unmap(~cen2MulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \cen2PasteM, \cen2, \cen2View, \cen2Spec, \multiTemp, \cen2SeqSpec, \multiSeqSpecTemp, \cen2SeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~cen2Default = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~cen2RoundView.valueAction_(11);
		~cen2RangePresetView.valueAction_(12);
		~cen2MulPresetView.valueAction_(10);

		~cen2SeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~cen2SeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~cen2ReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~cen2SeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~cen2SeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~cen2View.valueAction_(~cen2Spec[track][seq].unmap(30) ! ~cen2[track][seq].size);
		~cen2[track][seq] = ~cen2Spec[track][seq].unmap(60) ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~cen2View.valueAction_(~cen2[~tracksValue][~seqsValue]);

		~cen2SeqMode.valueAction_(1);
		~cen2RangeMode.valueAction_(0);
		~cen2DirView.valueAction_(0);
		~cen2PatView.valueAction_(0);
		~cen2PatSelView.valueAction_(4);
	};










	// PAN

	~makeRandFunction.(currentEnvironment, \panning, \pan, \panView, \dur, \seqDurPan, \panSeqView, \panSeqStart, \panSeqStop, \panSeqSpec, \panSeqVSpec, \panReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~panCopyA = { | track, seq |
		// pour le PasteA
		~panRoundViewTemp = ~panRoundView.value.copy;
		~panRangeSpecTemp = ~panRangeSpec[track][seq].copy;
		~panSpecTemp = ~panSpec[track][seq].copy;
		~panMinTemp = ~panMin[track][seq].copy;
		~panMaxTemp = ~panMax[track][seq].copy;
		~panTemp = ~pan[track][seq].copy;
		~panMulTemp = ~panMul[track][seq].copy;
		~panSeqSpecTemp = ~panSeqSpec[track][seq].copy;
		~panSeqStartTemp = ~panSeqStart[track][seq].copy;
		~panSeqStopTemp = ~panSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~pan[track][seq].copy;
		~multiSeqSpecTemp = ~panSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~panSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~panSeqStop[track][seq].copy;
	};

	~panPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~panTemp.isNil, {"You need to copy ~pan data !!!".postln}, {
			~panRoundView.valueAction_(~panRoundViewTemp);
			~panSeqSpec[track][seq] = ~panSeqSpecTemp;
			~panSeqView.step_(1/(~panTemp.size))
			.minRange_(1/(~panTemp.size))
			.valueAction_([~panSeqSpecTemp.unmap(~panSeqStartTemp), ~panSeqSpecTemp.unmap(~panSeqStopTemp+1)])
			.doAction;
			// BUG si ~pan[track][seq] = ~panTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~pan[track][seq] = Array.newClear(~panTemp.size);
			~panRangeSpec[track][seq] = ~panRangeSpecTemp;
			~panSpec[track][seq] = ~panSpecTemp;
			~panView.valueAction_(~panTemp);
			~panRangeView.valueAction_(~panRangeSpecTemp.unmap([~panMinTemp, ~panMaxTemp]));
			~panMulView.valueAction_(~panMulSpec.unmap(~panMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \panPasteM, \pan, \panView, \panSpec, \multiTemp, \panSeqSpec, \multiSeqSpecTemp, \panSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~panDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~panRoundView.valueAction_(0);
		~panRangePresetView.valueAction_(~panRangePresetItems.size-1);
		~panMulPresetView.valueAction_(10);

		~panSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~panSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~panReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~panSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~panSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~panView.valueAction_(~panSpec[track][seq].unmap(0) ! ~pan[track][seq].size);
		~pan[track][seq] = /*~panSpec[track][seq].unmap(0)*/ 0.5 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~panView.valueAction_(~pan[~tracksValue][~seqsValue]);

		~panSeqMode.valueAction_(1);
		~panRangeMode.valueAction_(0);
		~panRatView.valueAction_(/*~panRatSpec.unmap(0)*/ 0);
		~pAmpView.valueAction_(/*~pAmpSpec.unmap(0)*/ 0);
		~panDirView.valueAction_(0);
		~panPatView.valueAction_(0);
		~panPatSelView.valueAction_(4);
	};










	// DEL

	~makeRandFunction.(currentEnvironment, \delay, \del, \delView, \dur, \seqDurDel, \delSeqView, \delSeqStart, \delSeqStop, \delSeqSpec, \delSeqVSpec, \delReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~delCopyA = { | track, seq |
		// pour le PasteA
		~delRoundViewTemp = ~delRoundView.value.copy;
		~delRangeSpecTemp = ~delRangeSpec[track][seq].copy;
		~delSpecTemp = ~delSpec[track][seq].copy;
		~delMinTemp = ~delMin[track][seq].copy;
		~delMaxTemp = ~delMax[track][seq].copy;
		~delTemp = ~del[track][seq].copy;
		~delMulTemp = ~delMul[track][seq].copy;
		~delSeqSpecTemp = ~delSeqSpec[track][seq].copy;
		~delSeqStartTemp = ~delSeqStart[track][seq].copy;
		~delSeqStopTemp = ~delSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~del[track][seq].copy;
		~multiSeqSpecTemp = ~delSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~delSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~delSeqStop[track][seq].copy;
	};

	~delPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~delTemp.isNil, {"You need to copy ~del data !!!".postln}, {
			~delRoundView.valueAction_(~delRoundViewTemp);
			~delSeqSpec[track][seq] = ~delSeqSpecTemp;
			~delSeqView.step_(1/(~delTemp.size))
			.minRange_(1/(~delTemp.size))
			.valueAction_([~delSeqSpecTemp.unmap(~delSeqStartTemp), ~delSeqSpecTemp.unmap(~delSeqStopTemp+1)])
			.doAction;
			// BUG si ~del[track][seq] = ~delTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~del[track][seq] = Array.newClear(~delTemp.size);
			~delRangeSpec[track][seq] = ~delRangeSpecTemp;
			~delSpec[track][seq] = ~delSpecTemp;
			~delView.valueAction_(~delTemp);
			~delRangeView.valueAction_(~delRangeSpecTemp.unmap([~delMinTemp, ~delMaxTemp]));
			~delMulView.valueAction_(~delMulSpec.unmap(~delMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \delPasteM, \del, \delView, \delSpec, \multiTemp, \delSeqSpec, \multiSeqSpecTemp, \delSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~delDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~delRoundView.valueAction_(0);
		~delRangePresetView.valueAction_(1);
		~delMulPresetView.valueAction_(10);

		~delSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~delSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~delReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~delSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~delSeqView.valueAction_([0, 1]);
		// ~delView.valueAction_(~delSpec[track][seq].unmap(0) ! ~del[track][seq].size);
		~del[track][seq] = /*~delSpec[track][seq].unmap(0)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~delView.valueAction_(~del[~tracksValue][~seqsValue]);

		~delSeqMode.valueAction_(1);
		~delRangeMode.valueAction_(0);
		~delDirView.valueAction_(0);
		~delPatView.valueAction_(0);
		~delPatSelView.valueAction_(4);
	};










	// OUT L

	~makeRandFunction.(currentEnvironment, \outingL, \outL, \outLView, \dur, \seqDurOutL, \outLSeqView, \outLSeqStart, \outLSeqStop, \outLSeqSpec, \outLSeqVSpec, \outLReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~outLCopyA = { | track, seq |
		// pour le PasteA
		~outLRangeSpecTemp = ~outLRangeSpec[track][seq].copy;
		~outLSpecTemp = ~outLSpec[track][seq].copy;
		~outLMinTemp = ~outLMin[track][seq].copy;
		~outLMaxTemp = ~outLMax[track][seq].copy;
		~outLTemp = ~outL[track][seq].copy;
		~outLMulTemp = ~outLMul[track][seq].copy;
		~outLSeqSpecTemp = ~outLSeqSpec[track][seq].copy;
		~outLSeqStartTemp = ~outLSeqStart[track][seq].copy;
		~outLSeqStopTemp = ~outLSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~outL[track][seq].copy;
		~multiSeqSpecTemp = ~outLSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~outLSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~outLSeqStop[track][seq].copy;
	};

	~outLPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~outLTemp.isNil, {"You need to copy ~outL data !!!".postln}, {
			~outLSeqSpec[track][seq] = ~outLSeqSpecTemp;
			~outLSeqView.step_(1/(~outLTemp.size))
			.minRange_(1/(~outLTemp.size))
			.valueAction_([~outLSeqSpecTemp.unmap(~outLSeqStartTemp), ~outLSeqSpecTemp.unmap(~outLSeqStopTemp+1)])
			.doAction;
			// BUG si ~outL[track][seq] = ~outLTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~outL[track][seq] = Array.newClear(~outLTemp.size);
			~outLRangeSpec[track][seq] = ~outLRangeSpecTemp;
			~outLSpec[track][seq] = ~outLSpecTemp;
			~outLView.valueAction_(~outLTemp);
			~outLRangeView.valueAction_(~outLRangeSpecTemp.unmap([~outLMinTemp, ~outLMaxTemp]));
			~outLMulView.valueAction_(~outLMulSpec.unmap(~outLMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \outLPasteM, \outL, \outLView, \outLSpec, \multiTemp, \outLSeqSpec, \multiSeqSpecTemp, \outLSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~outLDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~outLRangePresetView.valueAction_(if (~numChannelsConfig == "22-8+Dome-8-4-2-Pair", {8}, {10}));
		~outLMulPresetView.valueAction_(10);

		~outLSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~outLSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~outLReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~outLSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~outLSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~outLRoundView.valueAction_(~linksChannel -1);
		~outL[track][seq] = ~outLSpec[track][seq].unmap(~linksChannel) ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~outLView.valueAction_(~outL[~tracksValue][~seqsValue]);

		~outLSeqMode.valueAction_(1);
		~outLRangeMode.valueAction_(0);
		~outLDirView.valueAction_(0);
		~outLPatView.valueAction_(0);
		~outLPatSelView.valueAction_(55);
	};










	// OUT R

	~makeRandFunction.(currentEnvironment, \outingR, \outR, \outRView, \dur, \seqDurOutR, \outRSeqView, \outRSeqStart, \outRSeqStop, \outRSeqSpec, \outRSeqVSpec, \outRReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~outRCopyA = { | track, seq |
		// pour le PasteA
		~outRRangeSpecTemp = ~outRRangeSpec[track][seq].copy;
		~outRSpecTemp = ~outRSpec[track][seq].copy;
		~outRMinTemp = ~outRMin[track][seq].copy;
		~outRMaxTemp = ~outRMax[track][seq].copy;
		~outRTemp = ~outR[track][seq].copy;
		~outRMulTemp = ~outRMul[track][seq].copy;
		~outRSeqSpecTemp = ~outRSeqSpec[track][seq].copy;
		~outRSeqStartTemp = ~outRSeqStart[track][seq].copy;
		~outRSeqStopTemp = ~outRSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~outR[track][seq].copy;
		~multiSeqSpecTemp = ~outRSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~outRSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~outRSeqStop[track][seq].copy;
	};

	~outRPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~outRTemp.isNil, {"You need to copy ~outR data !!!".postln}, {
			~outRSeqSpec[track][seq] = ~outRSeqSpecTemp;
			~outRSeqView.step_(1/(~outRTemp.size))
			.minRange_(1/(~outRTemp.size))
			.valueAction_([~outRSeqSpecTemp.unmap(~outRSeqStartTemp), ~outRSeqSpecTemp.unmap(~outRSeqStopTemp+1)])
			.doAction;
			// BUG si ~outR[track][seq] = ~outRTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~outR[track][seq] = Array.newClear(~outRTemp.size);
			~outRRangeSpec[track][seq] = ~outRRangeSpecTemp;
			~outRSpec[track][seq] = ~outRSpecTemp;
			~outRView.valueAction_(~outRTemp);
			~outRRangeView.valueAction_(~outRRangeSpecTemp.unmap([~outRMinTemp, ~outRMaxTemp]));
			~outRMulView.valueAction_(~outRMulSpec.unmap(~outRMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \outRPasteM, \outR, \outRView, \outRSpec, \multiTemp, \outRSeqSpec, \multiSeqSpecTemp, \outRSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~outRDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~outRRangePresetView.valueAction_(if (~numChannelsConfig == "22-8+Dome-8-4-2-Pair", {8}, {10}));
		~outRMulPresetView.valueAction_(10);

		~outRSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~outRSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~outRReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~outRSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~outRSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~outRRoundView.valueAction_(~rightChannel -1);
		~outR[track][seq] = ~outRSpec[track][seq].unmap(~rightChannel) ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~outRView.valueAction_(~outR[~tracksValue][~seqsValue]);

		~outRSeqMode.valueAction_(1);
		~outRRangeMode.valueAction_(0);
		~outRDirView.valueAction_(0);
		~outRPatView.valueAction_(0);
		~outRPatSelView.valueAction_(55);
	};










	// FX L

	~makeRandFunction.(currentEnvironment, \efxL, \fxL, \fxLView, \dur, \seqDurFxL, \fxLSeqView, \fxLSeqStart, \fxLSeqStop, \fxLSeqSpec, \fxLSeqVSpec, \fxLReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~fxLCopyA = { | track, seq |
		// pour le PasteA
		~fxLRangeSpecTemp = ~fxLRangeSpec[track][seq].copy;
		~fxLSpecTemp = ~fxLSpec[track][seq].copy;
		~fxLMinTemp = ~fxLMin[track][seq].copy;
		~fxLMaxTemp = ~fxLMax[track][seq].copy;
		~fxLTemp = ~fxL[track][seq].copy;
		~fxLMulTemp = ~fxLMul[track][seq].copy;
		~fxLSeqSpecTemp = ~fxLSeqSpec[track][seq].copy;
		~fxLSeqStartTemp = ~fxLSeqStart[track][seq].copy;
		~fxLSeqStopTemp = ~fxLSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~fxL[track][seq].copy;
		~multiSeqSpecTemp = ~fxLSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~fxLSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~fxLSeqStop[track][seq].copy;
	};

	~fxLPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~fxLTemp.isNil, {"You need to copy ~fxL data !!!".postln}, {
			~fxLSeqSpec[track][seq] = ~fxLSeqSpecTemp;
			~fxLSeqView.step_(1/(~fxLTemp.size))
			.minRange_(1/(~fxLTemp.size))
			.valueAction_([~fxLSeqSpecTemp.unmap(~fxLSeqStartTemp), ~fxLSeqSpecTemp.unmap(~fxLSeqStopTemp+1)])
			.doAction;
			// BUG si ~fxL[track][seq] = ~fxLTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~fxL[track][seq] = Array.newClear(~fxLTemp.size);
			~fxLRangeSpec[track][seq] = ~fxLRangeSpecTemp;
			~fxLSpec[track][seq] = ~fxLSpecTemp;
			~fxLView.valueAction_(~fxLTemp);
			~fxLRangeView.valueAction_(~fxLRangeSpecTemp.unmap([~fxLMinTemp, ~fxLMaxTemp]));
			~fxLMulView.valueAction_(~fxLMulSpec.unmap(~fxLMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \fxLPasteM, \fxL, \fxLView, \fxLSpec, \multiTemp, \fxLSeqSpec, \multiSeqSpecTemp, \fxLSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~fxLDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~fxLRangePresetView.valueAction_(1);
		~fxLMulPresetView.valueAction_(10);

		~fxLSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~fxLSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~fxLReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~fxLSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~fxLSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~fxLRoundView.valueAction_(0);
		~fxL[track][seq] = /*~fxLSpec[track][seq].unmap(0)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~fxLView.valueAction_(~fxL[~tracksValue][~seqsValue]);

		~fxLSeqMode.valueAction_(1);
		~fxLRangeMode.valueAction_(0);
		~fxLDirView.valueAction_(0);
		~fxLPatView.valueAction_(0);
		~fxLPatSelView.valueAction_(4);
	};










	// FX R

	~makeRandFunction.(currentEnvironment, \efxR, \fxR, \fxRView, \dur, \seqDurFxR, \fxRSeqView, \fxRSeqStart, \fxRSeqStop, \fxRSeqSpec, \fxRSeqVSpec, \fxRReadView);

	// Changement des menus mis dans le Copy & Paste mais à ne pas mettre dans les presets XXXXXXX
	~fxRCopyA = { | track, seq |
		// pour le PasteA
		~fxRRangeSpecTemp = ~fxRRangeSpec[track][seq].copy;
		~fxRSpecTemp = ~fxRSpec[track][seq].copy;
		~fxRMinTemp = ~fxRMin[track][seq].copy;
		~fxRMaxTemp = ~fxRMax[track][seq].copy;
		~fxRTemp = ~fxR[track][seq].copy;
		~fxRMulTemp = ~fxRMul[track][seq].copy;
		~fxRSeqSpecTemp = ~fxRSeqSpec[track][seq].copy;
		~fxRSeqStartTemp = ~fxRSeqStart[track][seq].copy;
		~fxRSeqStopTemp = ~fxRSeqStop[track][seq].copy;
		// pour le PasteM
		~multiTemp = ~fxR[track][seq].copy;
		~multiSeqSpecTemp = ~fxRSeqSpec[track][seq].copy;
		~multiSeqStartTemp = ~fxRSeqStart[track][seq].copy;
		~multiSeqStopTemp = ~fxRSeqStop[track][seq].copy;
	};

	~fxRPasteA = { | track, seq |
		// essai avec ? pour gain de place, mais apparemment ne marche pas pas avec des données entre ()
		if (~fxRTemp.isNil, {"You need to copy ~fxR data !!!".postln}, {
			~fxRSeqSpec[track][seq] = ~fxRSeqSpecTemp;
			~fxRSeqView.step_(1/(~fxRTemp.size))
			.minRange_(1/(~fxRTemp.size))
			.valueAction_([~fxRSeqSpecTemp.unmap(~fxRSeqStartTemp), ~fxRSeqSpecTemp.unmap(~fxRSeqStopTemp+1)])
			.doAction;
			// BUG si ~fxR[track][seq] = ~fxRTemp; // pas de mémoire quand on agit entre temps sur le multislider (recopie la dernière action du multislider) ???
			// mais nécessaire lorsque le nb de valeurs dans le multislider sont différentes -> donc contournement en mettant des valeurs à 0
			~fxR[track][seq] = Array.newClear(~fxRTemp.size);
			~fxRRangeSpec[track][seq] = ~fxRRangeSpecTemp;
			~fxRSpec[track][seq] = ~fxRSpecTemp;
			~fxRView.valueAction_(~fxRTemp);
			~fxRRangeView.valueAction_(~fxRRangeSpecTemp.unmap([~fxRMinTemp, ~fxRMaxTemp]));
			~fxRMulView.valueAction_(~fxRMulSpec.unmap(~fxRMulTemp))} );
	};

	~makePasteMFunction.(currentEnvironment, \fxRPasteM, \fxR, \fxRView, \fxRSpec, \multiTemp, \fxRSeqSpec, \multiSeqSpecTemp, \fxRSeqView, \multiSeqStartTemp, \multiSeqStopTemp);

	~fxRDefault = { | track, seq |
		var seqDur = ~dur[track][seq].size;
		~fxRRangePresetView.valueAction_(1);
		~fxRMulPresetView.valueAction_(10);

		~fxRSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
		~fxRSeqVSpec[track][seq] = ControlSpec(0, seqDur-1, \lin, 1, 1);
		~fxRReadView.thumbSize_(max(~readViewThumbSize, (333*~xSizeMul) / seqDur));
		~fxRSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
		~fxRSeqView.valueAction_([0, 1]); // pour englober toute la séquence
		// ~fxRRoundView.valueAction_(0);
		~fxR[track][seq] = /*~fxRSpec[track][seq].unmap(0)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
		~fxRView.valueAction_(~fxR[~tracksValue][~seqsValue]);

		~fxRSeqMode.valueAction_(1);
		~fxRRangeMode.valueAction_(0);
		~fxRDirView.valueAction_(0);
		~fxRPatView.valueAction_(0);
		~fxRPatSelView.valueAction_(4);
	};










	// Fonctions globales

	~copyA = { | track, seq |
		~rtmCopyA.value(track, seq);
		~proCopyA.value(track, seq);
		~synCopyA.value(track, seq);
		~spaCopyA.value(track, seq);
		~envCopyA.value(track, seq);
		~bufCopyA.value(track, seq);
		~ratCopyA.value(track, seq); ~rat2CopyA.value(track, seq);
		~strCopyA.value(track, seq); ~str2CopyA.value(track, seq);
		~ampCopyA.value(track, seq);
		~offCopyA.value(track, seq); ~off2CopyA.value(track, seq); ~off3CopyA.value(track, seq); ~off4CopyA.value(track, seq);
		~legCopyA.value(track, seq);
		~cenCopyA.value(track, seq); ~cen2CopyA.value(track, seq);
		~panCopyA.value(track, seq);
		~delCopyA.value(track, seq);
		~outLCopyA.value(track, seq);
		~outRCopyA.value(track, seq);
		~fxLCopyA.value(track, seq);
		~fxRCopyA.value(track, seq);
	};

	~pasteA = { | track, seq |
		var previousfxActOnWhich = ~fxActOnWhich; // Pour éviter que le fxL agisse sur le droit
		var previousoutActOnWhich = ~outActOnWhich; // Pour éviter que le outL agisse sur le droit
		var previousoutCompChoose = ~outCompChoose;
		~fxActOnWhichView.valueAction_(0); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(0); // Pour éviter que le outL agisse sur le droit

		~rtmPasteA.value(track, seq);
		~proPasteA.value(track, seq);
		~synPasteA.value(track, seq);
		~spaPasteA.value(track, seq);
		~envPasteA.value(track, seq);
		~bufPasteA.value(track, seq);
		~ratPasteA.value(track, seq); ~rat2PasteA.value(track, seq);
		~strPasteA.value(track, seq); ~str2PasteA.value(track, seq);
		~ampPasteA.value(track, seq);
		~offPasteA.value(track, seq); ~off2PasteA.value(track, seq); ~off3PasteA.value(track, seq); ~off4PasteA.value(track, seq);
		~legPasteA.value(track, seq);
		~cenPasteA.value(track, seq); ~cen2PasteA.value(track, seq);
		~panPasteA.value(track, seq);
		~delPasteA.value(track, seq);
		~outLPasteA.value(track, seq);
		~outRPasteA.value(track, seq);
		~fxLPasteA.value(track, seq);
		~fxRPasteA.value(track, seq);

		~fxActOnWhichView.valueAction_(previousfxActOnWhich); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(previousoutActOnWhich); // Pour éviter que le outL agisse sur le droit
		~outCompChooseView.valueAction_(previousoutCompChoose);
	};

	// utilisé notamment dans le ~retriggerPresetViewG
	~defaultA = { | track, seq |
		var previousfxActOnWhich = ~fxActOnWhich; // Pour éviter que le fxL agisse sur le droit
		var previousoutActOnWhich = ~outActOnWhich; // Pour éviter que le outL agisse sur le droit
		var previousoutCompChoose = ~outCompChoose;
		~fxActOnWhichView.valueAction_(0); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(0); // Pour éviter que le outL agisse sur le droit

		~rtmDefault.value(track, seq); // Nécessaire sinon erreur sur les Arrays
		// ~duration2show.value(track, seq); // déjà englobé dans ~rtmDefault
		~proDefault.value(track, seq);
		~synDefault.value(track, seq);
		~spaDefault.value(track, seq);
		~envDefault.value(track, seq);
		~bufDefault.value(track, seq);
		~ratDefault.value(track, seq); ~rat2Default.value(track, seq);
		~strDefault.value(track, seq); ~str2Default.value(track, seq);
		~ampDefault.value(track, seq);
		~offDefault.value(track, seq); ~off2Default.value(track, seq); ~off3Default.value(track, seq); ~off4Default.value(track, seq);
		~legDefault.value(track, seq);
		~cenDefault.value(track, seq); ~cen2Default.value(track, seq);
		~panDefault.value(track, seq);
		~delDefault.value(track, seq);
		~outLDefault.value(track, seq);
		~outRDefault.value(track, seq);
		~fxLDefault.value(track, seq);
		~fxRDefault.value(track, seq);

		~fxActOnWhichView.valueAction_(previousfxActOnWhich); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(previousoutActOnWhich); // Pour éviter que le outL agisse sur le droit
		~outCompChooseView.valueAction_(previousoutCompChoose);
	};

}.value;































// GUI Pdef

// problème avec le minSize qui ne marche pas ?
// checker le filtrage er l'ordre ?
// check pb de quantisation et affichage visuel au moment de la pause et reprise ?
/*Pdef(\a_one);
Pdef(\b_two);
Pdef(\c_three);
Pdef(\d_four);
Pdef(\e_five);
Pdef(\f_six);
Pdef(\g_seven);
Pdef(\h_height);
m = PdefAllGui(8, bounds: Rect(30, 900, 60, 60));*/






























// GUI CompositeView & StackLayout

// w.view.decorator = FlowLayout(w.view.bounds); // Pourquoi obligé de le retirer sinon le 2ème CompositeView se met forcément en dessous du 1er ???
// w.view.background_(Color.gray.alpha_(0.4)); // ne peut être mis dans le EZKnob car sinon pris en compte de SCCompoisteView et problème avec les valueAction ???????
// w.view.decorator.gap=2@2; // ???
~globalWindow = Window("Live for Life -- (A)Rhythmics in Space -- Space Loop Atomizer"/*, border: false*/, scroll: ~mainWindowScroll).setTopLeftBounds( Rect( /*328*/ /*(328+~windowWidth-1920)*~xSizeMul*/ ~windowWidth-(1605*~xSizeMul), 0, 1605*~xSizeMul, 1128*~ySizeMul)).background_(Color(0.5, 0.5, 0.5)).front;

// Fermeture de toutes les fenêtres et arrêt des patterns & de la routine d'update graphique si fermeture de la fenêtre principale
// ~globalWindow.onClose = {Pdef.all.size.do {|i| Pdef.all[~patterns[i]].stop }; ~fxSynth.size.do{|i| ~fxSynth[i].free; ~fxSynth2[i].free }; ~visuel.stop; m.close; v.close; ~controlWindow.close};
// obligé de rajouter .onClose sur ~controlWindow ci-dessous car WFSPathGUI enpêche de fermer certaines fenêtres correctement ???

// Comment assigner une couleur de String au Window ??? .stringColor(Color.white);

// OLD TabbedView
// ~tabbedView = TabbedView(w,Rect(2, 14, 1600, 1110), ["Sequence", "Code"]).tabHeight_(30).tabWidth_(80).labelColors_([Color.blue]).unfocusedColors_([Color.white]).backgrounds_([Color(0.8, 0.8, 0.8)]).tabCurve_(10);

~tabbedView = TabbedView2(~globalWindow, Rect(2*~xSizeMul, 23*~ySizeMul, 1600*~xSizeMul, 1110*~ySizeMul))
.lockPosition_(true)
.lockEdges_(true)
.backgrounds_([Color(0.8, 0.8, 0.8)])
.unfocusedColors_([Color.white])
.labelColors_([Color.blue])
.tabHeight_(22*~ySizeMul).tabWidth_(if (~server2.isNil, {25*~xSizeMul}, {25*~xSizeMul})).tabCurve_(8)
.font_(Font("Verdana",12*~fontSizeMul, bold: true));

~changeSeqMetaControls = { |tr, seq|
	~pFadeView.valueAction_(~pFadeSpec.unmap(~pFade[tr]));
	~quantView.valueAction_(~quantSpec.unmap(~quant[tr]));
	~rtmMulView.valueAction_(~rtmMulSpec[tr][seq].unmap(~rtmMul[tr][seq]));
	~proPatView.valueAction_(~proPat[tr][seq]);
	// ~proBjorView.valueAction_(~proBjorSpec[tr][seq].unmap(~proBjor[tr][seq])); // Old avant SC Grids
	// ~proBjor2View.valueAction_(~proBjorSpec[tr][seq].unmap(~proBjor2[tr][seq])); // Old avant SC Grids
	~proBjorView.valueAction_(~proBjorGridsX[tr][seq]);
	~proBjor2View.valueAction_(~proBjorGridsY[tr][seq]);
	~proSelectView.valueAction_(~proSelect[tr][seq]);
	~proMulView.valueAction_(~proMulSpec.unmap(~proMul[tr][seq]));
	~ratMulView.valueAction_(~ratMulSpec.unmap(~ratMul[tr][seq])); ~rat2MulView.valueAction_(~ratMulSpec.unmap(~rat2Mul[tr][seq]));
	~legMulView.valueAction_(~legMulSpec.unmap(~legMul[tr][seq]));
	~strMulView.valueAction_(~strMulSpec.unmap(~strMul[tr][seq])); ~str2MulView.valueAction_(~strMulSpec.unmap(~str2Mul[tr][seq]));
	~cenMulView.valueAction_(~cenMulSpec.unmap(~cenMul[tr][seq])); ~cen2MulView.valueAction_(~cenMulSpec.unmap(~cen2Mul[tr][seq]));
	~bufMulView.valueAction_(~bufMulSpec.unmap(~bufMul[tr][seq]));
	~offMulView.valueAction_(~offMulSpec.unmap(~offMul[tr][seq]));

	// ci-dessous retiré car récupère une mauvaise valeur par défaut du tab global vers le tab de la seq
	// ~spaRangePresetView.valueAction_(~spaRangePreset[tr][seq]); /*~spaRangePresetItemsListView.value_(~spaRangePreset[tr][seq]); // supprimé*/
	// ~panRangePresetView.valueAction_(~panRangePreset[tr][seq]);
	~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([~spaMin[tr][seq], ~spaMax[tr][seq]]));
	~panRangeView.valueAction_(~panRangeSpec[tr][seq].unmap([~panMin[tr][seq], ~panMax[tr][seq]]));

	~spaPatSelView.valueAction_(~spaPatSel[tr][seq]);
	~spaPatView.valueAction_(~spaPat[tr][seq]);

	~bufFolderView.valueAction_(~bufFolderValue[tr][seq]);
};

~changeSeqMetaControlsG = { |tr, seq|
	// ~pFadeViewG[tr].value_(~pFadeSpec.unmap(~pFade[tr])).string = ("X:%-%s").format(~pFade[tr], (~pFade[tr] / ~toTempo).round(0.01)); // pas necessaire car pas une info d'un preset
	// ~quantViewG[tr].value_(~quantSpec.unmap(~quant[tr])).string = ("Q:%-%s").format(~quant[tr], (~quant[tr] / ~toTempo).round(0.01)); // pas necessaire car pas une info d'un preset
	~rtmMulViewG[tr].value_(~rtmMulSpec[tr][seq].unmap(~rtmMul[tr][seq])).string = "Rtm : %".format(~rtmMul[tr][seq].round(0.001));
	~proPatViewG[tr].value_(~proPat[tr][seq]);
	// ~proBjorViewG[tr].value_(~proBjorSpec[tr][seq].unmap(~proBjor[tr][seq])).string = "Hit : %".format(~proBjor[tr][seq].asInteger); // Old avant SC Grids
	// ~proBjor2ViewG[tr].value_(~proBjorSpec[tr][seq].unmap(~proBjor2[tr][seq])).string = "Off : %".format(~proBjor2[tr][seq].asInteger); // Old avant SC Grids
	~proBjorViewG[tr].value_(~proBjorGridsX[tr][seq]).string = "H: %-%".format(~proBjor[tr][seq], ~proBjorGridsX[tr][seq]);
	~proBjor2ViewG[tr].value_(~proBjorGridsY[tr][seq]).string = "O: %-%".format(~proBjor2[tr][seq], ~proBjorGridsY[tr][seq]);
	~proSelectViewG[tr].value_(~proSelect[tr][seq]);
	~proMulViewG[tr].value_(~proMulSpec.unmap(~proMul[tr][seq])).string = "Pro : %".format(~proMul[tr][seq].round(0.01));
	~ratMulViewG[tr].value_(~ratMulSpec.unmap(~ratMul[tr][seq])).string = "Rat : %".format(~ratMul[tr][seq].round(0.01)); // ~rat2MulView.valueAction_(~ratMulSpec.unmap(~rat2Mul[tr][seq]));
	~legMulViewG[tr].value_(~legMulSpec.unmap(~legMul[tr][seq])).string = "Dur : %".format(~legMul[tr][seq].round(0.01));
	~strMulViewG[tr].value_(~strMulSpec.unmap(~strMul[tr][seq])).string = "Str : %".format(~strMul[tr][seq].round(0.01)); // ~str2MulView.valueAction_(~strMulSpec.unmap(~str2Mul[tr][seq]));
	~cenMulViewG[tr].value_(~cenMulSpec.unmap(~cenMul[tr][seq])).string = "Cen : %".format(~cenMul[tr][seq].round(0.01)); // ~cen2MulView.valueAction_(~cenMulSpec.unmap(~cen2Mul[tr][seq]));
	~bufMulViewG[tr].value_(~bufMulSpec.unmap(~bufMul[tr][seq])).string = "Buf : %".format(~bufMul[tr][seq].round(0.01));
	~offMulViewG[tr].value_(~offMulSpec.unmap(~offMul[tr][seq])).string = "Pos : %".format(~offMul[tr][seq].round(0.01));

	// ci-dessous retiré car récupère une mauvaise valeur par défaut du tab global vers le tab de la seq
	// ~spaRangePresetView.valueAction_(~spaRangePreset[tr][seq]); /*~spaRangePresetItemsListView.value_(~spaRangePreset[tr][seq]); // supprimé*/
	// ~panRangePresetView.valueAction_(~panRangePreset[tr][seq]);

	~spaPatSelViewG[tr].value_(~spaPatSel[tr][seq]);
	~spaPatViewG[tr].value_(~spaPat[tr][seq]);
	if (~spaPat[tr][seq] == 1, {
		~spaPatSelViewG[tr].background_(Color.red(0.7)).stringColor_(Color.white); // repris de envir[patView].states
	},{
		~spaPatSelViewG[tr].background_(~popUpMenuBackgroundColor).stringColor_(~popUpMenuStringColor);
	});
};


~seqComp5MaxVisibleOrigin = 4600*~ySizeMul;
~seqCompG1MaxVisibleOrigin = 4380*~ySizeMul;


~tabGUI = ~tabbedView.add("S" /*, scroll:true*/).focusAction = { ~currentTab = 0;
	// Impact sur le global
	/*~presetSeqRangeView.doAction;*/ ~presetSeqRangeView.value_(~presetSeqRangeSpec.unmap([~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]+1]) );
	~nbOfSeqs.do { |i|
		~presetSeqTextView[i].string = ~presetSelection[~tracksValue][i];
	};
	// ~seqComp5.visibleOrigin = ~seqCompG1[~tracksValue].visibleOrigin; // Pour conserver la visualisation des presets de séquences
	~seqComp5.visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-4)*20*~ySizeMul).max(0).min(~seqComp5MaxVisibleOrigin); // Préférable de le lier à la séquence car visibleOrigin est différent pour ~seqComp5 & ~seqCompG1 vu leur taille
	~changeSeqMetaControls.(~tracksValue, ~seqsValue);
};


~tabGlobal = ~tabbedView.add("G" /*, scroll:true*/).focusAction={ ~currentTab = 3;
	// Mise à jour du SeqReadView qui n'est mis à jour que lorsque ~currentTab = 3
	~nbOfTracksX2.do { |tr|
		if (~playViewValue[tr] == 1, {~seqReadViewG[tr].value_(~seqSeqSpec3.unmap(~posSeq2[tr])); });
		// ~seqCompG1[~tracksValue].visibleOrigin = ~seqComp5.visibleOrigin; // Pour conserver la visualisation des presets de séquences
		~seqCompG1[tr/*~tracksValue*/].visibleOrigin = 0@( (~presetSeqStart[tr/*~tracksValue*/]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin); // Préférable de le lier à la séquence car visibleOrigin est différent pour ~seqComp5 & ~seqCompG1 vu leur taille
	};
};


~tabFX = ~tabbedView.add("F"/*, scroll:true*/)/*.tabWidth_(24)*/.focusAction={~currentTab = 1};
~tabEQ = ~tabbedView.add("X"/*, scroll:true*/)/*.tabWidth_(24)*/.focusAction={~currentTab = 2};
~tabAMB = ~tabbedView.add("A" /*, scroll:true*/)/*.tabWidth_(24)*/.focusAction={~currentTab = 5};

~tabbedFX = TabbedView2(~tabFX, Rect(0, 0, 1600*~xSizeMul, 1082*~ySizeMul /*1110*/))
.lockPosition_(true)
.lockEdges_(true)
.backgrounds_([Color(0.8, 0.8, 0.8)])
.unfocusedColors_([Color.white])
.labelColors_([Color.blue])
.tabHeight_(15*~ySizeMul).tabWidth_(77*~xSizeMul).tabPosition_(\top)/*.tabCurve_(8)*/
.font_(Font("Verdana",11*~fontSizeMul, bold: false));

~tabbedEQ = TabbedView2(~tabEQ, Rect(0, 0, 1600*~xSizeMul, 1082*~ySizeMul /*1110*/))
.lockPosition_(true)
.lockEdges_(true)
.backgrounds_([Color(0.8, 0.8, 0.8)])
.unfocusedColors_([Color.white])
.labelColors_([Color.blue])
.tabHeight_(15*~ySizeMul).tabWidth_(77*~xSizeMul).tabPosition_(\top)/*.tabCurve_(8)*/
.font_(Font("Verdana",11*~fontSizeMul, bold: false));

~tabbedAMB = TabbedView2(~tabAMB, Rect(0, 0, 1600*~xSizeMul, 1110*~ySizeMul))
.lockPosition_(true)
.lockEdges_(true)
.backgrounds_([Color(0.8, 0.8, 0.8)])
.unfocusedColors_([Color.white])
.labelColors_([Color.blue])
.tabHeight_(15*~ySizeMul).tabWidth_(77*~xSizeMul).tabPosition_(\top)/*.tabCurve_(8)*/
.font_(Font("Verdana",11*~fontSizeMul, bold: false));

~tabFx = 0 ! 2;
~tabEq = 0 ! 2;
~tabAmb = 0 ! 2;
~tabFx[0] = ~tabbedFX.add("F1", scroll:true)/*.tabWidth_(24)*/.focusAction={~currentServerTab = 0};
~tabEq[0] = ~tabbedEQ.add("X1" , scroll:true)/*.tabWidth_(24)*/.focusAction={~currentServerTab = 0};
~tabAmb[0] = ~tabbedAMB.add("A1" /*, scroll:true*/)/*.tabWidth_(24)*/.focusAction={~currentServerTab = 0};
if (~server2.notNil, {
	~tabFx[1] = ~tabbedFX.add("F2", scroll:true)/*.tabWidth_(24)*/.focusAction={~currentServerTab = 1};
	~tabEq[1] = ~tabbedEQ.add("X2" , scroll:true)/*.tabWidth_(24)*/.focusAction={~currentServerTab = 1};
	~tabAmb[1] = ~tabbedAMB.add("A2" /*, scroll:true*/)/*.tabWidth_(24)*/.focusAction={~currentServerTab = 1};
});
~tabCode = ~tabbedView.add("C" /*, scroll:true*/)/*.tabWidth_(26)*/.focusAction={~currentTab = 4};



// ~currentTab = /*0*/ 3;
// ~tabbedView.focus(1);
~currentServerTab = 0;



~patComp = CompositeView(~tabGUI, Rect(2*~xSizeMul, 227*~ySizeMul, 399*~xSizeMul, (238+26)*~ySizeMul)).background = ~patCompColor;

~rtmComp = CompositeView(~tabGUI, Rect(2*~xSizeMul, (465+26)*~ySizeMul, 399*~xSizeMul, (183-26)*~ySizeMul)).background = ~rtmCompColor;
~rtmCompb = CompositeView(~tabGUI, Rect(2*~xSizeMul, (465+26)*~ySizeMul, 399*~xSizeMul, (183-26)*~ySizeMul));
~rtmStackComp = StackLayout(~rtmComp, ~rtmCompb).mode_(\stackOne);
~rtmStackCompL = CompositeView(~tabGUI, Rect(2*~xSizeMul, (465+26)*~ySizeMul, 399*~xSizeMul, (183-26)*~ySizeMul)).background_(~patCompColor/*~rtmCompColor*/).layout_(~rtmStackComp);

~rtmCompChooseView = RoundButton(~tabGUI, Rect(352*~xSizeMul, 441*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul))
.states_([["\RTM", Color.white, Color.blue], ["\GEN", Color.white, Color.red]])
.font_(Font("Verdana",10*~fontSizeMul))
.action_({|i| ~rtmCompChoose = i.value; ~rtmStackComp.index = ~rtmCompChoose })
.value_(1).doAction;

~rtmComp2 = CompositeView(~tabGUI, Rect(2*~xSizeMul, 648*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~rtmCompColor;
~proComp = CompositeView(~tabGUI, Rect(2*~xSizeMul, 864*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~rtmCompColor;
~synComp = CompositeView(~tabGUI, Rect(401*~xSizeMul, 0, 399*~xSizeMul, 216*~ySizeMul)).background = ~compColor1;
~spaComp = CompositeView(~tabGUI, Rect(800*~xSizeMul, 0, 399*~xSizeMul, 216*~ySizeMul)).background = ~panCompColor;
~legComp = CompositeView(~tabGUI, Rect(401*~xSizeMul, 216*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~compColor1;
~envComp = CompositeView(~tabGUI, Rect(800*~xSizeMul, 216*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~compColor2;
~ampComp = CompositeView(~tabGUI, Rect(800*~xSizeMul, 432*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~compColor2;
~bufComp = CompositeView(~tabGUI, Rect(401*~xSizeMul, 432*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~compColor1;

~offComp = CompositeView(~tabGUI, Rect(800*~xSizeMul, 648*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~compColor2;
~off2Comp = CompositeView(~tabGUI, Rect(800*~xSizeMul, 648*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~compColor2;
~off3Comp = CompositeView(~tabGUI, Rect(800*~xSizeMul, 648*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~compColor2;
~off4Comp = CompositeView(~tabGUI, Rect(800*~xSizeMul, 648*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~compColor2;
~offStackComp = StackLayout(~offComp, ~off2Comp, ~off3Comp, ~off4Comp).mode_(\stackOne);
~offStackCompL = CompositeView(~tabGUI, Rect(800*~xSizeMul, 648*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background_(~compColor1).layout_(~offStackComp);

~off2CompChooseView = RoundButton(~tabGUI, Rect(1167*~xSizeMul, 649*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
.states_([["\Thr", Color.blue, Color.white], ["\Fou", Color.red, Color.white]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({|i| ~offCompChoose = i.value+2; ~offStackComp.index = ~offCompChoose })
.value_(1).doAction;

~offCompChooseView = RoundButton(~tabGUI, Rect(1137*~xSizeMul, 649*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
.states_([["\One", Color.blue, Color.white], ["\Two", Color.red, Color.white]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({|i| ~offCompChoose = i.value; ~offStackComp.index = ~offCompChoose })
.value_(0).doAction;

~spa2Comp = CompositeView(~tabGUI, Rect(1199*~xSizeMul, 0, 399*~xSizeMul, 216*~ySizeMul)).background = ~panCompColor;
~panComp = CompositeView(~tabGUI, Rect(1199*~xSizeMul, 216*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~panCompColor;
~delComp = CompositeView(~tabGUI, Rect(1199*~xSizeMul, (216+216)*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background = ~panCompColor;

~ratComp = CompositeView(~tabGUI, Rect(401*~xSizeMul, 648*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul))/*.background = ~compColor1*/;
~rat2Comp = CompositeView(~tabGUI, Rect(401*~xSizeMul, 648*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul))/*.background = ~compColor1*/;
~ratStackComp = StackLayout(~ratComp, ~rat2Comp).mode_(\stackOne);
~ratStackCompL = CompositeView(~tabGUI, Rect(401*~xSizeMul, 648*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background_(~compColor1).layout_(~ratStackComp);

~ratCompChooseView = RoundButton(~tabGUI, Rect(738*~xSizeMul, 649*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
.states_([["\One", Color.blue, Color.white], ["\Two", Color.red, Color.white]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({|i| ~ratCompChoose = i.value; ~ratStackComp.index = ~ratCompChoose })
.value_(0).doAction; // Pourquoi .valueAction_(0); ne marche pas alors que .valueAction_(1); & nécessité de rajouter .doAction; car n'est activé que lorque l'état change par rapport au pécédent XXXXXXXXX

~ratSynthView = RoundButton(~tabGUI, Rect(768*~xSizeMul, 649*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
.states_([["\Gliss", Color.white, Color.red], ["\Gliss", Color.black, Color.green]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({|i| ~ratSynth[~tracksValue][~seqSeq[~tracksValue]] = i.value;

	if (~lemurConnected1 == 1, {
		if (~ratSynth[~tracksValue][~seqSeq[~tracksValue]] == 0, { // ~currentSeq = ~seqSeq[tr] dans le pattern  - non décalage
			~lemurAdress1.sendMsg( *[ ["/ParC/Gliss"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
		},{
			~lemurAdress1.sendMsg( *[ ["/ParC/Gliss"] ++ ["@color"] ++ [~greenLemurColor, ~greenLemurColor]  ].flatten(1) );
		});
	});

})
.valueAction_(0);


~strComp = CompositeView(~tabGUI, Rect(401*~xSizeMul, 864*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul))/*.background = ~strCompColor*/;
~str2Comp = CompositeView(~tabGUI, Rect(401*~xSizeMul, 864*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul))/*.background = ~strCompColor*/;
~strStackComp = StackLayout(~strComp, ~str2Comp).mode_(\stackOne);
~strStackCompL = CompositeView(~tabGUI, Rect(401*~xSizeMul, 864*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background_(~strCompColor).layout_(~strStackComp);

~strCompChooseView = RoundButton(~tabGUI, Rect(738*~xSizeMul, 865*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
.states_([["\One", Color.blue, Color.white], ["\Two", Color.red, Color.white]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({|i| ~strCompChoose = i.value; ~strStackComp.index = ~strCompChoose })
.value_(0).doAction;


~cenComp = CompositeView(~tabGUI, Rect(800*~xSizeMul, 864*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul))/*.background = ~strCompColor*/;
~cen2Comp = CompositeView(~tabGUI, Rect(800*~xSizeMul, 864*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul))/*.background = ~strCompColor*/;
~cenStackComp = StackLayout(~cenComp, ~cen2Comp).mode_(\stackOne);
~cenStackCompL = CompositeView(~tabGUI, Rect(800*~xSizeMul, 864*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background_(~strCompColor).layout_(~cenStackComp);

~cenCompChooseView = RoundButton(~tabGUI, Rect(1137*~xSizeMul, 865*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
.states_([["\One", Color.blue, Color.white], ["\Two", Color.red, Color.white]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({|i| ~cenCompChoose = i.value; ~cenStackComp.index = ~cenCompChoose })
.value_(0).doAction;

~transCompView = RoundButton(~tabGUI, Rect(1167*~xSizeMul, 865*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
.states_([["\Trans", Color.white, Color.red], ["\Trans", Color.black, Color.green]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({|i| ~transComp[~tracksValue][~seqsValue] = i.value;
	~ratStackComp.mode = ~transComp[~tracksValue][~seqsValue]; ~strStackComp.mode = ~transComp[~tracksValue][~seqsValue]; ~cenStackComp.mode = ~transComp[~tracksValue][~seqsValue]; ~offStackComp.mode = ~transComp[~tracksValue][~seqsValue];
	if (~transComp[~tracksValue][~seqsValue] == 1, {
		[~ratView, ~rat2View, ~strView, ~str2View, ~cenView, ~cen2View, ~offView, ~off2View].do { |i| i.showIndex_(~multiSliderIndex) };
	},{
		[~ratView, ~rat2View, ~strView, ~str2View, ~cenView, ~cen2View, ~offView, ~off2View].do { |i| i.showIndex_(~multiSliderIndex) };
	});
})
.valueAction_(0);

~ratCompAllChooseView = RoundButton(~tabGUI, Rect(768*~xSizeMul, 865*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
.states_([["\One", Color.blue, Color.white], ["\Two", Color.red, Color.white]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({|i|
	~ratCompAllChoose = i.value; ~ratCompChooseView.valueAction_(~ratCompAllChoose);
	~strCompChooseView.valueAction_( ~ratCompAllChoose); ~cenCompChooseView.valueAction_(~ratCompAllChoose); ~offCompChooseView.valueAction_(~ratCompAllChoose);
})
.value_(0).doAction;

/*
Color(0.32549019607843, 0.32549019607843, 0.32549019607843, 0.3)
~ratView.background_(Color(0.32549019607843, 0.32549019607843, 0.32549019607843, 0)); ~rat2View.background_(Color(0.32549019607843, 0.32549019607843, 0.32549019607843, 0));
~ratView.background_(~compColor1)
*/


// Position du CompositeView à la place de OutL Rect(1199, 216, 399, 216)
~outLComp = CompositeView(~tabGUI, Rect(1199*~xSizeMul, (432+215)*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul))/*.background = ~panCompColor*/;
~outRComp = CompositeView(~tabGUI, Rect(1199*~xSizeMul, (432+215)*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul))/*.background = ~panCompColor*/;

~outStackComp = StackLayout(~outLComp, ~outRComp).mode_(\stackOne);
~outStackCompL = CompositeView(~tabGUI, Rect(1199*~xSizeMul, (432+215)*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background_(/*~fxCompColor*/ ~panCompColor).layout_(~outStackComp);

~outStackComp.mode = 1; // Pour transparence

~outRevCompChoose = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
~outRevCompChooseView = RoundButton(~tabGUI, Rect(1536*~xSizeMul, 649*~ySizeMul, 60*~xSizeMul, 16*~ySizeMul))
.states_([["\LR Norm", Color.blue, Color.white], ["\LR Rev", Color.red, Color.white]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({|i| ~outRevCompChoose[~tracksValue][~seqsValue] = i.value; });


// Position du CompositeView tout en bas Rect(1199, 864, 399, 216)
~fxLComp = CompositeView(~tabGUI, Rect(1199*~xSizeMul, (648+216)*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul))/*.background = ~fxCompColor*/;
~fxRComp = CompositeView(~tabGUI, Rect(1199*~xSizeMul, (648+216)*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul))/*.background = ~fxCompColor*/;
~fxStackComp = StackLayout(~fxLComp, ~fxRComp).mode_(\stackOne);
~fxStackCompL = CompositeView(~tabGUI, Rect(1199*~xSizeMul, (648+216)*~ySizeMul, 399*~xSizeMul, 216*~ySizeMul)).background_(/*~fxCompColor*/ ~panCompColor).layout_(~fxStackComp);

~outCompChooseView = RoundButton(~tabGUI, Rect(1536*~xSizeMul, (650+215)*~ySizeMul, 60*~xSizeMul, 16*~ySizeMul))
.states_([["\Links", Color.blue, Color.white], ["\Right", Color.red, Color.white]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({|i| ~outCompChoose = i.value; ~outStackComp.index = ~outCompChoose; ~fxStackComp.index = ~outCompChoose })
.value_(0).doAction;

~fxStackComp.mode = 1; // Pour transparence






























// Control Panel

/*
~volumeBus1 = Bus(\control, index: 100, numChannels: 1);
~volumeBus1.free;
~volumeBus1.set(1); //turn up volume
~volumeBus1.set(0); //turn down volume
~volumeBus1.get;
~volumeBus1.scope; // ne marche pas ???
~ins1.fadeTime = 8; // ne marche pas ???
~ins1.free; ~ins1={Saw.kr(440, 1000) /1000}.play(s, ~volumeBus1);
~ins1.free; ~ins1={SinOsc.kr(5, 0, 0.5, 0.5)}.play(s, ~volumeBus1);
~ins1.free; ~ins1={SinOsc.kr(200, 0, 0.5, 0.5)}.play(s, ~volumeBus2);
~ins1={SinOsc.kr(2, 0, 0.5, 0.5)}.play(s, ~volumeBus1); // ~ins1.free; obligatoire sinon se cumule
~volumeBus1.line(1, 10);
~volumeBus1.xline(0, 0.1);
~volumeBus1.monitor; // ???

// A essayer de controler les bus de volume avec des NodeProxy XXXXXX
a = NodeProxy.new.play;
Ndef(\sound, 1, 400);
Ndef(\sound, {SinOsc.ar(880, 0, 0.5)})
Ndef(\sound).play
/*(s, ~volumeBus2)*/
*/

{ // Fonction Value pour le ControlPanel pour éviter ERROR: Selector table too big: too many classes, method selectors or function definitions in this function


	~xqControlView = 0 ! ~nbOfTracksX2; // in Contol window
	~xqViewValue = 0 ! ~nbOfTracksX2;
	~playControlView = 0 ! ~nbOfTracksX2; // in Contol window
	~play2ControlView = 0 ! ~nbOfTracksX2; // in Contol window
	~playViewValue = 0 ! ~nbOfTracksX2;
	~trackVolView = 0 ! ~nbOfTracks; // in Contol window
	~trackVol = 0 ! ~nbOfTracks;
	~durVolView = 0 ! ~nbOfTracks; // in Contol window
	~durVol = 0 ! ~nbOfTracks;
	~freqVolView = 0 ! ~nbOfTracks; // in Contol window
	~freqVol = 0 ! ~nbOfTracks;
	~toVolView = 0 ! ~nbOfTracks; // in Contol window
	~toVol = 0 ! ~nbOfTracks;
	~ampVolView = 0 ! ~nbOfTracks; // in Contol window
	~ampVol = 0 ! ~nbOfTracks;
	~lineControlView = 0 ! ~nbOfTracks; // in Contol window
	~lineControl = 0 ! ~nbOfTracks;
	~sineControlView = 0 ! ~nbOfTracks; // in Contol window
	~sineControl = 0 ! ~nbOfTracks;
	~outsConfigControlViewView = 0 ! ~nbOfTracks; // in Contol window
	~outsConfigControlView = 0 ! ~nbOfTracks; // in Contol window
	// ~outsConfigControlValue = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // aucun intérêt ???
	~multiStereoControlView = 0 ! ~nbOfTracks; // in Contol window
	~fxSelControlViewView = 0 ! ~nbOfTracks; // in Contol window
	~fxSelControlView = 0 ! ~nbOfTracks; // in Contol window
	~fxSelControlValue = 0 ! ~nbOfTracks;

	~eqChaLoView = 0 ! ~nbOfChannelEQ; // in Contol window // +1 pour les canaux FX
	~eqChaLo = 0 ! ~nbOfChannelEQ;
	~eqChaMiView = 0 ! ~nbOfChannelEQ; // in Contol window
	~eqChaMi = 0 ! ~nbOfChannelEQ;
	~eqChaHiView = 0 ! ~nbOfChannelEQ; // in Contol window
	~eqChaHi = 0 ! ~nbOfChannelEQ;
	~eqChaActivateView = 0 ! ~nbOfChannelEQ; // in Contol window
	~eqChaActivate = 0 ! ~nbOfChannelEQ;
	~eqChaSynth = 0 ! ~nbOfTracks;

	~playMono = 0 ! ~nbOfTracksX2;



	// essai de transfert vers le pattern mais ne marche pas & pas nécessaire puisque les bus survivent à CmdPeriod ???
	~volumeBus = 0 ! ~nbOfTracks ! 2;
	~volumeBus2 = 0 ! ~nbOfTracks ! 2; // Pour le changement de bus et coupure abrupte des sons d'une Track

	if (~server2.notNil, {
		~tracksList.do {|tr| ~volumeBus[0][tr] = Bus(\control, server: ~server1, index: (100+tr), numChannels: 1)};
		~tracksList.do {|tr| ~volumeBus2[0][tr] = Bus(\control, server: ~server1, index: (110+tr), numChannels: 1)};
		~tracksList.do {|tr| ~volumeBus[1][tr] = Bus(\control, server: ~server2, index: (100+tr), numChannels: 1)};
		~tracksList.do {|tr| ~volumeBus2[1][tr] = Bus(\control, server: ~server2, index: (110+tr), numChannels: 1)};
		// ~globalBus = Bus(\control, index: 10, numChannels: 1); // Plus utilisé ???
		~inBus = 0 ! 2;
		~inBus[0] = Bus(\control, server: ~server1, index: 99, numChannels: 1);
		~inBus[1] = Bus(\control, server: ~server2, index: 99, numChannels: 1);
	},{
		~tracksList.do {|tr| ~volumeBus[0][tr] = Bus(\control, server: ~server1, index: (100+tr), numChannels: 1)};
		~tracksList.do {|tr| ~volumeBus2[0][tr] = Bus(\control, server: ~server1, index: (110+tr), numChannels: 1)};
		// ~globalBus = Bus(\control, index: 10, numChannels: 1); // Plus utilisé ???
		~inBus = 0 ! 2;
		~inBus[0] = Bus(\control, server: ~server1, index: 99, numChannels: 1);
	});



	~ins = 0 ! ~nbOfTracks; // Pour la création d'un synthé qui fait l'oscillation du volume
	~insSliderFadeTime = 0.7; // Détermine également le temps de xfade et attente de 0.25 sec.
	~insSineFadeTime = 2;
	~ins.do { |i, tr| // var sv, svName; if (~server2.isNil or: {tr < ~serverTrackSwitch}, {sv = 0; svName = ~server1}, {sv = 1; svName = ~server2} ); // ~ins[tr] =  NodeProxy(svName, \control, 1); ~ins[tr])
		var sv; if (~server2.isNil or: {tr < ~serverTrackSwitch}, {sv = 0}, {sv = 1} );
		~ins[tr] = NodeProxy.for(~volumeBus[sv][tr]);
		// ~ins[tr].source = {DC.kr(1)};
		~ins[tr].fadeTime = ~insSliderFadeTime;
	};



	// ~dbSpec = \db.asSpec
	// 12.dbamp
	~dbSpec = ControlSpec(0.ampdb, /*1.9952*/ /*3.98107.ampdb*/ ~maxServerVolume, \db, units: " dB");
	~dbSpec2 = ControlSpec(0.ampdb, /*3.98107*/ 1.ampdb, \db, units: " dB"); // Pour booster les pistes rythmiques
	~dbSpec2b = ControlSpec(0.ampdb, /*1.9952*/ /*3.98107*/ ~maxTextureTracksVolume, \db, units: " dB"); // Pour booster les pistes trames
	// ~globalBus.set(~dbSpec.unmap(0));
	// ~volumeBus[0];


	// ~controlWindow = Window("Control Panel").setTopLeftBounds(Rect(0, ~controlWindowTopLeft*~ySizeMul, 315*~xSizeMul, 630*~ySizeMul))/*.alpha_(0.8)*/.alwaysOnTop_(true).front;
	~controlWindow = Window("Control Panel", Rect(0, ~controlWindowTopLeft, 315*~xSizeMul, 630*~ySizeMul))/*.alpha_(0.8)*/.alwaysOnTop_(true).front;

	~controlWindow.onClose = {

		if (~play.notNil, { Pdef.all.size.do {|i| Pdef.all[~patterns[i]].stop }; });

		~nbOfServers.do { |s|
			~numEffects.do {|i| ~fxSynth[s][i].free; ~fxSynth2[s][i].free };
			~nbOfControlBus.do {|i| ~controlBusSynth[s][i].clear; /*~controlBus[i].free;*/ }; // si Cmd. n'a pas déjà été déclenché -> libération des Nodeproxys Control qui libèrent les bus a. ??? -> apparemment oui
			~groups[s].as(Set).do {|i| i.free }; // libération des groupes
			~tracksList.do {|tr| ~ins[tr].clear; /*~volumeBus[s][tr].free; ~volumeBus2[s][tr].free;*/ }; ~inBus[s].free; // Libération des bus de volume et des NodeProxy de volume
			// try sur les NodeProxy juste pour éviter l'erreur lors de la fermeture de la GUI si le patten n'a pas été lancé - mais ne marche pas
			~presetTrajectorySelectionView.items.size.do { |i| ~trajectoryBuffers[s][i].free };

			if (~serverVolume[s].notNil, {~serverVolume[s].reset}); // permet de retirer le volumeAmpControl si par déjà fait par la fermeture de la GUI
		};

		if ( ~visualizeLevels == "SpatioScope" and: { ~spatioScopeWindow.notNil } , {
			~spatioScopeWindow.view.removeAll; ~spatioScopeWindow.close;
			~spatioScopePlayer.stop; ~spatioScopePlayer.proxy.clear; /*z.resp.remove;*/ // Suppression du Nodeproxy et arrêt du Spatioscope puis suppression de la fenêtre ci-dessous avec v
			// CmdPeriod.add({ ~spatioScopePlayer.stop; ~spatioScopePlayer.proxy.clear });
		}, {
			~serverLevels1.remove; ~levelsWindow.close;
			if (~nbOfServers == 2, { ~serverLevels2.remove; if (~levelsWindow2.notNil, {~levelsWindow2.close}); });
		});

		~globalWindow.view.removeAll; ~controlWindow.view.removeAll; // Appliquer .removeAll sur la view quand fermeture pour détruire tous les children
		~globalWindow.close;
		/*m.close;*/ // PdefAllGui supprimé
		/*~visuel.stop;*/ // Routine transformé en Skipjack
		// s.volume.free; ~serverVolume = nil; n'arrête pas le synthé de volume
		// StageLimiter.deactivate; ~stageLimiter = nil; // Provoque un crash du langage ?????????
		if (~fftbuffer.notNil, {~fftbuffer.free}); if (~fftbus.notNil, {~fftbus.free}); if (~fftroutine.notNil, {~fftroutine.stop}); // Pour Processing

		~presetVarsWindow.close;
		if (~automationWindow.notNil, {~automationWindow.close});

		if (~twister.notNil, { ~connectionsRate.free; ~connectionsBuf.free; ~connectionsRtm.free; ~connectionsLeg.free; ~connectionsStr.free });

		~linkClockController.remove;

	};


	~controlWindowVolume = CompositeView(~controlWindow, Rect(0, 5*~ySizeMul, 315*~xSizeMul, 55*~ySizeMul)).background = Color.grey(0.6);
	~controlWindowDefault = CompositeView(~controlWindow, Rect(0, (39+26)*~ySizeMul, 315*~xSizeMul, 24*~ySizeMul)).background = Color.grey(0.6);
	~controlWindowTracks = CompositeView(~controlWindow, Rect(0, 94*~ySizeMul, 315*~xSizeMul, 260*~ySizeMul)).background = Color.grey(0.6);
	~controlWindowTrig = CompositeView(~controlWindow, Rect(0, 500*~ySizeMul, 315*~xSizeMul, 124*~ySizeMul)).background = Color.grey(0.6);
	// ~controlWindowGlobal ~controlWindowSpaRy // plus bas


	// Message d'erreur lorsque fermeture du Control Panel et que la Routine fonctionnent encore car ~tracksView.value dans la routine n'existe plus ???
	// Comment éviter le message d'erreur ??? en modifiant le ~tracksView.value par une variable ???
	~tracksView = ListView(~controlWindowTracks, Rect(5*~xSizeMul, 15*~ySizeMul, 40*~xSizeMul, 242*~ySizeMul)).hiliteColor_(Color.red).font_(Font("Verdana",12*~fontSizeMul));
	// Constitution d'une liste pour les Tracks du type -> ["T1 A", "T1 B", "T2 A", "T2 B", "T3 A", "T3 B", "T4 A", "T4 B"...]
	~tracksViewItemsA = ([~tracksList.collect {|i| (i+1) +" A"}, ~tracksList.collect {|i| (i+1) +" B"}].flop.flatten(1)); // Pourquoi .flat ne fonctionne pas ?
	~tracksViewItemsB = ([~tracksList.collect {|i| (i+1)+"A"}, ~tracksList.collect {|i| (i+1)+"B"}].flop.flatten(1)); // un espace en plus ... pour une raison particulière ?
	~tracksView.items = ~tracksViewItemsA;
	~tracksView.colors = (([Color.gray(0.7), Color.gray(0.7), Color.white, Color.white] ! (~nbOfTracksX2 / 2)).flat);

	(
		~tracksView.action_({ |i| var prevTrack = ~tracksValue; var tra, conTwi;

			if (~twister.notNil, {
				if (~twisterIndex2.isNil, {
					case
					{~twisterInterface == 0}
					{ if (~connectionsRate.notNil, {~connectionsRate.disconnect}) }
					{~twisterInterface == 1}
					{ if (~connectionsBuf.notNil, {~connectionsBuf.disconnect}) }
					{~twisterInterface == 2}
					{ if (~connectionsLeg.notNil, {~connectionsLeg.disconnect}) }
					{~twisterInterface == 3}
					{ if (~connectionsRtm.notNil, {~connectionsRtm.disconnect}) }
					{~twisterInterface == 4}
					{ if (~connectionsStr.notNil, {~connectionsStr.disconnect}) };
				},{
					if (~connectionsRate.notNil, {~connectionsRate.disconnect});
					case
					{~twisterInterface2 == 1}
					{ if (~connectionsBuf.notNil, {~connectionsBuf.disconnect}) }
					{~twisterInterface2 == 2}
					{ if (~connectionsLeg.notNil, {~connectionsLeg.disconnect}) }
					{~twisterInterface2 == 3}
					{ if (~connectionsRtm.notNil, {~connectionsRtm.disconnect}) }
					{~twisterInterface2 == 4}
					{ if (~connectionsStr.notNil, {~connectionsStr.disconnect}) };
				});
			}); //  Obligé de déconnecter, sinon mauvaise valeurs envoyées du Twister à la GUI - A améliorer

			~prevAkaiTrack = (~tracksValue/2).asInteger;
			~tracksValue = i.value;
			tra = (~tracksValue/2).asInteger;

			~updateALLView.value;

			// Changement de piste A ou B en conséquence dans le global /////////////////////////////////////////// à optimiser en CPU...
			/*~seqCompGABIndex.postln; ~tracksValue.postln;*/
			/*if ((~tracksValue.odd and: { ~seqCompGABIndex[tra] == 0 })/*.postln*/, { ~seqABVisibleViewG[~tracksValue-1].valueAction_(1); /*de A vers B*/ }  );
			if ((~tracksValue.even and: { ~seqCompGABIndex[tra] == 1 })/*.postln*/, { ~seqABVisibleViewG[~tracksValue+1].valueAction_(0); /*de B vers A*/ } );*/
			// Intégration de l'action des boutons au lieu du bouton lui-même afin d'empecher l'action sur le ~tracksView & ~connectionsRateMake.()
			if (~tracksValue.even,
				{ ~seqCompGABIndex[tra] = 0; ~seqCompG[~tracksValue].visible_(1); ~seqCompG[~tracksValue+1].visible_(0); ~seqABVisibleViewG[~tracksValue+1].value_(1); },
				{ ~seqCompGABIndex[tra] = 1; ~seqCompG[~tracksValue].visible_(1); ~seqCompG[~tracksValue-1].visible_(0); ~seqABVisibleViewG[~tracksValue-1].value_(0);};
			);
			~rhythmTracksX2 = ~rhythmTracks.collect { |ia| (ia*2) + ~seqCompGABIndex[ia] }; // Mise à jour de pistes rythmiques


			// Changement des séquences de la piste
			~switchSeqView.valueAction_(~switchSeqValue[~tracksValue]); // Basculement entre le MultSlider et les TextView pour les séquences

			// if (~lemurConnected1 == 1, {
			// A t'on vraiment besoin d'un. valueAction ? Est ce q'un .value ne suffirait pas ???
			if (~lemurNewSeqs[~tracksValue].isInteger, {~presetSeqRangeView.valueAction_(~presetSeqRangeSpec.unmap([~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]+1]) ) });
			//});

			~nbOfSeqs.do { |i| ~presetSeqTextView[i].string = ~presetSelection[~tracksValue][i]; };

			// Les 2 lignes ci-dessous pour marquer davantage la piste sélectionée dans le Global
			~rtmReadViewG[prevTrack].background_(/*~readViewSliderBackgroundColor*/ Color(0.6, 0.6, 0.6, 0));
			~rtmReadViewG[~tracksValue].background_(/*~readViewSliderBackgroundColor*/ Color.red);

			~playViewFunction.(prevTrack, ~playViewValue[prevTrack]); /*prevTrack = ~tracksValue;*/ // Pour (dés-)afficher la couleur de la track sélectionnée dans la Vue Globale
			~playViewFunction.(~tracksValue,~playViewValue[~tracksValue]);

			// Pour conserver la visualisation des presets de séquences quand changement de pistes - Actuellement prend la pisualisation de la Vue Gloable
			/*~seqCompG1VisibleOrigin[prevTrack] = ~seqComp5.visibleOrigin;
			(0..~nbOfTracksX2-1).takeThese({ |i| i == prevTrack }).do { |i| ~seqCompG1VisibleOrigin[i] = ~seqCompG1[i].visibleOrigin };
			~seqComp5.visibleOrigin = ~seqCompG1VisibleOrigin[~tracksValue];*/
			// ~nbOfTracksX2.do { |i| ~seqCompG1VisibleOrigin[i] = ~seqCompG1[i].visibleOrigin }; // -> apparemment OK avec modif ci-dessous et en supprimant cette ligne
			~seqComp5.visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-4)*20*~ySizeMul).max(0).min(~seqComp5MaxVisibleOrigin);

			// Pour l'affichage du Tab du FX pour les 2 servers
			if (~nbOfServers == 2, { if (tra >= ~serverTrackSwitch, { ~fxTabbedView.focus(1) }, { ~fxTabbedView.focus(0) } ) });


			if (~aControllerConnected == 1, {

				if (~seqCompGABIndex[tra] == 1, { ~aController.setState(6,tra,1); }, { ~aController.setState(6,tra,0); });
				if ( ~prevAkaiTrack != tra, { ~aController.setState(4,~prevAkaiTrack,0); ~aController.setState(5,~prevAkaiTrack,0) });
				/*~aController.setState(4,~prevAkaiTrack,0);*/ ~aController.setState(4,tra,1); // ~prevAkaiTrack.postln; tra.postln;
				/*~aController.setState(5,~prevAkaiTrack,0);*/ ~aController.setState(5,tra,1);
				// ~aController.setState(7,~prevAkaiTrack,0); ~aController.setState(7,tra,1);

				if (~playViewValue[(tra*2)+~seqCompGABIndex[tra]] == 1 , {
					if (~aController.padInternalState[2,tra] == 0 or: { ~aController.padInternalState[2,tra] == 2}, {
						~aController.setState(2,tra,1); ~aController.setState(3,tra,1); ~aController.incrementState(2,tra); ~aController.incrementState(3,tra);
					});
				},{
					if (~aController.padInternalState[2,tra] == 1 or: { ~aController.padInternalState[2,tra] == 2}, {
						~aController.setState(2,tra,0); ~aController.setState(3,tra,0);
					});
				});
			});


			if (~twister.notNil, {

				case
				{~twisterInterface == 0}
				{ ~connectionsRateMake.(); /*conTwi = \twister*/ }
				{~twisterInterface == 1}
				{ ~connectionsBufMake.(); /*conTwi = \twister2*/}
				{~twisterInterface == 2}
				{ ~connectionsLegMake.(); /*conTwi = \twister3*/}
				{~twisterInterface == 3}
				{ ~connectionsRtmMake.(); /*conTwi = \twister4*/}
				{~twisterInterface == 4}
				{ ~connectionsStrMake.(); /*conTwi = \twister5*/};

				if (~twisterIndex2.notNil, {
					case
					{~twisterInterface2 == 1}
					{ ~connectionsBufMake.(); /*conTwi = \twister2*/}
					{~twisterInterface2 == 2}
					{ ~connectionsLegMake.(); /*conTwi = \twister3*/}
					{~twisterInterface2 == 3}
					{ ~connectionsRtmMake.(); /*conTwi = \twister4*/}
					{~twisterInterface2 == 4}
					{ ~connectionsStrMake.(); /*conTwi = \twister5*/};
				});

				// ~rtmValue.value_(~rtmMulSpec[~tracksValue][~seqsValue].unmap(~rtmMul[~tracksValue][~seqsValue]))/*.copy*/;
				// ~ratValues[~tracksValue].value_(~ratMulSpec.unmap(~ratMul[~tracksValue][~seqsValue]) );
				// Pour la mise à jour du Rat quand on change de track

				// if (~prevAkaiTrack > 2, {~twister.knobs[8+~prevAkaiTrack].ledColor_(Color.magenta)}, {~twister.knobs[8+~prevAkaiTrack].ledColor_(Color.green)});
				~seqCompGABIndex.do { |i, id| var a = (id*2+i);
					if (~playViewValue[a] == 0, {
						if (a == ~tracksValue, {
							/*conTwi.envirGet*/ ~twister.knobs[8+id].ledColor_(Color.red)
						},{
							if (id >2, {
								~twister.knobs[8+id].ledColor_(Color.magenta)
							},{
								~twister.knobs[8+id].ledColor_(Color.green)
							});
						});
					},{
						if (a == ~tracksValue, {
							~twister.knobs[8+id].ledColor_(Color.new255(200, 100, 0))
						},{
							~twister.knobs[8+id].ledColor_(Color.yellow)
						});
					});
				};


				if (~lemurConnected1 == 1, {
					~lemurAdress1.sendMsg("/ParC/RatM/value", ~ratMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg("/ParC/RatLed/value", ~ratMulView.value );
					~lemurAdress1.sendMsg("/ParC/RtmM/value", ~rtmMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg("/ParC/RtmLed/value", ~rtmMulView.value );
					~lemurAdress1.sendMsg("/ParC/LegM/value", ~legMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg("/ParC/LegLed/value", ~legMulView.value );
					~lemurAdress1.sendMsg("/ParC/StrM/value", ~strMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg("/ParC/StrLed/value", ~strMulView.value );
					~lemurAdress1.sendMsg("/ParC/CenM/value", ~cenMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg("/ParC/CenLed/value", ~cenMulView.value );
					~lemurAdress1.sendMsg("/ParC/ProM/value", ~proMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg("/ParC/ProLed/value", ~proMulView.value );
					// ~lemurAdress1.sendMsg("/ParC/OffM/value", ~offMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg("/ParC/OffLed/value", ~offMulView.value );
					// });
					if (~rhythmTracksX2.includes(~tracksValue), {
						~lemurAdress1.sendMsg(~lemurRatGTextValues[~tracksValue], ~ratMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg(~lemurRatGLedValues[~tracksValue], ~ratMulView.value );
						// ~lemurAdress1.sendMsg(~lemurRtmGTextValues[~tracksValue], ~rtmMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg(~lemurRtmGLedValues[~tracksValue], ~rtmMulView.value ); // erreur
						~lemurAdress1.sendMsg(~lemurLegGTextValues[~tracksValue], ~legMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg(~lemurLegGLedValues[~tracksValue], ~legMulView.value );
						// ~lemurAdress1.sendMsg(~lemurStrGTextValues[~tracksValue], ~strMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg(~lemurStrGLedValues[~tracksValue], ~strMulView.value ); // erreur
						// ~lemurAdress1.sendMsg(~lemurCenGTextValues[~tracksValue], ~cenMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg(~lemurCenGLedValues[~tracksValue], ~cenMulView.value ); // erreur
						// ~lemurAdress1.sendMsg(~lemurProGTextValues[~tracksValue], ~proMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg(~lemurProGLedValues[~tracksValue], ~proMulView.value ); // erreur
						// ~lemurAdress1.sendMsg(~lemurOffGTextValues[~tracksValue], ~offMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg(~lemurOffGLedValues[~tracksValue], ~offMulView.value );
					});
				});
				/*if (~lemurConnected2 == 1, {
				~lemurAdress2.sendMsg("/ParC/RatM/value", val); ~lemurAdress2.sendMsg("/ParC/RatLed/value", ~ratMulView.value );
				if (~rhythmTracksX2.includes(~secondLemurX2Track), {
				~lemurAdress2.sendMsg(~lemurRatGTextValues[~secondLemurX2Track], val); ~lemurAdress2.sendMsg(~lemurRatGLedValues[~secondLemurX2Track], ~ratMulView.value );
				});
				});*/
			});


			if (~lemurConnected1 == 1 /*and: {~trackNextProtect== 0}*/, { // var t;
				// 0 ! (~tracksValue/2).asInteger ++ 1 ++ (0 ! (16-~tracksValue/2-1).asInteger)
				/*~lemurAdress1.sendMsg( "/TrackSwitch1/x", 0, 1, 0, 0, 0, 0, 0, 0  );
				~lemurAdress1.sendMsg( "/TrackSwitch1/x", 0, 1, 0, 0, 0, 0  );
				~lemurAdress1.sendMsg( "/TrackSwitch1/x", 1  );*/

				if (/*~lemurTracksRadioSwitches[~tracksValue] == 1 or:{*/~lemurNewSeqs[~tracksValue].isInteger/*}*/, {
					~presetSeqRangeViewG[~tracksValue].background_(~sliderBackgroundColor2).hilightColor_(Color.red);
				},{
					~presetSeqRangeViewG[~tracksValue].background_(Color.magenta).hilightColor_(Color.blue); // ~presetSeqRangeViewG[(t*2)+1].background_(Color.magenta).hilightColor_(Color.blue)
				});

				~lemurAdress1.sendMsg( *[["/TrackSwitch1/x"] ++ (0 ! (~tracksValue/2).asInteger ++ 1 ++ (0 ! (~nbOfTracksX2-~tracksValue/2-1).asInteger) ++ 0) ].flatten(1) ); // ++ 0 -> necessaire sinon la piste peut parfois ne pas s'éteindre
				if (~seqCompGABIndex[tra] == 1, { ~lemurAdress1.sendMsg( ~lemurABSwitchesValues[tra],  1); }, { ~lemurAdress1.sendMsg( ~lemurABSwitchesValues[tra],  0); });

				if (~lemurNewSeqs[~tracksValue].size == 0, {
					if (~presetSeqStart[~tracksValue] - ~presetSeqStop[~tracksValue] == 0, {
						~lemurAdress1.sendMsg( "/CurSeq2/value", ~presetSeqStart[~tracksValue]+1 /*1.0.rand*/);
						~lemurAdress1.sendMsg( *["/CurSeqText2", "@content", ~presetSelection[~tracksValue][ ~presetSeqStart[~tracksValue]+1] ]);
					},{
						~lemurAdress1.sendMsg( *[ ["/CurSeq2/value"], [((~presetSeqStart[~tracksValue]+1)..~presetSeqStop[~tracksValue]+1).asString] ].flatten(1) );
						~lemurAdress1.sendMsg( *["/CurSeqText2", "@content", "" ]);
					});
				},{
					~lemurAdress1.sendMsg( *[ ["/CurSeq2/value"], [~lemurNewSeqs[~tracksValue].asString] ].flatten(1) );
					~lemurAdress1.sendMsg( *["/CurSeqText2", "@content", ""/*~presetSelection[tr][~lemurNewSeqs[tr][0]+1]*/ ]);
				});

				~lemurAdress1.sendMsg( "/CurSeq1/value", ~seqSeq[~tracksValue] /*~currentSeq*/ +1 /*1.0.rand*/); // ~currentSeq = ~~seqSeq[~tracksValue] dans le pattern - non décalage
				~lemurAdress1.sendMsg( *["/CurSeqText1", "@content", ~presetSelection[~tracksValue][~seqSeq[~tracksValue] /*~currentSeq*/] ]);

				~lemurAdress1.sendMsg( *[ ["/TrackNext"] ++ ["@color"] ++
					if (~tracksPresetColorModel1.includes(~tracksValue), { [~lemurColors[~seqSeq[~tracksValue]], ~lemurColors[~seqSeq[~tracksValue]]] },{ [~redLemurColor3, ~redLemurColor3] })
				].flatten(1) );

				~lemurAdress1.sendMsg( *["/ParC/BufM", "@content", ~bufFolderView.items[~bufFolderValue[~tracksValue][~seqSeq[~tracksValue]]] ]);
				~lemurAdress1.sendMsg( *["/ParC/BufMenuL", "@content", ~bufFolderView.items[~bufFolderValue[~tracksValue][~seqSeq[~tracksValue]]] ]);

				if (~proPat[~tracksValue][~seqSeq[~tracksValue]] == 0, { // ~currentSeq = ~seqSeq[tr] dans le pattern
					~lemurAdress1.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) );
				},{
					~lemurAdress1.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
				});

				if (~proSelect[~tracksValue][~seqSeq[~tracksValue]] == 0, { // ~currentSeq = ~seqSeq[tr] dans le pattern
					~lemurAdress1.sendMsg( *[ ["/ParC/Cyc2"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) );
					~lemurAdress1.sendMsg( *["/ParC/CycT2", "@content", "Pro S" ]);
				},{
					~lemurAdress1.sendMsg( *[ ["/ParC/Cyc2"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
					~lemurAdress1.sendMsg( *["/ParC/CycT2", "@content", "Pro 1" ]);
				});

				if (~legLoop[~tracksValue][~seqSeq[~tracksValue]] == 0, { // ~currentSeq = ~seqSeq[tr] dans le pattern  - non décalage
					~lemurAdress1.sendMsg( *[ ["/ParC/Loop"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
				},{
					~lemurAdress1.sendMsg( *[ ["/ParC/Loop"] ++ ["@color"] ++ [~greenLemurColor, ~greenLemurColor]  ].flatten(1) );
				});

				if (~ratSynth[~tracksValue][~seqSeq[~tracksValue]] == 0, { // ~currentSeq = ~seqSeq[tr] dans le pattern  - non décalage
					~lemurAdress1.sendMsg( *[ ["/ParC/Gliss"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
				},{
					~lemurAdress1.sendMsg( *[ ["/ParC/Gliss"] ++ ["@color"] ++ [~greenLemurColor, ~greenLemurColor]  ].flatten(1) );
				});

				~lemurAdress1.sendMsg( *["/ParC/SpaMenu/x", ~multiStereo[~tracksValue][~seqSeq[~tracksValue]] ]);

				if (~rhythmTracksX2.includes(~tracksValue), {
					~lemurAdress1.sendMsg(~lemurRatGTextValues[~tracksValue], ~ratMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg(~lemurRatGLedValues[~tracksValue], ~ratMulSpec.unmap(~ratMul[~tracksValue][~seqsValue]) );
					~lemurAdress1.sendMsg(~lemurLegGTextValues[~tracksValue], ~legMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg(~lemurLegGLedValues[~tracksValue], ~legMulSpec.unmap(~legMul[~tracksValue][~seqsValue]) );
				});
				if (~rhythmTracksX2.includes(~secondLemurX2Track), {
					~lemurAdress2.sendMsg(~lemurRatGTextValues[~secondLemurX2Track], ~ratMul[~secondLemurX2Track][~seqsValue]); ~lemurAdress2.sendMsg(~lemurRatGLedValues[~secondLemurX2Track], ~ratMulSpec.unmap(~ratMul[~secondLemurX2Track][~seqsValue]) );
					~lemurAdress2.sendMsg(~lemurLegGTextValues[~secondLemurX2Track], ~legMul[~secondLemurX2Track][~seqsValue]); ~lemurAdress2.sendMsg(~lemurLegGLedValues[~secondLemurX2Track], ~legMulSpec.unmap(~legMul[~secondLemurX2Track][~seqsValue]) );
				});

				/*{0.3.wait; ~lemurAdress1.sendMsg( *[["/TrackSwitch1/x"] ++ ((0 ! ((~tracksValue/2).asInteger)) ++ 1 ++ (0 ! ((~nbOfTracksX2-(~tracksValue)/2-1).asInteger)) ++ 0) ].flatten(1) ); 0.3.wait; ~lemurAdress1.sendMsg( *[["/TrackSwitch1/x"] ++ ((0 ! ((~tracksValue/2).asInteger)) ++ 1 ++ (0 ! ((~nbOfTracksX2-(~tracksValue)/2-1).asInteger)) ++ 0) ].flatten(1) ); 0.3.wait; ~lemurAdress1.sendMsg( *[["/TrackSwitch1/x"] ++ ((0 ! ((~tracksValue/2).asInteger)) ++ 1 ++ (0 ! ((~nbOfTracksX2-(~tracksValue)/2-1).asInteger)) ++ 0) ].flatten(1) ); 0.6.wait; ~lemurAdress1.sendMsg( *[["/TrackSwitch1/x"] ++ ((0 ! ((~tracksValue/2).asInteger)) ++ 1 ++ (0 ! ((~nbOfTracksX2-(~tracksValue)/2-1).asInteger)) ++ 0) ].flatten(1) ); }.fork(AppClock); */// Afin de revenir tant que l'on n'appuie pas plus de 1 seconde sur la piste courante de la GUI
				// supprimé car ~secondLemurX2Track est décalé si la même que le 1er Lemur
			});

			if (~lemurConnected2 == 1, {

				if (tra == ~secondLemurRawTrack, {
					var newTrack = (tra+1).wrap(0,~nbOfTracks-1);
					~secondLemurRawTrack = newTrack; if (~seqCompGABIndex[newTrack] == 1, { ~secondLemurX2Track = (newTrack*2) +1 }, { ~secondLemurX2Track = (newTrack*2)});
					~lemurAdress2.sendMsg( *[["/TrackSwitch1/x"] ++ ((0 ! newTrack.asInteger) ++ 1++ (0 ! (~nbOfTracks-1 - newTrack.asInteger)) ++ 0) ].flatten(1) );
					// ~lemurAdress2.sendMsg( *[["/TrackSwitch1/x"] ++ ((0 ! 3.asInteger) ++ 1++ (0 ! 3.asInteger) ++ 0) ].flatten(1) );
					if (~seqCompGABIndex[newTrack] == 1, { ~lemurAdress2.sendMsg( ~lemurABSwitchesValues[newTrack],  1); }, { ~lemurAdress2.sendMsg( ~lemurABSwitchesValuesnewTrack,  0); });
				});

			});

			if (~twister.notNil, {
				if (~twisterIndex2.isNil, {
					case
					{~twisterInterface == 0}
					{ if (~connectionsRate.notNil, {~connectionsRate.connect}) }
					{~twisterInterface == 1}
					{ if (~connectionsBuf.notNil, {~connectionsBuf.connect}) }
					{~twisterInterface == 2}
					{ if (~connectionsLeg.notNil, {~connectionsLeg.connect}) }
					{~twisterInterface == 3}
					{ if (~connectionsRtm.notNil, {~connectionsRtm.connect}) }
					{~twisterInterface == 4}
					{ if (~connectionsStr.notNil, {~connectionsStr.connect}) };
				},{
					if (~connectionsRate.notNil, {~connectionsRate.connect});
					case
					{~twisterInterface2 == 1}
					{ if (~connectionsBuf.notNil, {~connectionsBuf.connect}) }
					{~twisterInterface2 == 2}
					{ if (~connectionsLeg.notNil, {~connectionsLeg.connect}) }
					{~twisterInterface2 == 3}
					{ if (~connectionsRtm.notNil, {~connectionsRtm.connect}) }
					{~twisterInterface2 == 4}
					{ if (~connectionsStr.notNil, {~connectionsStr.connect}) };
				});
			}); //  Obligé de déconnecter, sinon mauvaise valeurs envoyées du Twister à la GUI - A améliorer

			prevTrack = ~tracksValue;

	}));

	~tracksValue = 0; // initialisation de la valeur


	/*	Plus nécessaire car s.getQueryTree plus utilisé car action directe sur le groupe plus performante
	case
	{ ~tracksValue.inclusivelyBetween(0,1) } { ~groupNumber = 7 }
	{ ~tracksValue.inclusivelyBetween(2,3) } { ~groupNumber = 6 }
	{ ~tracksValue.inclusivelyBetween(4,5) } { ~groupNumber = 5 }
	{ ~tracksValue.inclusivelyBetween(6,7) } { ~groupNumber = 4 }
	{ ~tracksValue.inclusivelyBetween(8,9) } { ~groupNumber = 3 }
	{ ~tracksValue.inclusivelyBetween(10,11) } { ~groupNumber = 2 }
	{ ~tracksValue.inclusivelyBetween(12,13) } { ~groupNumber = 1 }
	{ ~tracksValue.inclusivelyBetween(14,15) } { ~groupNumber = 0 }

	~groupNumber = 7; // initialisation de la valeur
	*/


	~seqsView = ListView(~patComp, Rect(366*~xSizeMul, 24*~ySizeMul, 30*~xSizeMul, 185*~ySizeMul)/*~controlWindowTracks, Rect(280, 17, 32, 242)*/).stringColor_(Color.white).hiliteColor_(Color.red).font_(Font("Verdana",(10*~fontSizeMul).asInteger));
	~seqsView.background = Color.grey(0.3);
	// Constitution d'une liste pour les Sequences du type -> ["S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8"...]
	~seqsView.items = ~seqs.collect {|i| /*"S"+*/ (i+1)};
	~seqsView.action_({ |i| ~seqsValue = i.value; ~updateALLView.value;
		// if (~tracksValue != 0, {~tabbedView.focus(0)} ); // voire si n'augmente pas le CPU ??? -> normalement OK, déclenché que si véritable action - Si La routine du Pattern ne déclenche pas l'action // Mais supprimé car problème d'update ???
	});
	~seqsValue = 0; // initialisation de la valeur







	~playViewFunction = { |track, val|
		case
		{track.even && val == 1}
		{
			// Pour mettre à jour le controlleur AKAI pour l'update de la lecture des pistes si déclenché de la GUI lors d'un Xfade entre A/B  -> sinon obligé de switcher entre les pistes pour l'updater
			if (~aControllerConnected == 1 and: { ~playViewValue[track +1] == 1 }, {
				~aController.setState(2,(track/2).asInteger,0);
				~aController.setState(3,(track/2).asInteger,0);
				~aController.setState(0,(track/2).asInteger,0); // Pour désactiver l'affichage du rythme
			});
			~playViewValue[track +1] = 0; ~playControlView[track +1].value = 0; /*pour le global*/ ~playViewG[track +1].value_(0); ~seqCompG[track +1].background_(~seqsGlobalColors[track] /*Color.grey(0.7)*/); ~seqCompG1[track +1].background_(/*~seqsGlobalColors[track]*/ Color.grey(0.7)); ~seqABPlayingViewG[track].string_(""); ~seqABPlayingViewG[track +1].string_("2 Pl");
			if (~tracksValue == track, {~seqCompG[track].background_(Color.magenta(0.8))}, {~seqCompG[track].background_(Color.yellow(0.8))} ); // Pour (dés-)afficher la couleur de la track sélectionnée dans la Vue Globale
			// ~seqCompG[track].background_(Color.yellow(0.8)); // Action sur le global
			~seqCompG1[track].background_(Color.yellow(0.9)); // Action sur le global
			if (~lemurConnected1 == 1, {~lemurAdress1.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track], 1 ) });
			if (~lemurConnected1 == 1, {~lemurAdress1.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track+1], 0 ) });
			if (~lemurConnected2 == 1, {~lemurAdress2.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track], 1 ) });
			if (~lemurConnected2 == 1, {~lemurAdress2.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track+1], 0 ) });
		}
		{track.even && val == 0}
		{
			~seqABPlayingViewG[track +1].string_("");
			if (~tracksValue == track, {~seqCompG[track].background_(Color.magenta(0.8))}, {~seqCompG[track].background_(~seqsGlobalColors[track] /*Color.grey(0.7)*/)} ); // Pour (dés-)afficher la couleur de la track sélectionnée dans la Vue Globale
			// ~seqCompG[track].background_(~seqsGlobalColors[track] /*Color.grey(0.7)*/); // Action sur le global
			~seqCompG1[track].background_(/*~seqsGlobalColors[tr]*/ Color.grey(0.7)); // Action sur le global
			if (~lemurConnected1 == 1, {~lemurAdress1.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track], 0 ) });
			if (~lemurConnected2 == 1, {~lemurAdress2.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track], 0 ) });
		}
		{track.odd && val == 1}
		{
			// Pour mettre à jour le controlleur AKAI pour l'update de la lecture des pistes si déclenché de la GUI lors d'un Xfade entre A/B  -> sinon obligé de switcher entre les pistes pour l'updater
			if (~aControllerConnected == 1 and: { ~playViewValue[track -1] == 1 }, {
				~aController.setState(2,(track/2).asInteger,0);
				~aController.setState(3,(track/2).asInteger,0);
				~aController.setState(0,(track/2).asInteger,0); // Pour désactiver l'affichage du rythme
			});
			~playViewValue[track -1] = 0; ~playControlView[track -1].value = 0; /*pour le global*/ ~playViewG[track -1].value_(0); ~seqCompG[track -1].background_(~seqsGlobalColors[track] /*Color.grey(0.7)*/); ~seqCompG1[track -1].background_(/*~seqsGlobalColors[track]*/ Color.grey(0.7)); ~seqABPlayingViewG[track].string_(""); ~seqABPlayingViewG[track -1].string_("2 Pl");
			if (~tracksValue == track, {~seqCompG[track].background_(Color.magenta(0.8))}, {~seqCompG[track].background_(Color.yellow(0.8))} ); // Pour (dés-)afficher la couleur de la track sélectionnée dans la Vue Globale
			// ~seqCompG[track].background_(Color.yellow(0.8)); // Action sur le global
			~seqCompG1[track].background_(Color.yellow(0.9)); // Action sur le global
			if (~lemurConnected1 == 1, {~lemurAdress1.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track], 1 ) });
			if (~lemurConnected1 == 1, {~lemurAdress1.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track-1], 0 ) });
			if (~lemurConnected2 == 1, {~lemurAdress2.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track], 1 ) });
			if (~lemurConnected2 == 1, {~lemurAdress2.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track-1], 0 ) });
		}
		{track.odd && val == 0}
		{
			~seqABPlayingViewG[track -1].string_("");
			if (~tracksValue == track, {~seqCompG[track].background_(Color.magenta(0.8))}, {~seqCompG[track].background_(~seqsGlobalColors[track] /*Color.grey(0.7)*/)} ); // Pour (dés-)afficher la couleur de la track sélectionnée dans la Vue Globale
			// ~seqCompG[track].background_(~seqsGlobalColors[track] /*Color.grey(0.7)*/); // Action sur le global
			~seqCompG1[track].background_(/*~seqsGlobalColors[tr]*/ Color.grey(0.7)); // Action sur le global
			if (~lemurConnected1 == 1, {~lemurAdress1.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track], 0 ) });
			if (~lemurConnected2 == 1, {~lemurAdress2.sendMsg(/*"/CurSeqT1/value"*/ ~lemurCurSeqPlayViewNames[track], 0 ) });
		};
	};

	// Préférable d'utiliser le Model View Controller avec Simple Controller pour faire l'update de 2 Views étant identiques XXX ??? -> plus nécessaire car retiré

	// Préparation des données pour prepseq -> switch entre lecture continue et remise à 0 - auparavant dans le pattern
	~infini = 0 ! ~nbOfTracksX2;

	~tracks.do {|tr|

		~xqControlView[tr] = RoundButton(~controlWindowTracks, Rect(90*~xSizeMul, (17+(tr*15))*~ySizeMul, 30*~xSizeMul, 15*~ySizeMul))
		.states_([["wiXQ", Color.black, Color.yellow /*Color.new255(255, 165, 0)*/ /*Color.green*/], ["noXQ", Color.white, Color.red]])
		.font_(Font("Verdana", 7*~fontSizeMul))
		.action_({|i| ~xqViewValue[tr] = i.value;
			// pour faire un update automatique du XQ Play du CompositeView - plus nécessaire
			// ~xqView.value_(~xqViewValue[~tracksValue]);
			// mais necessaire pour le global
			~xqViewG[tr].value_(~xqViewValue[tr]);
		});

		~playControlView[tr] = RoundButton(~controlWindowTracks, Rect(45*~xSizeMul, (17+(tr*15))*~ySizeMul, 45*~xSizeMul, 15*~ySizeMul))
		.states_([[("Play"+~tracksViewItemsB[tr]).asString, Color.black, Color.white], [("Ying"+~tracksViewItemsB[tr]).asString, Color.black, Color.green]])
		// .states_([["Play", Color.black, Color.green], ["Playing", Color.white, Color.red]])
		.font_(Font("Verdana",8*~fontSizeMul, bold: true))
		.action_({|i| var playMSwitch, tra; if (~playMono[tr] == 0, { playMSwitch =  \play.envirGet }, { playMSwitch =  \playM.envirGet } );

			~playViewValue[tr] = i.value;
			tra = (tr/2).asInteger;

			~infini[tr] = 0; // Préparation des données pour prepseq -> switch entre lecture continue et remise à 0
			// Vraiment necessaire pour éviter des décalages dans la position de lecture quand changement de séquence ? - lecture à relancer ?

			// ~tracksView.valueAction_(tr); // Pourquoi obligé de le rajouter sinon erreur du pattern ???????????????????????????????????????????????????????????????????????????????

			~playViewFunction.(tr, ~playViewValue[tr]);

			if (~playViewValue[tr].value == 1 /*and: {Pdef(~patterns2[tr]).isPlaying == false}*/, {

				if (~xqViewValue[tr] == 0, {
					// arguments à vérifier ???
					playMSwitch.value(npdef: ~patterns2[tr], track: ~tracks[tr], nfade: ~nFade[tr], pfade: ~pFade[tr], quant: ~quant[tr], stretchdur: 1/1)
				}, {
					playMSwitch.value(npdef: ~patterns2[tr], track: ~tracks[tr], nfade: ~nFade[tr], pfade: 0, quant: 0, stretchdur: 1/1)
				});

				// Pour mettre à jour le controlleur AKAI, quand on lance la lecture ou arrête une piste
				if (~aControllerConnected == 1, {
					/*
					{ ~aController.padInternalState[6,tra] == (tr%2) } // Pour ne pas mettre l'Akai si l'on affiche la piste A au lieu de la piste B et inversement
					// Pas besoin de le faire dans ~playViewG, car on est déjà sur la bonne piste A ou B
					*/
					if ( ~aController.padInternalState[2,tra] == 0 and: { ~aController.padInternalState[6,tra] == (tr%2) }, { ~aController.setState(2,tra,1); ~aController.incrementState(2,tra); ~aController.incrementState(2,tra); });
					if ( ~aController.padInternalState[3,tra] == 0 and: { ~aController.padInternalState[6,tra] == (tr%2) }, { ~aController.setState(3,tra,1); ~aController.incrementState(3,tra); ~aController.incrementState(3,tra); }); // Pour activer l'affichage du rythme
				});

				if (~twister.notNil, {
					if (tr == ~tracksValue, {
						~twister.knobs[8+tra].ledColor_(Color.new255(205, 133, 0))/*(Color.red)*/
					},{
						~twister.knobs[8+tra].ledColor_(Color.yellow)
					});
				});

			},{

				if (~xqViewValue[tr] == 0, {

					// Pour mettre à jour le visuel - meilleur manière d'updater le visuel ??????
					// x 4 car x2 puisque 0.5.wait; et encore x par 2 du fait de la quantisation
					fork({ block { |break| // pour stopper la boucle quand arrêt du pattern
						((~quant[tr] / ~toTempo).round(0.01) * 4).do {
							if (Pdef(~patterns2[tr]).isPlaying == true, // bizarre que la parenthèse vienne après ??????????????????

								// Pour mettre à jour le controlleur AKAI
								if (~aControllerConnected == 1, {
									~aController.setState(2,tra,2);
									~aController.setState(3,tra,2);
								});

								// Pour mettre à jour le visuel
								{
									~playControlView[tr].states_([["Stopping", Color.red, Color.yellow], ["Playing", Color.black, Color.green]]); {~playControlView[tr].acceptsMouse_(false)}.defer;
									~playViewG[tr].states_([["ping", Color.red, Color.yellow], ["ying", Color.black, Color.green]]); {~playViewG[tr].acceptsMouse_(false)}.defer

									// pour faire un update automatique du XQ Play du CompositeView - plus nécessaire
									/* ~playView.states_([["Stopping", Color.red, Color.yellow], ["Playing", Color.white, Color.red]]); {~playView.acceptsMouse_(false)}.defer */
								},{
									break.value;
							});
							0.5.wait; // lié au tempo ??? -> NON à chaque demi-seconde
							// "ok".postln; // juste pour tester
					}};
					~playControlView[tr].states_([[("Play"+~tracksViewItemsB[tr]).asString, Color.black, Color.white], [("Ying"+~tracksViewItemsB[tr]).asString, Color.black, Color.green]]);
					{~playControlView[tr].acceptsMouse_(true)}.defer;
					~playViewG[tr].states_([["Play", Color.black, Color.white], ["ying", Color.black, Color.green]]);
					{~playViewG[tr].acceptsMouse_(true)}.defer;
					// pour faire un update automatique du XQ Play du CompositeView - plus nécessaire
					/*~playView.states_([["Play", Color.black, Color.green], ["Playing", Color.white, Color.red]]);
					{~playView.acceptsMouse_(true)}.defer;*/

					// Pour mettre à jour le controlleur AKAI
					if (~aControllerConnected == 1, {
						~aController.setState(2,tra,0);
						~aController.setState(3,tra,0);
						~aController.setState(0,tra,0); // Pour désactiver l'affichage du rythme
					});

					});

					Pdef(~patterns2[tr]).quant_(~quant[tr]); Pdef(~patterns2[tr]).pause

				}, {

					// Pour mettre à jour le controlleur AKAI
					if (~aControllerConnected == 1, {
						~aController.setState(2,tra,0);
						~aController.setState(3,tra,0);
						~aController.setState(0,tra,0); // Pour désactiver l'affichage du rythme
					});

					Pdef(~patterns2[tr]).quant_(0); Pdef(~patterns2[tr]).pause
					// voir utilisation de mute -> différence vs CPU ???
				});

				// ne marche plus - Pourquoi ??????????????????
				// ~oneEvent[(tr/2).floor] = Pdef(~patterns2[tr]).asStream; // afin de permettre le déclenchement d'un évènement car erreur de positionnement si pattern déclenchée - donc remise à 0


				if (~twister.notNil, {
					if (tra > 2, {
						if (tr == ~tracksValue, {
							~twister.knobs[8+tra].ledColor_/*(Color.new255(255, 133, 0))*/(Color.red)
						},{
							~twister.knobs[8+tra].ledColor_(Color.magenta);
						});
					},{
						if (tr == ~tracksValue, {
							~twister.knobs[8+tra].ledColor_/*(Color.new255(255, 133, 0))*/(Color.red)
						},{
							~twister.knobs[8+tra].ledColor_(Color.green);
						})
					})
				});

			});

			// pour faire un update automatique du XQ Play du CompositeView - plus nécessaire
			// ~playView.value_(~playViewValue[~tracksValue]);
			// mais necessaire pour le global
			~playViewG[tr].value_(~playViewValue[tr]);

			// fonction ci-dessous qui rajoute beaucoup de CPU seulement nécessaire quand ~presetGetFunctionQuick est déclenché pour l'attribution de presets non visualisés
			if (~playViewValue[tr] == 1 and: {tr == ~tracksValue}, {~updateALLView.value} );

		});


		~play2ControlView[tr] = RoundButton(~controlWindowTracks, Rect(120*~xSizeMul, (17+(tr*15))*~ySizeMul, 30*~xSizeMul, 15*~ySizeMul))
		.states_([["Res", Color.black, ~popUpMenuBackgroundColor/*Color.gray*/]])
		.font_(Font("Verdana",7*~fontSizeMul))
		.action_({|i|
			if (Pdef(~patterns2[tr]).isPlaying == false, {Pdef(~patterns2[tr]).resume;
				if ((tr.even && ~playViewValue[tr +1] == 0) || (tr.odd && ~playViewValue[tr -1] == 0), {
					~playControlView[tr].value_(1);
					~playViewValue[tr] = 1;

					if (~twister.notNil, {
						if (tr == ~tracksValue, {
							~twister.knobs[8+(tr/2).asInteger].ledColor_(Color.new255(205, 133, 0))/*(Color.red)*/
						},{
							~twister.knobs[8+(tr/2).asInteger].ledColor_(Color.yellow)
						});
					});

					// pour faire un update automatique du XQ Play du CompositeView - plus nécessaire
					// ~playView.value_(~playViewValue[~tracksValue]);
					// mais necessaire pour le global
					~playViewG[tr].value_(~playViewValue[tr]);

				});
				~playViewFunction.(tr, ~playViewValue[tr]);

				// Pour mettre à jour le controlleur AKAI, quand on lance la lecture ou arrête une piste
				if (~aControllerConnected == 1, {
					/*
					{ ~aController.padInternalState[6,(tr/2).asInteger] == (tr%2) } // Pour ne pas mettre l'Akai si l'on affiche la piste A au lieu de la piste B et inversement
					// Pas besoin de le faire dans ~playViewG, car on est déjà sur la bonne piste A ou B
					*/
					if ( ~aController.padInternalState[2,(tr/2).asInteger] == 0 and: { ~aController.padInternalState[6,(tr/2).asInteger] == (tr%2) }, { ~aController.setState(2,(tr/2).asInteger,1); ~aController.incrementState(2,(tr/2).asInteger); ~aController.incrementState(2,(tr/2).asInteger); });
					if ( ~aController.padInternalState[3,(tr/2).asInteger] == 0 and: { ~aController.padInternalState[6,(tr/2).asInteger] == (tr%2) }, { ~aController.setState(3,(tr/2).asInteger,1); ~aController.incrementState(3,(tr/2).asInteger); ~aController.incrementState(3,(tr/2).asInteger); }); // Pour activer l'affichage du rythme
				});

			},{
				~playControlView[tr].valueAction_(0)
			});
		});

	};










	~multiStereo = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~outLRound = ~linksChannel ! ~nbOfSeqs ! ~nbOfTracksX2; // nécessaire pour que les autres pistes ne renvoient pas sur la stéréo que sur la gauche
	~outRRound = ~rightChannel ! ~nbOfSeqs ! ~nbOfTracksX2; // nécessaire pour que les autres pistes ne renvoient pas sur la stéréo que sur la gauche
	~stereoChannelSynths = {0 ! (~nbOfTracks * 2)} ! 2;


	~tracksList.do { |tr|

		// OK fait -> modifié le range de la spatialisation (0 à 4) pour ne pas prendre en compte Circ1 & Circ2 & l'ambisonique qui ne rendent pas la version stéréo
		~multiStereoControlView[tr] = RoundButton(~controlWindowTracks, Rect(150*~xSizeMul, (32+(tr*30))*~ySizeMul, 60*~xSizeMul, 15*~ySizeMul))
		.states_([["Stereo", Color.white, Color.blue], ["Multi", Color.white, Color.green(0.4)] /*["Multi", Color.black, Color.yellow]*/])
		.font_(Font("Verdana", 8*~fontSizeMul /*, bold: true*/))
		.action_({ |i|

			// Pour l'instant toutes les séquences des 2 pistes ont la même valeur
			~seqs.do {|a| ~multiStereo[tr*2][a] = i.value; ~multiStereo[tr*2+1][a] = i.value; /*~spaMin[tr][a] = 0; ~spaMax[tr][a] = 4*/};

			if (~lemurConnected1 == 1 and: { tr == ~tracksValue}, {
				~lemurAdress1.sendMsg( *["/ParC/SpaMenu/x", i.value /*~multiStereo[~tracksValue][~seqSeq[~tracksValue]]*/ ]);
			});

			if (~lemurConnected2 == 1 and: { tr == ~secondLemurX2Track}, {
				~lemurAdress2.sendMsg( *["/ParC/SpaMenu/x", i.value /*~multiStereo[~secondLemurX2Track][~seqSeq[~tracksValue]]*/ ]);
			});

			/* if (~patFlag == 0, {
			~multiStereo[tr][~seqsValue] = i.value;
			}, {~seqs.do {|a|
			~multiStereo[tr][a] = i.value;
			}});*/
		})
		.visible_(0); // Pourquoi obligé de les rendre invisible alors que effectué normalement par la suite


		~outsConfigControlViewView[tr] = View(~controlWindowTracks, Rect(210*~xSizeMul, (32+(tr*30))*~ySizeMul, 70*~xSizeMul, 15*~ySizeMul));

		~outsConfigControlView[tr] = PopUpMenu.new(~outsConfigControlViewView[tr], Rect(0, 0, 100*~xSizeMul, 15*~ySizeMul))
		.action_({ |menu|
			// ~outLRound[tr][~seqsValue] = (menu.item.split($-)[0].asInteger); ~outRRound[tr][~seqsValue] = (menu.item.split($-)[1].asInteger); ~outsConfigControlValue[tr][~seqsValue] = menu.value;
			// Pour l'instant toutes les séquences ont la même valeur
			// intérêt de ~outsConfigControlValue ???
			~seqs.do { |i| ~outLRound[tr][i] = (menu.item.split($-)[0].asInteger); ~outRRound[tr][i] = (menu.item.split($-)[1].asInteger); /*~outsConfigControlValue[tr][i] = menu.value*/ };
		})
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(~popUpMenuStringColor)
		/*.background_(Color.yellow)
		.stringColor_(Color.black)*/
		.font_(Font("Verdana",8*~fontSizeMul))
		.visible_(0); // Pourquoi obligé de les rendre invisible alors que effectué normalement par la suite



		~volControlSetRout = 0 ! ~nbOfTracks;
		~nbOfTracks.do { |id, tr|
			~volControlSetRout[tr] = Routine { var last = (-1);
				inf.do {
					if (~trackVol[tr] != last, {
						~ins[tr].fadeTime = ~insSliderFadeTime;
						~ins[tr].source = {DC.kr(~trackVol[tr])}; // "bim".postln;
						last = ~trackVol[tr];
						// "Volume Changed".postln; // juste pour check que la routine s'arrête bien
					});
					0.25.wait;
		}}/*.play(AppClock)*/};




		~trackVolView[tr] = SmoothSlider(~controlWindowTracks, Rect(150*~xSizeMul, (17+(tr*30))*~ySizeMul, 90*~xSizeMul, 15*~ySizeMul))
		.action_({ |view| var last;

			if (tr.inclusivelyBetween(0,2), { // Hack pour booster les pistes rythmiques en multipliant le volume de pistes trames x 2
				~trackVol[tr] = view.value*2/*+0.005*/;
				view.string = ("Tr"+(tr+1)+" : %").format(~dbSpec2b.map(~trackVol[tr]/2).round(0.1));
			},{
				~trackVol[tr] = view.value/*+0.005*/;
				view.string = ("Tr"+(tr+1)+" : %").format(~dbSpec2.map(~trackVol[tr]).round(0.1));
			});

			// Avant l'action directement sur les NodeProxy ~ins
			/*if (~server2.notNil, {
			~volumeBus[0][tr].line(~trackVol[tr], 0.1); ~volumeBus2[0][tr].line(~trackVol[tr], 0.1);
			~volumeBus[1][tr].line(~trackVol[tr], 0.1); ~volumeBus2[1][tr].line(~trackVol[tr], 0.1);
			/*~volumeBus[0][tr].set(~trackVol[tr]); ~volumeBus2[0][tr].set(~trackVol[tr]);
			~volumeBus[1][tr].set(~trackVol[tr]); ~volumeBus2[1][tr].set(~trackVol[tr]);*/
			},{
			~volumeBus[0][tr].line(~trackVol[tr], 0.1); ~volumeBus2[0][tr].line(~trackVol[tr], 0.1);
			// ~volumeBus[0][tr].set(~trackVol[tr]*2); ~volumeBus2[0][tr].set(~trackVol[tr]*2);
			});*/
		})
		.font_(Font("Verdana", 9*~fontSizeMul))
		.background_(~sliderBackgroundColor)
		.hilightColor_(~sliderHilightColor)
		.stringColor_(Color.white)
		.border_(~border)
		.borderColor_(~borderColor)
		// .mode_( \move )
		.valueAction_(1);
		// .doAction;

		// ~dbSpec2.map(0.5)

		~fxSelControlViewView[tr] = View(~controlWindowTracks, Rect(240*~xSizeMul, (17+(tr*30))*~ySizeMul, 40*~xSizeMul, 15*~ySizeMul));

		~fxSelControlView[tr] = PopUpMenu.new(~fxSelControlViewView[tr], Rect(0, 0, 70*~xSizeMul, 15*~ySizeMul))
		.action_({|menu| ~fxSelControlValue[tr] = menu.value;
			if (~fxSelControlValue[tr] > 0, { menu.background_(Color.red(0.7)); menu.stringColor_(Color.white) }, { menu.background_(~popUpMenuBackgroundColor); menu.stringColor_(Color.black) } );
		})
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(Color.black)
		.font_(Font("Verdana",8*~fontSizeMul))
		.items_(["Sq", "0", "1", "2", "3", "4", "5"]);


		~fadeTimeSynthEQChan = 1; // Les ~eqChaSynth avaient un fadetime relié à ~fadeTimeSynthFx // Mise en place d'un fadeTime propre aux EQs plus rapide // ~fadeTimeSynthEQChan
		~eqChaSpec = ControlSpec(-24, 24, \lin, 0.1, 0);

		~eqChaLoView[tr] = Knob(~controlWindowTracks, Rect(280*~xSizeMul, (17+(tr*30))*~ySizeMul, 16*~xSizeMul, 16*~ySizeMul)).mode_(\horiz).centered_(true).color_([Color.red, Color.white, Color.grey, Color.white])
		.action_({ |v|
			var sv; if (~server2.isNil or: {tr < ~serverTrackSwitch}, {sv = 0}, {sv = 1} );
			~eqChaLo[tr] = ~eqChaSpec.map(v.value); ~eqChannelUnitLib[sv][tr].set( \lowShelf, \db, ~eqChaLo[tr]);
			if (~eqChaActivate[tr] == 1, { ~eqChaSynth[tr].set(\fadeTime, ~fadeTimeSynthEQChan /*~fadeTimeSynthFx[sv]*/, \eqSetting, ~eqChannelUnitLib[sv][tr]) });
		})
		.valueAction_(0.5);

		~eqChaMiView[tr] = Knob(~controlWindowTracks, Rect(296*~xSizeMul, (17+(tr*30))*~ySizeMul, 16*~xSizeMul, 16*~ySizeMul)).mode_(\horiz).centered_(true).color_([Color.red(0.6), Color.white, Color.grey, Color.white])
		.action_({ |v|
			var sv; if (~server2.isNil or: {tr < ~serverTrackSwitch}, {sv = 0}, {sv = 1} );
			~eqChaMi[tr] = ~eqChaSpec.map(v.value); ~eqChannelUnitLib[sv][tr].set( \peak, \db, ~eqChaMi[tr]);
			if (~eqChaActivate[tr] == 1, { ~eqChaSynth[tr].set(\fadeTime, ~fadeTimeSynthEQChan /*~fadeTimeSynthFx[sv]*/, \eqSetting, ~eqChannelUnitLib[sv][tr]) });
		})
		.valueAction_(0.5);

		~eqChaHiView[tr] = Knob(~controlWindowTracks, Rect(280*~xSizeMul, (32+(tr*30))*~ySizeMul, 16*~xSizeMul, 16*~ySizeMul)).mode_(\horiz).centered_(true).color_([Color.blue, Color.white, Color.grey, Color.white])
		.action_({ |v|
			var sv; if (~server2.isNil or: {tr < ~serverTrackSwitch}, {sv = 0}, {sv = 1} );
			~eqChaHi[tr] = ~eqChaSpec.map(v.value); ~eqChannelUnitLib[sv][tr].set( \hiShelf, \db, ~eqChaHi[tr]);
			if (~eqChaActivate[tr] == 1, { ~eqChaSynth[tr].set(\fadeTime, ~fadeTimeSynthEQChan /*~fadeTimeSynthFx[sv]*/, \eqSetting, ~eqChannelUnitLib[sv][tr]) });
		})
		.valueAction_(0.5);
		// envir[readView].palette = envir[readView].palette.button_(Color.yellow);

		~eqChaActivateView[tr] = RoundButton(~controlWindowTracks, Rect(296*~xSizeMul, (32+(tr*30))*~ySizeMul, 15*~xSizeMul, 15*~ySizeMul))
		.states_([[/*"Off"*/ (tr+1).asString, Color.white, Color.red], [/*"On"*/(tr+1).asString, Color.black, Color.green]])
		.font_(Font("Verdana", 9*~fontSizeMul))
		.action_({|i|
			var sv; if (~server2.isNil or: {tr < ~serverTrackSwitch}, {sv = 0}, {sv = 1} );
			~eqChaActivate[tr] = i.value;
			if (~eqChaActivate[tr] == 1, {
				if (~stereoChannelSynths[sv][tr] == 0, {
					~eqChaSynth[tr] = Synth.tail(~groups[sv][tr*2], ~fxSynthDef2Cha[tr].name, [\in_bus, 0, \fadeTime, ~fadeTimeSynthEQChan /*~fadeTimeSynthFx[sv]*/, \eqSetting, ~eqChannelUnitLib[sv][tr]] );
				},{
					~eqChaSynth[tr] = Synth.before(~stereoChannelSynths[sv][tr] /*~groups[0][tr*2]*/, ~fxSynthDef2Cha[tr].name, [\in_bus, 0, \fadeTime, ~fadeTimeSynthEQChan /*~fadeTimeSynthFx[sv]*/, \eqSetting, ~eqChannelUnitLib[sv][tr]] );
				});
			},{
				~eqChaSynth[tr].set(\fadeTime, ~fadeTimeSynthEQChan /*~fadeTimeSynthFx[sv]*/);
				~eqChaSynth[tr].release;
			});
		});


		~freqVolView[tr] = NumberBox(~controlWindowTracks, Rect(150*~xSizeMul, (32+(tr*30))*~ySizeMul, 40*~xSizeMul, 15*~ySizeMul))
		.font_(Font("Verdana", 9*~fontSizeMul))
		.clipLo_(0.01)
		.clipHi_(600)
		.decimals_(2)
		.scroll_step_(0.01)
		.action_({|i| ~freqVol[tr]  = i.value; if (~sineControl[tr] == 1, { ~ins[tr].fadeTime = ~insSineFadeTime; ~ins[tr].source = {SinOsc.kr(~freqVol[tr], 0, ~ampVol[tr], 0.7)} }); })
		.valueAction_(0.2);

		~durVolView[tr] = NumberBox(~controlWindowTracks, Rect(150*~xSizeMul, (32+(tr*30))*~ySizeMul, 40*~xSizeMul, 15*~ySizeMul))
		.font_(Font("Verdana", 9*~fontSizeMul))
		.clipLo_(1)
		.clipHi_(60)
		.action_({|i| ~durVol[tr]  = i.value })
		.valueAction_(1);

		~ampVolView[tr] = NumberBox(~controlWindowTracks, Rect(190*~xSizeMul, (32+(tr*30))*~ySizeMul, 25*~xSizeMul, 15*~ySizeMul))
		.font_(Font("Verdana", 9*~fontSizeMul))
		.clipLo_(0)
		.clipHi_(0.5)
		.decimals_(1)
		.scroll_step_(0.1)
		//.step_(0.1)
		.action_({|i| ~ampVol[tr] = i.value;  })
		.valueAction_(0.5);

		~toVolView[tr] = NumberBox(~controlWindowTracks, Rect(190*~xSizeMul, (32+(tr*30))*~ySizeMul, 25*~xSizeMul, 15*~ySizeMul))
		.font_(Font("Verdana", 9*~fontSizeMul))
		.clipLo_(0)
		.clipHi_(1.0)
		.decimals_(1)
		.scroll_step_(0.1)
		//.step_(0.1)
		.action_({|i| ~toVol[tr] = i.value })
		.valueAction_(0);

		/* file:///Users/Xon/Library/Application%20Support/SuperCollider/quarks/dewdrop_lib/ddwCommon/Help/KrBusWatcher.html
		// Repeatedly polls control buses for their value and updates dependents assigned to the bus objects. Based on NodeWatcher.
		// Utile pour mettre à jour les sliders selon un bus de controle (updateFreq = 2x / seconde) - voir impact CPU
		// vs Routine qui update le slider seulement quand nécessaire

		(
		b = Bus.control(s, 1);
		a = { LFNoise1.kr(0.1, 0.5, 0.5) }.play(s, b);
		KrBusWatcher.register(b);

		f = FlowView.new;
		x = GUI.slider.new(f, Rect(0, 0, 100, 15));
		u = Updater(b, { |bus, val|
		{ x.value_(val[0]); }.defer;
		});
		)

		(
		KrBusWatcher.unregister(b);
		u.remove;
		a.free; b.free;
		a = b = f = x = u = nil;
		)
		*/

		~volControlGetRout = 0 ! ~nbOfTracks;
		~nbOfTracks.do { |tr| ~volControlGetRout[tr] = Routine {
			var sv, busVal; if (~server2.isNil or: {tr < ~serverTrackSwitch}, {sv = 0;}, {sv = 1;} );
			inf.do {
				~volumeBus[sv][tr].get { |i| busVal = i.value.round(0.01)}; 0.1.wait;
				~trackVolView[tr].value_(busVal).string = ("Tr"+(tr+1)+" : "+ busVal);
				~trackVol[tr] = busVal; // utile seulement car cette valeur détermine si on déclenche la note dans le pattern - pas efficace - le pattern doit prendre la valeur du bus
				// voire implémentation du KrBusWatcher plus haut -> serait encore plus lent car update seulement 2 x / seconde
				0.1.wait; // "bouh0".postln; // juste pour check que la routine s'arrête bien
			}
		}};

		// Apparition de messages d'erreur sur le round car recoit nil ???
		~sineControlView[tr] = Button(~controlWindowTracks, Rect(215*~xSizeMul, (32+(tr*30))*~ySizeMul, 25*~xSizeMul, 15*~ySizeMul))
		.states_([["Sine", Color.white, Color.blue], ["Sine", Color.red, Color.yellow]])
		.font_(Font("Verdana", 7*~fontSizeMul))
		.action_({ |i| var sv, svName;
			~sineControl[tr] = i.value;
			if (~server2.isNil or: {tr < ~serverTrackSwitch}, {sv = 0; svName = ~server1}, {sv = 1; svName = ~server2} );

			if (~sineControl[tr] == 1, {
				~volControlSetRout[tr].stop;
				~prevVol = ~trackVolView[tr].value;
				~ins[tr].fadeTime = ~insSineFadeTime; ~ins[tr].source = {SinOsc.kr(~freqVol[tr], 0, ~ampVol[tr], 0.7)}; // NodeProxy
				// ~ins[tr] = {SinOsc.kr(~freqVol[tr], 0, ~ampVol[tr], 0.5)}.play(svName, ~volumeBus[sv][tr]); // Synth

				~volControlGetRout[tr] = Routine { // Réaffectation pour intervertir entre sine et line et créer encore une Array de routines (~volControlGetRout)
					var busVal;
					inf.do {
						~volumeBus[sv][tr].get { |i| busVal = i.value.round(0.01)}; 0.1.wait;
						if (tr.inclusivelyBetween(0,2), {
							~trackVolView[tr].value_(busVal).string = ("Tr"+(tr+1)+" : %").format(~dbSpec2b.map(~trackVol[tr]).round(0.1)) /*("Tr"+(tr+1)+" : "+ busVal)*/;
						},{
							~trackVolView[tr].value_(busVal).string = ("Tr"+(tr+1)+" : %").format(~dbSpec2.map(~trackVol[tr]).round(0.1));
						});
						~trackVol[tr] = busVal;
						0.1.wait; // "bouh1".postln; // juste pour check que la routine s'arrête bien
					}
				};
				if (~volControlGetRout[tr].isPlaying, {}, { ~volControlGetRout[tr].reset; ~volControlGetRout[tr].play(/*AppClock, 0*/); });
				// Une Task serait peut être necessaire pour pouvoir repartir de la ou on est

			},{{
				~sineControlView[tr] /*.enabled = 0*/ .acceptsMouse_(false); // Pas vraiment de différence de comportement entre acceptsMouse_ & enabled ???
				~ins[tr].fadeTime = ~insSineFadeTime; ~ins[tr].source = {DC.kr(~prevVol)};
				~insSineFadeTime.wait;
				~volControlSetRout[tr].reset; ~volControlSetRout[tr].play;
				~volControlGetRout[tr].stop;
				~trackVolView[tr].valueAction_(~prevVol);
				~sineControlView[tr] /*.enabled = 1*/ .acceptsMouse_(true);
			}.fork(AppClock);
			});
		});


		~lineControlView[tr] = Button(~controlWindowTracks, Rect(215*~xSizeMul, (32+(tr*30))*~ySizeMul, 25*~xSizeMul, 15*~ySizeMul))
		.states_([["Line", Color.white, Color.blue], ["Line", Color.red, Color.yellow]])
		.font_(Font("Verdana", 7*~fontSizeMul))
		.action_({|i| var task, sv;
			~lineControl[tr] = i.value;
			if (~server2.isNil or: {tr < ~serverTrackSwitch}, {sv = 0}, {sv = 1} );

			if (~lineControl[tr] == 1, {
				~volControlSetRout[tr].stop;

				~volControlGetRout[tr] = Routine { // Réaffectation pour intervertir entre sine et line et créer encore une Array de routines (~volControlGetRout)
					var sv, busVal; if (~server2.isNil or: {tr < ~serverTrackSwitch}, {sv = 0;}, {sv = 1;} );
					((5*~durVol[tr])+1).do {
						~volumeBus[sv][tr].get { |i| busVal = i.value.round(0.01)}; 0.1.wait;
						// ~trackVolView[tr].value_(busVal).string = ("Tr"+(tr+1)+" : "+ busVal);
						~trackVol[tr] = busVal;
						if (tr.inclusivelyBetween(0,2), {
							~trackVolView[tr].value_(busVal/2).string = ("Tr"+(tr+1)+" : %").format(~dbSpec2b.map(~trackVol[tr]/2).round(0.1)) /*("Tr"+(tr+1)+" : "+ busVal)*/;
						},{
							~trackVolView[tr].value_(busVal).string = ("Tr"+(tr+1)+" : %").format(~dbSpec2.map(~trackVol[tr]).round(0.1));
						});
						0.1.wait; // "bouh2".postln; // juste pour check que la routine s'arrête bien
					};
					{~lineControlView[tr].valueAction_(0)}.defer;
				};

				~volumeBus[sv][tr].line(~toVol[tr], ~durVol[tr]);
				~volControlGetRout[tr].reset; ~volControlGetRout[tr].play(/*AppClock, 0*/);
				// Version ci-dessus plus gourmande en CPU car update graphique // pas comme ci-dessous
				// Task({1.do{ ~durVol[tr].wait; ~trackVolView[tr].value_(~toVol[tr]).string = ("Tr"+(tr+1)+" : "+~toVol[tr]); ~lineControlView[tr].valueAction_(0) }}).start;
			}, {~volControlGetRout[tr].stop; ~lineControlView[tr].value_(0);
				~volControlSetRout[tr].reset; ~volControlSetRout[tr].play;
			} /*// Comment interrompre le line ??? */);
		});

	};


	~switchTracksAllControlView = RoundButton(~controlWindowTracks, Rect(4*~xSizeMul, 0, 40*~xSizeMul, 15*~ySizeMul))
	.states_([["Tracks", Color.white, Color.blue]])
	.font_(Font("Verdana",8*~fontSizeMul, bold: true))
	.action_({ |i| var indicesOfTracks, indexOfTracks; // Pour switcher entre les pistes en train de jouer
		indicesOfTracks = ~playViewValue.indicesOfEqual(1);

		if (indicesOfTracks.notNil, {
			indexOfTracks = indicesOfTracks.indexOfGreaterThan(~tracksValue);
			if (indexOfTracks.isNil, {~tracksView.valueAction_(indicesOfTracks[0])}, {~tracksView.valueAction_(indicesOfTracks[indexOfTracks])});
			/*
			y = ~playViewValue.indicesOfEqual(1)
			if (y.notNil, {z = y.indexOfGreaterThan(~tracksValue); if (z.isNil, {y[0]}, {y[z]}) })
			*/

			if (indicesOfTracks.includes(~secondLemurX2Track) and: {~lemurConnected2 == 1}, { indicesOfTracks.remove(~secondLemurX2Track) });

		})
	});


	~playAllControlPrev = ~playViewValue.copy;
	~playAllControlView = RoundButton(~controlWindowTracks, Rect(45*~xSizeMul, 2*~ySizeMul, 45*~xSizeMul, 15*~ySizeMul))
	.states_([["Stop All", Color.red, Color.white]])
	.font_(Font("Verdana",8*~fontSizeMul, bold: true))
	.action_({
		if ( ~playViewValue.sum > 0, { ~playAllControlPrev = ~playViewValue.copy;
			~tracks.do {|tr| if (~playViewValue[tr] == 1, { ~playControlView[tr].valueAction_(0); ~playViewG[tr].value_(0) } ) };
		},{
			if (~playAllControlPrev.sum > 0, { ~tracks.do { |tr| if (~playAllControlPrev[tr] == 1, { ~play2ControlView[tr].valueAction_(1); ~playViewG[tr].value_(1) }) } });
		});
	});

	~xqAllControlView = RoundButton(~controlWindowTracks, Rect(90*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 15*~ySizeMul))
	.states_([["wiXQ", Color.black, Color.yellow /*Color.new255(255, 165, 0)*/ /*Color.green*/], ["No XQ", Color.white, Color.red]])
	.font_(Font("Verdana", 7*~fontSizeMul /*, bold: true*/ ))
	.action_({|i| ~tracks.do {|tr| ~xqControlView[tr].value_(i.value); ~xqViewValue[tr] = i.value;
		~xqViewG[tr].value_(~xqViewValue[tr]); // Action sur le global
	};
	});

	~playMonoAllView = RoundButton(~controlWindowTracks, Rect(120*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 15*~ySizeMul))
	.states_([["Mono", Color.red, Color.white]])
	.font_(Font("Verdana", 7*~fontSizeMul, bold: true))
	.action_({|i| if (~playMono[~tracksValue] == 0, {~playMono[~tracksValue] = 1}, {~playMono[~tracksValue] = 0}); ~playMono.postln;
	});

	~fxSelAllControlViewView = View(~controlWindowTracks, Rect(240*~xSizeMul, 2*~ySizeMul, 40*~xSizeMul, 15*~ySizeMul));

	~fxSelAllControlView = PopUpMenu.new(~fxSelAllControlViewView, Rect(0, 0, 70*~xSizeMul, 15*~ySizeMul))
	.action_({|menu|
		~nbOfTracks.do {|tr| ~fxSelControlView[tr].value_(menu.value); ~fxSelControlValue[tr] = menu.value;
			if (~fxSelControlValue[0] > 0, { menu.background_(Color.red(0.7)); menu.stringColor_(Color.white); ~fxSelControlView[tr].background_(Color.red(0.7)); ~fxSelControlView[tr].stringColor_(Color.white) }, { menu.background_(~popUpMenuBackgroundColor); menu.stringColor_(Color.black); ~fxSelControlView[tr].background_(~popUpMenuBackgroundColor); ~fxSelControlView[tr].stringColor_(Color.black) } );
		};
	})
	.allowsReselection_(true)
	.background_(~popUpMenuBackgroundColor)
	.stringColor_(Color.black)
	.font_(Font("Verdana",8*~fontSizeMul))
	.items_(["Sq", "0", "1", "2", "3", "4", "5"]);

	~eqChaAll1ActivateView = RoundButton(~controlWindowTracks, Rect(280*~xSizeMul, 2*~ySizeMul, 15*~xSizeMul, 15*~ySizeMul))
	.states_([["Off", Color.white, Color.red], ["On", Color.black, Color.green]])
	.font_(Font("Verdana", 7*~fontSizeMul))
	.action_({|v| (0..3).do { |i| ~eqChaActivateView[i].valueAction_(v.value) } });

	~eqChaAll2ActivateView = RoundButton(~controlWindowTracks, Rect(296*~xSizeMul, 2*~ySizeMul, 15*~xSizeMul, 15*~ySizeMul))
	.states_([["Off", Color.white, Color.red], ["On", Color.black, Color.green]])
	.font_(Font("Verdana", 7*~fontSizeMul))
	.action_({|v| (4..7).do { |i| ~eqChaActivateView[i].valueAction_(v.value) } });










	// controlWindowVolume

	~trackInVolView = SmoothSlider(~controlWindowVolume, Rect(5*~xSizeMul, 2*~ySizeMul, 100*~xSizeMul, 25*~ySizeMul))
	.action_({ |i| ~inVolume = i.value;
		~nbOfServers.do { |s| ~inBus[s].set(~inVolume); }; /*~inBus.line(~inVolume, 1);*/
		i.string = ("In Vol : %").format(i.value.round(0.01))
	})
	.font_(Font("Verdana", 12*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.mode_(\move )
	.valueAction_(1)
	.doAction;

	~trackFXVolView = SmoothSlider(~controlWindowVolume, Rect(105*~xSizeMul, 2*~ySizeMul, 120*~xSizeMul, 25*~ySizeMul))
	.action_({ |i| ~fxVolume = i.value;
		i.string = ("FX Vol : %").format(i.value.round(0.01));

		if (~twister.notNil, { ~fxValue.value_(~fxVolume) }); // pas redondant ??? - à améliorer XXX

		~nbOfServers.do { |s|

			// A quoi sert le "if (~fxSynth2[i] != 0" -> puisque ~fxSynth2 est normalement toujours différent de 0 ???
			// (~numEffects-1).do { |i|  if (~fxSynth2[i] != 0 and: { ~fxInSerieChoose[i] == 0}, { ~fxSynth2[/*~fxInSerieOrder[*/i/*]*/].set( \amp, ~fxVolume ) }) }; // Pour les synthés inout
			(~numEffects-1).do { |i|  if (~fxSynth2[s][i] != 0, {
				// ~fxSynth2[/*~fxInSerieOrder[*/i/*]*/].set( \amp, ~fxVolume );
				if ( ~fxInSerieChoose[s][i] == 0, {
					~fxSynth2[s][/*~fxInSerieOrder[*/i/*]*/].set( \amp, ~fxVolume );
				},{
					~fxSynth2[s][/*~fxInSerieOrder[*/i/*]*/].set( \amp, /*1*/ (~fxVolume * ~fxMulVolume /*2*/ /*1.6*/).sqrt )
				}); // Pour les synthés inout
			})
			};

			// if (~fxSynth2[4] != 0, { ~fxSynth2[4].set( \amp, ~fxVolume ) }); // remplacé par ci-dessous
			if (~fxSynth2[s][4] != 0, { if (~fxInSerieChoose[s][3] == 0, { ~fxSynth2[s][4].set( \amp, ~fxVolume ) }, { ~fxSynth2[s][4].set( \amp, (~fxVolume * ~fxMul2Volume).sqrt /*/2*/ /*(~fxVolume  / 2 /** 1.6*/ /*2*/ ).sqrt*/ /*~fxVolume.sqrt*/ ) }) }); // comme dans ~trackFXVolView

		};

		if (~lemurConnected1 == 1, {
			~lemurAdress1.sendMsg("/VolC/Vol_FX2/value", 1- (~fxVolume*2));
			~lemurAdress1.sendMsg("/VolC/Vol_FXM/value", ~fxVolume);
		});

		if (~lemurConnected2 == 1, {
			~lemurAdress2.sendMsg("/VolC/Vol_FX2/value", 1- (~fxVolume*2));
			~lemurAdress2.sendMsg("/VolC/Vol_FXM/value", ~fxVolume);
		});

		if (~fxVolume.round(0.01) < 0.07, { i.background_(Color.red) }, { i.background_(~sliderBackgroundColor) } );

	})
	.font_(Font("Verdana", 12*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.mode_(\move );
	// valueAction -> mis à la fin -> ~trackFXVolView.valueAction_(0.15);
	/*.valueAction_(0.15)
	.doAction;*/










	/*
	// simple basic clock

	a = ClockFace.new;
	a.play;
	a.stop;
	a.window.close;

	// uses as a metronome

	a = ClockFace.new;
	// change the tempo of the time change
	a.tempo_(92/60);
	a.mod_(4);

	a.onBeat_({arg curBeat;
	curBeat.postln;
	curBeat.even.if({
	(curBeat == 2).if({
	a.window.view.background_(Color.red(0.9))
	}, {
	a.window.view.background_(Color.red(0.6))
	})
	}, {
	a.window.view.background_(Color.white)
	})
	});

	a.play;

	// change the tempo at the next bar
	a.onMod_({a.tempo_(30/60)});
	a.onMod_({"Works!".postln; a.tempo_(120/60)});
	a.stop;


	( // Affichage du chronomètre : ClockFace
	// Changement vers ClockFace pour adapter l'affichage de la GUI
	a = ClockFace2(inc: 1);
	a.window.alwaysOnTop_(true);
	a.play;
	)
	( // Fermeture du chronomètre
	a.stop;
	a.window.close;
	)


	// diff & addresse de 2 fichiers -> pour connaitre la différence entre eux
	// Incorporating a Quark GUI into a Users's GUI? (e.g. ClockFace)
	w = Window.new;
	w.front;
	// do NOT show the GUI
	a = ClockFace3.new(inc: 1, showGUI: false);
	// pass in your own parent and bounds for the display
	a.cursecs = 0
	a.digitalGUI(w, Rect(10, 100, 430, 110));
	a.play;
	a.stop;

	(
	var start;
	start = Main.elapsedTime;
	{ loop({(Main.elapsedTime - start).asTimeString.postln; 0.05.wait}) }.fork;
	)
	(
	var start;
	start = Main.elapsedTime;
	{ loop({(Main.elapsedTime - start).asTimeString(1)[3..7].postln; 0.1.wait}) }.fork;
	)
	(
	var start;
	start = Main.elapsedTime;
	{ loop({(Main.elapsedTime - start).asTimeString(1)[3..7].postln; 0.1.wait}) }.fork;
	)

	Tdef(\x, { var start; start = Main.elapsedTime; loop ({(Main.elapsedTime - start).asTimeString(1)[3..7].postln; 0.1.wait}) });
	Tdef(\x).play;
	Tdef(\x).stop;
	Tdef(\x).pause;
	*/



	Tdef(\clock, { var start; start = Main.elapsedTime;
		loop ({
			~currentTime = (Main.elapsedTime - start).asTimeString(1)[3..7];
			{~timeView.string = ~currentTime}.defer; 0.1.wait;
		})
	});

	// Changement avec le Quark Automation
	Tdef(\clockA, { // var start; start = Main.elapsedTime;
		loop ({
			{ ~timeView.string = ~automation.now.asInteger.asTimeString(1)[3..7] }.defer; 0.1.wait;
		})
	});

	~timeView = StaticText(~controlWindowVolume, Rect(230*~xSizeMul, 2*~ySizeMul, 45*~xSizeMul, 22*~ySizeMul))
	.font_(Font("Verdana", 12*~fontSizeMul, bold: true))
	.align_(\center)
	.acceptsMouse_(0)
	.stringColor_(Color.black);

	~timeControlView = RoundButton(~controlWindowVolume, Rect(280*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["Cl", Color.white, Color.red], ["Cl", Color.black, Color.green]])
	.font_(Font("Verdana", 12*~fontSizeMul))
	.action_({|i|
		if (~automationActive == 1, {
			if (i.value == 1, {
				~automationWindow.background_(Color.red);
				~automation.seek(~automationInitRecTime, false /*true*/); // if (~automation.now.asInteger != 0, { ~automation.seek(0, true); });
				~automation.snapshot; ~automation.enableRecording; /*if (~automation.onPlay == 0, {*/ ~automation.play; ~automation.onPlay = 1; /*});*/ /*~automation.play;*/ // ~automation.onPlay = 1;
				Tdef(\clockA).play;
			},{
				~automationWindow.background_(Color.black);
				~automation.stopRecording; // ~automation.stop;
				if (~playViewValue.sum == 0, { /*~playAllControlView.valueAction_(1);*/ ~automation.stop; ~automation.onPlay = 0});
				Tdef(\clockA).stop;
			});
		},{
			if (i.value == 1, { Tdef(\clock).play; }, { Tdef(\clock).stop; });
		});
	});
	// ~timeControlView.valueAction_(0);








	// permet de retirer le volumeAmpControl si pas déjà fait par la fermeture de la GUI
	if (~server2.notNil, {
		if (~serverVolume[0].notNil, {~serverVolume[0].reset});
		if (~serverVolume[1].notNil, {~serverVolume[1].reset});
	},{
		if (~serverVolume[0].notNil, {~serverVolume[0].reset});
	});

	~trackAllVolView = SmoothSlider(~controlWindowVolume, Rect(5*~xSizeMul, 28*~ySizeMul, 220*~xSizeMul, 25*~ySizeMul))
	.action_({ |i| ~globalVolume = ~dbSpec.map(i.value);
		if (~server2.notNil, {
			~serverVolume[0].volume = ~globalVolume;
			~serverVolume[1].volume = ~globalVolume;
		},{
			~serverVolume[0].volume = ~globalVolume;
		});
		i.string = ("Global Volume : % db").format(~globalVolume.round(0.01));

		if (~lemurConnected1 == 1, {
			~lemurAdress1.sendMsg("/VolC/Vol_G2/value", 1- i.value /*~globalVolume*/);
			~lemurAdress1.sendMsg("/VolC/Vol_GM/value", ~globalVolume);
		});
		if (~lemurConnected2 == 1, {
			~lemurAdress2.sendMsg("/VolC/Vol_G2/value", 1- i.value /*~globalVolume*/);
			~lemurAdress2.sendMsg("/VolC/Vol_GM/value", ~globalVolume);
		});
	})
	.font_(Font("Verdana", 12*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.mode_(\move )
	.valueAction_(~dbSpec.unmap(0))
	.doAction;

	~trackAllVolControl1View = RoundButton(~controlWindowVolume, Rect(228*~xSizeMul, 28*~ySizeMul, 40*~xSizeMul, 25*~ySizeMul))
	.states_([["0", Color.white, Color.red]])
	.font_(Font("Verdana", 12*~fontSizeMul))
	.action_({|i| ~trackAllVolView.value_(0).string = ("Global Volume : -inf db"); /*~globalBus.line(0, 0.05);*/
		if (~server2.notNil, {
			~serverVolume[0].volume = -90;
			~serverVolume[1].volume = -90;
		},{
			~serverVolume[0].volume = -90;
		});
	});

	~trackAllVolControl2View = RoundButton(~controlWindowVolume, Rect(270*~xSizeMul, 28*~ySizeMul, 40*~xSizeMul, 25*~ySizeMul))
	.states_([["1", Color.black, Color.green]])
	.font_(Font("Verdana", 12*~fontSizeMul))
	.action_({|i| ~trackAllVolView.value_(~dbSpec.unmap(0)).string = ("Global Volume : 0 db"); /*~globalBus.line(1, 0.05);*/
		if (~server2.notNil, {
			~serverVolume[0].volume = 0;
			~serverVolume[1].volume = 0;
		},{
			~serverVolume[0].volume = 0;
		});

	});





	// Activate limiter - transféré dans la GUI après le s.volume
	// prevents nan in audio & limiter in Bat lib
	// if (~stageLimiter.isNil, {~stageLimiter = StageLimiter.activate(numChannels: ~numChannels) });
	// StageLimiter.deactivate;





	~visibleControlView = RoundButton(~controlWindowTracks, Rect(150*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 15*~ySizeMul))
	.states_([["V1", Color.white, Color.blue], ["V2", Color.white, Color.blue], ["V0", Color.white, Color.blue]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i| ~visibleControlValue = i.value;
		case
		{~visibleControlValue == 0} {
			~tracksList.do {|tr|
				~durVolView[tr].visible_(1); ~toVolView[tr].visible_(1); ~lineControlView[tr].visible_(1);
				~freqVolView[tr].visible_(0); ~ampVolView[tr].visible_(0); ~sineControlView[tr].visible_(0);
				~multiStereoControlView[tr].visible_(0); ~outsConfigControlView[tr].visible_(0)	}
		}
		{~visibleControlValue == 1} {
			~tracksList.do {|tr|
				~durVolView[tr].visible_(0); ~toVolView[tr].visible_(0); ~lineControlView[tr].visible_(0);
				~freqVolView[tr].visible_(1); ~ampVolView[tr].visible_(1); ~sineControlView[tr].visible_(1);
				~multiStereoControlView[tr].visible_(0); ~outsConfigControlView[tr].visible_(0)	}
		}
		{~visibleControlValue == 2} {
			~tracksList.do {|tr|
				~durVolView[tr].visible_(0); ~toVolView[tr].visible_(0); ~lineControlView[tr].visible_(0);
				~freqVolView[tr].visible_(0); ~ampVolView[tr].visible_(0); ~sineControlView[tr].visible_(0);
				~multiStereoControlView[tr].visible_(1); ~outsConfigControlView[tr].visible_(1)	};
		}
	})
	.valueAction_(2);

	~eqChaDefAllView = RoundButton(~controlWindowTracks, Rect(180*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 15*~ySizeMul))
	.states_([["Eq D", Color.white, Color.blue]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i| // L'autre donnée de l'array n'est pas utilisée - pas besoin d'array, mais besoin d' ajouter une fonction légèrement modifiée en conséquence
		~fxTabCompDefEQCha1View[0].valueAction_(1); ~fxTabCompDefEQCha2View[0].valueAction_(1); ~fxTabCompDefEQCha3View[0].valueAction_(1); ~fxTabCompDefEQCha4View[0].valueAction_(1); ~fxTabCompDefEQCha5View[0].valueAction_(1); ~fxTabCompDefEQCha6View[0].valueAction_(1); ~fxTabCompDefEQCha7View[0].valueAction_(1); ~fxTabCompDefEQCha8View[0].valueAction_(1);
	});

	~eqChaRandAllView = RoundButton(~controlWindowTracks, Rect(210*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 15*~ySizeMul))
	.states_([["Eq R", Color.white, Color.red]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i| ~fxTabCompRand1EQCha1View[0].valueAction_(1); ~fxTabCompRand1EQCha2View[0].valueAction_(1); ~fxTabCompRand1EQCha3View[0].valueAction_(1); ~fxTabCompRand1EQCha4View[0].valueAction_(1); ~fxTabCompRand1EQCha5View[0].valueAction_(1); ~fxTabCompRand1EQCha6View[0].valueAction_(1); ~fxTabCompRand1EQCha7View[0].valueAction_(1); ~fxTabCompRand1EQCha8View[0].valueAction_(1); });














	// controlWindowTrig

	~busControlComp = CompositeView(~globalWindow, Rect(162*~xSizeMul, 2*~ySizeMul, 107*~xSizeMul, 41*~ySizeMul)).background = Color.white /*~sliderHilightNoColor*/ /*Color.magenta*/;

	~trigAll = 0; // Pourquoi le valueAction ne renvoie pas la valeur et besoin d'assigner ~trigAll ???
	~trigAllView = RoundButton(/*~controlWindowTrig*/~busControlComp, Rect(2*~xSizeMul, 2*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["Track", Color.white, Color.blue], ["Other", Color.black, Color.yellow], ["ALL", Color.white, Color.red], ["Tex13", Color.red, Color.white]])
	.font_(Font("Verdana", 9*~fontSizeMul, bold: true))
	.action_({|i| ~trigAll = i.value;
	});
	~trigAllView.valueAction_(3);

	// Triggers in Panel Control

	// See Server Command Reference

	~clearPostWindowView = RoundButton(~controlWindowTrig, Rect(262*~xSizeMul, 2*~ySizeMul, 48*~xSizeMul, 20*~ySizeMul))
	.states_([["ClearPW", Color.blue, Color.white]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i| 30.do({"\n".post});
	});

	~queryABusView = RoundButton(~controlWindowTrig, Rect(262*~xSizeMul, 27*~ySizeMul, 48*~xSizeMul, 20*~ySizeMul))
	.states_([["QueryB5", Color.blue, Color.white]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i|
		~nbOfServers.do { |s| ~controlBusSynth[s][5].group.dumpTree; /*~controlBus[0][5].get;*/ ~controlBus[s][5].get({|val| ("Server"+s+"->"+val).postln;}); };
	});

	/*~freeABusView = RoundButton(~controlWindowTrig, Rect(262, 52, 48, 20))
	.states_([["FreeB5", Color.blue, Color.white]])
	.font_(Font("Verdana", 9))
	.action_({|i| ~controlBusSynth[5].free;
	});*/



	// Le TrigRate se désactive parfois à cause d'une perte de connexion entre le langage et le server -> le patch de James Harkins résout en partie ce problème
	// Mais le déclenchement simultané de plusieurs TrigRates les ajoute au groupe et les additionne -> possibilité de les supprimer avec free XXXXXXXXX
	// Mais comment repérer automatiquement le nombre de temporary nodes dans un groupe ?????????

	/*
	~controlBus[5].get
	~controlBus[5].clear

	~controlBusSynth[5].group
	~controlBusSynth[5].sources
	~controlBusSynth[5].group.dumpTree
	~controlBusSynth[5].group.queryTree
	~controlBusSynth[5].group.query
	~controlBusSynth[5].defaultGroupID // ???
	~controlBusSynth[5].asGroup
	~controlBusSynth[5].nodeID

	~controlBusSynth[5].sources.do(_.postcs);
	~controlBusSynth[5].nodeMap

	~controlBusSynth[5].end // supprime le Node supplémentaire mais pas la valeur faussée
	~controlBusSynth[5].free // XXXXXXXXX

	~controlBus = ~numberOfControlBus.collect {|i| Bus(\control, index: (120+i), numChannels: 1) };
	~controlBusSynth = ~numberOfControlBus.collect {|i| NodeProxy.for(~controlBus[i]).fadeTime_(0).source = { DC.kr(1.0) } };

	~controlBusSynth[5].source = { DC.kr(1.0) };
	~controlBusSynth[5].source = NodeProxy.for(~controlBus[5]).fadeTime_(0).source = { DC.kr(1.0) }
	*/





	~trigRate1View = RoundButton(~controlWindowTrig, Rect(5*~xSizeMul, 2*~ySizeMul, 45*~xSizeMul, 20*~ySizeMul))
	.states_([["Rat 1", Color.white, Color.blue]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({ |i|
		case
		{~trigAll == 0}
		{
			/*s.getQueryTree({ |data|
			~serverCollection = data;
			~synthsIDCollection = ~serverCollection['children'][0]['children'][~groupNumber]['children'].size.collect { |i| ~serverCollection['children'][0]['children'][~groupNumber]['children'][i]['id'] };
			~synthsIDCollection.size.do { |i| s.sendMsg("/n_set",~synthsIDCollection[i], "rate", ~rate1) };
			})*/

			// Amélioration en agissant directement sur tout le groupe et pas de requête sur le numéro du Node
			~nbOfServers.do { |s| ~groups[s][~tracksValue].set("rater", ~rate1) };
		}
		{~trigAll == 2}
		{
			/*s.getQueryTree({ |data|
			~serverCollection = data;
			~synthsIDCollection = 8.collect { |t| ~serverCollection['children'][0]['children'][t]['children'].size.collect { |i| ~serverCollection['children'][0]['children'][t]['children'][i]['id'] } }.flatten;
			~synthsIDCollection.size.do { |i| s.sendMsg("/n_set",~synthsIDCollection[i], "rate", ~rate1) };
			})*/

			// Amélioration en agissant directement sur tout le groupe et pas de requête sur le numéro du Node
			~nbOfServers.do { |s| ~groups[s].select({ |i, index| index.even}).do { |i| i.set("rater", ~rate1) } };
		}
		{~trigAll == 1}
		{
			~nbOfServers.do { |s|
				var list = ~groups[s].select({ |i, index| index.even}); list.remove(~groups[s][~tracksValue]); /*list.postln;*/
				list.do { |i| i.set("rater", ~rate1) }
			};
		}
	});

	// ~rateSpec = ControlSpec(0.01, 200, 4, 0.1);

	/*~rate1View = SmoothSlider(~controlWindowTrig, Rect(60, 2, 200, 22))
	.action_({ |view| ~rate1 = ~rateSpec.map(view.value);
	view.string = "Rat 1 : %".format(~rate1);
	})
	.font_(Font("Verdana", 10))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~rateSpec.unmap(0.2))
	.doAction;*/

	~rate1View = NumberBox(~controlWindowTrig, Rect(52*~xSizeMul, 2*~ySizeMul, 36*~xSizeMul, 20*~ySizeMul))
	.action_({ |view| ~rate1 = view.value })
	.clipLo_(0.1).clipHi_(200).minDecimals_(0).maxDecimals_(1)
	.font_(Font("Verdana", 10*~fontSizeMul))
	.valueAction_(0.2);

	~trigRate2View = RoundButton(~controlWindowTrig, Rect(90*~xSizeMul, 2*~ySizeMul, 45*~xSizeMul, 20*~ySizeMul))
	.states_([["Rat 2", Color.white, Color.blue]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({ |i|
		case
		{~trigAll == 0}
		{
			// Amélioration en agissant directement sur tout le groupe et pas de requête sur le numéro du Node
			~nbOfServers.do { |s| ~groups[s][~tracksValue].set("rater", ~rate2) };
		}
		{~trigAll == 2}
		{
			~nbOfServers.do { |s| ~groups[s].select({ |i, index| index.even}).do { |i| i.set("rater", ~rate2) } };
		}
		{~trigAll == 1}
		{
			~nbOfServers.do { |s|
				var list = ~groups[s].select({ |i, index| index.even}); list.remove(~groups[s][~tracksValue]); /*list.postln;*/
				list.do { |i| i.set("rater", ~rate2) }
			};
		}
	});

	/*~rate2View = SmoothSlider(~controlWindowTrig, Rect(60, 24, 200, 22))
	.action_({ |view| ~rate2 = ~rateSpec.map(view.value);
	view.string = "Rat 2 : %".format(~rate2);
	})
	.font_(Font("Verdana", 10))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~rateSpec.unmap(5))
	.doAction;*/

	~rate2View = NumberBox(~controlWindowTrig, Rect(137*~xSizeMul, 2*~ySizeMul, 36*~xSizeMul, 20*~ySizeMul))
	.action_({ |view| ~rate1 = view.value })
	.clipLo_(0.01).clipHi_(200).minDecimals_(0).maxDecimals_(1)
	.font_(Font("Verdana", 10*~fontSizeMul))
	.valueAction_(5);

	~trigRate3View = RoundButton(~controlWindowTrig, Rect(175*~xSizeMul, 2*~ySizeMul, 45*~xSizeMul, 20*~ySizeMul))
	.states_([["Rat 3", Color.white, Color.blue]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({ |i|
		case
		{~trigAll == 0}
		{
			// Amélioration en agissant directement sur tout le groupe et pas de requête sur le numéro du Node
			~nbOfServers.do { |s| ~groups[s][~tracksValue].set("rater", ~rate3) };
		}
		{~trigAll == 2}
		{
			~nbOfServers.do { |s| ~groups[s].select({ |i, index| index.even}).do { |i| i.set("rater", ~rate3) } };
		}
		{~trigAll == 1}
		{
			~nbOfServers.do { |s|
				var list = ~groups[s].select({ |i, index| index.even}); list.remove(~groups[s][~tracksValue]); /*list.postln;*/
				list.do { |i| i.set("rater", ~rate3) }
			};
		}
	});

	/*~rate3View = SmoothSlider(~controlWindowTrig, Rect(60, 46, 200, 22))
	.action_({ |view| ~rate3 = ~rateSpec.map(view.value);
	view.string = "Rat 3 : %".format(~rate3);
	})
	.font_(Font("Verdana", 10))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~rateSpec.unmap(50))
	.doAction;*/

	~rate3View = NumberBox(~controlWindowTrig, Rect(222*~xSizeMul, 2*~ySizeMul, 36*~xSizeMul, 20*~ySizeMul))
	.action_({ |view| ~rate1 = view.value })
	.clipLo_(0.01).clipHi_(200).minDecimals_(0).maxDecimals_(1)
	.font_(Font("Verdana", 10*~fontSizeMul))
	.valueAction_(50);





	~trigCutPrevent = 0;

	// un controle linéaire de l'amplitude pas très adapté -> à modifier ???

	~trigCut1View = RoundButton(~controlWindowTrig, Rect(5*~xSizeMul, 27*~ySizeMul, 45*~xSizeMul, 20*~ySizeMul))
	.states_([["Cut 1", Color.white, Color.blue]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i|
		// if (~trigCutPrevent == 0, {
		// { ("Try to Wait" + (~cut1+~silenceTime+0.1) ++ "s - end of Vol Cut").warn; ~trigCutPrevent = 1; (~cut1+~silenceTime+0.1).wait; "End of Vol Cut - OK to retrigger".inform; ~trigCutPrevent = 0; }.fork;

		// if (~trigAll == 0, {

		/*s.getQueryTree({ |data|
		~serverCollection = data;
		~synthsIDCollection = ~serverCollection['children'][0]['children'][~groupNumber]['children'].size.collect { |i| ~serverCollection['children'][0]['children'][~groupNumber]['children'][i]['id'] };
		// des actions sur l'enveloppe n'agissent pas
		// ~synthsIDCollection.size.do { |i| s.sendMsg("/n_set", c[i], "durenv", 0.1) };
		// ~synthsIDCollectionsize.do { |i| s.sendMsg("/n_get", c[i], "amp", 0) };
		~synthsIDCollection.size.do { |i| s.sendMsg("/n_set", ~synthsIDCollection[i], "busVolume", 110+(~tracksValue/2).floor ) };
		~volumeBus2[(~tracksValue/2).floor].line(0, ~cut1);
		~synthsIDCollection.size.do { |i| s.sendBundle(~cut1, ["/n_free", ~synthsIDCollection[i]]) };
		s.sendBundle(~cut1+0.1, ["/c_set", 110+(~tracksValue/2).floor, ~trackVol[(~tracksValue/2).floor]]);
		})*/

		// Amélioration en agissant directement sur tout le groupe et pas de requête sur le numéro du Node mais pb avec la 3ème ligne g_freeAll qui coupe tous les synthés
		/*if (~server2.notNil, {
		~nbOfServers.do { |s|
		~groups[s][~tracksValue].set("busVolume", 110+(~tracksValue/2).floor);
		~volumeBus2[s][(~tracksValue/2).floor].line(0, ~cut1);
		};
		// s.sendBundle(~cut1, ["/g_freeAll", ~groups[~tracksValue].nodeID]); // Utilisation de DetectSilence pour arrêter un synthé quand le signal est en dessous d'un certain niveau
		// ~groups[~tracksValue].freeAll; // équivalent à la ligne du dessus MAIS ne décale pas l'action dans le temps
		~server1.sendBundle(~cut1+~silenceTime+0.01, ["/c_set", 110+(~tracksValue/2).floor, ~trackVol[(~tracksValue/2).floor]]);
		~server2.sendBundle(~cut1+~silenceTime+0.01, ["/c_set", 110+(~tracksValue/2).floor, ~trackVol[(~tracksValue/2).floor]]);
		},{
		~groups[0][~tracksValue].set("busVolume", 110+(~tracksValue/2).floor);
		~volumeBus2[0][(~tracksValue/2).floor].line(0, ~cut1);
		~server1.sendBundle(~cut1+~silenceTime+0.01, ["/c_set", 110+(~tracksValue/2).floor, ~trackVol[(~tracksValue/2).floor]]);
		});*/

		// }, {

		/*s.getQueryTree({ |data|
		~serverCollection = data;
		~synthsIDCollection = 8.collect { |t| ~serverCollection['children'][0]['children'][t]['children'].size.collect { |i| ~serverCollection['children'][0]['children'][t]['children'][i]['id'] } }.flatten;
		// des actions sur l'enveloppe n'agissent pas
		// ~synthsIDCollection.size.do { |i| s.sendMsg("/n_set", c[i], "durenv", 0.1) };
		// ~synthsIDCollectionsize.do { |i| s.sendMsg("/n_get", c[i], "amp", 0) };
		~synthsIDCollection.size.do { |i| s.sendMsg("/n_set", ~synthsIDCollection[i], "busVolume", 110+(~tracksValue/2).floor ) };
		~volumeBus2[(~tracksValue/2).floor].line(0, ~cut1);
		~synthsIDCollection.size.do { |i| s.sendBundle(~cut1, ["/n_free", ~synthsIDCollection[i]]) };
		s.sendBundle(~cut1+0.1, ["/c_set", 110+(~tracksValue/2).floor, ~trackVol[(~tracksValue/2).floor]]);
		})*/

		// Amélioration 2
		/*~nbOfServers.do { |s|
		~groups[s].select({ |i, index| index.even}).do { |i| i.set("busVolume", 110+(~tracksValue/2).floor) };
		~volumeBus2[s][(~tracksValue/2).floor].line(0, ~cut1);
		};
		if (~server2.notNil, {
		// ~groups.select({ |i, index| index.even}).do { |i| s.sendBundle(~cut1, ["/g_freeAll", i.nodeID]) }; // Utilisation de DetectSilence pour arrêter un synthé quand le signal est en dessous d'un certain niveau
		~server1.sendBundle(~cut1+~silenceTime+0.01, ["/c_set", 110+(~tracksValue/2).floor, ~trackVol[(~tracksValue/2).floor]]);
		~server2.sendBundle(~cut1+~silenceTime+0.01, ["/c_set", 110+(~tracksValue/2).floor, ~trackVol[(~tracksValue/2).floor]]);
		},{
		~server1.sendBundle(~cut1+~silenceTime+0.01, ["/c_set", 110+(~tracksValue/2).floor, ~trackVol[(~tracksValue/2).floor]]);
		});*/

		// ~volumeBus2[0][6].getSynchronous
		// Les touches VBN de coupure du volume ne marchent pas bien quand le volume rythmique est à 0 car remet le volume des pistes rythmiques à 1, puis fait un fade down
		// Annuler l'effet sur les pistes rythmiques si le volume des pistes rythmiques est déjà à 0 ou reprendre le volume courant des pistes rythmiques pour faire le fade ???
		// Tentative, à vérifier & à optimiser
		~nbOfServers.do { |s| var groups = ~groups[s].select({ |i, index| index.even});
			groups.do { |i, ad| i.set("busVolume", 117-ad); ~volumeBus2[s][ad].line(0, ~cut1) };
			[~server1, ~server2][s].do { |i, id| i.sendBundle(~cut1+~silenceTime+0.01, ["/c_set", 117-id, ~trackVol[id]]) };
		};

		/*
		// Comment libérer tous les synthés de plusieurs groupes ? XXX
		s.sendBundle(~cut1, ["/g_freeAll", 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033 ]); // syntaxe correcte
		s.sendBundle(~cut1, ["/g_freeAll",  [1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033] ]); // syntaxe non correcte & provoque FAILURE IN SERVER /s_new Group 1026 not found en boucle
		s.sendBundle(~cut1, ["/g_freeAll", ~groups.select({ |i, index| index.even}).collect { |i| i.nodeID } ]); // syntaxe non correcte
		s.sendBundle(~cut1, ["/g_freeAll", "~groups.select({ |i, index| index.even}).collect { |i| i.nodeID }.asString.split($[)[1].split($])[0]".interpret ]) // syntaxe non correcte
		~groups.select({ |i, index| index.even}).do { |i| s.sendBundle(~cut1, ["/g_freeAll", i.nodeID]) }; // ok
		~groups.select({ |i, index| index.even}).do { |i| i.freeAll }; // encore mieux MAIS ne décale pas l'action dans le temps
		*/
		// });

		// ~fadeTimeSynthFxView.valueAction_(~cut1*2);
		~nbOfServers.do { |s| ~fxDefaultAll2View[s].valueAction_(1) };

		// });
	});

	// ~cutSpec = ControlSpec(0.1, 10, \lin, 0.1);

	/*~cut1View = SmoothSlider(~controlWindowTrig, Rect(43, 68, 44, 22))
	.action_({ |view| ~cut1 = ~cutSpec.map(view.value);
	view.string = "%".format(~cut1);
	})
	.font_(Font("Verdana", 10))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~cutSpec.unmap(0.5))
	.doAction;*/

	~cut1View = NumberBox(~controlWindowTrig, Rect(52*~xSizeMul, 27*~ySizeMul, 36*~xSizeMul, 20*~ySizeMul))
	.action_({ |view| ~cut1 = view.value })
	.clipLo_(0.01).clipHi_(10).minDecimals_(0).maxDecimals_(2)
	.font_(Font("Verdana", 10*~fontSizeMul))
	.valueAction_(0.1);


	~trigCut2View = RoundButton(~controlWindowTrig, Rect(90*~xSizeMul, 27*~ySizeMul, 45*~xSizeMul, 20*~ySizeMul))
	.states_([["Cut 2", Color.white, Color.blue]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i|
		if (~trigCutPrevent == 0, {
			{ ("Try to Wait" + (~cut2+~silenceTime+0.1) ++ "s - end of Vol Cut").warn; ~trigCutPrevent = 1; (~cut2+~silenceTime+0.1).wait; "End of Vol Cut - OK to retrigger".inform; ~trigCutPrevent = 0; }.fork;

			~nbOfServers.do { |s| var groups = ~groups[s].select({ |i, index| index.even});
				groups.do { |i, ad| i.set("busVolume", 117-ad); ~volumeBus2[s][ad].line(0, ~cut2) };
				[~server1, ~server2][s].do { |i, id| i.sendBundle(~cut2+~silenceTime+0.01, ["/c_set", 117-id, ~trackVol[id]]) };
			};

			// ~fadeTimeSynthFxView.valueAction_(~cut2*2);
			~nbOfServers.do { |s| ~fxDefaultAll2View[s].valueAction_(1) };
		})
	});

	~cut2View = NumberBox(~controlWindowTrig, Rect(137*~xSizeMul, 27*~ySizeMul, 36*~xSizeMul, 20*~ySizeMul))
	.action_({ |view| ~cut2 = view.value })
	.clipLo_(0.1).clipHi_(10).minDecimals_(0).maxDecimals_(1)
	.font_(Font("Verdana", 10*~fontSizeMul))
	.valueAction_(4);


	~trigCut3View = RoundButton(~controlWindowTrig, Rect(175*~xSizeMul, 27*~ySizeMul, 45*~xSizeMul, 20*~ySizeMul))
	.states_([["Cut 3", Color.white, Color.blue]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i|
		if (~trigCutPrevent == 0, {
			{ ("Try to Wait" + (~cut3+~silenceTime+0.1) ++ "s - end of Vol Cut").warn; ~trigCutPrevent = 1; (~cut3+~silenceTime+0.1).wait; "End of Vol Cut - OK to retrigger".inform; ~trigCutPrevent = 0; }.fork;

			~nbOfServers.do { |s| var groups = ~groups[s].select({ |i, index| index.even});
				groups.do { |i, ad| i.set("busVolume", 117-ad); ~volumeBus2[s][ad].line(0, ~cut3) };
				[~server1, ~server2][s].do { |i, id| i.sendBundle(~cut3+~silenceTime+0.01, ["/c_set", 117-id, ~trackVol[id]]) };
			};

			~nbOfServers.do { |s| ~fxDefaultAll2View[s].valueAction_(1) };
		});
	});

	~cut3View = NumberBox(~controlWindowTrig, Rect(222*~xSizeMul, 27*~ySizeMul, 36*~xSizeMul, 20*~ySizeMul))
	.action_({ |view| ~cut3 = view.value })
	.clipLo_(0.1).clipHi_(10).minDecimals_(0).maxDecimals_(1)
	.font_(Font("Verdana", 10*~fontSizeMul))
	.valueAction_(7);





	/*
	s.getQueryTree plus utilisé car action directe sur le groupe plus performante

	// for All the Tracks  to change the rate
	s.getQueryTree({ |data|
	~serverCollection = data;
	~synthsIDCollection = 8.collect { |t| ~serverCollection['children'][0]['children'][t]['children'].size.collect { |i| ~serverCollection['children'][0]['children'][t]['children'][i]['id'] } }.flatten;
	// ~synthsIDCollection = ~serverCollection['children'][0]['children'][~groupNumber]['children'].size.collect { |i| ~serverCollection['children'][0]['children'][~groupNumber]['children'][i]['id'] };
	~synthsIDCollection.size.do { |i| s.sendMsg("/n_set",~synthsIDCollection[i], "rate", 10) };
	});

	~serverCollection.cs;
	~serverCollection['children'][0].cs;
	~serverCollection['children'][0]['children'].cs
	~serverCollection['children'][0]['children'][~groupNumber].cs
	~serverCollection['children'][0]['children'][~groupNumber]['children'].cs
	~serverCollection['children'][0]['children'][~groupNumber]['children'].size.cs
	*/





	~trigBusRatView = RoundButton(~controlWindowTrig, Rect(5*~xSizeMul, 52*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul))
	.states_([["RAT B", Color.white, Color.red],["RAT B", Color.black, Color.green]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i| ~trigBusRat = i.value;
	})
	.valueAction_(0);

	~trigBusStrView = RoundButton(~controlWindowTrig, Rect(47*~xSizeMul, 52*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul))
	.states_([["STR B", Color.white, Color.red],["STR B", Color.black, Color.green]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i| ~trigBusStr = i.value;
	})
	.valueAction_(0);

	~trigBusCenView = RoundButton(~controlWindowTrig, Rect(89*~xSizeMul, 52*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul))
	.states_([["CEN B", Color.white, Color.red],["CEN B", Color.black, Color.green]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i| ~trigBusCen = i.value;
	})
	.valueAction_(0);

	~trigBusAmpView = RoundButton(~controlWindowTrig, Rect(131*~xSizeMul, 52*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul))
	.states_([["AMP B", Color.white, Color.red],["AMP B", Color.black, Color.green]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i| ~trigBusAmp = i.value;
	})
	.valueAction_(0);

	~trigBusAllView = RoundButton(~controlWindowTrig, Rect(173*~xSizeMul, 52*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul))
	.states_([["ALL RB", Color.white, Color.red],["ALL B", Color.black, Color.green]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i| ~trigBusRAll = i.value;
		~trigBusRatView.valueAction_(~trigBusRAll); ~trigBusStrView.valueAction_(~trigBusRAll); ~trigBusCenView.valueAction_(~trigBusRAll);
	})
	.valueAction_(0);

	/*~trigBusAllView = RoundButton(~controlWindowTrig, Rect(270, 94, 40, 20))
	.states_([["ALL B", Color.white, Color.red],["ALL B", Color.black, Color.green]])
	.font_(Font("Verdana", 9))
	.action_({|i| ~trigBusAll = i.value;
	~trigBusRatView.valueAction_(~trigBusAll); ~trigBusStrView.valueAction_(~trigBusAll); ~trigBusCenView.valueAction_(~trigBusAll); ~trigBusAmpView.valueAction_(~trigBusAll);
	})
	.valueAction_(0);*/















	// controlWindowDefault

	~retriggerPresetAllTracksView = RoundButton(~controlWindowDefault, Rect(67*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["Pre", Color.black, Color.yellow]])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({
		{ "WAIT RESETTING ALL PRESETS !".postln;
			/*~tracks*/ ((~tracksList*2) + ~seqCompGABIndex).do { |a| ~retriggerPresetPreViewG[a].valueAction_(1);
				0.05.wait }; "OK GO !".postln; }.fork(AppClock);
	});

	~triggerAllSeqsAllTracksView = RoundButton(~controlWindowDefault, Rect(228*~xSizeMul, 2*~ySizeMul, 35*~xSizeMul, 20*~ySizeMul))
	.states_([ ["1", Color.white, Color.blue], ["Sel", Color.white, Color.magenta], /*["Cur Pre", Color.black, Color.yellow]*/])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({ |i| ~triggerAllSeqsAllTracks = i.value;
		~tracks /*~playViewValue.indicesOfEqual(1)*/ .do { |a| ~triggerAllSeqsViewG[a].valueAction_(~triggerAllSeqsAllTracks) }
	}).value_(0);

	~retriggerSelAllTracksView = RoundButton(~controlWindowDefault, Rect(266*~xSizeMul, 2*~ySizeMul, 45*~xSizeMul, 20*~ySizeMul))
	.states_([["Sel Pl", Color.black, Color.new255(255, 165, 0) /*Color.white, Color.red*/]])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({ var p = ~playViewValue.indicesOfEqual(1);
		if (p.notNil, {
			{ "WAIT RESETTING PRESETS OF PLAYING TRACKS !".postln;
				/*~tracks*/ p.do { |a| ~retriggerPresetViewG[a].valueAction_(1);
					0.05.wait }; "OK GO !".postln; }.fork(AppClock);
		},{
			{ "WAIT RESETTING ALL PRESETS !".postln;
				/*~tracks*/ ((~tracksList*2) + ~seqCompGABIndex).do { |a| ~retriggerPresetPreViewG[a].valueAction_(1);
					0.05.wait }; "OK GO !".postln; }.fork(AppClock);
		});
	});


	// OK fait -> modifié le range de la spatialisation (0 à 5) pour ne pas prendre en compte Circ1 & Circ2 & l'ambisonique qui ne rendent pas la version stéréo
	~multiStereoView = RoundButton(~controlWindowDefault, Rect(98*~xSizeMul, 2*~ySizeMul, 46*~xSizeMul, 20*~ySizeMul))
	.states_([["Stereo", Color.white, Color.blue], ["Multi", Color.white, Color.green(0.4)] /*["Multi", Color.black, Color.yellow]*/])
	.font_(Font("Verdana",9*~fontSizeMul, bold: true))
	.action_({ |a| ~multiStereoA = a.value;
		~tracksList.do { |i| ~multiStereoControlView[i].valueAction_(~multiStereoA)};
		~multiStereoRyView.valueAction_(~multiStereoA);

		if (~multiStereoA == 0, { ~multiStereoRandRyRout2View.valueAction_(0) }); // Si stéréo Globale, remettre la stéréo par défaut devant

		/* if (~patFlag == 0, {
		~multiStereo[~tracksValue][~seqsValue] = i.value;
		}, {~seqs.do {|a|
		~multiStereo[~tracksValue][a] = i.value;
		}});*/

		// A optimiser ?????????????????????????????????????????????????????????????????????????????????????????????
		if (~lemurConnected1 == 1, { ~lemurAdress1.sendMsg( "/MultiStereoRandAllSwitch/x", ~multiStereoA); ~lemurAdress1.sendMsg( *["/ParC/SpaMenu/x", ~multiStereoA ]) });
		if (~lemurConnected2 == 1, { ~lemurAdress2.sendMsg( "/MultiStereoRandAllSwitch/x", ~multiStereoA); ~lemurAdress2.sendMsg( *["/ParC/SpaMenu/x", ~multiStereoA ]) });
		// if (a.value == 0,  { ~multiStereoRandRySwitchView.valueAction_(0) });

	});
	// ~multiStereoView.value_(0).doAction; // Erreur à cause des éléments comme ~multiStereoRyView ou ~multiStereoRandRyRout2View


	~outsConfigViewView = View(~controlWindowDefault, Rect(146*~xSizeMul, 2*~ySizeMul, 80*~xSizeMul, 20*~ySizeMul));

	~outsConfigView = PopUpMenu.new(~outsConfigViewView, Rect(0, 0, 110*~xSizeMul, 20*~ySizeMul))
	.action_({|menu|
		~tracksList.do { |i| ~outsConfigControlView[i].valueAction_(menu.value)};
	})
	.allowsReselection_(true)
	.background_(~popUpMenuBackgroundColor)
	.stringColor_(Color.black)
	.font_(Font("Verdana",9*~fontSizeMul));

	case

	{~numChannelsConfig == "2"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2- 1Tr",
			"3-4- 2Tr",
			"5-6- 3Tr",
			"7-8- 4Tr",
			"9-10- 5Tr",
			"11-12- 6Tr",
			"13-14- 7Tr",
			"15-16- 8Tr"
	])}}

	{~numChannelsConfig == "4"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"3-4-Rear",
			"1-4-Links",
			"2-3-Right",
			"1-3-Diag1",
			"2-4-Diag2"
	])}}

	{~numChannelsConfig == "5-Centre"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"4-5-Rear",
			"1-5-Links",
			"2-4-Right",
			"1-4-Diag1",
			"2-5-Diag2",
			"3-5-DiagC1",
			"3-4-DiagC2"
	])}}

	{~numChannelsConfig == "5-Clock"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"5-2-Front",
			"3-4-Rear",
			"5-4-Links",
			"2-3-Right",
			"5-3-Diag1",
			"2-4-Diag2",
			"1-4-DiagC1",
			"1-3-DiagC2"
	])}}

	{~numChannelsConfig == "7"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"7-2-Front",
			"6-3-LR",
			"5-4-Rear",
			"6-7-Links",
			"2-3-Right",
			"7-3-Diag",
			"2-6-Diag"
	])}}

	{~numChannelsConfig == "8-Centre"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"8-2-Front",
			"7-3-LR",
			"6-4-Rear",
			"8-6-Links",
			"1-5-FR",
			"2-4-Right",
			"8-4-Diag1",
			"2-6-Diag2"
	])}}

	{~numChannelsConfig == "8-PairClock"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"8-3-Mid1",
			"7-4-Mid2",
			"6-5-Rear",
			"8-7-LinksC",
			"1-6-LinksEx",
			"2-5-RightEx",
			"3-4-RightC",
			"1-4-Diag1",
			"2-7-Diag2"
	])}}

	{~numChannelsConfig == "8-PairPair"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"3-4-Mid1",
			"5-6-Mid2",
			"7-8-Rear",
			"1-7-LinksC",
			"3-5-LinksEx",
			"4-6-RightEx",
			"2-8-RightC",
			"1-8-Diag1",
			"2-7-Diag2"
	])}}

	// RESTE à Introduire la hauteur ?????????
	{~numChannelsConfig == "16-Dome-8-6-2-Pair"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"3-4-Mid1",
			"5-6-Mid2",
			"7-8-Rear",
			"1-7-LinksC",
			"3-5-LinksEx",
			"4-6-RightEx",
			"2-8-RightC",
			"1-8-Diag1",
			"2-7-Diag2",
			"15-16-Elev"
	])}}

	// RESTE à Introduire la hauteur ?????????
	{~numChannelsConfig == "16-Dome-8-6-2-Clock" or: {~numChannelsConfig == "16-Dome-8-6-2-Clock-CC"} or: {~numChannelsConfig == "16-UsineC-2Octo"} or: {~numChannelsConfig == "24-UsineC-3Octo"}} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"8-3-Mid1",
			"7-4-Mid2",
			"6-5-Rear",
			"8-7-LinksC",
			"1-6-LinksEx",
			"3-4-RightEx",
			"2-5-RightC",
			"1-5-Diag1",
			"2-6-Diag2",
			"15-16-Elev"
	])}}

	// Dome 32 - Positionnement juste sur la 1ère couronne - à refaire XXXXXXXXXXXX
	{~numChannelsConfig == "32-Dome-12-10-8-2"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"10-11-Links",
			"4-5-Right",
			"7-8-Rear",
			"12-6-Diag1",
			"3-9-Diag2",
			"31-32-Elev",
	])}}

	// Dome 32 - Positionnement juste sur la 1ère couronne - à refaire XXXXXXXXXXXX
	{~numChannelsConfig == "32-Dome-12-10-8-2-Motu"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"11-12-Front",
			"8-9-Links",
			"2-3-Right",
			"5-6-Rear",
			"10-4-Diag1",
			"1-7-Diag2",
			"23-24-Elev",
			"1-2-Ster"
	])}}

	// Dome 32 - Positionnement juste sur la 1ère couronne - à refaire XXXXXXXXXXXX
	{~numChannelsConfig == "32-Dome-UQAM-11-11-9-1"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"10-11-Links",
			"4-5-Right",
			"7-8-Rear",
			"12-6-Diag1",
			"3-9-Diag2",
			"31-32-Elev",
	])}}

	// RESTE à Introduire la hauteur ?????????
	{~numChannelsConfig == "22-8+Dome-8-4-2-Pair"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"3-4-Mid1",
			"5-6-Mid2",
			"7-8-Rear",
			"1-7-LinksC",
			"3-5-LinksEx",
			"4-6-RightEx",
			"2-8-RightC",
			"1-8-Diag1",
			"2-7-Diag2",
			"15-16-Elev"
	])}}

	// Couronne 64 - à refaire XXXXXXXXXXXX
	{~numChannelsConfig == "64-CentreClock"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"10-11-Links",
			"4-5-Right",
			"7-8-Rear",
			"12-6-Diag1",
			"3-9-Diag2",
			"31-32-Elev",
	])}}

	// Couronne 96 - à refaire XXXXXXXXXXXX
	{~numChannelsConfig == "96-CentreClock"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"10-11-Links",
			"4-5-Right",
			"7-8-Rear",
			"12-6-Diag1",
			"3-9-Diag2",
			"31-32-Elev",
	])}}

	// Couronne 128 - à refaire XXXXXXXXXXXX
	{~numChannelsConfig == "128-CentreClock"} {
		[~tracksList.collect {|tr| ~outsConfigControlView[tr]}, ~outsConfigView].flat.do {|i| i.items_([
			"1-2-Front",
			"10-11-Links",
			"4-5-Right",
			"7-8-Rear",
			"12-6-Diag1",
			"3-9-Diag2",
			"31-32-Elev",
	])}};

	~outsConfigView.valueAction_(0);

}.value;





























// KeyActions

{

	~keyControlView = RoundButton(~globalWindow, Rect(2*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
	.states_([["KeyN", Color.black, Color.green], ["KeyS", Color.white, Color.magenta], ["KeyR", Color.white, Color.red] /*, ["KeyR", Color.white, Color.grey]*/ ])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({|i| ~keyControl = i.value})
	.valueAction_(2);

	~speakerRangeView = RoundButton(~globalWindow, Rect(54*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
	.states_([ ["SpRange", Color.white, Color.red], ["SpRange", Color.black, Color.green] ])
	.font_(Font("Verdana",9*~fontSizeMul, bold: true))
	.action_({|i| ~speakerRange = i.value})
	.valueAction_(1);

	~fxServerSwitchView = RoundButton(~globalWindow, Rect(106*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
	.states_([["FX S 1", Color.white, Color.blue], ["FX S 2", Color.red, Color.yellow], ["FX ALL", Color.yellow, Color.red] /*, ["KeyR", Color.white, Color.grey]*/ ])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({|i| ~fxServerSwitch = i.value})
	.valueAction_(2);

	~controlBusSynthFunc = [
		{ |s| ~nbOfControlBus.do { |i| ~controlBusSynth[s][i].fadeTime_(0); } },
		// { |s| ~nbOfControlBus.do { |i| ~controlBusSynth[s][i].fadeTime_(0.001); } },
		{ |s| ~nbOfControlBus.do { |i| ~controlBusSynth[s][i].fadeTime_(0.01); } },
		{ |s| ~nbOfControlBus.do { |i| ~controlBusSynth[s][i].fadeTime_(1); } },
		{ |s| ~nbOfControlBus.do { |i| ~controlBusSynth[s][i].fadeTime_(3); } },
		{ |s| ~nbOfControlBus.do { |i| ~controlBusSynth[s][i].fadeTime_(6); } },
		{ |s| ~nbOfControlBus.do { |i| ~controlBusSynth[s][i].fadeTime_(10); } },
		{ |s| ~nbOfControlBus.do { |i| ~controlBusSynth[s][i].fadeTime_(15); } },
		{ |s| ~nbOfControlBus.do { |i| ~controlBusSynth[s][i].fadeTime_(30); } },
	];

	~controlBusSynth5FadeTime = 0;
	~controlBusSynth5FadeTimeView = RoundButton(/*~globalWindow*/~busControlComp, Rect(2*~xSizeMul, 22*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul) /*Rect(39, 2, 35, 18)*/)
	.states_([["0", Color.white, Color.blue], /*["low", Color.white, Color.blue],*/ ["0.01", Color.white, Color.blue], ["1", Color.black, Color.green], ["3", Color.black, Color.green], ["6", Color.black, Color.green], ["10", Color.black, Color.green], ["15", Color.black, Color.green], ["30", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({|i| ~controlBusSynth5FadeTime = i.value; ~nbOfServers.do { |s| ~controlBusSynthFunc[~controlBusSynth5FadeTime].value(s); } });

	~controlBusTypeArgView = RoundButton(/*~globalWindow*/~busControlComp, Rect(40*~xSizeMul, 2*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul) /*Rect(76, 2, 35, 18)*/)
	.states_([["Rat", Color.white, Color.blue], ["Str", Color.white, Color.red], ["Cen", Color.white, Color.red]])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({|i| ~controlBusTypeArgValue = i.value;
		case
		{~controlBusTypeArgValue == 0}
		{~controlBusTypeArg = \rater}
		{~controlBusTypeArgValue == 1}
		{~controlBusTypeArg = \stretcher}
		{~controlBusTypeArgValue == 2}
		{~controlBusTypeArg = \center}
	})
	.valueAction_(0).doAction; // Pour effectuer l'action lorsque l'état ne change pas

	~controlRandFuncViewView = View(~busControlComp, Rect(40*~xSizeMul, 22*~ySizeMul, 36*~xSizeMul, 18*~ySizeMul));

	~controlRandFuncView = PopUpMenu.new(/*~globalWindow*/~controlRandFuncViewView, Rect(0, 0, 70*~xSizeMul, 18*~ySizeMul) /*Rect(113, 2, 48, 18)*/)
	.action_({ |menu| ~controlRandFunc = menu./*item*/value.asInteger })
	.allowsReselection_(true)
	.background_(Color.red(0.7) /*Color.blue*/)
	.stringColor_(Color.yellow)
	.font_(Font("Verdana",10*~fontSizeMul, bold: true));
	~controlRandFuncView.items_(["1 R", "2 S", "3 P", "4 M"])
	.valueAction_(0).doAction;

	~controlBusTypeSignView = RoundButton(/*~globalWindow*/~busControlComp, Rect(80*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul) /*Rect(163, 2, 25, 18)*/)
	.states_([["+", Color.black, Color.green], ["-", Color.white, Color.red] /*, ["KeyR", Color.white, Color.grey]*/ ])
	.font_(Font("Verdana",12*~fontSizeMul, bold: true))
	.action_({|i| ~controlBusTypeSign = i.value})
	.valueAction_(0).doAction;

	// see View helpfile for more info on key down actions.
	// you could use the HID/LID classes
	// you need either a focused view that receives key actions, or you send back data from a KeyState ugen to the lang-side (SendReply / SendTrig)
	// Comment arrêter le code ci-dessous 1 fois lancé ??? -> en relancer un autre

	/*
	// for in the IDE:
	Document.globalKeyDownAction = { |...args| args.postln };

	// for inside sclang
	View.globalKeyDownAction = { |...args| args.postln };
	// L'utilisation d'une view spécifique est plus rapide que la classe View

	// this posts [document, character, modifiers, unicode/ascii, keycode] in post window
	Document.globalKeyDownAction = { |...args| args.postcs; };

	// or you can send them to a little view, and read there:
	e = EZText();
	Document.globalKeyDownAction = { |...args| e.value = args[[1, 3]]; };

	note that you can test for modifiers by:
	.isAlt
	.isCtrl
	*/

	/* Document.current ne marche plus
	Document.current.keyDownAction_({arg thisDoc, character, modifiers, unicode, keycode;
	[thisDoc, character, modifiers, unicode, keycode].postln;
	});

	~globalWindow = Window().front;
	~globalWindow.view.keyDownAction_({arg thisDoc, character, modifiers, unicode, keycode, key;
	[thisDoc, /*character,*/ modifiers, unicode, keycode, key].postln;
	character.postln
	});

	// AFFICHE le key de toutes les touches (et particulièrement des touches spéciales) lorsque character est mis en commentaire contrairement au code ci-dessus ??????
	// capslock ne marche que quand il est enclenché mais pas lorqu'il est désenclenché ??????
	~globalWindow = Window().front;
	~globalWindow.view.keyDownAction_({arg thisDoc, character, modifiers, unicode, keycode, key;
	[thisDoc, character, modifiers, unicode, keycode, key].postln;
	key.postln;
	modifiers.postln;
	// (modifiers.isCaps).postln // ne marche pas
	});

	// Pourquoi le code ci-dessous retourne un code ASCII pour ¨ -> -88.asAscii & % -> -93.asAscii alors que le code du dessus retourne un charactère différent ???
	~globalWindow = Window(\test, Rect(500, 50, 200, 150));
	u = UserView(w, w.view.bounds.insetBy(5, 5))
	.background_(Color(1, 0.7, 1))
	.keyDownAction_({ |view, char| char.postcs })
	.focus(true);
	~globalWindow.front;

	~globalWindow = Window().front;
	~globalWindow.view.mouseOverAction_({arg view, x, y;
	[view, x, y].postln; // ne marche pas ???
	});
	*/

	/*
	btw. you can do
	if(modifier.isFun)

	In Integer: // Apparemment plus à jour ???
	// support for modifiers keys
	isCaps { ^this & 65536 == 65536}
	isShift { ^this & 131072 == 131072 }
	isCtrl { ^this & 262144 == 262144 }
	isAlt { ^this & 524288 == 524288 }
	isCmd { ^this & 1048576 == 1048576 }
	isNumPad { ^this & 2097152 == 2097152 }
	isHelp { ^this & 4194304 == 4194304 }
	isFun { ^this & 8388608 == 8388608 }
	*/

	/*k = KeyState.kr(18, 0, 1);
	if (k>=1, {~tabbedView.focus(0)});*/

	/*
	( // exemple pour coloriser le TextView
	~tabCode.keyUpAction_({|view, chr, mod, uni, key|
	//[mod, uni, key].postln;
	if(mod.isFun, { //fn key
	switch(key,
	122, { //F1
	view.syntaxColorize;
	},
	120, { //F2
	view.string= view.string.insert(view.selectionStart, "()");
	},
	99, { //F3
	view.string= view.string.insert(view.selectionStart, "[]");
	},
	118, { //F4
	view.string= view.string.insert(view.selectionStart, "{}");
	}
	);
	});
	});
	// ~tabbedView.focus;
	);
	*/



	// CHECK de la différence entre uni & key
	// apparemment pas besoin de faire une distinction avec mod.isCaps car déjà pris en compte dans l'uni ? pas vraiment



	// ~currentControlBusSynthGUIContainer = Window("NdefGui");
	// ~currentControlBusSynthGUIContainer = Window("NdefGui").setTopLeftBounds( Rect(0, 160, 340, 120)).onClose_({~controlBusSynthGUIContainerCheck = 0; SkipJack.all.as(Array).do { |i| if (i.name == "_anon_", { i.stop /*i.name.postln*/}) } }).alwaysOnTop_(true).front.close;



	~printControlBusFunc = 1;

	~rySpeedDiviser = 12; // Mise en place d'un diviseur sur l'envoi des vitesses de lecture sur les pistes rythmiques
	~rySpeedMax = 6;



	~controlBusFunc = { |argType = \rater, rate = 1, bus = 5, server = 0|
		case
		{~trigAll == 0} // Track
		{
			~controlBusSynth[server][bus].source = { DC.kr(rate) }; // ~groups[~tracksValue].map(\rate, ~controlBus[5]);
			~groups[server][~tracksValue].map(argType /*~controlBusTypeArg*/ /*\rate*/, ~controlBus[server][bus]);
		}
		{~trigAll == 2}  // ALL
		{ var rateR; if (rate/~rySpeedDiviser > ~rySpeedMax, {rateR = 0.7.rand}, {rateR = 0});
			/*~controlBusSynth[server][bus].source = { DC.kr(rate) }; // ~groups[~tracksValue].map(\rate, ~controlBus[5]);
			// Amélioration en agissant directement sur tout le groupe et pas de requête sur le numéro du Node
			~groups[server].select({ |i, index| index.even}).do { |i| i.map(argType /*~controlBusTypeArg*/ /*\rate*/ /*"rate"*/, ~controlBus[server][bus]) };*/

			// Mise en place d'un diviseur sur l'envoi des vitesses de lecture sur les pistes rythmiques
			~controlBusSynth[server][bus].source = { DC.kr(rate) }; ~controlBusSynth[server][4].source = { DC.kr((rate/~rySpeedDiviser).min(~rySpeedMax)+rateR) };
			~groups[server].select({ |i, index| index.even}).do { |i|
				if ([0,2,4].includes(i), { i.map(argType, ~controlBus[server][bus]) },{ i.map(argType, ~controlBus[server][4]) });
			};
		}
		{~trigAll == 3} // Piste 1, 2 et 3
		{
			~controlBusSynth[server][bus].source = { DC.kr(rate) }; // ~groups[~tracksValue].map(\rate, ~controlBus[5]);
			[~groups[server][0], ~groups[server][2], ~groups[server][4] ].do { |i| i.map(argType /*~controlBusTypeArg*/ /*\rate*/ /*"rate"*/, ~controlBus[server][bus]) };
		}
		{~trigAll == 1} // Other
		{
			var list;
			~controlBusSynth[server][4].source = { DC.kr(rate) }; // ~groups[~tracksValue].map(\rate, ~controlBus[5]);
			list = ~groups[server].select({ |i, index| index.even}); list.remove(~groups[server][~tracksValue]); /*list.postln;*/
			list.do { |i| i.map(argType /*~controlBusTypeArg*/ /*\rate*/, ~controlBus[server][4/*bus*/]) }; // devrait être 4 aussi ??????????????????
		};
		if (server == 0 and: {~printControlBusFunc == 1}, { (/*"Server" + server + */ "Speed Range:" + rate.asString).postln });
	};




	// Action sur le groupe ou requête sur le Server pour obtenir les n° de synthés avec les paramètres

	// Envoi de vitesses de lecture aléatoires (valeurs) Sans Glissando aux synthés déjà lancés sur 1 ou toutes les pistes
	// Intérêt de pouvoir modifier Toutes les valeurs différemment, mais Désavantage sans transition ?
	// Action en 1er apparemment sur le dernier synthé lancé ? voire à utiliser .reverse ?

	~serverCollection = 0 ! 2;
	// ~serverCollection[1]

	~controlRandFixCollection = { | par = \rater, func = 0, val = 1.0, post = 1, serv = 0 |
		var col, server;
		if (serv == 0, { server = currentEnvironment[\server1] }, { server = currentEnvironment[\server2] } );
		if (~serverProtect == 0, { ~serverProtect = 1; // Vraiment nécessaire ???
			server.getQueryTree2({ |data| /*~serverCollection = nil;*/ ~serverCollection[serv] = data;
				// ~serverCollection.cs
				// s.getQueryTree2({ |data|  data.postcs });
				case
				{~trigAll == 0} // Track
				{
					var ch = 0; if (~numChannels /*>=*/ >= 32 or: {~numChannels <= 8} /*or: {~numChannels == 4}*/ /*and: {~serverFX == 0}*/, { ch = 1 }, { ch = 0 } ); // à cause de 1052 Local1InputLevels qui est la seulement avec le 32 hP ???

					// lié au serverMeter qui affiche les Inputs
					col = ~serverCollection[serv]['children'][ch]['children'][~nbOfTracks-1-((~tracksValue/2).asInteger)];
					// ~serverCollection[1]['children'][1]['children'][~nbOfTracks-1-((~tracksValue/2).asInteger)]; // Test

					// ~synthsIDCollection = col['children'].size.collect { |i| col['children'][i]['id'] }.flatten;
					if ((~tracksValue/2).asInteger > ~serverTrackSwitch, {
						~synthsIDCollectionR = col['children'].collect { |i| i['id'] }.flatten
					},{
						~synthsIDCollectionT = col['children'].collect { |i| i['id'] }.flatten
					});
					if ( func == 3, { ~synthsValCollection = col['children'].collect { |i| i['controls'][par] }.flatten } );
				}
				{~trigAll == 2}  // ALL
				{
					var ch = 0; if (~numChannels /*>=*/ >= 32 or: {~numChannels <= 8} /*or: {~numChannels == 4}*/ /*and: {~serverFX == 0}*/, { ch = 1 }, { ch = 0 } ); // à cause de 1052 Local1InputLevels qui est la seulement avec le 32 hP ???
					col = ~serverCollection[serv]['children'][ch]['children'];
					// ~synthsIDCollection = ~nbOfTracks.collect { |t| ~serverCollection['children'][0]['children'][t]['children'].size.collect { |i| ~serverCollection['children'][0]['children'][t]['children'][i]['id'] } }.flatten;
					// ~synthsIDCollection = ~nbOfTracks.collect { |t| col[t]['children'].size.collect { |i| col[t]['children'][i]['id'] } }.flatten;
					~synthsIDCollectionT = [5,6,7].collect { |t| col[t]['children'].collect { |i| i['id'] } }.flatten;
					~synthsIDCollectionR = [0,1,2,3,4].collect { |t| col[t]['children'].collect { |i| i['id'] } }.flatten;
					if ( func == 3, { ~synthsValCollection = ~nbOfTracks.collect { |t| col[t]['children'].collect { |i| i['controls'][par] } }.flatten } );
				}
				{~trigAll == 3} // Piste 1, 2 et 3
				{
					var ch = 0; if (~numChannels /*>=*/ >= 32 or: {~numChannels <=8} /*or: {~numChannels == 4}*/ /*and: {~serverFX == 0}*/, { ch = 1 }, { ch = 0 } ); // à cause de 1052 Local1InputLevels qui est la seulement avec le 32 hP ???
					col = ~serverCollection[serv]['children'][ch]['children'];
					// [5,6,7] -> à l'envers, cela correspond aux pistes 1,2 & 3
					// ~synthsIDCollection = [5,6,7].collect { |t| col[t]['children'].size.collect { |i| col[t]['children'][i]['id'] } }.flatten;
					~synthsIDCollectionT = [5,6,7].collect { |t| col[t]['children'].collect { |i| i['id'] } }.flatten;
					if ( func == 3, { ~synthsValCollection = [5,6,7].collect { |t| col[t]['children'].collect { |i| i['controls'][par] } }.flatten } );
				}
				{~trigAll == 1} // Other
				{
					var tracks, track;
					var ch = 0; if (~numChannels /*>=*/ >= 32 or: {~numChannels <= 8} /*or: {~numChannels == 4}*/ /*and: {~serverFX == 0}*/, { ch = 1 }, { ch = 0 } ); // à cause de 1052 Local1InputLevels qui est la seulement avec le 32 hP ???
					track = ~nbOfTracks-1-((~tracksValue/2).asInteger); tracks = (0..~nbOfTracks-1); tracks.remove(track);
					col = ~serverCollection[serv]['children'][ch]['children'];
					// ~synthsIDCollection = ~nbOfTracks.collect { |t| ~serverCollection['children'][0]['children'][t]['children'].size.collect { |i| ~serverCollection['children'][0]['children'][t]['children'][i]['id'] } }.flatten;
					// ~synthsIDCollection = tracks.collect { |t| col[t]['children'].size.collect { |i| col[t]['children'][i]['id'] } }.flatten; // ~synthsIDCollection.postln;
					~synthsIDCollectionT = tracks.collect { |t| if (t > ~serverTrackSwitch+2, { col[t]['children'].collect { |i| i['id'] } }) }.flatten; // ~synthsIDCollection.postln;
					~synthsIDCollectionR = tracks.collect { |t| if (t <= ~serverTrackSwitch+2, { col[t]['children'].collect { |i| i['id'] } }) }.flatten;
					if ( func == 3, { ~synthsValCollection = tracks.collect { |t| col[t]['children'].collect { |i| i['controls'][par] } }.flatten } );
				};
				if (~synthsIDCollectionT.size != 0, {
					case
					{ func == 0 } // Val détermine le range de la valeur aléatoire
					// { ~synthsIDCollection.size.do { |i| server.sendMsg("/n_set",~synthsIDCollection[i], par, {val.rand}.value ) } }
					{
						~synthsIDCollectionT.do { |i| server.sendMsg("/n_set", i, par, {val.rand}.value ) };
					}
					{ func == 1 } // Val détermine le multiplicateur de la série
					{ var a = Array.series(~synthsIDCollection.size, 1, val); ~synthsIDCollection.do { |i, id| server.sendMsg("/n_set", i, par, a[id] ) } } // Array.series(~synthsIDCollection.size, 1)
					{ func == 2 } // Val ne détermine rien - valeur du paramètre à assigner déjà donnée
					{ var a = Array.fill(~synthsIDCollection.size, Pxrand([0.25, 0.5, 1, 2, 3], inf).iter); ~synthsIDCollection.do { |i, id| server.sendMsg("/n_set", i, par, a[id] ) } } // Array.fill(~synthsIDCollection.size, Pxrand([0.5, 1, 2], inf).iter);
					{ func == 3 } // Val détermine le multiplicateur des valeurs déjà attribuées aux synthés
					{ ~synthsIDCollection.do { |i, id| server.sendMsg("/n_set", i, par, (~synthsValCollection[id] * val).min(1000000000.0).max(-1000000000.0) ) } }; // 1e+17.0 et -1e+15
					// .min(100000000000000000.0).max(-1000000000000000.0) // 1e+17.0 et -1e+15
					if (post == 1, { ("Server" + serv + " / Speed Range:" + val + "->" + ~synthsIDCollectionT).postln/*.sort*/;  } );
					if (func == 3, { ~synthsValCollection.postln/*.sort*/; } );
				});
				if (~synthsIDCollectionR.size != 0, {
					case
					{ func == 0 } // Val détermine le range de la valeur aléatoire
					// { ~synthsIDCollection.size.do { |i| server.sendMsg("/n_set",~synthsIDCollection[i], par, {val.rand}.value ) } }
					{
						~synthsIDCollectionR.do { |i, id| var rVal = {val.rand}.value; server.sendMsg("/n_set", i, par, (rVal/~rySpeedDiviser).min(~rySpeedMax) + /*0.7.rand*/ (if (rVal/~rySpeedDiviser > ~rySpeedMax, {0.7.rand}, {0} )) )};
					}
					{ func == 1 } // Val détermine le multiplicateur de la série
					{ var a = Array.series(~synthsIDCollection.size, 1, val); ~synthsIDCollection.do { |i, id| server.sendMsg("/n_set", i, par, a[id] ) } } // Array.series(~synthsIDCollection.size, 1)
					{ func == 2 } // Val ne détermine rien - valeur du paramètre à assigner déjà donnée
					{ var a = Array.fill(~synthsIDCollection.size, Pxrand([0.25, 0.5, 1, 2, 3], inf).iter); ~synthsIDCollection.do { |i, id| server.sendMsg("/n_set", i, par, a[id] ) } } // Array.fill(~synthsIDCollection.size, Pxrand([0.5, 1, 2], inf).iter);
					{ func == 3 } // Val détermine le multiplicateur des valeurs déjà attribuées aux synthés
					{ ~synthsIDCollection.do { |i, id| server.sendMsg("/n_set", i, par, (~synthsValCollection[id] * val).min(1000000000.0).max(-1000000000.0) ) } }; // 1e+17.0 et -1e+15
					// .min(100000000000000000.0).max(-1000000000000000.0) // 1e+17.0 et -1e+15
					if (post == 1, { ("Server" + serv + " / Speed Range:" + val + "->" + ~synthsIDCollectionR).postln/*.sort*/;  } );
					if (func == 3, { ~synthsValCollection.postln/*.sort*/; } );
				});
			});
		},{
			"getQueryTree still in action".postln;
		});
		~serverProtect = 0;
	};

	// ~controlRandFixCollection.(par: \rater, func: 0, val: 100, post: 1, serv: 1);
	// ~controlRandFixCollection.(par: \amp, func: 0, val: 2.0, post: 1);



	// Envoi de 6 vitesses de lecture aléatoires (bus) Avec ou Sans Glissando aux synthés déjà lancés sur 1 ou toutes les pistes
	// Désavantage de pouvoir modifier Seulement 6 valeurs différemment, mais Intérêt avec transition ?
	~controlRandLineCollection = { | par = \rater, func = 0, val = 1.0, post = 1, serv = 0, pat = #[0.5, 1, 2] |
		var col, collectSize, server, ch;
		if (serv == 0, { server = currentEnvironment[\server1] }, { server = currentEnvironment[\server2] } );
		if (~serverProtect == 0, { ~serverProtect = 1; // Vraiment nécessaire ???

			server.getQueryTree2({ |data| ~serverCollection[serv] = data;

				if (~numChannels /*>=*/ >= 32 or: {~numChannels <= 8} /*or: {~numChannels == 4}*/ /*and: {~serverFX == 0}*/, { ch = 1 }, { ch = 0 } ); // à cause de 1052 Local1InputLevels qui est la seulement avec le 32 hP ???

				col = ~serverCollection[serv]['children'][ch]['children'];

				case
				{~trigAll == 0} // Track
				{
					col = col[~nbOfTracks-1-((~tracksValue/2).asInteger)];
					// ~synthsIDCollection = col['children'].size.collect { |i| col['children'][i]['id'] }.flatten;
					if ((~tracksValue/2).asInteger > ~serverTrackSwitch, {
						~synthsIDCollectionR = col['children'].collect { |i| i['id'] }.flatten
					},{
						~synthsIDCollectionT = col['children'].collect { |i| i['id'] }.flatten
					});
				}
				{~trigAll == 2}  // ALL
				{
					// ~serverCollection[0]['children'][0]['children'].cs;
					// ~serverCollection[0]['children'][1]['children'].cs;
					// ~serverCollection[0]['children'][1]['children'][0]['children'].size
					// ~synthsIDCollection = ~nbOfTracks.collect { |t| ~serverCollection[0]['children'][1]['children'][t]['children'].size.collect { |i| ~serverCollection[0]['children'][1]['children'][t]['children'][i]['id'] } }.flatten;
					// ~synthsIDCollection = ~nbOfTracks.collect { |t| col[t]['children'].size.collect { |i| col[t]['children'][i]['id'] } }.flatten;
					~synthsIDCollectionT = [5,6,7].collect { |t| col[t]['children'].collect { |i| i['id'] } }.flatten;
					~synthsIDCollectionR = [0,1,2,3,4].collect { |t| col[t]['children'].collect { |i| i['id'] } }.flatten;
				}
				{~trigAll == 3} // Piste 1, 2 et 3
				{
					// [5,6,7] -> à l'envers, cela correspond aux pistes 1,2 & 3
					// ~synthsIDCollection = [5,6,7].collect { |t| col[t]['children'].size.collect { |i| col[t]['children'][i]['id'] } }.flatten;
					~synthsIDCollectionT = [5,6,7].collect { |t| col[t]['children'].collect { |i| i['id'] } }.flatten;
					~synthsIDCollectionR = [ ];
				}
				{~trigAll == 1} // Other
				{
					var tracks, track;
					track = ~nbOfTracks-1-((~tracksValue/2).asInteger); tracks = (0..~nbOfTracks-1); tracks.remove(track);
					// ~synthsIDCollection = ~nbOfTracks.collect { |t| ~serverCollection['children'][0]['children'][t]['children'].size.collect { |i| ~serverCollection['children'][0]['children'][t]['children'][i]['id'] } }.flatten;
					// ~synthsIDCollection = tracks.collect { |t| col[t]['children'].size.collect { |i| col[t]['children'][i]['id'] } }.flatten;
					~synthsIDCollectionT = tracks.collect { |t| if (t > ~serverTrackSwitch+2, { col[t]['children'].collect { |i| i['id'] } }) }.flatten; // ~synthsIDCollection.postln;
					~synthsIDCollectionR = tracks.collect { |t| if (t <= ~serverTrackSwitch+2, { col[t]['children'].collect { |i| i['id'] } }) }.flatten;
				};
				/*if (~synthsIDCollection.size != 0, {
				// if (~trigAll == 1, { bus = 4 }, { bus = 5 } ); // à quoi cela sert ??? ne renvoie vers rien ...
				collectSize = ~nbOfControlBus.min(~synthsIDCollection.size);
				// ~synthsIDCollection = ~synthsIDCollection.clumps( collectSize.partition(6, (collectSize/6).floor).postln; );
				~synthsIDCollectionC = ~synthsIDCollection.clumps( ~synthsIDCollection.size.partition(collectSize, (~synthsIDCollection.size/collectSize).floor); );
				collectSize.do { |i|
				case
				{ func == 0 } // Val détermine le range de la valeur aléatoire
				{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( {val.rand}.value ) }	}
				{ func == 1 } // Val détermine le multiplicateur de la série
				{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( Array.series(collectSize, 1, val)[i] ) } } // Array.series(~synthsIDCollection.size, 1)
				{ func > 1 } // Val ne détermine rien
				{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( Array.fill(collectSize, Pxrand([0.5, 1, 2], inf).iter)[i] ) } }; // Array.fill(~synthsIDCollection.size, Pxrand([0.5, 1, 2], inf).iter);
				~synthsIDCollectionC[i].do { |a| server.sendMsg( "/n_map", a, par, ~controlBus[serv][~nbOfControlBus-1-i].index ) };
				};
				if (post == 1, { ("Server" + serv + " / Speed Range:" + val + "->" + ~synthsIDCollectionC).postln/*.sort*/; } );
				});*/

				if (~synthsIDCollectionT.size != 0, {
					collectSize = ~nbOfControlBus.min(~synthsIDCollectionT.size);
					~synthsIDCollectionCT = ~synthsIDCollectionT.clumps( ~synthsIDCollectionT.size.partition(collectSize, (~synthsIDCollectionT.size/collectSize).floor); );
					collectSize.do { |i|
						case
						{ func == 0 } // Val détermine le range de la valeur aléatoire
						{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( {val.rand}.value ) }	}
						{ func == 1 } // Val détermine le multiplicateur de la série
						{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( Array.series(collectSize, 1, val)[i] ) } } // Array.series(~synthsIDCollection.size, 1)
						{ func > 1 } // Val ne détermine rien
						{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( Array.fill(collectSize, Pxrand(pat, inf).iter)[i] ) } }; // Array.fill(~synthsIDCollection.size, Pxrand([0.5, 1, 2], inf).iter);
						~synthsIDCollectionCT[i].do { |a| server.sendMsg( "/n_map", a, par, ~controlBus[serv][~nbOfControlBus-1-i].index ) };
					};
					if (post == 1, { ("Server" + serv + " / Speed Range:" + val + "->" + ~synthsIDCollectionCT).postln/*.sort*/; } );
				});
				if (~synthsIDCollectionR.size != 0, {
					collectSize = ~nbOfControlBus.min(~synthsIDCollectionR.size);
					~synthsIDCollectionCR = ~synthsIDCollectionR.clumps( ~synthsIDCollectionR.size.partition(collectSize, (~synthsIDCollectionR.size/collectSize).floor); );
					collectSize.do { |i|
						var rateR,  rVal = {val.rand}.value;
						if (rVal/~rySpeedDiviser > ~rySpeedMax, {rateR = 0.7.rand}, {rateR = 0});
						case
						{ func == 0 } // Val détermine le range de la valeur aléatoire
						{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( (rVal/~rySpeedDiviser).min(~rySpeedMax) /*+ /*0.7.rand*/ rateR*/ ) }	}
						{ func == 1 } // Val détermine le multiplicateur de la série
						{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( Array.series(collectSize, 1, val)[i] ) } } // Array.series(~synthsIDCollection.size, 1)
						{ func == 2 } // Val ne détermine rien
						{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( Array.fill(collectSize, Pxrand(pat, inf).iter)[i] ) } } // Array.fill(~synthsIDCollection.size, Pxrand([0.5, 1, 2], inf).iter);
						{ func > 2 } // Val ne détermine rien
						{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( Array.fill(collectSize, Pseq(pat, inf).iter)[i] ) } };
						~synthsIDCollectionCR[i].do { |a| server.sendMsg( "/n_map", a, par, ~controlBus[serv][~nbOfControlBus-1-i].index ) }; // ~synthsIDCollectionCR.postln;
					};
					if (post == 1, { ("Server" + serv + " / Speed Range:" + val + "->" + ~synthsIDCollectionCR).postln/*.sort*/; } );
				});

			})
		},{
			"getQueryTree still in action".postln;
		});
		~serverProtect = 0;
	};

	// ~controlRandLineCollection.(par: \rater, func: 0, val: 100, post: 1, serv: 0);
	// ~controlRandLineCollection.(par: \amp, func: 0, val: 2.0, post: 1);

	/*
	~array = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.3];
	~array = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2];
	~array = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2];
	~array = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2];
	~array.size.partition(6, (~array.size/6).floor)
	*/





	~lastTrigEvent = {0 ! 1} ! 1 /* ! ~nbOfTracks */;

	// Initialisation des données nécessaires pour les shortcuts de changement de dossier son de la séquence
	// ~kindOfFoldersStructure.indicesOfEqual("AR")
	if (~foldersStructure == 1, {
		~folderStructureValues = (~kindOfFolders ++ ["All"]).collect { |i| ~kindOfFoldersStructure.indicesOfEqual(i) };
		~kindOfFoldersSymbol = (~kindOfFolders ++ ["All"]).collect { |i| i.asSymbol };

		if (~folderStructureValues.size > 7, {
			~folderStructureAValues = ~folderStructureValues[0]++ ~folderStructureValues[1];
			~folderStructureDValues = ~folderStructureValues[2]++ ~folderStructureValues[3];
			~folderStructureIValues = ~folderStructureValues[4]++ ~folderStructureValues[5];
			~folderStructureRValues = ~folderStructureValues[6]++ ~folderStructureValues[7];
		});
	});





	// Mémoire pour les Preset Selection

	/*~presetsSelEventSource = EventSource();
	~presetsSelListMemoryNb = 20;
	~positionInPresetSel = ~presetsSelListMemoryNb-1;
	~eventSourceSelFomula = (~presetsSelListMemoryNb-1).collect{|i| "state[" ++ (i+1) ++ "]"};
	~eventSourceSelFomula = "{ |state,v|" + ~eventSourceSelFomula.asString[0..~eventSourceSelFomula.asString.size-3] + ",v] }";
	~presetsSelEventInjection = ~presetsSelEventSource.inject(0!~presetsSelListMemoryNb, ~eventSourceSelFomula.interpret );
	// You can assign a key to the function:
	~presetsSelEventInjection.doDef(\action1, { |v| ~presetsSelCollection = v/*.postln*/ });*/ // juste pour l'affichage
	// ~presetsEventSource.fire(~presetSelectionView.item.asSymbol);

	~memoryNbOfTracks = 3;
	~presetsSelListMemoryNb = 30;
	~eventSourceSelFomula = (~presetsSelListMemoryNb-1).collect{|i| "state[" ++ (i+1) ++ "]"};
	~eventSourceSelFomula = "{ |state,v|" + ~eventSourceSelFomula.asString[0..~eventSourceSelFomula.asString.size-2] + ",v] }";

	~presetsSelEventSource = EventSource() ! ~memoryNbOfTracks;
	~presetsSelEventInjection = 0 ! ~memoryNbOfTracks;
	~presetsSelCollection = 0 ! ~memoryNbOfTracks;
	~positionInPresetSel = (~presetsSelListMemoryNb-1) !  ~memoryNbOfTracks;

	~memoryNbOfTracks.do { |i|
		~presetsSelEventInjection[i] = ~presetsSelEventSource[i].inject(0!~presetsSelListMemoryNb, ~eventSourceSelFomula.interpret );
		// You can assign a key to the function:
		~presetsSelEventInjection[i].doDef(\action1, { |v| ~presetsSelCollection[i] = v/*.postln*/ });
	};





	(
		// Le clavier francais numérique doit être sélectionné

		~keyActions = ({ |view, char, mod, uni, key, key2|

			// [char, uni, key, key2, mod].postln; // Parfois le char de certaines touches empêche l'affichage ?
			// [uni, key, key2, mod].postln;

			// if(mod.isCaps, { "ok".postln;}); // ne marche pas ???

			// if (mod == 16777252, { "1".postln; /*~disableFocusPopUpMenu.(false); ~disableFocusPopUpMenu.(true);*/ });

			/*
			if (mod == 524288, {
			case
			{ ~test == 1}
			{ ~test = 0 }
			{ ~test == 0}
			{ ~test = 1 };
			});
			*/





			/*
			unicode (key2) avec shift -> 16777248
			unicode (key2) avec control -> 16777250
			unicode (key2) avec alt -> 16777251
			unicode (key2) avec cmd -> 16777249

			1 mod :
			mod avec shift -> 131072
			mod avec control -> 262144
			mod avec alt -> 524288
			mod avec cmd -> 1048576

			2 mod :
			mod avec shift + control -> 393216
			mod avec shift + alt -> 655360
			mod avec shift + cmd -> 1179648

			mod avec control + alt -> 786432
			mod avec control + cmd -> 1310720

			mod avec cmd + alt -> 1572864

			Possibilité de coupler 3 ou plusieurs mod -> mais pas vraiment utilisable car obligé de passer par 2 mod au préalable et donc d'influencer d'autres actions
			*/

			// Possibilité d'utiliser les unicodes sur les fonctions

			switch(uni,

				// Utilisation du modifier pour protection si le modifier MAJ est désactivé malencontreusement
				// Si le modifier MAJ n'est pas activé, rien n'est déclenché, hormis pour le Alt

				// @#
				35, { //@# -> Control Key / Pour déclencher 2 types de keyDownAction / 2 types de clavier
					// Changement pour le temps d'interpolation des bus de contrôle
					if (mod == 0, {
						// if (~keyControl == 0, {~keyControlView.valueAction_(2) }, {~keyControlView.valueAction_(0) });
						if (~controlBusSynth5FadeTime == 7, {~controlBusSynth5FadeTimeView.valueAction_(0)}, {~controlBusSynth5FadeTimeView.valueAction_(7)} );
					});
					// if (~keyControl == 2, {~keyControlView.valueAction_(0) }, {~keyControlView.valueAction_(~keyControl+1) });
				},
				64, { // #@ + shift -> Changement  du paramètre ~controlBusTypeArgValue (Rat / Str / Cen)
					if (mod == 131072 and: {~keyBoardPerfProtect == 0}, {
						if (~controlBusSynth5FadeTime == 7, {~controlBusSynth5FadeTimeView.valueAction_(0) }, {~controlBusSynth5FadeTimeView.valueAction_(~controlBusSynth5FadeTime + 1)});
						// ~controlBusTypeArgView.valueAction_( (~controlBusTypeArgValue +1).wrap(0,2) )
					});
				},
				8226, { // #@ + alt -> Changement de type de la fonction de la vitesse de lecture (Rand / Ser / Par / Mul...)
					// if (mod == 524288, {
					~controlRandFuncView.valueAction_( (~controlRandFunc +1).wrap(0,3) )
					// });
				},

				// TRACKS
				63743 /*$1*/, { if (~tracksValue == 0, {~tracksView.valueAction_(1)}, {~tracksView.valueAction_(0)}); /*~tabbedView.focus(0)*/ }, // 1
				// if (~tracksValue != 0, {~tabbedView.focus(0)} ); // voire si n'augmente pas le CPU ??? Apparemment non si l'on est déjà dans la tab en question
				235 /*$2*/, { if (~tracksValue == 2, {~tracksView.valueAction_(3)}, {~tracksView.valueAction_(2)}); /*~tabbedView.focus(0)*/ }, // 2
				8220 /*$3*/, { if (~tracksValue == 4, {~tracksView.valueAction_(5)}, {~tracksView.valueAction_(4)}); /*~tabbedView.focus(0)*/ }, // 3
				8216 /*$4*/, { if (~tracksValue == 6, {~tracksView.valueAction_(7)}, {~tracksView.valueAction_(6)}); /*~tabbedView.focus(0)*/ }, // 4
				123 /*$5*/, { if (~tracksValue == 8, {~tracksView.valueAction_(9)}, {~tracksView.valueAction_(8)}); /*~tabbedView.focus(0)*/ }, // 5
				182 /*$6*/, { if (~tracksValue == 10, {~tracksView.valueAction_(11)}, {~tracksView.valueAction_(10)}); /*~tabbedView.focus(0)*/ }, // 6
				171 /*$7*/, { if (~tracksValue == 12, {~tracksView.valueAction_(13)}, {~tracksView.valueAction_(12)}); /*~tabbedView.focus(0)*/ }, // 7
				161 /*$8*/, { if (~tracksValue == 14, {~tracksView.valueAction_(15)}, {~tracksView.valueAction_(14)}); /*~tabbedView.focus(0)*/ }, // 8

				// <>
				/*62, { // <> -> Changement du fadeTime des Bus pour avancer dans les temps de défilement
				if (mod == 0, {
				if (~controlBusSynth5FadeTime == 8, {~controlBusSynth5FadeTimeView.valueAction_(0) }, {~controlBusSynth5FadeTimeView.valueAction_(~controlBusSynth5FadeTime + 1)});
				});
				},
				60, { // <> + shift  -> revenir à un temps de fadeTime de 0
				if (mod == 131072, {
				~controlBusSynth5FadeTimeView.valueAction_(0);
				});
				},
				8804, { // <> + alt -> Changement du fadeTime des Bus avec <> pour revenir en arrière dans les temps de défilement
				// if (mod == 524288, {
				// if (~controlBusSynth5FadeTime == 0, {~controlBusSynth5FadeTimeView.valueAction_(8) }, {~controlBusSynth5FadeTimeView.valueAction_(~controlBusSynth5FadeTime - 1)});
				~controlBusSynth5FadeTimeView.valueAction_(8);
				// });
				},*/

				// Backspace -> Divers changments de Tab selon mod
				127, {
					case
					{mod == 0} // Backspace -> pour alterner entre le Tab séquence et le Tab global
					{
						if (~currentTab == 0, {~tabbedView.focus(1)}, {~tabbedView.focus(0)})
					}
					{mod == 131072} // Backspace + shift -> Changement de scroll dans le Tab FX
					{
						if (~currentTab != 1 and: {~currentTab != 2}, {
							~tabbedView.focus(2);
							~tabFx[0].view.visibleOrigin = Point( 0, 0 );
							~tabFx[1].view.visibleOrigin = Point( 0, 0 );
						},{
							if (~currentTab == 2, {
								~tabbedView.focus(2);
								~tabFx[0].view.visibleOrigin = Point( 0, 0 );
								~tabFx[1].view.visibleOrigin = Point( 0, 0 );
							},{
								if (~currentTab == 1 and: {~tabFx[~currentServerTab].view.visibleOrigin == Point( 0, 485 ) }, {
									~tabbedView.focus(3);
								});
								if (~currentTab == 1 and: {~tabFx[~currentServerTab].view.visibleOrigin == Point( 0, 0 ) }, {
									~tabFx[0].view.visibleOrigin = Point( 0, 485 );
									~tabFx[1].view.visibleOrigin = Point( 0, 485 );
								});
							});
						});
						/*if (~currentTab != 1, {
						~tabbedView.focus(2); ~tabFx[0].view.visibleOrigin = Point( 0, 0 )
						},{
						if (~tabFx[0].view.visibleOrigin == Point( 0, 0 ), {
						~tabFx[0].view.visibleOrigin = Point( 0, 485 )
						},{
						~tabFx[0].view.visibleOrigin = Point( 0, 0 )
						})
						});*/
						/*case // Changement des Tab FX et de spatialisation avec différentes vues sur le Scroll
						{~currentTab != 1 and: {~currentTab != 2} /*and: {~tabFx.view.visibleOrigin == Point( 0, 475 )}*/ }
						{ ~tabbedView.focus(2); ~tabFx.view.visibleOrigin = Point( 0, 0 ) }
						{~currentTab == 1 and: {~tabFx.view.visibleOrigin != Point( 0, 475 )} }
						{ ~tabbedView.focus(2); ~tabFx.view.visibleOrigin = Point( 0, 475 ) }
						{~currentTab == 1}
						{~tabbedView.focus(3); }
						{~currentTab == 2}
						{~tabbedView.focus(4); }*/
					}
					{mod == 524288} // Backspace + Alt -> Changement des Tab FX EQ et de spatialisation
					{
						~tabFx[0].view.visibleOrigin = Point( 0, 0 );
						~tabFx[1].view.visibleOrigin = Point( 0, 0 );
						if (~currentServerTab == 0, {
							~tabbedFX.focus(1); ~tabbedEQ.focus(1); ~tabbedAMB.focus(1); ~fxTabbedView.focus(1);
						},{
							~tabbedFX.focus(0); ~tabbedEQ.focus(0); ~tabbedAMB.focus(0); ~fxTabbedView.focus(0);
						});
						// if ( ~currentTab != 2, { ~tabbedView.focus(3) }, { ~tabbedView.focus(4) });
					}
				},

				// Zoom -> ne marche pas ???
				// if (mod == 131072 and: {char == $Z}, {if (~zoomMultiSliderView.value == 0, {~zoomMultiSliderView.valueAction_(0)}, {~zoomMultiSliderView.valueAction_(1)}) } );

				// Changement de Tab + ou - avec -> += pour faire avancer les tabs ou shift & += pour les faire défiler à l'envers
				/*if (mod != 131072 and: {key == 44}, {
				~curTabKey = ~currentTab; ~newTabKey = ~curTabKey + 1;
				if (~newTabKey > (~tabbedView.tabViews.size -1), { ~tabbedView.focus(0) }, { ~tabbedView.focus(~newTabKey) } ) });
				if (mod == 131072 and: {key == 44}, {
				// ~tabbedView.focus(3); // Pourquoi la visualisation du Tab global prend du temps à s'afficher alors que l'évaluation de focus(3) s'affiche immédiatement
				~curTabKey = ~currentTab; ~newTabKey = ~curTabKey - 1;
				if (~newTabKey < 0, { ~tabbedView.focus(~tabbedView.tabViews.size -1) }, { ~tabbedView.focus(~newTabKey) } ) });*/

				// -_
				95, { // -_ - ->Alternance des modules L & R ou Alternance entre les séquences A & B dans le tab Global
					// if (~outCompChoose[~tracksValue][~seqsValue] == 0, {~outCompChooseView.valueAction_(1)}, {~outCompChooseView.valueAction_(0)} );
					if (mod == 0, {
						case
						{~currentTab == 0}
						{ if (~outCompChoose/*[~tracksValue][~seqsValue]*/ == 0, {~outCompChooseView.valueAction_(1)}, {~outCompChooseView.valueAction_(0)} ) }
						{~currentTab == 3}
						{ if (~seqABVisibleAllViewG.value == 0, {~seqABVisibleAllViewG.valueAction_(1)}, {~seqABVisibleAllViewG.valueAction_(0)} ) };
					});
				},

				// )°
				176, { // )° -> Affichage des modules supplémentaires RAT / STR / CEN ou Affichage des séquences lues dans le tab Global // ° - � correspond à 176.asAscii
					if (mod == 0, {
						case
						{~currentTab == 0}
						{if (~ratCompAllChoose/*[~tracksValue][~seqsValue]*/ == 0, {~ratCompAllChooseView.valueAction_(1); ~transCompView.valueAction_(1)}, {~ratCompAllChooseView.valueAction_(0); ~transCompView.valueAction_(1)}) }
						{~currentTab == 3}
						{if (~seqPlayingVisibleAllViewG.value == 0, {~seqPlayingVisibleAllViewG.valueAction_(1)}, {~seqPlayingVisibleAllViewG.valueAction_(0)})};
					});
				},
				125, { // )° + alt -> ~visuelLocView.valueAction_(1);
					// if (mod == 524288, {
					~ratCompAllChooseView.valueAction_(0); // Switch vers la vue par défaut RAT / STR / CEN
					if (~transComp[~tracksValue][~seqsValue] == 0, {~transCompView.valueAction_(1)}, {~transCompView.valueAction_(0)}); // Mise en transparence des seconds modules
					// });
				},

				// 0à
				48, { // 0à -> Suivi des séquences ou non pour aller sur d'autres séquences de la piste en train de jouer & Sélectionne la séquence jouée en cours
					// if (~visuelTab == 1, {~visuelTabView.valueAction_(0); ~visuelLocView.valueAction_(1)}, {~visuelTabView.valueAction_(1)} ) },
					// if (~tracksValue.even, {~tracksView.valueAction_(~tracksValue + 1)}, {~tracksView.valueAction_(~tracksValue - 1)} ); // A / B
					// Changement de tab entre Chorus / Spatialisation & Envellope au lieu du changement de Visuel Tab
					if (mod == 0, {
						~envParTabView.valueAction_((~envParTab+1).wrap(0, 7))
					});
					/*case
					{~envParTab == 0}
					{ ~envParTabView.valueAction_(1) }
					{~envParTab == 1}
					{ ~envParTabView.valueAction_(2) }
					{~envParTab == 2}
					{ ~envParTabView.valueAction_(3) }
					{~envParTab == 3}
					{ ~envParTabView.valueAction_(4) }
					{~envParTab == 4}
					{ ~envParTabView.valueAction_(5) }
					{~envParTab == 5}
					{ ~envParTabView.valueAction_(6) }
					{~envParTab == 6}
					{ ~envParTabView.valueAction_(7) }
					{~envParTab == 7}
					{ ~envParTabView.valueAction_(0) };*/
				},
				248, { // 0à + alt -> Changement vers le module de spatialisation
					// if (mod == 524288, {
					~envParTabView.valueAction_(2);
					// });
				},

				// ù%
				37, { // ù% -> Action directement sur le bouton et non la fonction BUFFER RANDOM
					if (mod == 0, {
						/*~buffer.value([~tracksValue][~seqsValue]);*/ ~bufRandView.valueAction_(1);
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					});
				},
				8240, { // ù% + alt + shift -> Action directement sur le bouton et non la fonction OUTS
					if (mod == 655360, {
						~randFxView.valueAction_(1);
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					});
				},

				// P
				80, { // P -> Retrigger current Preset
					if (mod == 0, {
						// mod.postln;
						// { mod == 524288 /*655360*/ } // alt + shift + P fait cracher le server donc utilisation de alt + P
						~retriggerPresetViewG[~tracksValue].valueAction_(1);
					});
				},

				// M
				/*13 /*77*/, { // M + control + alt  -> Preset aléatoire -> MIS PLUS BAS AVEC KEY2
				if (mod == /*0*/ 1835008, {
				~presetSelectionView.valueAction_(~presetList.find([~presetListAcType[~presetRandomTypeValue].choose])); // Random selon le type de presets
				});
				},*/
				77, { // M  Preset aléatoire dans la présélection très définie d'une famille small
					if (mod == 0 and: { ~sequenceSection == 1} and: {~tracksPresetColorModel1.includes(~tracksValue)},
						{~tracksChooseSmallFamilyFunction.(~tracksValue) }
					);
				},
				109, { // M + alt -> Preset aléatoire dans la présélection si disponible
					if (mod == 524288, { var rand; if (~presetSeqRandList[~tracksValue].size == 0, { }, { rand = ~presetSeqRandList[~tracksValue] } );
						if (rand.notNil, {
							rand = rand.choose;
							if (~currentTab == 0, {
								~presetSeqRangeView.valueAction_(~presetSeqRangeSpec.unmap([ rand, rand ]));
								~seqComp5.visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-4)*20*~ySizeMul).max(0).min(~seqComp5MaxVisibleOrigin)
							},{
								~presetSeqRangeViewG[~tracksValue].valueAction_(~presetSeqRangeSpec.unmap([ rand, rand ]));
								~seqCompG1[~tracksValue].visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin)
							});
						},{
							"No Preset in this Track".postln;
						});
					});
				},
				/*109, { // M + shift -> Changement vers la piste B avec un preset aléatoire et Xfade
				if (mod == 131072 and: { ~sequenceSection == 1},
				{ var p;
				case
				{~sectionPB.includes(~presetSeqStart[~tracksValue])} {p = ~sectionPB.choose+1}
				{~sectionPBD.includes(~presetSeqStart[~tracksValue])} {p = ~sectionPBD.choose+1}
				{~sectionPBN.includes(~presetSeqStart[~tracksValue])} {p = ~sectionPBN.choose+1}
				{~sectionPL.includes(~presetSeqStart[~tracksValue])} {p = ~sectionPL.choose+1}
				{~sectionPLD.includes(~presetSeqStart[~tracksValue])} {p = ~sectionPLD.choose+1}
				{~sectionPLN.includes(~presetSeqStart[~tracksValue])} {p = ~sectionPLN.choose+1}
				{~sectionTNM.includes(~presetSeqStart[~tracksValue])} {p = ~sectionTNM.choose+1}
				{~sectionTE.includes(~presetSeqStart[~tracksValue])} {p = ~sectionTE.choose+1}
				{~sectionTF.includes(~presetSeqStart[~tracksValue])} {p = ~sectionTF.choose+1}
				{~sectionTV.includes(~presetSeqStart[~tracksValue])} {p = ~sectionTV.choose+1}
				{~sectionTS.includes(~presetSeqStart[~tracksValue])} {p = ~sectionTS.choose+1};
				// p.postln;
				~presetSeqRangeViewG[~tracksValue].valueAction_(~presetSeqRangeSpec.unmap([p, p]));
				~seqCompG1[~tracksValue].visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-10)*20).max(0);
				}
				/*{
				{
				"Xfade begins - Wait !!!".postln;
				// if (~seqABVisibleViewG[~tracksValue].value == 0, {~seqABVisibleViewG[~tracksValue].valueAction_(1)}, {~seqABVisibleViewG[~tracksValue].valueAction_(0)} ); // Changement du View A ou B dans la vue Globale
				// 0.05.wait;
				if (~tracksValue.even, {~seqABVisibleViewG[~tracksValue].valueAction_(1); ~tracksView.valueAction_(~tracksValue+1)}, {~seqABVisibleViewG[~tracksValue].valueAction_(0); ~tracksView.valueAction_(~tracksValue-1);} ); // Déclenchement de la piste B
				0.05.wait;
				~seqsView.valueAction_(~seqSeq[~tracksValue]); // Sélection de la séquence de la séquence en cours de la piste concernée
				0.05.wait;
				~presetSelectionView.valueAction_(~presetList.find([~presetListAcType[~presetRandomTypeValue].choose])); // Random selon le type de presets
				0.05.wait;
				if (~playControlView[~tracksValue].acceptsMouse == true, { // Déclenchement du crossfade
				if (~playViewValue[~tracksValue] == 1, { ~playControlView[~tracksValue].valueAction_(0) }, { ~playControlView[~tracksValue].valueAction_(1) } ) });
				((~pFade[~tracksValue] / ~toTempo).round(0.01)).wait;
				"End of Xfade - Ok".postln;
				}.fork(AppClock)
				}*/
				);
				},*/

				// Barre Espace
				32, { // Barre Espace -> Action sur le bouton qui déclenche la fonction Play / Stop
					// OK avec shift mais ne marche pas si alt XXXXXX
					if (~aControllerConnected == 1, {
					},{
						if (~playControlView[~tracksValue].acceptsMouse == true, {
							if (~playViewValue[~tracksValue] == 1, { ~playControlView[~tracksValue].valueAction_(0) }, { ~playControlView[~tracksValue].valueAction_(1) } ) });
					});
				},

				// ?,
				44, { // ?, -> Action qui déclenche la fonction Play mais sans quant et Xfade pour déclenchement immédiat / Lag des FX aléatoire si shift
					if (mod == 0, {
						if (~aControllerConnected == 1, {
							case
							{ ~fxServerSwitch == 0 }
							{
								~fxRandLParametersAllView[0].valueAction_(1);
							}
							{ ~fxServerSwitch == 1 }
							{
								~fxRandLParametersAllView[1].valueAction_(1);
							}
							{ ~fxServerSwitch == 2 }
							{
								~nbOfServers.do { |s| ~fxRandLParametersAllView[s].valueAction_(1); };
							};
						},{
							if (~playControlView[~tracksValue].acceptsMouse == true, {
								if (~playViewValue[~tracksValue] == 0, {
									~play.value(npdef: ~patterns2[~tracksValue], track: ~tracks[~tracksValue], nfade: ~nFade[~tracksValue], pfade: 0, quant: 0, stretchdur: 1/1); ~playViewValue[~tracksValue] = 1; ~playControlView[~tracksValue].value_(1);
								}, {
									Pdef(~patterns2[~tracksValue]).quant_(0); Pdef(~patterns2[~tracksValue]).pause; ~playViewValue[~tracksValue] = 0; ~playControlView[~tracksValue].value_(0);
								});
								~playViewFunction.(~tracksValue, ~playViewValue[~tracksValue]); ~playViewG[~tracksValue].value_(~playViewValue[~tracksValue]);
							});
						});
					});
				},
				63, { // ?, + shift -> Action qui déclenche la fonction Play mais sans quant et Xfade pour déclenchement immédiat / FX aléatoire si shift
					// 191 en uni et 655360 en mod si alt + shift
					if (mod == 131072 /*655360*/ and: {~keyBoardPerfProtectFX == 0}, {
						case
						{ ~fxServerSwitch == 0 }
						{
							~fxRandAllView[0].valueAction_(1);
						}
						{ ~fxServerSwitch == 1 }
						{
							~fxRandAllView[1].valueAction_(1);
						}
						{ ~fxServerSwitch == 2 }
						{
							~nbOfServers.do { |s| ~fxRandAllView[s].valueAction_(1) };
						};
						// Rajouter une condition car le serveur n'est pas forcément sur la piste sélectionnée XXXXXXXXX TO DO
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					});
				},

				// ;.
				46, { // ;. -> Action sur le bouton qui déclenche la fonction Resume ou stop si pattern déjà lancé
					if (mod == 0, {
						if (~aControllerConnected == 1, {
							case
							{ ~fxServerSwitch == 0 }
							{
								~fxRandMParametersAllView[0].valueAction_(1);
							}
							{ ~fxServerSwitch == 1 }
							{
								~fxRandMParametersAllView[1].valueAction_(1);
							}
							{ ~fxServerSwitch == 2 }
							{
								~nbOfServers.do { |s| ~fxRandMParametersAllView[s].valueAction_(1) };
							};
						},{
							// if (~playControlView[~tracksValue].acceptsMouse == true, { ~play2ControlView[~tracksValue].valueAction_(1); });
							if (~playControlView[~tracksValue].acceptsMouse == true, {
								// ~play2ControlView[~tracksValue].valueAction_(1);
								if (~playViewValue[~tracksValue] == 0, {
									~play2ControlView[~tracksValue].valueAction_(1);
								}, {
									Pdef(~patterns2[~tracksValue]).quant_(0); Pdef(~patterns2[~tracksValue]).pause; ~playViewValue[~tracksValue] = 0; ~playControlView[~tracksValue].value_(0);
								});
								~playViewFunction.(~tracksValue, ~playViewValue[~tracksValue]); ~playViewG[~tracksValue].value_(~playViewValue[~tracksValue]);
							});
						});
					});
				},
				59, { // ;. + shift -> Action qui arrête les FX
					if (mod == 131072, {
						case
						{ ~fxServerSwitch == 0 }
						{
							~fxDefaultAll2View[0].valueAction_(1);
						}
						{ ~fxServerSwitch == 1 }
						{
							~fxDefaultAll2View[1].valueAction_(1);
						}
						{ ~fxServerSwitch == 2 }
						{
							~nbOfServers.do { |s| ~fxDefaultAll2View[s].valueAction_(1); }
						}
						// if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					});
				},

				// :/
				47, { // :/ -> pour Random sur les paramêtres des FX

					if (mod == 0, {
						case
						{ ~fxServerSwitch == 0 }
						{
							~fxRandParametersAllView[0].valueAction_(1);
						}
						{ ~fxServerSwitch == 1 }
						{
							~fxRandParametersAllView[1].valueAction_(1);
						}
						{ ~fxServerSwitch == 2 }
						{
							~nbOfServers.do { |s| ~fxRandParametersAllView[s].valueAction_(1) };
						}
						// if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					});

					// :/ -> // Action qui déclenche un seul évènement d'un pattern - // Quelle est la vitesse de déclenchement lorsqu'on reste appuyé sur l'évaluation ??????
					// Marche par défaut sur la piste A ou la dernière jouée - pas possible de le faire à la fois sur les pistes A & B
					// Problème de positionnement quand le pattern est relancé - obligé de relancer le code à la fin de Init Pattern ?????????
					/*if (mod == 0, {
					~curEventTrigView.valueAction_(1)
					/*if (mod == 131072, {
					if ( ~fxInSerieChooseAllButtonView.value == 0, { ~fxInSerieChooseAllButtonView.valueAction_(1) }, { ~fxInSerieChooseAllButtonView.valueAction_(0) });
					},{
					~curEventTrigView.valueAction_(1);
					})*/
					});*/
				},
				92, { // :/ + alt + shift -> // Switch entre Série & Parallèle des FX
					if (mod == 655360, {
						case
						{ ~fxServerSwitch == 0 }
						{
							if ( ~fxInSerieChooseAllButtonView[0].value == 0, { ~fxInSerieChooseAllButtonView[0].valueAction_(1) }, { ~fxInSerieChooseAllButtonView[0].valueAction_(0) });
						}
						{ ~fxServerSwitch == 1 }
						{
							if ( ~fxInSerieChooseAllButtonView[1].value == 0, { ~fxInSerieChooseAllButtonView[1].valueAction_(1) }, { ~fxInSerieChooseAllButtonView[1].valueAction_(0) });
						}
						{ ~fxServerSwitch == 2 }
						{
							~nbOfServers.do { |s|
								if ( ~fxInSerieChooseAllButtonView[s].value == 0, { ~fxInSerieChooseAllButtonView[s].valueAction_(1) }, { ~fxInSerieChooseAllButtonView[s].valueAction_(0) });
							};
						}
						// if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					});
				},

				// +=
				43, { // += -> pour Random sur les modulation FX par HP
					if (mod == 0, {
						case
						{ ~fxServerSwitch == 0 }
						{
							~fxDefaultAllView[0].valueAction_(1);
						}
						{ ~fxServerSwitch == 1 }
						{
							~fxDefaultAllView[1].valueAction_(1);
						}
						{ ~fxServerSwitch == 2 }
						{
							~nbOfServers.do { |s| ~fxDefaultAllView[s].valueAction_(1) };
						}
						// if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					});
				},
				177, { // += + alt + shift -> // Shuffle des 5 FX
					if (mod == 655360, {
						case
						{ ~fxServerSwitch == 0 }
						{
							~fxInSerieRandButtonView[0].valueAction_(1); // if (~fxSelect.sum > 0, { "FX shuffled".postln; });
						}
						{ ~fxServerSwitch == 1 }
						{
							~fxInSerieRandButtonView[1].valueAction_(1);
						}
						{ ~fxServerSwitch == 2 }
						{
							~nbOfServers.do { |s| ~fxInSerieRandButtonView[s].valueAction_(1) };
						};
						// if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					});
				},

				// Return
				13, { // Return -> switcher entre les différentes Tracks qui sont jouées - distinction entre les pistes rthmiques et les autres
					// Problème avec Return qui fait le ShortCut de changement de Track quand on valide un chiffre -> Pas de solution
					// -> Appuyer sur Pomme+ Return à la place pour ne rien faire, car Return, Return + shift & Return + alt sont déjà affectés.
					case
					{mod == 0} // Avec rien -> switch entre toutes les pistes atmosphériques du haut
					{ var indicesOfTracks, indexOfTracks;
						indicesOfTracks = ~playViewValue[0..5].indicesOfEqual(1);
						if (indicesOfTracks.notNil and: {indicesOfTracks.size !=1}, {
							indexOfTracks = indicesOfTracks.indexOfGreaterThan(~tracksValue);
							if (indexOfTracks.isNil, {~tracksView.valueAction_(indicesOfTracks[0])}, {~tracksView.valueAction_(indicesOfTracks[indexOfTracks])});
							if (indicesOfTracks.includes(~secondLemurX2Track) and: {~lemurConnected2 == 1}, { indicesOfTracks.remove(~secondLemurX2Track) });
						},{
							~tracksView.valueAction_( ( ((0..~nbOfTracks-1)*2) + ~seqCompGABIndex)[((~tracksValue/2).asInteger+1).wrap(0,7)]);
						});
					}
					{mod == 131072} // Avec shift -> switch entre toutes les pistes rythmiques du bas
					{ var indicesOfTracks, indexOfTracks;
						indicesOfTracks = ~playViewValue[6..15].indicesOfEqual(1);
						if (indicesOfTracks.notNil, { indicesOfTracks=indicesOfTracks+6;
							indexOfTracks = indicesOfTracks.indexOfGreaterThan(~tracksValue);
							if (indexOfTracks.isNil, {~tracksView.valueAction_(indicesOfTracks[0])}, {~tracksView.valueAction_(indicesOfTracks[indexOfTracks])});
							if (indicesOfTracks.includes(~secondLemurX2Track) and: {~lemurConnected2 == 1}, { indicesOfTracks.remove(~secondLemurX2Track) });
						},{
							~tracksView.valueAction_( 0 );
						});
					}
					{mod == 524288} // Avec Alt -> switch entre toutes les pistes
					{ ~switchTracksAllControlView.valueAction_(1) };
				},

				// *$
				42, { // *$  -> Preset Selection + 1 (-1 dans key2 car pas d'unicode)
					if (~currentTab == 0, {
						~presetSeqRangeView.valueAction_(~presetSeqRangeSpec.unmap([ (~presetSeqStart[~tracksValue]+2).clip(0, ~nbOfSeqs), (~presetSeqStart[~tracksValue]+2).clip(0, ~nbOfSeqs)  ]));
						~seqComp5.visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-4)*20*~ySizeMul).max(0).min(~seqComp5MaxVisibleOrigin)
					},{
						~presetSeqRangeViewG[~tracksValue].valueAction_(~presetSeqRangeSpec.unmap([ (~presetSeqStart[~tracksValue]+2).clip(0, ~nbOfSeqs), (~presetSeqStart[~tracksValue]+2).clip(0, ~nbOfSeqs)  ]));
						~seqCompG1[~tracksValue].visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin)
					});
				},
				36, { // *$ + shift  -> même comportement qu'au dessus
					if (~currentTab == 0, {
						~presetSeqRangeView.valueAction_(~presetSeqRangeSpec.unmap([ (~presetSeqStart[~tracksValue]+2).clip(0, ~nbOfSeqs), (~presetSeqStart[~tracksValue]+2).clip(0, ~nbOfSeqs)  ]));
						~seqComp5.visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-4)*20*~ySizeMul).max(0).min(~seqComp5MaxVisibleOrigin)
					},{
						~presetSeqRangeViewG[~tracksValue].valueAction_(~presetSeqRangeSpec.unmap([ (~presetSeqStart[~tracksValue]+2).clip(0, ~nbOfSeqs), (~presetSeqStart[~tracksValue]+2).clip(0, ~nbOfSeqs)  ]));
						~seqCompG1[~tracksValue].visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin)
					});
				},
				8364, { // *$ + alt-> PresetSelection suivante de la piste
					if (mod == 524288, {
						var curPreset, tr;
						case
						{ ~tracksValue == 0 } { tr = 0 }
						{ ~tracksValue == 2 } { tr = 1 }
						{ ~tracksValue == 4 } { tr = 2 }
						{ ~tracksValue != 4 } { tr = nil };
						if (tr.notNil, {
							~positionInPresetSel[tr] = min(~presetsSelListMemoryNb, ~positionInPresetSel[tr] +1);
							curPreset = ~presetsSelCollection[tr][~positionInPresetSel[tr]];

							if (~positionInPresetSel[tr] == ~presetsSelListMemoryNb, {
								~positionInPresetSel[tr] = ~positionInPresetSel[tr]  - 1; "No next Selection".postln; // pour annuler la dernière action
							},{
								~presetSeqStart[~tracksValue] = curPreset; ~presetSeqStop[~tracksValue] = curPreset;

								~seq2[~tracksValue] = (1..~nbOfSeqs).copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])[~presetSeqNb2Value[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]).order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])[~presetSeqNb2Value[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]).order][id] }.flat;

								// Pour la fabrication de la séquence aléatoire à chaque fois que le RangeSlider est modifié
								~presetSeqRangeRand[~tracksValue] = Pxrand(~seq2[~tracksValue]/*.copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])*/, inf).asStream;

								// Changement de séquence dès que le RangeSlider est modifié sans attendre la fin de la séquence
								if (~seqChange[~tracksValue] == 1, {
									~seqBlock[~tracksValue] = 1;
									[\rtmBlock, \proBlock, \synBlock, \spaBlock, \legBlock, \envBlock, \bufBlock, \ampBlock, \ratBlock, \rat2Block, \offBlock, \strBlock, \str2Block, \cenBlock, \cen2Block, \panBlock, \delBlock, \outLBlock, \outRBlock, \fxLBlock, \fxRBlock].do {|i| currentEnvironment[i][~tracksValue] = 1};
								});

								// Armer la séquence si changement du rangeslider
								if (~curSeqTrig == 1, {
									if (Pdef(~patterns2[~tracksValue]).isPlaying == false, {
										if (~seqChange[~tracksValue] == 0, {~seqChangeViewG[~tracksValue].valueAction_(1)});
										// ~seqsView.valueAction_(~presetSeqStart[~tracksValue]);
										~seqsView.valueAction_(~presetSeqStart[~tracksValue]); // pour lire la bonne séquence quand la sélection est supérieure au ~nbOfSeqs
									});
								});

								if (~currentTab == 0, {
									~presetSeqRangeView.value_(~presetSeqRangeSpec.unmap([ curPreset, curPreset+1 ]));
									~presetSeqRangeViewG[~tracksValue].value_(~presetSeqRangeSpec.unmap([ curPreset, curPreset+1 ]));
									~seqComp5.visibleOrigin = 0@( (curPreset /*~presetSeqStart[~tracksValue]*/-4)*20*~ySizeMul).max(0).min(~seqComp5MaxVisibleOrigin)
								},{
									~presetSeqRangeViewG[~tracksValue].value_(~presetSeqRangeSpec.unmap([ curPreset, curPreset+1 ]));
									~seqCompG1[~tracksValue].visibleOrigin = 0@( (curPreset /*~presetSeqStart[~tracksValue]*/-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin)
								});
								/*if (~presetSelection[~tracksValue][curPreset] != 0, {
								~presetGetFunction.value(~presetSelection[~tracksValue][curPreset].asSymbol);
								// ~presetGetFunction.value(~presetSelection[~tracksValue][~presetsSelCollection[0][~positionInPresetSel[0]]]);
								if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, { ~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.grey(0.3)) });
								},{
								"0 -> No Preset".postln;
								});*/
								("Preset Memory Nb : " + (~positionInPresetSel[tr]+1-~presetsSelListMemoryNb)).postln;
							});
						});
					});
				},
				/*
				8364, { // *$ + alt et protection-> PresetListe +1
				// Pas possible avec unicode, besoin de key2
				if (~keyBoardPerfProtect == 0, {
				~presetSelectionView.valueAction_((~presetSelectionView.value + 1).clip(0, ~presetList.size - 1))
				});
				},
				*/

			);





			switch(key,


				33, { // ^¨-> Obligé de conserver key (33) car keyCode (key2) est identique avec `£ et pas d'unicode
					case
					{mod == 0} // ^¨ -> Preset Selection -1
					// changement de ~presetSeqStart en ~presetSeqStart pour eviter des sauts de déplacement du à la durée des séquences
					{
						if (~currentTab == 0, {
							~presetSeqRangeView.valueAction_(~presetSeqRangeSpec.unmap([ (~presetSeqStart[~tracksValue]).clip(0, ~nbOfSeqs), (~presetSeqStart[~tracksValue]-1).clip(0, ~nbOfSeqs)  ]));
							~seqComp5.visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-4)*20*~ySizeMul).max(0).min(~seqComp5MaxVisibleOrigin)
						},{
							~presetSeqRangeViewG[~tracksValue].valueAction_(~presetSeqRangeSpec.unmap([ (~presetSeqStart[~tracksValue]).clip(0, ~nbOfSeqs), (~presetSeqStart[~tracksValue]-1).clip(0, ~nbOfSeqs)  ]));
							~seqCompG1[~tracksValue].visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin)
						});
					}
					{mod == 524288}  // ^¨ + alt-> Preset Selection précédente de la piste
					{
						var curPreset, tr;
						case
						{ ~tracksValue == 0 } { tr = 0 }
						{ ~tracksValue == 2 } { tr = 1 }
						{ ~tracksValue == 4 } { tr = 2 }
						{ ~tracksValue != 4 } { tr = nil };
						if (tr.notNil, {
							~positionInPresetSel[tr] = max(0, ~positionInPresetSel[tr] - 1);
							curPreset = ~presetsSelCollection[tr][~positionInPresetSel[tr]];

							if (curPreset == 0 or: {~positionInPresetSel[tr] == 0}, {
								~positionInPresetSel[tr] = ~positionInPresetSel[tr]  + 1; "No previous Selection".postln; // pour annuler la dernière action
							}, {
								~presetSeqStart[~tracksValue] = curPreset; ~presetSeqStop[~tracksValue] = curPreset;

								~seq2[~tracksValue] = (1..~nbOfSeqs).copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])[~presetSeqNb2Value[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]).order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])[~presetSeqNb2Value[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]).order][id] }.flat;

								// Pour la fabrication de la séquence aléatoire à chaque fois que le RangeSlider est modifié
								~presetSeqRangeRand[~tracksValue] = Pxrand(~seq2[~tracksValue]/*.copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])*/, inf).asStream;

								// Changement de séquence dès que le RangeSlider est modifié sans attendre la fin de la séquence
								if (~seqChange[~tracksValue] == 1, {
									~seqBlock[~tracksValue] = 1;
									[\rtmBlock, \proBlock, \synBlock, \spaBlock, \legBlock, \envBlock, \bufBlock, \ampBlock, \ratBlock, \rat2Block, \offBlock, \strBlock, \str2Block, \cenBlock, \cen2Block, \panBlock, \delBlock, \outLBlock, \outRBlock, \fxLBlock, \fxRBlock].do {|i| currentEnvironment[i][~tracksValue] = 1};
								});

								// Armer la séquence si changement du rangeslider
								if (~curSeqTrig == 1, {
									if (Pdef(~patterns2[~tracksValue]).isPlaying == false, {
										if (~seqChange[~tracksValue] == 0, {~seqChangeViewG[~tracksValue].valueAction_(1)});
										~seqsView.valueAction_(~presetSeqStart[~tracksValue]);
									});
								});

								if (~currentTab == 0, {
									~presetSeqRangeView.value_(~presetSeqRangeSpec.unmap([ curPreset, curPreset+1 ]));
									~presetSeqRangeViewG[~tracksValue].value_(~presetSeqRangeSpec.unmap([ curPreset, curPreset+1 ]));
									~seqComp5.visibleOrigin = 0@( (curPreset /*~presetSeqStart[~tracksValue]*/-4)*20*~ySizeMul).max(0).min(~seqComp5MaxVisibleOrigin)
								},{
									~presetSeqRangeViewG[~tracksValue].value_(~presetSeqRangeSpec.unmap([ curPreset, curPreset+1 ]));
									~seqCompG1[~tracksValue].visibleOrigin = 0@( (curPreset /*~presetSeqStart[~tracksValue]*/-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin)
								});
								/*if (~presetSelection[~tracksValue][curPreset] != 0, {
								~presetGetFunction.value(~presetSelection[~tracksValue][curPreset].asSymbol);
								// ~presetGetFunction.value(~presetSelection[~tracksValue][~presetsSelCollection[0][~positionInPresetSel[0]]].asSymbol)
								if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, { ~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.grey(0.3)) });
								},{
								"0 -> No Preset".postln;
								});*/
								("Preset Memory Nb : " + (~positionInPresetSel[tr]+1-~presetsSelListMemoryNb)).postln;
							});
						});
					}
					{mod == 786432} // ^¨ + control + alt et protection-> PresetListe -1
					{
						if (~keyBoardPerfProtect == 0, { var view, list;
							if ( ~presetsFileName2.isNil, { view = \presetSelectionView.envirGet; list = \presetList.envirGet
							},{
								if (~currentTabPresetSelection == 0, { view = \presetSelectionView.envirGet; list = \presetList1.envirGet },{ view = \presetSelection2View.envirGet; list = \presetList2.envirGet });
							});
							view.valueAction_((view.value - 1).clip(0, list.size - 1))
						})
					};
				},

				30, { // *$ + alt et protection-> PresetListe +1
					// Pas possible avec unicode, besoin de key2
					if (~keyBoardPerfProtect == 0 and: {mod == 786432} , { var view, list;
						if ( ~presetsFileName2.isNil, { view = \presetSelectionView.envirGet; list = \presetList.envirGet
						},{
							if (~currentTabPresetSelection == 0, { view = \presetSelectionView.envirGet; list = \presetList1.envirGet },{ view = \presetSelection2View.envirGet; list = \presetList2.envirGet });
						});
						view.valueAction_((view.value + 1).clip(0, list.size - 1))
					});
				},

				// £`
				42, { // £`- � correspond à 163.asAscii -> // RATE RANDOM
					if (mod == 0, {
						/*~rate.value([~tracksValue][~seqsValue]);*/ ~ratRandView.valueAction_(1);
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					});
				},

			);





			switch(key2, // Pour avoir le même chiffre, peu importe si le modifier est allumé ou non (valable pour shift mais pas pour alt)

				71, { // Glissando avec Ctrl + G
					case
					{mod == 262144}
					{ if (~ratSynth[~tracksValue][~seqSeq[~tracksValue]] == 0, {~ratSynthView.valueAction_(1); "Glissando Activated".postln; }, {~ratSynthView.valueAction_(0); "Glissando Deactivated".postln;});
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					}
				},
				76, { // Loop avec Ctrl + L
					case
					{mod == 262144}
					{ if (~legLoop[~tracksValue][~seqSeq[~tracksValue]] == 0, {~legLoopView.valueAction_(1)}, {~legLoopView.valueAction_(0)});
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					}
				},
				81, { // Trig ALL avec Ctrl + Q
					case
					{mod == 262144}
					{
						if ( ~trigAll != 2, {~trigAllView.valueAction_(2)}, {~trigAllView.valueAction_(3)} );
					}
				},
				83, { // Switch entre Track et Others Ctrl + S
					case
					{mod == 262144}
					{
						if (~trigAll != 0 /*or: { ~trigAll != 3 }*/, {~trigAllView.valueAction_(0)}, {~trigAllView.valueAction_(1) } );
					}
				},
				68, { // FX Server ALL avec Ctrl + D
					case
					{mod == 262144}
					{
						~fxServerSwitchView.valueAction_(2);
					}
				},
				70, { // FX Swich entre Server 1 & 2 avec Ctrl + F
					case
					{mod == 262144}
					{
						if (~fxServerSwitch == 0, {~fxServerSwitchView.valueAction_(1)}, {~fxServerSwitchView.valueAction_(0)} );
					}
				},
				65, { // Panic Preset 1
					case
					{mod == 262144}
					{  "Panic Preset 1 to define".postln
					}
				},
				90, { // Panic Preset 2
					case
					{mod == 262144}
					{  "Panic Preset 2 to define".postln
					}
				},
				69, { // Panic Preset 3
					case
					{mod == 262144}
					{  "Panic Preset 3 to define".postln
					}
				},
				82, { // Panic Preset 4
					case
					{mod == 262144}
					{  "Panic Preset 4 to define".postln
					}
				},
				84, { // Panic Preset 5
					case
					{mod == 262144}
					{  "Panic Preset 5 to define".postln
					}
				},
				89, { // Panic Preset 6
					case
					{mod == 262144}
					{  "Panic Preset 6 to define".postln
					}
				},


				// Pomme ->  Pour empêcher la sélection dans le ~presetSelectionView quand dragging
				16777249, {~presetSelectionPrevent = 1},

				// control + shift
				16777248/*1*/, { // control + shift -> Changement  du signe pour les vitesses de lecture
					if (mod == 393216 /*262144*/, {
						~controlBusTypeSignView.valueAction_( (~controlBusTypeSign +1).wrap(0,1) )
					});
				},

				// Fonction F1
				16777264, { // F1 -> Changement des temps de Xfade des FX (lag et synthèse)
					// ~fxTimePresetView.valueAction_( (~fxTimePresetView.value + 1).wrap(0,2) );
					case
					{ ~fxServerSwitch == 0 }
					{
						~fxTimePresetView[0].valueAction_(0);
					}
					{ ~fxServerSwitch == 1 }
					{
						~fxTimePresetView[1].valueAction_(0);
					}
					{ ~fxServerSwitch == 2 }
					{
						~nbOfServers.do { |s| ~fxTimePresetView[s].valueAction_(0) };
					}
				},
				// Fonction F2
				16777265, { // F2 -> Changement des temps de Xfade des FX (lag et synthèse)
					case
					{ ~fxServerSwitch == 0 }
					{
						~fxTimePresetView[0].valueAction_(1);
					}
					{ ~fxServerSwitch == 1 }
					{
						~fxTimePresetView[1].valueAction_(1);
					}
					{ ~fxServerSwitch == 2 }
					{
						~nbOfServers.do { |s| ~fxTimePresetView[s].valueAction_(1) };
					}
				},
				// Fonction F3
				16777266, { // F3 -> Changement des temps de Xfade des FX (lag et synthèse)
					// ~fxTimePresetView.valueAction_( (~fxTimePresetView.value + 1).wrap(0,2) );
					case
					{ ~fxServerSwitch == 0 }
					{
						~fxTimePresetView[0].valueAction_(2);
					}
					{ ~fxServerSwitch == 1 }
					{
						~fxTimePresetView[1].valueAction_(2);
					}
					{ ~fxServerSwitch == 2 }
					{
						~nbOfServers.do { |s| ~fxTimePresetView[s].valueAction_(2) };
					}
				},

				// Fonction F4
				16777267, { // F4 -> Changement du fadeTime des Bus pour avancer dans les temps de défilement
					~controlBusSynth5FadeTimeView.valueAction_(6)
				},
				// Fonction F5
				16777268, { // F5 -> Changement du fadeTime des Bus pour avancer dans les temps de défilement
					if (mod == 0, {
						~controlBusSynth5FadeTimeView.valueAction_(8)
					}, {
						if (~controlBusSynth5FadeTime == 8, {~controlBusSynth5FadeTimeView.valueAction_(0) }, {~controlBusSynth5FadeTimeView.valueAction_(~controlBusSynth5FadeTime + 1)});
					});
				},
				// Fonction F6
				16777269, { // F6 -> Changement du fadeTime des Bus pour avancer dans les temps de défilement
					if (mod == 0, {
						~controlBusSynth5FadeTimeView.valueAction_(0)
					}, {
						if (~controlBusSynth5FadeTime == 0, {~controlBusSynth5FadeTimeView.valueAction_(8) }, {~controlBusSynth5FadeTimeView.valueAction_(~controlBusSynth5FadeTime - 1)});
					});
				},

				// Fonction F7
				16777270, { // Fonction F7 -> Changement  du paramètre ~controlBusTypeArgValue (Rat)
					// if (~keyBoardPerfProtect == 0, {
					~controlBusTypeArgView.valueAction_( 0 )
					// });
				},
				// Fonction F8
				16777271, { // Fonction F8 -> Changement  du paramètre ~controlBusTypeArgValue (Str)
					~controlBusTypeArgView.valueAction_( 1 )
				},
				// Fonction F9
				16777272, { // Fonction F9 -> Changement  du paramètre ~controlBusTypeArgValue (Cen)
					~controlBusTypeArgView.valueAction_( 2 )
				},

				80, { // P + alt -> Retrigger tous les presets de la piste
					if (mod == 524288, { // mod.postln;
						~retriggerPresetPreViewG[~tracksValue].valueAction_(1);
					});
				},

				// M -> A supprimer dans le cadre de performances ?
				77, { // M + control + alt -> Preset aléatoire
					if (~keyBoardPerfProtect == 0 and: {mod == /*0*/ 786432 /*1835008*/ }, {
						// var pres = ~presetListAcType[~presetRandomTypeValue].choose.postln;
						// Rand
						// ~presetSelectionView.valueAction_(rand(~presetList.size)); // Random global
						// {~presetSelectionView.valueAction_(rand(~presetList.size))}.bench;
						// {~presetSelectionView.valueAction_(~presetList.find([~presetListAcType[~presetRandomTypeValue].choose]))}.bench; // pas vraiment de différence entre les 2 benchmarks

						if ( ~presetsFileName2.isNil, {
							~presetSelectionView.valueAction_(~presetList.find([~presetListAcType[~presetRandomTypeValue].choose])); // Random selon le type de presets
						},{
							if (~currentTabPresetSelection == 0, {
								~presetSelectionView.valueAction_(~presetList1.find([~presetListAcType1[~presetRandomTypeValue].choose]));
							},{
								~presetSelection2View.valueAction_(~presetList2.find([~presetListAcType2[~presetRandomType2Value].choose]));
							});
						});

						// {~presetSelectionView.valueAction_(~presetList.find([~presetListAcType[~presetRandomTypeValue].choose])); /*0.0001.wait;*/}.fork(AppClock);
						// Essai pour réduire les erreurs lorsque M est constamment appuyée, mais ne résoud pas le problème et provoque en plus parfois des coupures du server avec des lates
					});
				},

				// <>
				62, { // <> -> Changement aléatoire dans certains types de dossiers sons (du même type)
					if (mod == 0 and: {~foldersStructure == 1}, {
						var fol = ~folderStructureValues[~kindOfFoldersSymbol.indexOf(~kindOfFoldersStructure[~bufFolderView.value].asSymbol)].choose;
						~bufFolderViewG[~tracksValue].value_(fol); ~bufFolderView.valueAction_(fol);
						~bufRangeView.doAction;
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					});
					/*
					// Initialisation plus haut des données nécessaires pour les shortcuts de changement de dossier son de la séquence
					~folderStructureValues[~kindOfFoldersSymbol.indexOf(~kindOfFoldersStructure[~bufFolderView.value].asSymbol)].choose
					*/
				},
				60, { // <> + shift -> Changement aléatoire dans certains types de dossiers sons (AR/AS) OU changement aléatoire de ~bufSequence (Eléments doux) si disponible
					if (mod == 131072 and: {~folderStructureAValues.notNil}, {
						var fol = if (~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0] != 0, {~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0].choose}, {~folderStructureAValues.choose});
						~bufFolderViewG[~tracksValue].value_(fol); ~bufFolderView.valueAction_(fol);
						~bufRangeView.doAction;
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					});
				},

				// BUFFER FOLDER
				87 /*$W*/, {
					case
					{mod == 0} // Rand -> Changement aléatoire Total
					{
						var fol = rand(~bufFolderSize1);
						~bufFolderViewG[~tracksValue].value_(fol); ~bufFolderView.valueAction_(fol);
						~bufRangeView/*.valueAction_([0, ~bufRangeSpec[~tracksValue][~seqsValue].unmap(~bufFolderM[0][~tracksValue][~seqsValue].size-1)])*/.doAction;
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
						// });
					}
					{mod == 131072 and: {~folderStructureDValues.notNil}} // W + shift -> Changement aléatoire dans certains types de dossiers sons OU changement aléatoire de ~bufSequence (Eléments violents) si disponible
					{
						var fol = if (~bufSequence[~tracksValue][~seqSeq[~tracksValue]][1] != 0, {~bufSequence[~tracksValue][~seqSeq[~tracksValue]][1].choose}, {~folderStructureDValues.choose});
						~bufFolderViewG[~tracksValue].value_(fol); ~bufFolderView.valueAction_(fol);
						~bufRangeView.doAction;
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					};
					/*var bufRange = ~bufRangeView.value; if (~chooseTest.isNil, {~chooseTest = 2});
					~bufFolderView.valueAction_(rand(~bufFolderSize1));
					/*
					~chooseTest = 0
					~chooseTest = 1
					~chooseTest = 2
					*/
					case
					{ ~chooseTest == 0 }
					{ ~bufRangeView/*.valueAction_([0, ~bufRangeSpec[~tracksValue][~seqsValue].unmap(~bufFolderM[~tracksValue][~seqsValue].size-1)])*/.doAction; }
					{ ~chooseTest == 1 }
					{ ~bufRangeView.valueAction_([0, ~bufRangeSpec[~tracksValue][~seqsValue].unmap(~bufFolderM[~tracksValue][~seqsValue].size-1)]).doAction; }
					{ ~chooseTest == 2 }
					{ // var bufRange = ~bufRangeView.value;
					// ~bufRangeView/*.valueAction_([0, ~bufRangeSpec[~tracksValue][~seqsValue].unmap(~bufFolderM[~tracksValue][~seqsValue].size-1)])*/.doAction;
					~bufRangeView.valueAction_(bufRange);
					};*/
				},
				88 /*$X*/, {
					case
					{mod == 0} // -1 sur BufFolderValue
					/*
					(// Raw
					~bufFolderView.valueAction_(~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0].permute(if (~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0].indexOfGreaterThan(~bufFolderView.value).isNil, {0}, {~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0].indexOfGreaterThan(~bufFolderView.value)}))[0]);~bufFolderView.value.postln; (~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0].indexOfGreaterThan(~bufFolderView.value)).postln;
					)
					(// Arranged OLD
					var seq = ~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0];
					var nth = seq.indexOfGreaterThan(~bufFolderView.value);
					seq = seq.permute(if (nth.isNil, {0}, {nth}));
					~bufFolderView.valueAction_(seq[0]); ~bufFolderView.value.postln; nth.postln;
					)
					*/
					{
						var fol = if (~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0] != 0, {~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0].choose}, {(~bufFolderView.value - 1).wrap/*clip*/(0, ~bufFolderSize1)}); // wrap permet un navigation ininterrompue vs clip
						~bufFolderViewG[~tracksValue].value_(fol); ~bufFolderView.valueAction_(fol);
						// ~nbFolders = ~bufFolderView.items.size // pour accélérer le changement // benchmark à faire ?????????
						~bufRangeView/*.valueAction_([0, ~bufRangeSpec[~tracksValue][~seqsValue].unmap(~bufFolderM[0][~tracksValue][~seqsValue].size-1)])*/.doAction; // Vraiment nécessaire
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					}
					{mod == 131072 and: {~folderStructureIValues.notNil}} // X + shift -> Changement aléatoire dans certains types de dossiers sons (DR/IP) OU changement en série de ~bufSequence (Eléments doux) si disponible
					{
						var fol;
						if (~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0] != 0, {
							~bufSequenceNb[0] = if (~bufSequenceNb[0] >= ~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0].size, {0}, {~bufSequenceNb[0]+1});
							fol = ~bufSequence[~tracksValue][~seqSeq[~tracksValue]][0].permute(~bufSequenceNb[0])[0];
						}, {
							fol = ~folderStructureIValues.choose;
						});
						~bufFolderViewG[~tracksValue].value_(fol); ~bufFolderView.valueAction_(fol);
						~bufRangeView.doAction;
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					};
					/* Test de rapidité
					bench { 10000.do { ~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red); }}
					bench { 10000.do { if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) }); }}
					*/
				},

				120, { // <> + shift -> Changement aléatoire das certains types de dossiers sons // ?????????
				},

				67 /*$C*/, { // +1 sur BufFolderValue
					case
					{mod == 0}
					{
						var fol = (~bufFolderView.value + 1).wrap/*clip*/(0, ~bufFolderSize1);
						~bufFolderViewG[~tracksValue].value_(fol); ~bufFolderView.valueAction_(fol);
						~bufRangeView/*.valueAction_([0, ~bufRangeSpec[~tracksValue][~seqsValue].unmap(~bufFolderM[0][~tracksValue][~seqsValue].size-1)])*/.doAction;
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					}
					{mod == 131072 and: {~folderStructureRValues.notNil}} // C + shift -> Changement aléatoire das certains types de dossiers sons (PN/IT) OU changement en série de ~bufSequence (Eléments violents) si disponible
					{
						var fol;
						if (~bufSequence[~tracksValue][~seqSeq[~tracksValue]][1] != 0, {
							~bufSequenceNb[1] = if (~bufSequenceNb[1] >= ~bufSequence[~tracksValue][~seqSeq[~tracksValue]][1].size, {0}, {~bufSequenceNb[1]+1});
							fol = ~bufSequence[~tracksValue][~seqSeq[~tracksValue]][1].permute(~bufSequenceNb[1])[0];
						}, {
							fol = ~folderStructureRValues.choose;
						});
						~bufFolderViewG[~tracksValue].value_(fol); ~bufFolderView.valueAction_(fol);
						~bufRangeView.doAction;
						if (~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background == Color.red, {}, {~presetSeqTextViewG[~tracksValue][~seqSeq[~tracksValue]].background_(Color.red) });
					};
				},

				// TRIG CUT 1
				86 /*$V*/, {
					~trigCut1View.valueAction_(1);
					// if (~trigAll == 1, {~trigAllView.valueAction_(0)}, {~trigAllView.valueAction_(1)} );
				},
				// TRIG CUT 2
				66 /*$B*/, {
					~trigCut2View.valueAction_(1);
				},
				// TRIG CUT 3
				78 /*$N*/, {
					~trigCut3View.valueAction_(1);
				}

			);





			case

			{~keyControl == 0}

			{
				switch(char,

					// TRACKS
					$1, { if (~tracksValue == 0, {~tracksView.valueAction_(1)}, {~tracksView.valueAction_(0)}); /*~tabbedView.focus(0)*/ }, // 1
					// if (~tracksValue != 0, {~tabbedView.focus(0)} ); // voire si n'augmente pas le CPU ??? Apparemment non si l'on est déjà dans la tab en question
					$2, { if (~tracksValue == 2, {~tracksView.valueAction_(3)}, {~tracksView.valueAction_(2)}); /*~tabbedView.focus(0)*/ }, // 2
					$3, { if (~tracksValue == 4, {~tracksView.valueAction_(5)}, {~tracksView.valueAction_(4)}); /*~tabbedView.focus(0)*/ }, // 3
					$4, { if (~tracksValue == 6, {~tracksView.valueAction_(7)}, {~tracksView.valueAction_(6)}); /*~tabbedView.focus(0)*/ }, // 4
					$5, { if (~tracksValue == 8, {~tracksView.valueAction_(9)}, {~tracksView.valueAction_(8)}); /*~tabbedView.focus(0)*/ }, // 5
					$6, { if (~tracksValue == 10, {~tracksView.valueAction_(11)}, {~tracksView.valueAction_(10)}); /*~tabbedView.focus(0)*/ }, // 6
					$7, { if (~tracksValue == 12, {~tracksView.valueAction_(13)}, {~tracksView.valueAction_(12)}); /*~tabbedView.focus(0)*/ }, // 7
					$8, { if (~tracksValue == 14, {~tracksView.valueAction_(15)}, {~tracksView.valueAction_(14)}); /*~tabbedView.focus(0)*/ }, // 8


					$A, { if (~tracksValue != 0, {~tracksView.valueAction_(0)}); ~curEventTrigFunction.(0);
						/*~controlBusFunc.(0.05)*/ // 1
						// ~seqsView.valueAction_(0); if (~tracksValue != 0, {~tabbedView.focus(0)} ); // SÉQUENCE 1
					},
					$Z, { /*~controlBusFunc.(0.1)*/ if (~tracksValue != 2, {~tracksView.valueAction_(2)}); ~curEventTrigFunction.(0); }, // 2
					$E, { /*~controlBusFunc.(0.2)*/ if (~tracksValue != 4, {~tracksView.valueAction_(4)}); ~curEventTrigFunction.(0); }, // 3
					$R, { /*~controlBusFunc.(0.4)*/ if (~tracksValue != 6, {~tracksView.valueAction_(6)}); ~curEventTrigFunction.(0); }, // 4
					$T, { /*~controlBusFunc.(0.6)*/ if (~tracksValue != 8, {~tracksView.valueAction_(8)}); ~curEventTrigFunction.(0); }, // 5
					$Y, { /*~controlBusFunc.(0.8)*/ if (~tracksValue != 10, {~tracksView.valueAction_(10)}); ~curEventTrigFunction.(0); }, // 6
					$U, { /*~controlBusFunc.(1)*/ if (~tracksValue != 12, {~tracksView.valueAction_(12)}); ~curEventTrigFunction.(0); }, // 7
					$I, {/* ~controlBusFunc.(1.5)*/ if (~tracksValue != 14, {~tracksView.valueAction_(14)}); ~curEventTrigFunction.(0); }, // 8
					$O, { /*~controlBusFunc.(2)*/ ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, 0.2, 5, s) } }, // 9
					/*$P, {
					~seqsView.valueAction_((~seqsValue - 1).clip(0, ~nbOfSeqs -1)); if (~tracksValue != 0, {~tabbedView.focus(0)} ); // SÉQUENCE -1
					~seqsView.valueAction_((~seqsValue + 1).clip(0, ~nbOfSeqs -1)); if (~tracksValue != 0, {~tabbedView.focus(0)} ); // SÉQUENCE +1
					},*/
					// Control Rate Bus
					$Q, { /*~controlBusFunc.(3)*/ if (~tracksValue != 0, {~tracksView.valueAction_(0)}); ~curEventTrigFunction.(1); }, // 1
					$S, { /*~controlBusFunc.(5)*/ if (~tracksValue != 2, {~tracksView.valueAction_(2)}); ~curEventTrigFunction.(1); }, // 2
					$D, { /*~controlBusFunc.(10)*/ if (~tracksValue != 4, {~tracksView.valueAction_(4)}); ~curEventTrigFunction.(1); }, // 3
					$F, { /*~controlBusFunc.(20)*/ if (~tracksValue != 6, {~tracksView.valueAction_(6)}); ~curEventTrigFunction.(1); }, // 4
					$G, { /*~controlBusFunc.(40)*/ if (~tracksValue != 8, {~tracksView.valueAction_(8)}); ~curEventTrigFunction.(1); }, // 5
					$H, { /*~controlBusFunc.(80)*/ if (~tracksValue != 10, {~tracksView.valueAction_(10)}); ~curEventTrigFunction.(1); }, // 6
					$J, { /*~controlBusFunc.(160)*/ if (~tracksValue != 12, {~tracksView.valueAction_(12)}); ~curEventTrigFunction.(1); }, // 7
					$K, { /*~controlBusFunc.(320)*/ if (~tracksValue != 14, {~tracksView.valueAction_(14)}); ~curEventTrigFunction.(1); }, // 8
					$L, { /*~controlBusFunc.(1000)*/ ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, 5, 5, s) } }, // 9


					// TEST ???
					/*$#, {
					w.view.focus (flag: true);
					}*/

				);
			}

			{~keyControl == 1}

			{
				switch(char,

					// TRACKS
					$1, { if (~tracksValue == 0, {~tracksView.valueAction_(1)}, {~tracksView.valueAction_(0)}); /*~tabbedView.focus(0)*/ }, // 1
					// if (~tracksValue != 0, {~tabbedView.focus(0)} ); // voire si n'augmente pas le CPU ??? Apparemment non si l'on est déjà dans la tab en question
					$2, { if (~tracksValue == 2, {~tracksView.valueAction_(3)}, {~tracksView.valueAction_(2)}); /*~tabbedView.focus(0)*/ }, // 2
					$3, { if (~tracksValue == 4, {~tracksView.valueAction_(5)}, {~tracksView.valueAction_(4)}); /*~tabbedView.focus(0)*/ }, // 3
					$4, { if (~tracksValue == 6, {~tracksView.valueAction_(7)}, {~tracksView.valueAction_(6)}); /*~tabbedView.focus(0)*/ }, // 4
					$5, { if (~tracksValue == 8, {~tracksView.valueAction_(9)}, {~tracksView.valueAction_(8)}); /*~tabbedView.focus(0)*/ }, // 5
					$6, { if (~tracksValue == 10, {~tracksView.valueAction_(11)}, {~tracksView.valueAction_(10)}); /*~tabbedView.focus(0)*/ }, // 6
					$7, { if (~tracksValue == 12, {~tracksView.valueAction_(13)}, {~tracksView.valueAction_(12)}); /*~tabbedView.focus(0)*/ }, // 7
					$8, { if (~tracksValue == 14, {~tracksView.valueAction_(15)}, {~tracksView.valueAction_(14)}); /*~tabbedView.focus(0)*/ }, // 8


					$A, { ~spaRangePresetItemsLV1Buttons[0].valueAction_(1) }, // 1 Fix
					$Z, { ~spaRangePresetItemsLV1Buttons[1].valueAction_(1) }, // 2 Del
					$E, { ~spaRangePresetItemsLV1Buttons[2].valueAction_(1) }, // 3 Lines
					$R, { ~spaRangePresetItemsLV2Buttons[0].valueAction_(1) }, // 4 C 1
					$T, { ~spaRangePresetItemsLV2Buttons[3].valueAction_(1) }, // 5 C M
					$Y, { ~spaRangePresetItemsLV3Buttons[0].valueAction_(1) }, // 6 Traj SD
					$U, { ~spaRangePresetItemsLV3Buttons[1].valueAction_(1) }, // 7 Traj
					$I, { ~spaRangePresetItemsLV4Buttons[0].valueAction_(1) }, // 8 2 All
					$O, { ~spaRangePresetItemsLV4Buttons[3].valueAction_(1) }, // 9 All
					/*$P, {
					~seqsView.valueAction_((~seqsValue - 1).clip(0, ~nbOfSeqs -1)); if (~tracksValue != 0, {~tabbedView.focus(0)} ); // SÉQUENCE -1
					~seqsView.valueAction_((~seqsValue + 1).clip(0, ~nbOfSeqs -1)); if (~tracksValue != 0, {~tabbedView.focus(0)} ); // SÉQUENCE +1
					},*/

					// Control Rate Bus
					/*$Q, { ~controlBusFunc.(0.1) }, // 1
					$S, { ~controlBusFunc.(0.2) }, // 2
					$D, { ~controlBusFunc.(0.5) }, // 3
					$F, { ~controlBusFunc.(1) }, // 4
					$G, { ~controlBusFunc.(2) }, // 5
					$H, { ~controlBusFunc.(5) }, // 6
					$J, { ~controlBusFunc.(10) }, // 7
					$K, { ~controlBusFunc.(20) }, // 8
					$L, { ~controlBusFunc.(50) }, // 9*/

					$Q, { ~trajSpatTypeView.valueAction_(0) }, // 1
					$S, { ~trajSpatTypeView.valueAction_(1) }, // 2
					$D, { ~trajSpatTypeView.valueAction_(2) }, // 3
					$F, { ~sdSpatTypeView.valueAction_(0) }, // 4
					$G, { ~sdSpatTypeView.valueAction_(1) }, // 5
					$H, { ~sdSpatTypeView.valueAction_(2) }, // 6
					$J, { ~sdSpatTypeView.valueAction_(3) }, // 7
					$K, { ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, 0.2, 5, s) } }, // 8
					$L, { ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, 5, 5, s) } }, // 9


					// TEST ???
					/*$#, {
					w.view.focus (flag: true);
					}*/

				);
			}

			{~keyControl == 2}

			{
				switch( uni /*char*/,

					// Control Rate Bus
					// mod == 131072 -> shift / mod == 262144 -> control / / mod == 524288 -> alt

					/*$1, { ~controlBusFunc.(~controlBusTypeArg, 0.05, 5); /*~gblTempo.seconds.postln;*/ }, // 1
					$2, { ~controlBusFunc.(~controlBusTypeArg, 0.1, 5) }, // 2
					$3, { ~controlBusFunc.(~controlBusTypeArg, 0.2, 5) }, // 3
					$4, { ~controlBusFunc.(~controlBusTypeArg, 0.4, 5) }, // 4
					$5, { ~controlBusFunc.(~controlBusTypeArg, 0.6, 5) }, // 5
					$6, { ~controlBusFunc.(~controlBusTypeArg, 0.8, 5) }, // 6
					$7, { ~controlBusFunc.(~controlBusTypeArg, 1, 5) }, // 7
					$8, { ~controlBusFunc.(~controlBusTypeArg, 1.5, 5) }, // 8
					/*$9, { ~controlBusFunc.(2) }, // 9
					$0, { ~controlBusFunc.(3) }, // 10
					176.asAscii, { ~controlBusFunc.(4.0) }, // 11
					95.asAscii, { ~controlBusFunc.(5.0) }, // 12*/
					$A, { ~controlBusFunc.(~controlBusTypeArg, 2, 5) }, // 1
					$Z, { ~controlBusFunc.(~controlBusTypeArg, 3, 5) }, // 2
					$E, { ~controlBusFunc.(~controlBusTypeArg, 5, 5) }, // 3
					$R, { ~controlBusFunc.(~controlBusTypeArg, 10, 5); "topi".postln; }, // 4
					$T, { ~controlBusFunc.(~controlBusTypeArg, 20, 5) }, // 5
					$Y, { ~controlBusFunc.(~controlBusTypeArg, 30, 5) }, // 6
					$U, { ~controlBusFunc.(~controlBusTypeArg, 40, 5) }, // 7
					$I, { ~controlBusFunc.(~controlBusTypeArg, 50, 5) }, // 8
					$O, { ~controlBusFunc.(~controlBusTypeArg, 75, 5) }, // 9
					// $P, { ~controlBusFunc.(100) }, // 10
					$Q, { ~controlBusFunc.(~controlBusTypeArg, 100, 5) }, // 1
					$S, { ~controlBusFunc.(~controlBusTypeArg, 200, 5) }, // 2
					$D, { ~controlBusFunc.(~controlBusTypeArg, 500, 5) }, // 3
					$F, { ~controlBusFunc.(~controlBusTypeArg, 1000, 5) }, // 4
					$G, { ~controlBusFunc.(~controlBusTypeArg, 10000, 5) }, // 5*/

					/*$1*/ 49, { var a = 0.025; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 1
					/*$2*/ 50, { var a = 0.05; a = if (~controlBusTypeSign == 0, { a }, { a.neg });~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 2
					/*$3*/ 51, { var a = 0.1; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 3
					/*$4*/ 52, { var a = 0.2; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 4
					/*$5*/ 53, { var a = 0.4; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 5
					/*$6*/ 54, { var a = 0.6; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 6
					/*$7*/ 55, { var a = 0.8; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 7
					/*$8*/ 56, { var a = 1.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 8
					/*$8*/ 57, { var a = 1.5; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 8
					/*$A*/ 65, { var a = 2.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 1
					/*$Z*/ 90, { var a = 3.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 2
					/*$E*/ 69, { var a = 5.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 3
					/*$R*/ 82, { var a = 10.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) };
						if (~presetVarsVolFocus == 1, {~presetVarsVol2SliderView.valueAction_(2.rand)  });
					}, // 4
					/*$T*/ 84, { var a = 20.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 5
					/*$Y*/ 89, { var a = 30.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 6
					/*$U*/ 85, { var a = 40.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 7
					/*$I*/ 73, { var a = 50.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 8
					/*$O*/ 79, { var a = 75.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 9
					/*$Q*/ 81, { var a = 100.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 1
					/*$S*/ 83, { var a = 200.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 2
					/*$D*/ 68, { var a = 500.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 3
					/*$F*/ 70, { var a = 1000.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 4
					/*$G*/ 71, { var a = 10000.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg }); ~nbOfServers.do { |s| ~controlBusFunc.(~controlBusTypeArg, a, 5, s) } }, // 5

					// Avec shift
					/*$1*/ 38, { var a = 0.025; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s|
							if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 1
					/*$2*/ 233, { var a = 0.05; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s|
							if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 2
					/*$3*/ 34, { var a = 0.1; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 3
					/*$4*/ 39, { var a = 0.2; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 4
					/*$5*/ 40, { var a = 0.4; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 5
					/*$6*/ 167, { var a = 0.6; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 6
					/*$7*/ 232, { var a = 0.8; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 7
					/*$8*/ 33, { var a = 1.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 8
					/*$8*/ 231, { var a = 1.5; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 9
					/*$A*/ 97, { var a = 2.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 1
					/*$Z*/ 122, { var a = 3.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 2
					/*$E*/ 101, { var a = 5.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 3
					/*$R*/ 114, { var a = 10.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 4
					/*$T*/ 116, { var a = 20.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 5
					/*$Y*/ 121, { var a = 30.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 6
					/*$U*/ 117, { var a = 40.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 7
					/*$I*/ 105, { var a = 50.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 8
					/*$O*/ 111, { var a = 75.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 9
					/*$Q*/ 113, { var a = 100.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 1
					/*$S*/ 115, { var a = 200.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 2
					/*$D*/ 100, { var a = 500.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 3
					/*$F*/ 102, { var a = 1000.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 4
					/*$G*/ 103, { var a = 10000.0; a = if (~controlBusTypeSign == 0, { a }, { a.neg });
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: s) } ) } }, // 5



					/*
					$H, { // 6
					~setID.(~listID[~tracksValue], ~controlBusTypeArg, { rrand(0.1, 3) });
					},
					$J, { // 7
					~setID.(~listID[~tracksValue], ~controlBusTypeArg, { exprand(0.1, 30) });
					},
					$K, { // 8
					~setID.(~listID[~tracksValue], ~controlBusTypeArg, { |i| (i+1) * 1 });
					},
					*/

					/*$H*/ 72, { // 6
						// ~controlRandFixCollection.(par: \amp, func: 0, val: 1.0, post: 1)
						try {if (~currentControlBusSynthGUIContainer.isClosed, {}, {~currentControlBusSynthRandView.valueAction_(1) }) };
					},

					// Avec shift
					/*$H*/ 104, {
						~nbOfServers.do { |s| ~controlRandFixCollection.(par: \amp, func: 0, val: 1.0, post: 1, serv: s) };
					}, // 5



					// Problème pour sélectionner une autre window XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX ????????????????????????????
					// comes to the front but its not selected and focused.
					// http://new-supercollider-mailing-lists-forums-use-these.2681727.n2.nabble.com/Qt-fronting-windows-td7440697.html#a7487576


					/*$J*/ 74, { // 7
						// Création d'une GUI
						if (~controlBusSynthGUIContainerCheck == 0, {

							Spec.add(\lagTime, #[0, 60, \lin, 0, 1]);
							Spec.add(\amp, #[0, 1, \lin, 0, 1]);
							Spec.add(\limiterlevel, #[0, 1, \lin, 0, 0.1]);
							Spec.add(\freq1, #[20, 10000, \exp, 0, 100]);
							Spec.add(\freq2, #[20, 10000, \exp, 0, 200]);
							Spec.add(\freq3, #[20, 10000, \exp, 0, 300]);
							Spec.add(\fmod1, #[0.001, 100, \exp, 0, 0.11]);
							Spec.add(\fmod2, #[0.001, 100, \exp, 0, 0.22]);
							Spec.add(\fmod3, #[0.001, 100, \exp, 0, 0.33]);
							Spec.add(\fmoda1, #[0, 100, \lin, 0, 1]);
							Spec.add(\fmoda2, #[0, 100, \lin, 0, 1]);
							Spec.add(\fmoda3, #[0, 100, \lin, 0, 1]);
							Spec.add(\pmod1, #[0.001, 100, \exp, 0, 0.1]);
							Spec.add(\pmod2, #[0.001, 100, \exp, 0, 0.2]);
							Spec.add(\pmod3, #[0.001, 100, \exp, 0, 0.3]);
							Spec.add(\amod1, #[0.001, 100, \exp, 0, 0.01]);
							Spec.add(\amod2, #[0.001, 100, \exp, 0, 0.02]);
							Spec.add(\amod3, #[0.001, 100, \exp, 0, 0.03]);
							Spec.add(\amoda1, #[0, 10, \lin, 0, 0.05]);
							Spec.add(\amoda2, #[0, 10, \lin, 0, 0.05]);
							Spec.add(\amoda3, #[0, 10, \lin, 0, 0.05]);
							Spec.add(\smod, #[0.001, 100, \exp, 0, 0.13]);
							Spec.add(\smoda, #[0, 100, \lin, 0, 5]);
							Spec.add(\smodm, #[0, 100, \lin, 0, 6]);
							Spec.add(\smodaa, #[0, 100, \lin, 0, 8]);
							Spec.add(\smodmm, #[0, 100, \lin, 0, 50]);
							Spec.add(\cmod, #[0.001, 100, \exp, 0, 1.2]);
							Spec.add(\cmoda, #[0, 10, \lin, 0, 0.6]);

							~controlBusSynth[0][5].source = {| lagTime=1 |
								LeakDC.kr(Mix(SinOsc.kr([\freq1.kr(100, lagTime), \freq2.kr(200, lagTime), \freq3.kr(300, lagTime)])+SinOsc.kr([\fmod1.kr(0.11, lagTime), \fmod2.kr(0.22, lagTime), \fmod3.kr(0.33, lagTime)], 0, [\fmoda1.kr(1, lagTime), \fmoda2.kr(1, lagTime), \fmoda3.kr(1, lagTime)]), SinOsc.kr([\pmod1.kr(0.1, lagTime), \pmod2.kr(0.2, lagTime), \pmod3.kr(0.3, lagTime)], 0, 2pi), SinOsc.kr([\amod1.kr(0.01, lagTime), \amod2.kr(0.02, lagTime), \amod3.kr(0.03, lagTime)], 0, [\amoda1.kr(0.05, lagTime), \amoda2.kr(0.05, lagTime), \amoda3.kr(0.05, lagTime)])), SinOsc.kr(SinOsc.kr(SinOsc.kr(\smod.kr(0.13, lagTime), 0, \smoda.kr(5, lagTime), \smodm.kr(6, lagTime)), 0, \smodaa.kr(8, lagTime), \smodmm.kr(50, lagTime)), 0, 1, 1), \amp.kr(0.7, lagTime), SinOsc.kr(\cmod.kr(1.2, lagTime), 0, \cmoda.kr(0.6, lagTime)));
							};

							// ~currentControlBusSynthPreset = NdefPreset(Ndef(\a));
							// ~currentControlBusSynthPreset1 = NodeProxyPreset(~controlBusSynth[5]);

							~currentControlBusSynthGUIContainer = Window("NdefGui").setTopLeftBounds(/*Rect(0, 70, 390, 180)*/ Rect(320*~xSizeMul, 504*~ySizeMul, 396*~xSizeMul, 570*~ySizeMul)).onClose_({~controlBusSynthGUIContainerCheck = 0; SkipJack.all.as(Array).do { |i| if (i.name == "_anon_", { i.stop /*i.name.postln*/}) } }).alwaysOnTop_(true).front;
							// ~currentControlBusSynthGUIContainer.addFlowLayout;
							~currentControlBusSynthGUIPreset = ProxyPresetGui(~currentControlBusSynthPreset1, parent: ~currentControlBusSynthGUIContainer, bounds: Rect(2*~xSizeMul, 2*~ySizeMul, 420*~xSizeMul, 30*~ySizeMul));
							// // Mais déclenchement de 2 SkipJack quand NdefGUI lancé avec L enfoncé ??? - 1 stoppé avec : makeSkip: false ?????????
							~currentControlBusSynthGUI = NdefGui.new(~controlBusSynth[0][5], numItems: 28, parent: ~currentControlBusSynthGUIContainer, bounds: Rect(2*~xSizeMul, 62*~ySizeMul, 384*~xSizeMul, 120*~ySizeMul), makeSkip: true, options: /*NdefGui.control*/ [ \name, \pausR, \sendR, \poll, \ed, \scope ]);

							// pass in functions to add your own elements, such as:
							// \zoink -> { |ndgui| Button(ndgui.zone, 60@20).states_([["zoink"]]).action_({ ndgui.object.zoink }) };

							~currentControlBusSynthRandView = RoundButton(~currentControlBusSynthGUIContainer, Rect(260*~xSizeMul, 62*~ySizeMul, 40*~xSizeMul, 18*~ySizeMul))
							.states_([["\Rand", Color.black, Color.green]])
							.font_(Font("Verdana",9*~fontSizeMul))
							.action_({|i|
								// ~currentControlBusSynthPreset.setRand(~currentControlBusSynthRand/*, except: */);
								// Comme except ne marche pas - pour ne pas faire de random sur le limiter ? -> mais pas de limiter en kr
								/*~controlBusSynth[5].controlKeys*/[ 'lagTime', 'freq1', 'freq2', 'freq3', 'fmod1', 'fmod2', 'fmod3', 'fmoda1', 'fmoda2', 'fmoda3', 'pmod1', 'pmod2', 'pmod3', 'amod1', 'amod2', 'amod3', 'amoda1', 'amoda2', 'amoda3', 'smod', 'smoda', 'smodm', 'smodaa', 'smodmm', 'amp', 'cmod', 'cmoda' ].do{ |k|
									if (k!=\lagTime /*and: {k!=\amp}*/, { /*k.postln;*/
										~controlBusSynth[0][5].set(k, k.asSpec.map(1.0.rand));
									});
								};
							});

							// retiré car setRand n'accepte pas de except ???
							/*~currentControlBusSynthRandSpec = ControlSpec(0, 1, \lin, 0.01);
							~currentControlBusSynthRandView = SmoothSlider(~currentControlBusSynthGUIContainer,  Rect(260, 62, 60, 18))
							.action_({ |view| ~currentControlBusSynthRand = ~currentControlBusSynthRandSpec.map(view.value);
							view.string = "%".format(~currentControlBusSynthRand);
							})
							.font_(Font("Verdana", 9))
							.background_(Color.magenta)
							.hilightColor_(~sliderHilightColor)
							.stringColor_(Color.white)
							.border_(~border)
							.borderColor_(~borderColor)
							.valueAction_(1)
							.doAction;*/

							~groups[0][~tracksValue].map(~controlBusTypeArg, ~controlBus[0][5]);
							~controlBusSynthGUIContainerCheck = 1;

						}, {

							Spec.add(\lagTime, #[0, 60, \lin, 0, 1]);
							Spec.add(\amp, #[0, 1, \lin, 0, 1]);
							Spec.add(\limiterlevel, #[0, 1, \lin, 0, 0.1]);
							Spec.add(\freq1, #[20, 10000, \exp, 0, 100]);
							Spec.add(\freq2, #[20, 10000, \exp, 0, 200]);
							Spec.add(\freq3, #[20, 10000, \exp, 0, 300]);
							Spec.add(\fmod1, #[0.001, 100, \exp, 0, 0.11]);
							Spec.add(\fmod2, #[0.001, 100, \exp, 0, 0.22]);
							Spec.add(\fmod3, #[0.001, 100, \exp, 0, 0.33]);
							Spec.add(\fmoda1, #[0, 100, \lin, 0, 1]);
							Spec.add(\fmoda2, #[0, 100, \lin, 0, 1]);
							Spec.add(\fmoda3, #[0, 100, \lin, 0, 1]);
							Spec.add(\pmod1, #[0.001, 100, \exp, 0, 0.1]);
							Spec.add(\pmod2, #[0.001, 100, \exp, 0, 0.2]);
							Spec.add(\pmod3, #[0.001, 100, \exp, 0, 0.3]);
							Spec.add(\amod1, #[0.001, 100, \exp, 0, 0.01]);
							Spec.add(\amod2, #[0.001, 100, \exp, 0, 0.02]);
							Spec.add(\amod3, #[0.001, 100, \exp, 0, 0.03]);
							Spec.add(\amoda1, #[0, 10, \lin, 0, 0.05]);
							Spec.add(\amoda2, #[0, 10, \lin, 0, 0.05]);
							Spec.add(\amoda3, #[0, 10, \lin, 0, 0.05]);
							Spec.add(\smod, #[0.001, 100, \exp, 0, 0.13]);
							Spec.add(\smoda, #[0, 100, \lin, 0, 5]);
							Spec.add(\smodm, #[0, 100, \lin, 0, 6]);
							Spec.add(\smodaa, #[0, 100, \lin, 0, 8]);
							Spec.add(\smodmm, #[0, 100, \lin, 0, 50]);
							Spec.add(\cmod, #[0.001, 100, \exp, 0, 1.2]);
							Spec.add(\cmoda, #[0, 10, \lin, 0, 0.6]);

							~controlBusSynth[0][5].source = {| lagTime=1 |
								LeakDC.kr(Mix(SinOsc.kr([\freq1.kr(100, lagTime), \freq2.kr(200, lagTime), \freq3.kr(300, lagTime)])+SinOsc.kr([\fmod1.kr(0.11, lagTime), \fmod2.kr(0.22, lagTime), \fmod3.kr(0.33, lagTime)], 0, [\fmoda1.kr(1, lagTime), \fmoda2.kr(1, lagTime), \fmoda3.kr(1, lagTime)]), SinOsc.kr([\pmod1.kr(0.1, lagTime), \pmod2.kr(0.2, lagTime), \pmod3.kr(0.3, lagTime)], 0, 2pi), SinOsc.kr([\amod1.kr(0.01, lagTime), \amod2.kr(0.02, lagTime), \amod3.kr(0.03, lagTime)], 0, [\amoda1.kr(0.05, lagTime), \amoda2.kr(0.05, lagTime), \amoda3.kr(0.05, lagTime)])), SinOsc.kr(SinOsc.kr(SinOsc.kr(\smod.kr(0.13, lagTime), 0, \smoda.kr(5, lagTime), \smodm.kr(6, lagTime)), 0, \smodaa.kr(8, lagTime), \smodmm.kr(50, lagTime)), 0, 1, 1), \amp.kr(0.7, lagTime), SinOsc.kr(\cmod.kr(1.2, lagTime), 0, \cmoda.kr(0.6, lagTime)));
							};

							~currentControlBusSynthGUIContainer.setTopLeftBounds(Rect(320, 526, 396, 570));
							~currentControlBusSynthGUIPreset.object_(~currentControlBusSynthPreset1);

							~currentControlBusSynthRandView.action_({|i|
								// ~currentControlBusSynthPreset.setRand(~currentControlBusSynthRand/*, except: */);
								// Comme except ne marche pas - pour ne pas faire de random sur le limiter ? -> mais pas de limiter en kr
								/*~controlBusSynth[5].controlKeys*/[ 'lagTime', 'freq1', 'freq2', 'freq3', 'fmod1', 'fmod2', 'fmod3', 'fmoda1', 'fmoda2', 'fmoda3', 'pmod1', 'pmod2', 'pmod3', 'amod1', 'amod2', 'amod3', 'amoda1', 'amoda2', 'amoda3', 'smod', 'smoda', 'smodm', 'smodaa', 'smodmm', 'amp', 'cmod', 'cmoda' ].do{ |k|
									if (k!=\lagTime /*and: {k!=\amp}*/, { /*k.postln;*/
										~controlBusSynth[0][5].set(k, k.asSpec.map(1.0.rand));
									});
								};
							});

							~groups[0][~tracksValue].map(~controlBusTypeArg, ~controlBus[0][5]);
						});
					}
					// { ~controlRandFixCollection.(par: \amp, func: 0, val: 1.5, post: 1) }
					,

					// Avec shift
					/*$J*/ 106, { ~nbOfServers.do { |s| ~controlRandFixCollection.(par: \amp, func: 0, val: 1.3, post: 1, serv: s) } }, // 5



					/*$K*/ 75, { // 8
						// Création d'une GUI
						if (~controlBusSynthGUIContainerCheck == 0, {

							Spec.add(\lagTime, [0, 60, \lin, 0.01, 1]);
							Spec.add(\freqC1, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\ratio1, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\modIndex1, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\amp1, [0.01, 50, \exp, 0.01, 0.3]);
							Spec.add(\rMin, [-10, 10, \lin, 0.01, 0]);
							Spec.add(\rMax, [-10, 10, \lin, 0.01, 1]);
							// Spec.add(\limiter, [0, 1, \lin, 0.01, 0.1]);
							~controlBusSynth[0][5].source = { | lagTime = 1/*freq = 100, ratio = 20, modIndex = 10, amp = 0.3*/ /*, limiter = 0.1*/|
								var freq = \freqC1.kr(100, lagTime);
								var modulator = SinOsc.kr(freq * \ratio1.kr(20, lagTime), 0, \modIndex1.kr(10, lagTime), 1);
								/*Limiter.kr(*/SinOsc.kr(freq * modulator, 0, \amp1.kr(0.3, lagTime)).range(\rMin.kr(0, lagTime), \rMax.kr(1, lagTime))/*, limiter)*/; // Carrier
							};
							/*
							~controlBusSynth[5].source = { |freqM=0.23, mulM=200, addM=100, ampM=10|
							SinOsc.kr(SinOsc.kr(freqM)*mulM + addM, 0, ampM) }; // FM
							*/

							// ~currentControlBusSynthPreset = NdefPreset(Ndef(\a));
							// ~currentControlBusSynthPreset2 = NodeProxyPreset(~controlBusSynth[5]);

							~currentControlBusSynthGUIContainer = Window("NdefGui").setTopLeftBounds(/*Rect(0, 70, 390, 180)*/ Rect(320*~xSizeMul, 504*~ySizeMul, 396*~xSizeMul, 208*~ySizeMul)).onClose_({~controlBusSynthGUIContainerCheck = 0; SkipJack.all.as(Array).do { |i| if (i.name == "_anon_", { i.stop /*i.name.postln*/}) } }).alwaysOnTop_(true).front;
							// ~currentControlBusSynthGUIContainer.addFlowLayout;
							~currentControlBusSynthGUIPreset = ProxyPresetGui(~currentControlBusSynthPreset2, parent: ~currentControlBusSynthGUIContainer, bounds: Rect(2*~xSizeMul, 2*~ySizeMul, 420*~xSizeMul, 30*~ySizeMul));
							// // Mais déclenchement de 2 SkipJack quand NdefGUI lancé avec L enfoncé ??? - 1 stoppé avec : makeSkip: false ?????????
							~currentControlBusSynthGUI = NdefGui.new(~controlBusSynth[0][5], numItems: /*7*/ 28, parent: ~currentControlBusSynthGUIContainer, bounds: Rect(2*~xSizeMul, 62*~ySizeMul, 384*~xSizeMul, 130*~ySizeMul), makeSkip: true, options: /*NdefGui.control*/ [ \name, \pausR, \sendR, \poll, \ed, \scope ]);

							~currentControlBusSynthRandView = RoundButton(~currentControlBusSynthGUIContainer, Rect(260*~xSizeMul, 62*~ySizeMul, 40*~xSizeMul, 18*~ySizeMul))
							.states_([["\Rand", Color.black, Color.green]])
							.font_(Font("Verdana",9*~fontSizeMul))
							.action_({|i|
								// ~currentControlBusSynthPreset.setRand(~currentControlBusSynthRand/*, except: */);
								// Comme except ne marche pas - pour ne pas faire de random sur le limiter ? -> mais pas de limiter en kr
								/*~controlBusSynth[5].controlKeys*/[ 'lagTime', 'freqC1', 'ratio1', 'modIndex1', 'rMin', 'rMax' ].do{ |k|
									if (k!=\lagTime and: {k!=\rMin} and: {k!=\rMax}, { /*k.postln;*/
										~controlBusSynth[0][5].set(k, k.asSpec.map(1.0.rand));
									});
								};
							});

							~groups[0][~tracksValue].map(~controlBusTypeArg, ~controlBus[0][5]);
							~controlBusSynthGUIContainerCheck = 1;

						}, {

							Spec.add(\lagTime, [0, 60, \lin, 0.01, 1]);
							Spec.add(\freqC1, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\ratio1, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\modIndex1, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\amp1, [0.01, 50, \exp, 0.01, 0.3]);
							Spec.add(\rMin, [-10, 10, \lin, 0.01, 0]);
							Spec.add(\rMax, [-10, 10, \lin, 0.01, 1]);
							// Spec.add(\limiter, [0, 1, \lin, 0.01, 0.1]);
							~controlBusSynth[0][5].source = { | lagTime = 1/*freq = 100, ratio = 20, modIndex = 10, amp = 0.3*/ /*, limiter = 0.1*/|
								var freq = \freqC1.kr(100, lagTime);
								var modulator = SinOsc.kr(freq * \ratio1.kr(20, lagTime), 0, \modIndex1.kr(10, lagTime), 1);
								/*Limiter.kr(*/SinOsc.kr(freq * modulator, 0, \amp1.kr(0.3, lagTime)).range(\rMin.kr(0, lagTime), \rMax.kr(1, lagTime))/*, limiter)*/; // Carrier
							};
							/*
							~controlBusSynth[5].source = { |freqM=0.23, mulM=200, addM=100, ampM=10|
							SinOsc.kr(SinOsc.kr(freqM)*mulM + addM, 0, ampM) }; // FM
							*/

							~currentControlBusSynthGUIContainer.setTopLeftBounds(Rect(320*~xSizeMul, 526*~ySizeMul, 396*~xSizeMul, 208*~ySizeMul));
							~currentControlBusSynthGUIPreset.object_(~currentControlBusSynthPreset2);

							~currentControlBusSynthRandView.action_({|i|
								// ~currentControlBusSynthPreset.setRand(~currentControlBusSynthRand/*, except: */);
								// Comme except ne marche pas - pour ne pas faire de random sur le limiter ? -> mais pas de limiter en kr
								/*~controlBusSynth[5].controlKeys*/[ 'lagTime', 'freqC1', 'ratio1', 'modIndex1', 'rMin', 'rMax' ].do{ |k|
									if (k!=\lagTime and: {k!=\rMin} and: {k!=\rMax}, { /*k.postln;*/
										~controlBusSynth[0][5].set(k, k.asSpec.map(1.0.rand));
									});
								};
							});

							~groups[0][~tracksValue].map(~controlBusTypeArg, ~controlBus[0][5]);
						});
					}
					// { var a = 3.0; if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: 0, val: a, post: 1); ~controlRandFixCollection.(par: \amp, func: 0, val: 1.5, post: 1); }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: 0, val: a, post: 1); ~controlRandFixCollection.(par: \amp, func: 0, val: 1.5, post: 1); } ) }
					,

					// Avec shift
					/*$K*/ 107, { var a = 3.0;
						~nbOfServers.do { |s| if (~controlBusSynth5FadeTime < 3, { ~controlRandFixCollection.(par: ~controlBusTypeArg, func: 0, val: a, post: 1, serv: s); ~controlRandFixCollection.(par: \amp, func: 0, val: 1.3, post: 1, serv: s); }, { ~controlRandLineCollection.(par: ~controlBusTypeArg, func: 0, val: a, post: 1, serv: s); ~controlRandFixCollection.(par: \amp, func: 0, val: 1.3, post: 1, serv: s); } ) } }, // 5


					/*$L, { // 9
					// Création d'une GUI
					if (~controlBusSynthGUIContainerCheck == 0, {
					~currentControlBusSynthGUIContainer = Window("NdefGui").setTopLeftBounds( Rect(0, 160, 340, 120)).onClose_({~controlBusSynthGUIContainerCheck = 0; SkipJack.all.as(Array).do { |i| if (i.name == "_anon_", { i.stop /*i.name.postln*/}) } }).alwaysOnTop_(true).front;
					// // Mais déclenchement de 2 SkipJack quand NdefGUI lancé avec L enfoncé ??? - 1 stoppé avec : makeSkip: false ?????????
					~currentControlBusSynthGUI = NdefGui.new(numItems: 5, parent: ~currentControlBusSynthGUIContainer, bounds: Rect(5, 5, 340, 120), makeSkip: false, options: NdefGui.control)/*.gui.alwaysOnTop_(true)*/;
					~currentControlBusSynthGUI.object_(~controlBusSynth[5]);

					/*
					~controlBusSynth[5].source = { |freqM=0.23, mulM=200, addM=100, ampM=10|
					SinOsc.kr(SinOsc.kr(freqM)*mulM + addM, 0, ampM) }; // FM
					Spec.add(\freqM, [0.1, 20000, \exp, 0.01, 10]);
					Spec.add(\mulM, [0.1, 1000, \exp, 0.01, 10]);
					Spec.add(\addM, [0.1, 1000, \exp, 0.01, 10]);
					Spec.add(\ampM, [0.1, 1000, \exp, 0.01, 10]);
					*/

					~controlBusSynth[5].source = { |freq = 100, ratio = 20, mod_index = 10, amp = 0.3|
					var modulator = SinOsc.kr(freq * ratio, 0, mod_index, 1);
					SinOsc.kr(freq * modulator, 0, amp); // Carrier
					};
					Spec.add(\freq, [0.1, 20000, \exp, 0.01, 100]);
					Spec.add(\ratio, [0.1, 100, \lin, 0.01, 20]);
					Spec.add(\mod_index, [0.1, 100, \lin, 0.01, 10]);
					Spec.add(\amp, [0, 10, \lin, 0.01, 0.3]);

					~groups[~tracksValue].map(~controlBusTypeArg, ~controlBus[5]);
					~controlBusSynthGUIContainerCheck = 1;

					}, {

					/*~controlBusSynth[5].source = { |freqM=0.23, mulM=200, addM=100, ampM=10|
					SinOsc.kr(SinOsc.kr(freqM)*mulM + addM, 0, ampM)
					}; // FM
					Spec.add(\freqM, [0.1, 20000, \exp, 0.01, 10]);
					Spec.add(\mulM, [0.1, 1000, \exp, 0.01, 10]);
					Spec.add(\addM, [0.1, 1000, \exp, 0.01, 10]);
					Spec.add(\ampM, [0.1, 1000, \exp, 0.01, 10]);*/

					~controlBusSynth[5].source = { |freq = 100, ratio = 20, mod_index = 10, amp = 0.3|
					var modulator = SinOsc.kr(freq * ratio, 0, mod_index, 1);
					SinOsc.kr(freq * modulator, 0, amp); // Carrier
					};
					Spec.add(\freq, [0.1, 20000, \exp, 0.01, 100]);
					Spec.add(\ratio, [0.1, 100, \lin, 0.01, 20]);
					Spec.add(\mod_index, [0.1, 100, \lin, 0.01, 10]);
					Spec.add(\amp, [0, 10, \lin, 0.01, 0.3]);

					~groups[~tracksValue].map(~controlBusTypeArg, ~controlBus[5]);
					});
					}*/

					/*$L*/ 76, { // 9
						// Création d'une GUI
						if (~controlBusSynthGUIContainerCheck == 0, {

							/*Spec.add(\lagTime, [0, 60, \lin, 0.01, 1]);
							Spec.add(\freqC2, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\ratio2, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\modIndex2, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\amp2, [0, 10, \lin, 0.01, 0.3]);
							// Spec.add(\limiter, [0, 1, \lin, 0.01, 0.1]);
							~controlBusSynth[5].source = { | lagTime = 1/*freq = 100, ratio = 20, modIndex = 10, amp = 0.3*/ /*, limiter = 0.1*/|
							var freq = \freqC2.kr(100, lagTime);
							var modulator = SinOsc.kr(freq * \ratio2.kr(20, lagTime), 0, \modIndex2.kr(10, lagTime), 1);
							/*Limiter.kr(*/SinOsc.kr(freq * modulator, 0, \amp2.kr(0.3, lagTime))/*, limiter)*/; // Carrier
							};*/
							Spec.add(\lagTime, [0, 60, \lin, 0.01, 1]);

							Spec.add(\CfreqC2, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\Cratio2, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\CmodI2, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\Camp2, [0, 10, \lin, 0.01, 0.3]);

							Spec.add(\RfreqC2, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\Rratio2, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\RmodI2, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\Ramp2, [0, 10, \lin, 0.01, 0.3]);

							Spec.add(\MfreqC2, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\Mratio2, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\MmodI2, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\Mamp2, [0, 10, \lin, 0.01, 0.3]);

							Spec.add(\amp2, [0.01, 50, \exp, 0.01, 0.3]);
							Spec.add(\rMin, [-10, 10, \lin, 0.01, 0]);
							Spec.add(\rMax, [-10, 10, \lin, 0.01, 1]);

							~controlBusSynth[0][5].source = { | lagTime = 1 |
								var freqC = \CfreqC2.kr(100, lagTime); // Carrier Carrier
								var freqR = \RfreqC2.kr(100, lagTime); // Carrier Ratio
								var freqM = \MfreqC2.kr(100, lagTime); // Carrier ModIndex

								var modulatorC = SinOsc.kr(freqC * \Cratio2.kr(20, lagTime), 0, \CmodI2.kr(10, lagTime), 1);
								var carrierC = SinOsc.kr(freqC * modulatorC, 0, \Camp2.kr(0.3, lagTime)); // Carrier Carrier

								var modulatorR = SinOsc.kr(freqR * \Rratio2.kr(20, lagTime), 0, \RmodI2.kr(10, lagTime), 1);
								var carrierR = SinOsc.kr(freqR * modulatorR, 0, \Ramp2.kr(0.3, lagTime)); // Carrier Ratio

								var modulatorM = SinOsc.kr(freqM * \Mratio2.kr(20, lagTime), 0, \MmodI2.kr(10, lagTime), 1);
								var carrierM = SinOsc.kr(freqM * modulatorM, 0, \Mamp2.kr(0.3, lagTime)); // Carrier ModIndex

								var modulator = SinOsc.kr(carrierC * carrierR, 0, carrierM, 1);
								SinOsc.kr(carrierC * modulator, 0, \amp2.kr(0.3, lagTime)).range(\rMin.kr(0, lagTime), \rMax.kr(1, lagTime)); // Carrier
							};

							// ~currentControlBusSynthPreset = NdefPreset(Ndef(\a));
							// ~currentControlBusSynthPreset3 = NodeProxyPreset(~controlBusSynth[5]);

							~currentControlBusSynthGUIContainer = Window("NdefGui").setTopLeftBounds(/*Rect(0, 70, 390, 180)*/ Rect(320*~xSizeMul, 504*~ySizeMul, 396*~xSizeMul, 370*~ySizeMul)).onClose_({~controlBusSynthGUIContainerCheck = 0; SkipJack.all.as(Array).do { |i| if (i.name == "_anon_", { i.stop /*i.name.postln*/}) } }).alwaysOnTop_(true).front;
							// ~currentControlBusSynthGUIContainer.addFlowLayout;
							~currentControlBusSynthGUIPreset = ProxyPresetGui(~currentControlBusSynthPreset3, parent: ~currentControlBusSynthGUIContainer, bounds: Rect(2*~xSizeMul, 2*~ySizeMul, 420*~xSizeMul, 30*~ySizeMul));
							// // Mais déclenchement de 2 SkipJack quand NdefGUI lancé avec L enfoncé ??? - 1 stoppé avec : makeSkip: false ?????????
							~currentControlBusSynthGUI = NdefGui.new(~controlBusSynth[0][5], numItems: /*16*/ 28, parent: ~currentControlBusSynthGUIContainer, bounds: Rect(2*~xSizeMul, 62*~ySizeMul, 384*~xSizeMul, 120*~ySizeMul), makeSkip: true, options: /*NdefGui.control*/ [ \name, \pausR, \sendR, \poll, \ed, \scope ]);

							~currentControlBusSynthRandView = RoundButton(~currentControlBusSynthGUIContainer, Rect(260*~xSizeMul, 62*~ySizeMul, 40*~xSizeMul, 18*~ySizeMul))
							.states_([["\Rand", Color.black, Color.green]])
							.font_(Font("Verdana",9*~fontSizeMul))
							.action_({|i|
								// ~currentControlBusSynthPreset.setRand(~currentControlBusSynthRand/*, except: */);
								// Comme except ne marche pas - pour ne pas faire de random sur le limiter ? -> mais pas de limiter en kr
								/*~controlBusSynth[5].controlKeys.cs*/[ 'lagTime', 'CfreqC2', 'RfreqC2', 'MfreqC2', 'Cratio2', 'CmodI2', 'Camp2', 'Rratio2', 'RmodI2', 'Ramp2', 'Mratio2', 'MmodI2', 'Mamp2', 'amp2' ].do{ |k|
									if (k!=\lagTime and: {k!=\amp2}, { /*k.postln;*/
										~controlBusSynth[0][5].set(k, k.asSpec.map(1.0.rand));
									});
								};
							});

							~groups[0][~tracksValue].map(~controlBusTypeArg, ~controlBus[0][5]);
							~controlBusSynthGUIContainerCheck = 1;

						}, {

							/* // Simple FM
							Spec.add(\lagTime, [0, 60, \lin, 0.01, 1]);
							Spec.add(\freqC2, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\ratio2, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\modIndex2, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\amp2, [0, 10, \lin, 0.01, 0.3]);
							// Spec.add(\limiter, [0, 1, \lin, 0.01, 0.1]);
							~controlBusSynth[5].source = { | lagTime = 1/*freq = 100, ratio = 20, modIndex = 10, amp = 0.3*/ /*, limiter = 0.1*/|
							var freq = \freqC2.kr(100, lagTime);
							var modulator = SinOsc.kr(freq * \ratio2.kr(20, lagTime), 0, \modIndex2.kr(10, lagTime), 1);
							/*Limiter.kr(*/SinOsc.kr(freq * modulator, 0, \amp2.kr(0.3, lagTime))/*, limiter)*/; // Carrier
							};*/

							/* // FM dont les 3 arguments sont controlés par des FM -> pas terrible
							Spec.add(\lagTime, [0, 60, \lin, 0.01, 1]);

							Spec.add(\CfreqC2, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\Cratio2, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\CmodI2, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\Camp2, [0, 10, \lin, 0.01, 0.3]);

							Spec.add(\RfreqC2, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\Rratio2, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\RmodI2, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\Ramp2, [0, 10, \lin, 0.01, 0.3]);

							Spec.add(\MfreqC2, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\Mratio2, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\MmodI2, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\Mamp2, [0, 10, \lin, 0.01, 0.3]);

							Spec.add(\amp2, [0.01, 50, \exp, 0.01, 0.3]);
							Spec.add(\rMin, [-10, 10, \lin, 0.01, 0]);
							Spec.add(\rMax, [-10, 10, \lin, 0.01, 1]);

							~controlBusSynth[5].source = { | lagTime = 1 |
							var freqC = \CfreqC2.kr(100, lagTime); // Carrier Carrier
							var freqR = \RfreqC2.kr(100, lagTime); // Carrier Ratio
							var freqM = \MfreqC2.kr(100, lagTime); // Carrier ModIndex

							var modulatorC = SinOsc.kr(freqC * \Cratio2.kr(20, lagTime), 0, \CmodI2.kr(10, lagTime), 1);
							var carrierC = SinOsc.kr(freqC * modulatorC, 0, \Camp2.kr(0.3, lagTime)); // Carrier Carrier

							var modulatorR = SinOsc.kr(freqR * \Rratio2.kr(20, lagTime), 0, \RmodI2.kr(10, lagTime), 1);
							var carrierR = SinOsc.kr(freqR * modulatorR, 0, \Ramp2.kr(0.3, lagTime)); // Carrier Ratio

							var modulatorM = SinOsc.kr(freqM * \Mratio2.kr(20, lagTime), 0, \MmodI2.kr(10, lagTime), 1);
							var carrierM = SinOsc.kr(freqM * modulatorM, 0, \Mamp2.kr(0.3, lagTime)); // Carrier ModIndex

							var modulator = SinOsc.kr(carrierC * carrierR, 0, carrierM, 1);
							SinOsc.kr(carrierC * modulator, 0, \amp2.kr(0.3, lagTime)).range(\rMin.kr(0, lagTime), \rMax.kr(1, lagTime)); // Carrier
							};*/
							Spec.add(\lagTime, [0, 60, \lin, 0.01, 1]);

							Spec.add(\CfreqC2, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\Cratio2, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\CmodI2, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\Camp2, [0, 10, \lin, 0.01, 0.3]);

							Spec.add(\RfreqC2, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\Rratio2, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\RmodI2, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\Ramp2, [0, 10, \lin, 0.01, 0.3]);

							Spec.add(\MfreqC2, [0.1, 20000, \exp, 0.01, 100]);
							Spec.add(\Mratio2, [0.1, 100, \lin, 0.01, 20]);
							Spec.add(\MmodI2, [0.1, 100, \lin, 0.01, 10]);
							Spec.add(\Mamp2, [0, 10, \lin, 0.01, 0.3]);

							Spec.add(\amp2, [0.01, 50, \exp, 0.01, 0.3]);
							Spec.add(\rMin, [-10, 10, \lin, 0.01, 0]);
							Spec.add(\rMax, [-10, 10, \lin, 0.01, 1]);

							~controlBusSynth[0][5].source = { | lagTime = 1 |
								var freqC = \CfreqC2.kr(100, lagTime); // Carrier Carrier
								var freqR = \RfreqC2.kr(100, lagTime); // Carrier Ratio
								var freqM = \MfreqC2.kr(100, lagTime); // Carrier ModIndex

								var modulatorC = SinOsc.kr(freqC * \Cratio2.kr(20, lagTime), 0, \CmodI2.kr(10, lagTime), 1);
								var carrierC = SinOsc.kr(freqC * modulatorC, 0, \Camp2.kr(0.3, lagTime)); // Carrier Carrier

								var modulatorR = SinOsc.kr(freqR * \Rratio2.kr(20, lagTime), 0, \RmodI2.kr(10, lagTime), 1);
								var carrierR = SinOsc.kr(freqR * modulatorR, 0, \Ramp2.kr(0.3, lagTime)); // Carrier Ratio

								var modulatorM = SinOsc.kr(freqM * \Mratio2.kr(20, lagTime), 0, \MmodI2.kr(10, lagTime), 1);
								var carrierM = SinOsc.kr(freqM * modulatorM, 0, \Mamp2.kr(0.3, lagTime)); // Carrier ModIndex

								var modulator = SinOsc.kr(carrierC * carrierR, 0, carrierM, 1);
								SinOsc.kr(carrierC * modulator, 0, \amp2.kr(0.3, lagTime)).range(\rMin.kr(0, lagTime), \rMax.kr(1, lagTime)); // Carrier
							};

							~currentControlBusSynthGUIContainer.setTopLeftBounds(Rect(320, 526, 396, 370));
							~currentControlBusSynthGUIPreset.object_(~currentControlBusSynthPreset3);

							~currentControlBusSynthRandView.action_({|i|
								// ~currentControlBusSynthPreset.setRand(~currentControlBusSynthRand/*, except: */);
								// Comme except ne marche pas - pour ne pas faire de random sur le limiter ? -> mais pas de limiter en kr
								/*~controlBusSynth[5].controlKeys.cs*/[ 'lagTime', 'CfreqC2', 'RfreqC2', 'MfreqC2', 'Cratio2', 'CmodI2', 'Camp2', 'Rratio2', 'RmodI2', 'Ramp2', 'Mratio2', 'MmodI2', 'Mamp2', 'amp2' ].do{ |k|
									if (k!=\lagTime and: {k!=\amp2}, { /*k.postln;*/
										~controlBusSynth[0][5].set(k, k.asSpec.map(1.0.rand));
									});
								};
							});

							~groups[0][~tracksValue].map(~controlBusTypeArg, ~controlBus[0][5]);
						});
					},



					/*168.asAscii, { // 11
					~controlBusSynth[5].source = { DC.kr(150.0) }; ~groups[~tracksValue].map(\rate, ~controlBus[5]);
					},
					42.asAscii, { // 12
					~controlBusSynth[5].source = { DC.kr(200.0) }; ~groups[~tracksValue].map(\rate, ~controlBus[5]);
					},*/

				);
		}});

		[~controlWindow, ~globalWindow].collect { |i| i.view./*global*/keyDownAction_(~keyActions) });



	// ne marche pas ???
	/*~currentControlBusSynthGUIContainer.view./*global*/keyDownAction_({ |view, char, mod, uni, key, key2|
	if (char == $H, {~currentControlBusSynthRandView.valueAction_(1)
	});
	});*/



	([~controlWindow, ~globalWindow].collect { |i| i.view./*global*/keyUpAction_({ |view, char, mod, uni, key, key2|
		if (key2 == 16777249, {~presetSelectionPrevent = 0});
	}) };
	);



}.value;




/*
Modulateur Vitesse de lecture FM :

// SC User List :
// Which parameter determines its pitch?



(
SynthDef(\fm, {
arg freq = 440;
var osc;

osc = SinOsc.kr(100, 0, 100, 100);
osc = SinOsc.ar(osc, 0, 0.8);

Out.ar(0, osc.dup)}
).play
)



Well i guess this will solve your question stated before.
arg {freq=34.7, freq1=44, freq2=55}
SinOsc.ar(SinOsc.ar(freq,0,freq1,freq2)),

So.. the first argument will be the cycles per second in which your oscillator runs.
mul: and, add: arguments will function as the space boundaries where by  these oscillation moves back and forth.
Perhaps you might think about chords design, like for instance, [C,G,D], where by substitution;
[60,67,74].midicps -  you will get values like - [261.62,391.99,587.32]
[58,63,65].midicps - you will get values like - [233.08, 311.126, 349.2]
[63,66,69].midicps
[61,67,70].midicps
and you might  change those values using a Pseq. Lets say:
(
Pbind(\instrument,\something,
\freq, Pseq([[261.62, 233.08],[311.1, 277.1]]) ,
\freq1,Pseq([[391.99, 311.12],[369.9, 391.9]])
\freq2,Pseq([[587,32, 349.2], [440.0, 466.1]])
)))



My usual FM formula:
arg freq = 440, ratio = 1, mod_index = 1, amp = 0.1;
modulator = SinOsc.ar(freq * ratio, 0, mod_index, 1);
carrier = SinOsc.ar(freq * modulator, 0, amp);
Actually, I use wavetable oscillators more often -- a more complex sound for no extra CPU use.
hjh



Shouldn't it be freq + modulator in the carrier line? Also, I'm confused by your add: 1 inside the modulator SinOsc. Why is it?
For Chip (the original poster) -- I keep these two bits of code in my "cheatsheet" for FM. They unpack some of the basic concepts more explicitly:
// Very basic, no use of index or ratio
(
{
var carrier, modulator, carrfreq, modfreq, freqdev;
carrfreq = 440;
modfreq = 5; // lower values for 'vibrato' effect; try higher numbers for modulation
freqdev = 50;
modulator = SinOsc.ar(modfreq, 0, freqdev);
carrier = SinOsc.ar(carrfreq + modulator, 0, 0.2);
}.play
)
// Now using modulation index based on formula i = d/m
(
{
var carrier, modulator, carrfreq, modfreq, freqdev, modindex;
carrfreq = 440;
modfreq = 15;
modindex = MouseY.kr(0.01, 5000, 'exponential');
freqdev = modfreq * modindex; // index = dev/modfreq, so dev = modfreq*index
modulator = SinOsc.ar(modfreq, 0, freqdev);
carrier = SinOsc.ar(carrfreq + modulator, 0, 0.2);
}.play;
)
I adapted these examples from this tutorial by Nick Collins: http://www.sussex.ac.uk/Users/nc81/modules/cm1/scfiles/2.4%20Modulation%20Synthesis.html
For a GUI-based exploration of the technique, I have four FM examples here (scroll down the page): http://sccode.org/bruno
Bruno



I interpret the modulation index so that an index of 1 causes the carrier frequency to vary between 0 and 2f. This means that the spectral effect of mod_index will be the same, regardless of frequency (except for aliasing, of course, always a potential issue in FM).
This means the modulator should be scaled by f:
modWave = SinOsc.ar(freq * ratio);
mod = modWave * mod_index * freq;
Then the carrier frequency is:
freq + modWave * mod_index * freq
These have a common factor, which can be transformed algebraically:
(1 + (modWave * mod_index)) * freq
... where the first bit could be expressed by giving modWave:
mul = mod_index
There's no particular efficiency gain one way or the other, but I got the feeling from my middle school algebra classes that "ab + a" is somehow less elegant than "a(b + 1)" and my coding style reflects that aesthetic bias.
hjh



you can also look at the PMOsc object,this is a complete carrier/modulator
pair for phase modulation, which sounds similar to FM

*/































// GUI MODULES

{ // Fonction Value pour RTM1 pour éviter ERROR: Selector table too big: too many classes, method selectors or function definitions in this function



	// GUI RHYTHM 1

	// Pour les NumberBox -> intérêt et utilisation de normalColor ??? // change the normal color for the box. won't change until next value change ???
	// ≠ entre RoundNumberBox & SmoothNumberBox ???
	// L'exemple de SmoothNumberBox montrant le changement de chaque unité à la fin du Help ne marche pas à la différence de RoundNumberBox ???
	// Améliorer & comprendre le changement d'unité de RoundNumberBox XXX
	// Comment changer la couleur de sélection de l'index ou la faire disparaitre quand pas sélectionné ???
	// Bug quand changement du NumberBox avec la palette graphique ???
	// voire exemple intéressant de synthèse dans le NumberBox avec simplement 1 SinOsc & 8 Allpass XXXXXXXXXXXXXX



	// Déclaration variables RHYTHM

	~dur = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~durTemp = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~dura = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;

	~rhythmFunction = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;

	// initialisation du ~displayRhythm pour éviter qu'il ne retourne 0
	~displayRhythm = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	// ~displayRhythm ="~rtmView.valueAction_( [ 4, [ [ 1, [ 1, 1, 1, 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ] ] ] .convertRhythm.linlin(0, 2 , 0, 1))" ! ~nbOfSeqs ! ~nbOfTracksX2;
	// ~displayRhythm = "~rhythmChange[ 0 ][ 0 ] = [ 4, [ [ 1, [ 1, 1, 1, 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ] ] ] ; ~rtmRangeView.valueAction_(~rtmRangeSpec[ 0 ][ 0 ].unmap([0,  ~rhythmChange[ 0 ][ 0 ].convertRhythm.maxItem * 2])); ~rtmView.valueAction_( ~rhythmChange[ 0 ][ 0 ].convertRhythm.linlin(0, ~rtmMax[ 0 ][ 0 ], 0, 1));" ! ~nbOfSeqs ! ~nbOfTracksX2;
	~rhythmChange = "[ 4, [ [ 1, [ 1, 1, 1, 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ] ] ] .convertRhythm" ! ~nbOfSeqs ! ~nbOfTracksX2;
	~tracks.collect { |tr|
		~seqs.collect { |seq|
			~displayRhythm[tr][seq] = "~rhythmChange["+tr+"]["+seq+"] = [ 4, [ [ 1, [ 1, 1, 1, 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ] ] ] ; ~rtmRangeView.valueAction_(~rtmRangeSpec["+tr+"]["+seq+"].unmap([0,  ~rhythmChange["+tr+"]["+seq+"].convertRhythm.maxItem * 2])); ~rtmView.valueAction_( ~rhythmChange["+tr+"]["+seq+"].convertRhythm.linlin(0, ~rtmMax["+tr+"]["+seq+"], 0, 1));"
	}};

	~configBeatsValue = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;

	~nbTotalBeats = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~pBeatView = 0 ! 6;
	~pBeat = {{0!6} ! ~nbOfSeqs} ! ~nbOfTracksX2; // necessary to do functions at the 2nd level of nesting
	~nbBeatView = 0 ! 6;
	~nbBeat = {{0!6} ! ~nbOfSeqs} ! ~nbOfTracksX2;
	~sumBeatView = 0 ! 6;
	~sumBeat = {{0!6} ! ~nbOfSeqs} ! ~nbOfTracksX2;
	~minSumBeatView = 0 ! 6;
	~minSumBeat = {{0!6} ! ~nbOfSeqs} ! ~nbOfTracksX2;
	~selectBeatView = 0 ! 6;
	~selectBeatValue = {{0!6} ! ~nbOfSeqs} ! ~nbOfTracksX2;

	~nbEvents = 4 ! ~nbOfSeqs ! ~nbOfTracksX2;



	~toTempo = 2; // ATTENTION Déclaration nécessaire pour calcul du "BPM" ci-dessous
	~nbTotalBeatsSpec = ControlSpec(1, 64, \lin, 1, 4);


	~nbTotalBeatsView = SmoothSlider(~patComp, Rect(2*~xSizeMul, 239*~ySizeMul, 320*~xSizeMul, 22*~ySizeMul))
	.action_({ |view|
		// Actualisation aussi faite du ~toTempoView dans le Global Visual Feedback
		/*(8.collect({|i| ~nbBeat[~tracksValue][~seqsValue][i]})).sum;*/
		// Correction du code pour faire le sum du collect seulement si ~pBeat > 0
		// var nb; nb = (6.collect({|i| (~pBeat[~tracksValue][~seqsValue][i] > 0).if ({~nbBeat[~tracksValue][~seqsValue][i]}, {0}) })).sum;

		if (~updateVisualPreset == 0, {
			~nbEvents[~tracksValue][~seqsValue] = (6.collect({|i| (~pBeat[~tracksValue][~seqsValue][i] > 0).if ({~nbBeat[~tracksValue][~seqsValue][i]}, {0}) })).sum;
			~nbTotalBeats[~tracksValue][~seqsValue] = ~nbTotalBeatsSpec.map(view.value);
			view.string = ("% Beats - % Ev in %s - ABPM: %").format(~nbTotalBeats[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue], ~nbEvents[~tracksValue][~seqsValue], (~nbTotalBeats[~tracksValue][~seqsValue] / ~toTempo * ~rtmMul[~tracksValue][~seqsValue]).round(0.01), ( ~nbEvents[~tracksValue][~seqsValue] / ~nbTotalBeats[~tracksValue][~seqsValue] * ~toTempo * 60 * ~rtmMul[~tracksValue][~seqsValue].reciprocal).round(0.01));
		});
	})
	.font_(Font("Verdana", 12*~fontSizeMul))
	.background_(Color.magenta)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.value_(~nbTotalBeatsSpec.unmap(4))
	.step_(1/64)
	.doAction;

	~durSelectionDefaultView = RoundButton(~patComp, Rect(325*~xSizeMul, 240*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["Def", Color.white, Color.blue]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({

		// if (~patFlag == 0, {

		~configBeatsView.valueAction_(0);
		~nbTotalBeatsView.valueAction_(~nbTotalBeatsSpec.unmap(4));
		5.do({|i| ~pBeatView[i+1].valueAction_(0)});
		5.do({|i| ~nbBeatView[i+1].valueAction_(1)});
		5.do({|i| ~sumBeatView[i+1].valueAction_(1)});
		5.do({|i| ~minSumBeatView[i+1].valueAction_(1)});
		~selectBeatView[0].valueAction_([ '  4 Ev', '4 Ev - Sum  4' ]);

		/*}, {~seqs.do {|i|

		}});*/

		/*
		~pBeatView[0].valueAction_(1);
		~nbBeatView[0].valueAction_(4);
		~sumBeatView[0].valueAction_(4);
		5.do({|i| ~pBeatView[i+1].valueAction_(0)});
		5.do({|i| ~nbBeatView[i+1].valueAction_(1)});
		5.do({|i| ~sumBeatView[i+1].valueAction_(1)});
		6.do({|i| ~minSumBeatView[i].valueAction_(1)});
		*/
	});

	// ~rtmFix = 1 ! ~nbOfTracksX2;
	~rtmFixView = RoundButton(~patComp, Rect(360*~xSizeMul, 240*~ySizeMul, 35*~xSizeMul, 20*~ySizeMul))
	.states_([["RFix", Color.white, Color.red], ["RVar", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul,true))
	.action_({ |i| ~rtmFix = i.value;
	})
	.valueAction_(1);


	// Config Beats Functions

	~initBeatFunc = {
		6.do {|a| ~pBeatView[a].valueAction_(0); ~nbBeatView[a].valueAction_(1); ~sumBeatView[a].valueAction_(1); ~minSumBeatView[a].valueAction_(1) };
		// pas la possibilité de le mettre dans le globalAction du feu EZMenu car est évalué après
		// Comment remettre à 0 aussi (cad aucun affichage) le PopUpTreeMenu ?????????
		// Voire si l'initialisation de toutes les boxes en plus du ~pBeat ne charge pas trop le CPU ?????????
	};

	~configBeatsViewFunc = [
		{ ~initBeatFunc.(); ~selectBeatView[0].valueAction_(['  4 Ev', '4 Ev - Sum  4']) }, // Const 4 Ev - Sum 4
		{|tr, seq| ~initBeatFunc.(); ~selectBeatView[0].valueAction_(['  4 Ev', '4 Ev - Sum  6']) }, // Const 4 Ev - Sum 6
		{|tr, seq| ~initBeatFunc.(); ~selectBeatView[0].valueAction_(['  4 Ev', '4 Ev - Sum  8']) }, // Const 4 Ev - Sum 8
		{|tr, seq| ~initBeatFunc.(); ~selectBeatView[0].valueAction_(['  8 Ev', '8 Ev - Sum  8']) }, // Const 8 Ev - Sum 8
		{|tr, seq| ~initBeatFunc.(); ~selectBeatView[0].valueAction_(['  8 Ev', '8 Ev - Sum 12']) }, // Const 8 Ev - Sum 12
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  2 Ev', '2 Ev - Sum  4']) } }, // Const 8 Ev - Sum 16
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  2 Ev', '2 Ev - Sum  8']) } }, // Const 8 Ev - Sum 32
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  2 Ev', '2 Ev - Sum 16']) } }, // Const 8 Ev - Sum 64
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  3 Ev', '3 Ev - Sum  3']) } }, // Const 12 Ev - Sum 12
		{|tr, seq| ~initBeatFunc.(); 2.do {|a| ~selectBeatView[a].valueAction_(['  6 Ev', '6 Ev - Sum  9']) } }, // Const 12 Ev - Sum 18
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  3 Ev', '3 Ev - Sum  6']) } }, // Const 12 Ev - Sum 24
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  3 Ev', '3 Ev - Sum  9']) } }, // Const 12 Ev - Sum 36
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  3 Ev', '3 Ev - Sum 18']) } }, // Const 12 Ev - Sum 72
		{|tr, seq| ~initBeatFunc.(); 2.do {|a| ~selectBeatView[a].valueAction_(['  8 Ev', '8 Ev - Sum  8']) } }, // Const 16 Ev - Sum 16
		{|tr, seq| ~initBeatFunc.(); 2.do {|a| ~selectBeatView[a].valueAction_(['  8 Ev', '8 Ev - Sum 12']) } }, // Const 16 Ev - Sum 24
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  4 Ev', '4 Ev - Sum  8']) } }, // Const 16 Ev - Sum 32
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  4 Ev', '4 Ev - Sum 12']) } }, // Const 16 Ev - Sum 48
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  4 Ev', '4 Ev - Sum 24']) } }, // Const 16 Ev - Sum 96
		{|tr, seq| ~initBeatFunc.(); 3.do {|a| ~selectBeatView[a].valueAction_(['  8 Ev', '8 Ev - Sum  8']) } }, // Const 24 Ev - Sum 24
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  6 Ev', '6 Ev - Sum 12']) } }, // Const 24 Ev - Sum 48
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  6 Ev', '6 Ev - Sum 18']) } }, // Const 24 Ev - Sum 72
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  6 Ev', '6 Ev - Sum 32']) } }, // Const 24 Ev - Sum 128
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  8 Ev', '8 Ev - Sum  8']) } }, // Const 32 Ev - Sum 32
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  8 Ev', '8 Ev - Sum 16']) } }, // Const 32 Ev - Sum 64
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['  8 Ev', '8 Ev - Sum 32']) } }, // Const 32 Ev - Sum 128
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_([' 12 Ev', '12 Ev - Sum 12']) } }, // Const 48 Ev - Sum 48
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_([' 12 Ev', '12 Ev - Sum 24']) } }, // Const 48 Ev - Sum 96
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_([' 12 Ev', '12 Ev - Sum 48']) } }, // Const 48 Ev - Sum 192
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_([' 16 Ev', '16 Ev - Sum 16']) } }, // Const 64 Ev - Sum 64
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_([' 16 Ev', '16 Ev - Sum 32']) } }, // Const 64 Ev - Sum 128
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_([' 16 Ev', '16 Ev - Sum 48']) } }, // Const 64 Ev - Sum 192
		{|tr, seq| ~initBeatFunc.(); 6.do {|a| ~selectBeatView[a].valueAction_([' 16 Ev', '16 Ev - Sum 16']) } }, // Const 96 Ev - Sum 96
		{|tr, seq| ~initBeatFunc.(); 6.do {|a| ~selectBeatView[a].valueAction_([' 16 Ev', '16 Ev - Sum 48']) } }, // Const 96 Ev - Sum 288
		{|tr, seq| ~initBeatFunc.(); 2.do {|a| ~selectBeatView[a].valueAction_(['100 Ev', '100 Ev - Sum 100']) } }, // Const 200 Ev - Sum 200
		{|tr, seq| ~initBeatFunc.(); 2.do {|a| ~selectBeatView[a].valueAction_(['100 Ev', '100 Ev - Sum 200']) } }, // Const 200 Ev - Sum 400
		{|tr, seq| ~initBeatFunc.(); 2.do {|a| ~selectBeatView[a].valueAction_(['100 Ev', '100 Ev - Sum 400']) } }, // Const 200 Ev - Sum 800
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['100 Ev', '100 Ev - Sum 100']) } }, // Const 400 Ev - Sum 400
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['100 Ev', '100 Ev - Sum 200']) } }, // Const 400 Ev - Sum 800
		{|tr, seq| ~initBeatFunc.(); 4.do {|a| ~selectBeatView[a].valueAction_(['100 Ev', '100 Ev - Sum 400']) } } // Const 400 Ev - Sum 1600
		/*'Total Random' ->{|i| // Random à créer XXXXXXXXXX directement sur les NumberBox
		~selectBeatView[0].tree.asSortedArray[1][1]
		~selectBeatView[0].valueAction_(rand([' 2 Ev', '2 Ev - Sum  2'],[' 2 Ev', '2 Ev - Sum  4'],[' 2 Ev', '2 Ev - Sum  6'],[' 2 Ev', '2 Ev - Sum  8']));
		~selectBeatView[1].valueAction_(['16 Ev', '16 Ev - Sum 48']);
		~selectBeatView[2].valueAction_(['16 Ev', '16 Ev - Sum 48']);
		~selectBeatView[3].valueAction_(['16 Ev', '16 Ev - Sum 48']);
		}*/
	];





	~selectBeatValueFunc = { |nb, i|
		~pBeat[~tracksValue][i][nb] = 1;
		~nbBeat[~tracksValue][i][nb] = (if (~selectBeatValue[~tracksValue][i][nb].asString.split($ )[4].asInteger > 0 , {~selectBeatValue[~tracksValue][i][nb].asString.split($ )[4].asInteger}, {~selectBeatValue[~tracksValue][i][nb].asString.split($ )[3].asInteger}));
		~sumBeat[~tracksValue][i][nb] = (case {~selectBeatValue[~tracksValue][i][nb].asString.split($ )[7].asInteger > 0} {~selectBeatValue[~tracksValue][i][nb].asString.split($ )[7].asInteger}
			{~selectBeatValue[~tracksValue][i][nb].asString.split($ )[8].asInteger > 0} {~selectBeatValue[~tracksValue][i][nb].asString.split($ )[8].asInteger}
			{~selectBeatValue[~tracksValue][i][nb].asString.split($ )[9].asInteger > 0} {~selectBeatValue[~tracksValue][i][nb].asString.split($ )[9].asInteger}
			{~selectBeatValue[~tracksValue][i][nb].asString.split($ )[10].asInteger > 0} {~selectBeatValue[~tracksValue][i][nb].asString.split($ )[10].asInteger});
		~minSumBeat[~tracksValue][i][nb] = 1;
	};

	~initBeatSFunc = {
		{ |i| 6.do {|a| ~pBeat[~tracksValue][i][a] = 0; ~nbBeat[~tracksValue][i][a] = 1; ~sumBeat[~tracksValue][i][a] = 1; ~minSumBeat[~tracksValue][i][a] = 1 } };
		// Voire si l'initialisation de toutes les boxes en plus du ~pBeat ne charge pas trop le CPU ?????????
	};

	~configBeatsViewFuncAllSeqs = [
		{|tr, seq| // Const 4 Ev - Sum 4
			~seqs.do {|i| ~initBeatSFunc.(); ~selectBeatValue[~tracksValue][i][0] = ['  4 Ev', '4 Ev - Sum  4']; ~selectBeatValueFunc.value(0, i) }},
		{|tr, seq| // Const 4 Ev - Sum 6
			~seqs.do {|i| ~initBeatSFunc.(); ~selectBeatValue[~tracksValue][i][0] = ['  4 Ev', '4 Ev - Sum  6']; ~selectBeatValueFunc.value(0, i) }},
		{|tr, seq| // Const 4 Ev - Sum 8
			~seqs.do {|i| ~initBeatSFunc.(); ~selectBeatValue[~tracksValue][i][0] = ['  4 Ev', '4 Ev - Sum  8']; ~selectBeatValueFunc.value(0, i) }},
		{|tr, seq| // Const 8 Ev - Sum 8
			~seqs.do {|i| ~initBeatSFunc.(); ~selectBeatValue[~tracksValue][i][0] = ['  8 Ev', '8 Ev - Sum  8']; ~selectBeatValueFunc.value(0, i) }},
		{|tr, seq| // Const 8 Ev - Sum 12
			~seqs.do {|i| ~initBeatSFunc.(); ~selectBeatValue[~tracksValue][i][0] = ['  8 Ev', '8 Ev - Sum 12']; ~selectBeatValueFunc.value(0, i) }},
		{|tr, seq| // Const 8 Ev - Sum 16
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  2 Ev', '2 Ev - Sum  4']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 8 Ev - Sum 32
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  2 Ev', '2 Ev - Sum  8']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 8 Ev - Sum 64
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  2 Ev', '2 Ev - Sum 16']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 12 Ev - Sum 12
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  3 Ev', '3 Ev - Sum  3']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 12 Ev - Sum 18
			~seqs.do {|i| ~initBeatSFunc.(); 2.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  6 Ev', '6 Ev - Sum  9']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 12 Ev - Sum 24
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  3 Ev', '3 Ev - Sum  6']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 12 Ev - Sum 36
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  3 Ev', '3 Ev - Sum  9']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 12 Ev - Sum 72
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  3 Ev', '3 Ev - Sum 18']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 16 Ev - Sum 16
			~seqs.do {|i| ~initBeatSFunc.(); 2.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  8 Ev', '8 Ev - Sum  8']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 16 Ev - Sum 24
			~seqs.do {|i| ~initBeatSFunc.(); 2.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  8 Ev', '8 Ev - Sum 12']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 16 Ev - Sum 32
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  4 Ev', '4 Ev - Sum  8']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 16 Ev - Sum 48
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  4 Ev', '4 Ev - Sum 12']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 16 Ev - Sum 96
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  4 Ev', '4 Ev - Sum 24']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 24 Ev - Sum 24
			~seqs.do {|i| ~initBeatSFunc.(); 3.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  8 Ev', '8 Ev - Sum  8']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 24 Ev - Sum 48
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  6 Ev', '6 Ev - Sum 12']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 24 Ev - Sum 72
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  6 Ev', '6 Ev - Sum 18']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 24 Ev - Sum 128
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  6 Ev', '6 Ev - Sum 32']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 32 Ev - Sum 32
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  8 Ev', '8 Ev - Sum  8']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 32 Ev - Sum 64
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  8 Ev', '8 Ev - Sum 16']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 32 Ev - Sum 128
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['  8 Ev', '8 Ev - Sum 32']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 48 Ev - Sum 48
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = [' 12 Ev', '12 Ev - Sum 12']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 48 Ev - Sum 96
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = [' 12 Ev', '12 Ev - Sum 24']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 48 Ev - Sum 192
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = [' 12 Ev', '12 Ev - Sum 48']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 64 Ev - Sum 64
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = [' 16 Ev', '16 Ev - Sum 16']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 64 Ev - Sum 128
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = [' 16 Ev', '16 Ev - Sum 32']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 64 Ev - Sum 192
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = [' 16 Ev', '16 Ev - Sum 48']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 96 Ev - Sum 96
			~seqs.do {|i| ~initBeatSFunc.(); 6.do {|a| ~selectBeatValue[~tracksValue][i][a] = [' 16 Ev', '16 Ev - Sum 16']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 96 Ev - Sum 288
			~seqs.do {|i| ~initBeatSFunc.(); 6.do {|a| ~selectBeatValue[~tracksValue][i][a] = [' 16 Ev', '16 Ev - Sum 48']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 200 Ev - Sum 200
			~seqs.do {|i| ~initBeatSFunc.(); 2.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['100 Ev', '100 Ev - Sum 100']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 200 Ev - Sum 400
			~seqs.do {|i| ~initBeatSFunc.(); 2.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['100 Ev', '100 Ev - Sum 200']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 200 Ev - Sum 800
			~seqs.do {|i| ~initBeatSFunc.(); 2.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['100 Ev', '100 Ev - Sum 400']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 400 Ev - Sum 400
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['100 Ev', '100 Ev - Sum 100']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 400 Ev - Sum 800
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['100 Ev', '100 Ev - Sum 200']; ~selectBeatValueFunc.value(a, i) } }},
		{|tr, seq| // Const 400 Ev - Sum 1600
			~seqs.do {|i| ~initBeatSFunc.(); 4.do {|a| ~selectBeatValue[~tracksValue][i][a] = ['100 Ev', '100 Ev - Sum 400']; ~selectBeatValueFunc.value(a, i) } }}
		/*'Total Random' ->{|i| // Random à créer XXXXXXXXXX directement sur les NumberBox
		~selectBeatView[0].valueAction_([[' 2 Ev', '2 Ev - Sum  2'],[' 2 Ev', '2 Ev - Sum  4'],[' 2 Ev', '2 Ev - Sum  6'],[' 2 Ev', '2 Ev - Sum  8']].choose);
		~selectBeatView[1].valueAction_(['16 Ev', '16 Ev - Sum 48']);
		~selectBeatView[2].valueAction_(['16 Ev', '16 Ev - Sum 48']);
		~selectBeatView[3].valueAction_(['16 Ev', '16 Ev - Sum 48']);
		}*/
	];





	/* Pour une meilleure visualisation du PopUpTreeMenu

	~configBeatsViewFunc = [
	{|tr, seq| if (~patFlag == 0, { // Const 4 Ev - Sum 4
	6.do {|a| ~pBeatView[a].valueAction_(0)}; // pas la possibilité de le mettre dans le globalAction du feu EZMenu car est évalué après
	~selectBeatView[0].valueAction_(['  4 Ev', '4 Ev - Sum  4      -']);
	}, {~seqs.do {|i|
	6.do {|a| ~pBeatView[a].valueAction_(0)};
	~selectBeatView[0].valueAction_(['  4 Ev', '4 Ev - Sum  4      -']);
	}})},
	{|tr, seq| if (~patFlag == 0, { // Const 8 Ev - Sum 8
	6.do {|a| ~pBeatView[a].valueAction_(0)};
	~selectBeatView[0].valueAction_(['  8 Ev', '8 Ev - Sum  8      -']);
	}, {~seqs.do {|i|
	6.do {|a| ~pBeatView[a].valueAction_(0)};
	~selectBeatView[0].valueAction_(['  8 Ev', '8 Ev - Sum  8      -']);
	}})},
	...
	];
	*/





	// Tenter de le mettre dans le coin -> mais amélioration du PopUpMenu nécessaire
	~configBeatsView = PopUpMenu.new(~rtmComp, Rect(2*~xSizeMul, 2*~ySizeMul, 160*~xSizeMul, 20*~ySizeMul) /*Rect(336, 170, 62, 38)*/)
	.action_({ |menu| ~configBeatsValue[~tracksValue][~seqsValue] = ~configBeatsView.value;
		if (~patFlag == 0, {
			~configBeatsViewFunc[menu.value].value/*(~tracksValue, ~seqsValue)*/;
		}, {
			~seqs.do { |i| ~configBeatsValue[~tracksValue][i] = ~configBeatsView.value };
			~configBeatsViewFunc[menu.value].value/*(~tracksValue, i)*/; ~configBeatsViewFuncAllSeqs[menu.value].value/*(~tracksValue, i)*/ });
	})
	.allowsReselection_(true)
	.background_(~popUpMenuBackgroundColor)
	.stringColor_(Color.black)
	.font_(Font("Verdana",10*~fontSizeMul));
	~configBeatsView.items_([
		"Const 4 Ev - Sum 4",
		"Const 4 Ev - Sum 6",
		"Const 4 Ev - Sum 8",
		"Const 8 Ev - Sum 8",
		"Const 8 Ev - Sum 12",
		"Const 8 Ev - Sum 16",
		"Const 8 Ev - Sum 32",
		"Const 8 Ev - Sum 64",
		"Const 12 Ev - Sum 12",
		"Const 12 Ev - Sum 18",
		"Const 12 Ev - Sum 24",
		"Const 12 Ev - Sum 36",
		"Const 12 Ev - Sum 72",
		"Const 16 Ev - Sum 16",
		"Const 16 Ev - Sum 24",
		"Const 16 Ev - Sum 32",
		"Const 16 Ev - Sum 48",
		"Const 16 Ev - Sum 96",
		"Const 24 Ev - Sum 24",
		"Const 24 Ev - Sum 48",
		"Const 24 Ev - Sum 72",
		"Const 24 Ev - Sum 128",
		"Const 32 Ev - Sum 32",
		"Const 32 Ev - Sum 64",
		"Const 32 Ev - Sum 128",
		"Const 48 Ev - Sum 48",
		"Const 48 Ev - Sum 96",
		"Const 48 Ev - Sum 192",
		"Const 64 Ev - Sum 64",
		"Const 64 Ev - Sum 128",
		"Const 64 Ev - Sum 192",
		"Const 96 Ev - Sum 96",
		"Const 96 Ev - Sum 288",
		"Const 200 Ev - Sum 200",
		"Const 200 Ev - Sum 400",
		"Const 200 Ev - Sum 800",
		"Const 400 Ev - Sum 400",
		"Const 400 Ev - Sum 800",
		"Const 400 Ev - Sum 1600",
		// "Total Random"
	])/*.valueAction_(0) // nécessaire de le mettre à la fin du module RTM1 au moins*/;

	// Utiliser la fonction prévue pour ~defaultA XXXXXX
	~defaultAllButtonView = RoundButton(~rtmComp, Rect(170*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["Init", Color.white, Color.blue]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({ var durseq, durseq2;

		var previousfxActOnWhich = ~fxActOnWhich; // Pour éviter que le fxL agisse sur le droit
		var previousoutActOnWhich = ~outActOnWhich; // Pour éviter que le outL agisse sur le droit
		var previousoutCompChoose = ~outCompChoose;
		~fxActOnWhichView.valueAction_(0); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(0); // Pour éviter que le outL agisse sur le droit

		if (~patFlag == 0, {
			// ~duration2show.value(~tracksValue, ~seqsValue); // déjà dans ~rtmDefault.value
			// utilisation de .asCompileString pour pouvoir afficher toute une array
			// ~displayRhythmView.string_(("~rtmView.valueAction_("+~dura[~tracksValue][~seqsValue].asCompileString+".convertRhythm.linlin(0,"+ ~rtmMax[~tracksValue][~seqsValue]+", 0, 1));")).asString;
			~rtmDefault.value(~tracksValue, ~seqsValue);
			~proDefault.value(~tracksValue, ~seqsValue);
			~synDefault.value(~tracksValue, ~seqsValue);
			~spaDefault.value(~tracksValue, ~seqsValue);
			~legDefault.value(~tracksValue, ~seqsValue);
			~envDefault.value(~tracksValue, ~seqsValue);
			~bufDefault.value(~tracksValue, ~seqsValue);
			~offDefault.value(~tracksValue, ~seqsValue); ~off2Default.value(~tracksValue, ~seqsValue); ~off3Default.value(~tracksValue, ~seqsValue); ~off4Default.value(~tracksValue, ~seqsValue);
			~ratDefault.value(~tracksValue, ~seqsValue); ~rat2Default.value(~tracksValue, ~seqsValue);
			~ampDefault.value(~tracksValue, ~seqsValue);
			~strDefault.value(~tracksValue, ~seqsValue); ~str2Default.value(~tracksValue, ~seqsValue);
			~cenDefault.value(~tracksValue, ~seqsValue); ~cen2Default.value(~tracksValue, ~seqsValue);
			~panDefault.value(~tracksValue, ~seqsValue);
			~delDefault.value(~tracksValue, ~seqsValue);
			~outLDefault.value(~tracksValue, ~seqsValue);
			~outRDefault.value(~tracksValue, ~seqsValue);
			~fxLDefault.value(~tracksValue, ~seqsValue);
			~fxRDefault.value(~tracksValue, ~seqsValue);
		}, {~seqs.do {|i|
			// ~duration2show.value(~tracksValue, i); // déjà dans ~rtmDefault.value
			// utilisation de .asCompileString pour pouvoir afficher toute une array
			// ~displayRhythm[~tracksValue][i] = (("~rtmView["+~tracksValue+"]["+i+"].valueAction_("+~dura[~tracksValue][i].asCompileString+".convertRhythm.curvelin(1e-17,"+  ~nbTotalBeats[~tracksValue][i].value+" , 0, 1, 4));")).asString;
			// ~displayRhythmView.string_(("~rtmView.valueAction_("+~dura[~tracksValue][i].asCompileString+".convertRhythm.linlin(0,"+ ~rtmMax[~tracksValue][i]+", 0, 1));")).asString;
			~rtmDefault.value(~tracksValue, i);

			durseq = ~dur[~tracksValue][i].size; durseq2 = /*(6.collect({|a| (~pBeat[~tracksValue][i][a] > 0).if ({~nbBeat[~tracksValue][i][a]}, {0}) })).sum -1;*/ durseq-1;
			~gblSeqStop[~tracksValue][i] = durseq2;
			~rtmSeqStop[~tracksValue][i] = durseq2;
			~proSeqStop[~tracksValue][i] = durseq2; ~pro[~tracksValue][i] = Array.newClear(durseq);
			~synSeqStop[~tracksValue][i] = durseq2; ~syn[~tracksValue][i] = Array.newClear(durseq);
			~envSeqStop[~tracksValue][i] = durseq2; ~env[~tracksValue][i] = Array.newClear(durseq);
			~bufSeqStop[~tracksValue][i] = durseq2; ~buf[~tracksValue][i] = Array.newClear(durseq);
			~ratSeqStop[~tracksValue][i] = durseq2; ~rat[~tracksValue][i] = Array.newClear(durseq);
			~rat2SeqStop[~tracksValue][i] = durseq2; ~rat2[~tracksValue][i] = Array.newClear(durseq);
			~spaSeqStop[~tracksValue][i] = durseq2; ~spa[~tracksValue][i] = Array.newClear(durseq);
			~ampSeqStop[~tracksValue][i] = durseq2; ~amp[~tracksValue][i] = Array.newClear(durseq);

			~offSeqStop[~tracksValue][i] = durseq2; ~off[~tracksValue][i] = Array.newClear(durseq);
			~off2SeqStop[~tracksValue][i] = durseq2; ~off2[~tracksValue][i] = Array.newClear(durseq);
			~off3SeqStop[~tracksValue][i] = durseq2; ~off3[~tracksValue][i] = Array.newClear(durseq);
			~off4SeqStop[~tracksValue][i] = durseq2; ~off4[~tracksValue][i] = Array.newClear(durseq);

			~legSeqStop[~tracksValue][i] = durseq2; ~leg[~tracksValue][i] = Array.newClear(durseq);
			~panSeqStop[~tracksValue][i] = durseq2; ~pan[~tracksValue][i] = Array.newClear(durseq);
			~delSeqStop[~tracksValue][i] = durseq2; ~del[~tracksValue][i] = Array.newClear(durseq);
			~outLSeqStop[~tracksValue][i] = durseq2; ~outL[~tracksValue][i] = Array.newClear(durseq);
			~outRSeqStop[~tracksValue][i] = durseq2; ~outR[~tracksValue][i] = Array.newClear(durseq);
			~fxLSeqStop[~tracksValue][i] = durseq2; ~fxL[~tracksValue][i] = Array.newClear(durseq);
			~fxRSeqStop[~tracksValue][i] = durseq2; ~fxR[~tracksValue][i] = Array.newClear(durseq);
			~strSeqStop[~tracksValue][i] = durseq2; ~str[~tracksValue][i] = Array.newClear(durseq);
			~str2SeqStop[~tracksValue][i] = durseq2; ~str2[~tracksValue][i] = Array.newClear(durseq);
			~cenSeqStop[~tracksValue][i] = durseq2; ~cen[~tracksValue][i] = Array.newClear(durseq);
			~cen2SeqStop[~tracksValue][i] = durseq2; ~cen2[~tracksValue][i] = Array.newClear(durseq);

			~proDefault.value(~tracksValue, i);
			~synDefault.value(~tracksValue, i);
			~spaDefault.value(~tracksValue, i);
			~legDefault.value(~tracksValue, i);
			~envDefault.value(~tracksValue, i);
			~bufDefault.value(~tracksValue, i);
			~offDefault.value(~tracksValue, i); ~off2Default.value(~tracksValue, i); ~off3Default.value(~tracksValue, i); ~off4Default.value(~tracksValue, i);
			~ratDefault.value(~tracksValue, i); ~rat2Default.value(~tracksValue, i);
			~ampDefault.value(~tracksValue, i);
			~strDefault.value(~tracksValue, i); ~str2Default.value(~tracksValue, i);
			~cenDefault.value(~tracksValue, i); ~cen2Default.value(~tracksValue, i);
			~panDefault.value(~tracksValue, i);
			~delDefault.value(~tracksValue, i);
			~outLDefault.value(~tracksValue, i);
			~outRDefault.value(~tracksValue, i);
			~fxLDefault.value(~tracksValue, i);
			~fxRDefault.value(~tracksValue, i);
		}});

		~fxActOnWhichView.valueAction_(previousfxActOnWhich); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(previousoutActOnWhich); // Pour éviter que le outL agisse sur le droit
		~outCompChooseView.valueAction_(previousoutCompChoose);

	});



	~stepSizes = [ 10, 1, 0]; // stepsizes
	~stepSizes1 = [ 100, 10, 1, 0]; // stepsizes
	~stepSizes2 = [ 1000, 100, 10, 1, 0]; // stepsizes

	// Mise en place d'1 second niveau de nesting et besoin de modifier l'initialisation des variables
	// voir réponse de Forum

	6.collect({|nb|

		~pBeatTextView = StaticText(~rtmComp, Rect(2*~xSizeMul, (22+(nb*14))*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
		.stringColor_(Color.white)
		.string_((nb+1)+"%:");

		~pBeatView[nb] = RoundNumberBox(~rtmComp, Rect(28*~xSizeMul, (24+(nb*14))*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
		.clipLo_(0).clipHi_(100).align_( \right )
		.formatFunc_({ |view| view.asString.preExtend(3, $ ); }) // fixed width string
		.normalColor_(Color.blue)
		.action_({|view| ~pBeat[~tracksValue][~seqsValue][nb] = view.value.asInteger; 	if (~pBeat[~tracksValue][~seqsValue][nb] > 0, {~pBeatView[nb].background_(Color.yellow); ~nbBeatView[nb].background_(Color.yellow); ~sumBeatView[nb].background_(Color.yellow); ~minSumBeatView[nb].background_(Color.yellow)}, {~pBeatView[nb].background_(Color.white); ~nbBeatView[nb].background_(Color.white); ~sumBeatView[nb].background_(Color.white); ~minSumBeatView[nb].background_(Color.white)});
			// changement de ~nbTotalBeatsView
			~nbTotalBeatsView.string = ("% Beats - % Ev in %s - ABPM: %").format(~nbTotalBeats[~tracksValue][~seqsValue]  * ~rtmMul[~tracksValue][~seqsValue],
				/*(8.collect({|i| ~nbBeat[~tracksValue][~seqsValue][i]})).sum;*/ // Correction du code pour faire le sum du collect seulement si ~pBeat > 0
				(6.collect({|i| (~pBeat[~tracksValue][~seqsValue][i] > 0).if ({~nbBeat[~tracksValue][~seqsValue][i]}, {0}) })).sum, (~nbTotalBeats[~tracksValue][~seqsValue] / ~toTempo).round(0.01), ( (6.collect({|i| (~pBeat[~tracksValue][~seqsValue][i] > 0).if ({~nbBeat[~tracksValue][~seqsValue][i]}, {0}) })).sum / ~nbTotalBeats[~tracksValue][~seqsValue] * ~toTempo * 60).round(0.01));
		})
		// mouse support
		.mouseDownAction_({ |vw, x, y|
			vw.charSelectIndex = vw.charIndexFromPoint( x@y, [4] );
			vw.scroll_step = ~stepSizes1[vw.charSelectIndex] ? 1;
			vw.step = vw.scroll_step;
		})
		// arrow keys left/right to select char, up/down to change value
		.keyDownAction = { arg vw, char, mod, unicode, keycode, key;
			var res;
			res = case { key == 16777236 }
			{ vw.charSelectIndex = (vw.charSelectIndex + 1).min(2); nil }
			{ key == 16777234 }
			{ vw.charSelectIndex = (vw.charSelectIndex - 1).max(0); nil }
			{ key == 16777235 }
			{ vw.increment }
			{ key == 16777237 }
			{ vw.decrement };
			vw.step = ~stepSizes1[vw.charSelectIndex] ? 1;
			// vw.charSelectIndex.postln;
			res;
		};

		~nbBeatTextView = StaticText(~rtmComp, Rect(63*~xSizeMul, (22+(nb*14))*~ySizeMul, 25*~xSizeMul, 20*~ySizeMul))
		.stringColor_(Color.white)
		.string_("Nb:");

		~nbBeatView[nb] = RoundNumberBox(~rtmComp, Rect(84*~xSizeMul, (24+(nb*14))*~ySizeMul, 40*~xSizeMul, 16*~ySizeMul))
		.clipLo_(1).clipHi_(1000).align_( \right )
		.valueAction_(1)
		.formatFunc_({ |view| view.asString.preExtend(4, $ ); }) // fixed width string
		.action_({|view| ~nbBeat[~tracksValue][~seqsValue][nb] = view.value.asInteger; ~sumBeatView[nb].clipLo_(~nbBeat[~tracksValue][~seqsValue][nb]);
			if ( ~nbBeat[~tracksValue][~seqsValue][nb] > ~sumBeat[~tracksValue][~seqsValue][nb], {~sumBeatView[nb].valueAction_(~nbBeat[~tracksValue][~seqsValue][nb])} );
			// changement de ~nbTotalBeatsView
			~nbTotalBeatsView.string = ("% Beats - % Ev in %s - ABPM: %").format(~nbTotalBeats[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue],
				/*(8.collect({|i| ~nbBeat[~tracksValue][~seqsValue][i]})).sum;*/ // Correction du code pour faire le sum du collect seulement si ~pBeat > 0
				(6.collect({|i| (~pBeat[~tracksValue][~seqsValue][i] > 0).if ({~nbBeat[~tracksValue][~seqsValue][i]}, {0}) })).sum, (~nbTotalBeats[~tracksValue][~seqsValue] / ~toTempo).round(0.01), ( (6.collect({|i| (~pBeat[~tracksValue][~seqsValue][i] > 0).if ({~nbBeat[~tracksValue][~seqsValue][i]}, {0}) })).sum / ~nbTotalBeats[~tracksValue][~seqsValue] * ~toTempo * 60).round(0.01));
		})
		// mouse support
		.mouseDownAction_({ |vw, x, y|
			vw.charSelectIndex = vw.charIndexFromPoint( x@y, [4] );
			vw.scroll_step = ~stepSizes2[vw.charSelectIndex] ? 1;
			vw.step = vw.scroll_step;
		})
		// arrow keys left/right to select char, up/down to change value
		.keyDownAction = { arg vw, char, mod, unicode, keycode, key;
			var res;
			res = case { key == 16777236 }
			{ vw.charSelectIndex = (vw.charSelectIndex + 1).min(3); nil }
			{ key == 16777234 }
			{ vw.charSelectIndex = (vw.charSelectIndex - 1).max(0); nil }
			{ key == 16777235 }
			{ vw.increment }
			{ key == 16777237 }
			{ vw.decrement };
			vw.step = ~stepSizes2[vw.charSelectIndex] ? 1;
			// vw.charSelectIndex.postln;
			res;
		};

		~sumBeatTextView = StaticText(~rtmComp, Rect(129*~xSizeMul, (22+(nb*14))*~ySizeMul, 35*~xSizeMul, 20*~ySizeMul))
		.stringColor_(Color.white)
		.string_("Sum:");

		~sumBeatView[nb] = RoundNumberBox(~rtmComp, Rect(159*~xSizeMul, (24+(nb*14))*~ySizeMul, 40*~xSizeMul, 16*~ySizeMul))
		.clipLo_(1).clipHi_(1000).align_( \right )
		.valueAction_(1)
		.formatFunc_({ |view| view.asString.preExtend(4, $ ); }) // fixed width string
		.action_({|view| ~sumBeat[~tracksValue][~seqsValue][nb] = view.value.asInteger; })
		// mouse support
		.mouseDownAction_({ |vw, x, y|
			vw.charSelectIndex = vw.charIndexFromPoint( x@y, [4] );
			vw.scroll_step = ~stepSizes2[vw.charSelectIndex] ? 1;
			vw.step = vw.scroll_step;
		})
		// arrow keys left/right to select char, up/down to change value
		.keyDownAction = { arg vw, char, mod, unicode, keycode, key;
			var res;
			res = case { key == 16777236 }
			{ vw.charSelectIndex = (vw.charSelectIndex + 1).min(3); nil }
			{ key == 16777234 }
			{ vw.charSelectIndex = (vw.charSelectIndex - 1).max(0); nil }
			{ key == 16777235 }
			{ vw.increment }
			{ key == 16777237 }
			{ vw.decrement };
			vw.step = ~stepSizes2[vw.charSelectIndex] ? 1;
			// vw.charSelectIndex.postln;
			res;
		};

		~minSumBeatTextView = StaticText(~rtmComp, Rect(204*~xSizeMul, (22+(nb*14))*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
		.stringColor_(Color.white)
		.string_("Min:");

		~minSumBeatView[nb] = RoundNumberBox(~rtmComp, Rect(229*~xSizeMul, (24+(nb*14))*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
		.clipLo_(0).clipHi_(10).align_( \right )
		.formatFunc_({ |view| view.asString.preExtend(2, $  ); }) // fixed width string
		.action_({|view| ~minSumBeat[~tracksValue][~seqsValue][nb] = view.value.asInteger; })
		.valueAction_(1)
		// mouse support
		.mouseDownAction_({ |vw, x, y|
			vw.charSelectIndex = vw.charIndexFromPoint( x@y, [4] );
			vw.scroll_step = ~stepSizes[vw.charSelectIndex] ? 1;
			vw.step = vw.scroll_step;
		})
		// arrow keys left/right to select char, up/down to change value
		.keyDownAction = { arg vw, char, mod, unicode, keycode, key;
			var res;
			res = case { key == 16777236 }
			{ vw.charSelectIndex = (vw.charSelectIndex + 1).min(1); nil }
			{ key == 16777234 }
			{ vw.charSelectIndex = (vw.charSelectIndex - 1).max(0); nil }
			{ key == 16777235 }
			{ vw.increment }
			{ key == 16777237 }
			{ vw.decrement };
			vw.step = ~stepSizes[vw.charSelectIndex] ? 1;
			// vw.charSelectIndex.postln;
			res;
		};

		~selectBeatView[nb] = PopUpTreeMenu.new(~rtmComp, Rect(264*~xSizeMul, (2+(nb*18))*~ySizeMul, 133*~xSizeMul, 18*~ySizeMul))
		.font_(Font("Verdana",10*~fontSizeMul))
		.background_(~popUpMenuBackgroundColor)
		.hiliteColor_(Color.red(0.75))
		.stringColor_(~popUpMenuStringColor)
		.tree_(
			(
				'  1 Ev': (
					'1 Ev - Sum  1': ()
				),
				'  2 Ev': (
					'2 Ev - Sum  2': (),
					'2 Ev - Sum  3': (),
					'2 Ev - Sum  4': (),
					'2 Ev - Sum  6': (),
					'2 Ev - Sum  8': (),
					'2 Ev - Sum 16': ()
				),
				'  3 Ev': (
					'3 Ev - Sum  3': (),
					'3 Ev - Sum  6': (),
					'3 Ev - Sum  9': (),
					'3 Ev - Sum 12': (),
					'3 Ev - Sum 18': ()
				),
				'  4 Ev': (
					'4 Ev - Sum  4': (),
					'4 Ev - Sum  6': (),
					'4 Ev - Sum  8': (),
					'4 Ev - Sum 12': (),
					'4 Ev - Sum 16': (),
					'4 Ev - Sum 24': ()
				),
				'  5 Ev': (
					'5 Ev - Sum  5': (),
					'5 Ev - Sum 10': (),
					'5 Ev - Sum 20': (),
					'5 Ev - Sum 30': (),
					'5 Ev - Sum 40': ()
				),
				'  6 Ev': (
					'6 Ev - Sum  6': (),
					'6 Ev - Sum  9': (),
					'6 Ev - Sum 12': (),
					'6 Ev - Sum 18': (),
					'6 Ev - Sum 24': (),
					'6 Ev - Sum 32': (),
					'6 Ev - Sum 48': ()
				),
				'  7 Ev': (
					'7 Ev - Sum  7': (),
					'7 Ev - Sum 14': (),
					'7 Ev - Sum 28': (),
					'7 Ev - Sum 42': (),
					'7 Ev - Sum 56': ()
				),
				'  8 Ev': (
					'8 Ev - Sum  8': (),
					'8 Ev - Sum 12': (),
					'8 Ev - Sum 16': (),
					'8 Ev - Sum 32': (),
					'8 Ev - Sum 48': (),
					'8 Ev - Sum 64': ()
				),
				'  9 Ev': (
					'9 Ev - Sum  9': (),
					'9 Ev - Sum 18': (),
					'9 Ev - Sum 36': (),
					'9 Ev - Sum 54': (),
					'9 Ev - Sum 72': ()
				),
				' 10 Ev': (
					'10 Ev - Sum 10': (),
					'10 Ev - Sum 20': (),
					'10 Ev - Sum 40': (),
					'10 Ev - Sum 60': (),
					'10 Ev - Sum 80': ()
				),
				' 11 Ev': (
					'11 Ev - Sum 11': (),
					'11 Ev - Sum 22': (),
					'11 Ev - Sum 44': (),
					'11 Ev - Sum 66': (),
					'11 Ev - Sum 88': ()
				),
				' 12 Ev': (
					'12 Ev - Sum 12': (),
					'12 Ev - Sum 15': (),
					'12 Ev - Sum 18': (),
					'12 Ev - Sum 24': (),
					'12 Ev - Sum 48': (),
					'12 Ev - Sum 72': (),
					'12 Ev - Sum 96': ()
				),
				' 16 Ev': (
					'16 Ev - Sum 16': (),
					'16 Ev - Sum 20': (),
					'16 Ev - Sum 24': (),
					'16 Ev - Sum 32': (),
					'16 Ev - Sum 48': (),
					'16 Ev - Sum 72': (),
					'16 Ev - Sum 96': ()
				),
				'100 Ev': (
					'100 Ev - Sum 100': (),
					'100 Ev - Sum 200': (),
					'100 Ev - Sum 400': (),
					'100 Ev - Sum 800': ()
				)
			)
		)
		.action_{|view, val|
			~selectBeatValue[~tracksValue][~seqsValue][nb] = /*view.value*/ val;
			/*val.asString.split($ ).postln;
			val.asString.split($ )[3].postln;
			val.asString.split($ )[4].postln;
			val.asString.split($ )[7].postln;
			val.asString.split($ )[8].postln;
			val.asString.split($ )[9].postln;
			val.asString.split($ )[10].postln;*/
			~pBeatView[nb].valueAction_(1);
			~nbBeatView[nb].valueAction_(if (val.asString.split($ )[4].asInteger > 0 , {val.asString.split($ )[4].asInteger}, {val.asString.split($ )[3].asInteger}));
			~sumBeatView[nb].valueAction_(case {val.asString.split($ )[7].asInteger > 0} {val.asString.split($ )[7].asInteger}
				{val.asString.split($ )[8].asInteger > 0} {val.asString.split($ )[8].asInteger}
				{val.asString.split($ )[9].asInteger > 0} {val.asString.split($ )[9].asInteger}
				{val.asString.split($ )[10].asInteger > 0} {val.asString.split($ )[10].asInteger});
			~minSumBeatView[nb].valueAction_(1);
		};

		/* Pour une visualisation meilleure du PopUpTreeMenu affichant tout le texte
		(
		'  1 Ev': (
		'1 Ev - Sum  1      -': ()
		),
		*/
	});



	// Remplacement du EZText / TextField par TextView (multilignes & lance l'exécution pour changer ~dur[track][seq] mais pas ~dura[track][seq])
	~displayRhythmView = TextView(~rtmComp, Rect(2*~xSizeMul, 113*~ySizeMul, 394*~xSizeMul, 40*~ySizeMul))
	// .autohidesScrollers_(true)
	.hasVerticalScroller_(false)
	.hasHorizontalScroller_(false)
	.enterInterpretsSelection_(1)
	.font_(Font("Verdana",9*~fontSizeMul))
	.string_(/*~rtmView.valueAction_( [ 4, [ [ 1, [ 1, 1, 1, 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ] ] ] .convertRhythm.linlin(0, 2 , 0, 1));*/
		"~rhythmChange[ 0 ][ 0 ] =  [ 4, [ [ 1, [ 1, 1, 1, 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ] ] ] ; ~rtmRangeView.valueAction_(~rtmRangeSpec[ 0 ][ 0 ].unmap([0,  ~rhythmChange[ 0 ][ 0 ].convertRhythm.maxItem * 2])); ~rtmView.valueAction_( ~rhythmChange[ 0 ][ 0 ].convertRhythm.linlin(0, ~rtmMax[ 0 ][ 0 ], 0, 1));"
	);


	~tracks.do { |tr|
		~seqs.do { |seq|

			~nbTotalBeats[tr][seq] = 4;
			// Pour initialiser la 1ere ligne de rythmique avec 4 valeurs
			~pBeat[tr][seq][0] = 1;
			~nbBeat[tr][seq][0] = 4;
			~sumBeat[tr][seq][0] = 4;
			~minSumBeat[tr][seq][0] = 1;
			// Pour initialiser les autres lignes de rythmique à 0
			5.collect { |nb|
				~pBeat[tr][seq][nb+1] = 0;
				~nbBeat[tr][seq][nb+1] = 1;
				~sumBeat[tr][seq][nb+1] = 1;
				~minSumBeat[tr][seq][nb+1] = 1;
			}
		}
	};

	/*
	A supprimer
	~pBeat[2][0][0]
	~nbBeat[2][0][0]
	~minSumBeat[2][0][0]
	~pBeat[2][0][1]
	~nbBeat[2][0][1]
	~minSumBeat[2][0][1]
	~pBeat[2][0][2]
	~nbBeat[2][0][2]
	~minSumBeat[2][0][2]
	~pBeat[2][0][3]
	~nbBeat[2][0][3]
	~minSumBeat[2][0][3]
	~pBeat[2][0][4]
	~nbBeat[2][0][4]
	~minSumBeat[2][0][4]
	~pBeat[2][0][5]
	~nbBeat[2][0][5]
	~minSumBeat[2][0][5]
	*/





	~randAllView = RoundButton(~rtmCompb, Rect(5*~xSizeMul, 5*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
	.states_([["R A", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({ var durseq, durseq2;

		var previousfxActOnWhich = ~fxActOnWhich; // Pour éviter que le fxL agisse sur le droit
		var previousoutActOnWhich = ~outActOnWhich; // Pour éviter que le outL agisse sur le droit
		var previousoutCompChoose = ~outCompChoose;
		~fxActOnWhichView.valueAction_(0); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(0); // Pour éviter que le outL agisse sur le droit

		if (~patFlag == 0, {
			~duration2show.value(~tracksValue, ~seqsValue);
			// utilisation de .asCompileString pour pouvoir afficher toute une array
			// ~displayRhythmView.string_(("~rtmView.valueAction_("+~dura[~tracksValue][~seqsValue].asCompileString+".convertRhythm.linlin(0,"+ ~rtmMax[~tracksValue][~seqsValue]+", 0, 1));")).asString;
			~probability.value(~tracksValue, ~seqsValue);
			~synthese.value(~tracksValue, ~seqsValue);
			~enveloppe.value(~tracksValue, ~seqsValue);
			~buffer.value(~tracksValue, ~seqsValue);
			~rate.value(~tracksValue, ~seqsValue); ~rate2f.value(~tracksValue, ~seqsValue);
			~spatialisation.value(~tracksValue, ~seqsValue);
			~amplitude.value(~tracksValue, ~seqsValue);
			~offset.value(~tracksValue, ~seqsValue);
			~legato.value(~tracksValue, ~seqsValue);
			~panning.value(~tracksValue, ~seqsValue);
			~delay.value(~tracksValue, ~seqsValue);
			~outingL.value(~tracksValue, ~seqsValue);
			~outingR.value(~tracksValue, ~seqsValue);
			~efxL.value(~tracksValue, ~seqsValue);
			~efxR.value(~tracksValue, ~seqsValue);
			~stretching.value(~tracksValue, ~seqsValue); ~stretching2.value(~tracksValue, ~seqsValue);
			~center.value(~tracksValue, ~seqsValue); ~center2.value(~tracksValue, ~seqsValue);
		}, {~seqs.do {|i|
			~duration2show.value(~tracksValue, i);
			// ~displayRhythm[~tracksValue][i] = (("~rtmView["+~tracksValue+"]["+i+"].valueAction_("+~dura[~tracksValue][i].asCompileString+".convertRhythm.curvelin(1e-17,"+  ~nbTotalBeats[~tracksValue][i].value+" , 0, 1, 4));")).asString;

			durseq = ~dur[~tracksValue][i].size; durseq2 = /*(6.collect({|a| (~pBeat[~tracksValue][i][a] > 0).if ({~nbBeat[~tracksValue][i][a]}, {0}) })).sum -1;*/ durseq-1;
			~gblSeqStop[~tracksValue][i] = durseq2;
			~rtmSeqStop[~tracksValue][i] = durseq2;
			~proSeqStop[~tracksValue][i] = durseq2; ~pro[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~synSeqStop[~tracksValue][i] = durseq2; ~syn[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~envSeqStop[~tracksValue][i] = durseq2; ~env[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~bufSeqStop[~tracksValue][i] = durseq2; ~buf[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~ratSeqStop[~tracksValue][i] = durseq2; ~rat[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~rat2SeqStop[~tracksValue][i] = durseq2; ~rat2[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~spaSeqStop[~tracksValue][i] = durseq2; ~spa[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~ampSeqStop[~tracksValue][i] = durseq2; ~amp[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~offSeqStop[~tracksValue][i] = durseq2; ~off[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~legSeqStop[~tracksValue][i] = durseq2; ~leg[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~panSeqStop[~tracksValue][i] = durseq2; ~pan[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~delSeqStop[~tracksValue][i] = durseq2; ~del[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~outLSeqStop[~tracksValue][i] = durseq2; ~outL[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~outRSeqStop[~tracksValue][i] = durseq2; ~outR[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~fxLSeqStop[~tracksValue][i] = durseq2; ~fxL[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~fxRSeqStop[~tracksValue][i] = durseq2; ~fxR[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~strSeqStop[~tracksValue][i] = durseq2; ~str[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~str2SeqStop[~tracksValue][i] = durseq2; ~str2[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~cenSeqStop[~tracksValue][i] = durseq2; ~cen[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~cen2SeqStop[~tracksValue][i] = durseq2; ~cen2[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;

			~probability.value(~tracksValue, i);
			~synthese.value(~tracksValue, i);
			~enveloppe.value(~tracksValue, i);
			~buffer.value(~tracksValue, i);
			~rate.value(~tracksValue, i); ~rate2f.value(~tracksValue, i);
			~spatialisation.value(~tracksValue, i);
			~amplitude.value(~tracksValue, i);
			~offset.value(~tracksValue, i);
			~legato.value(~tracksValue, i);
			~panning.value(~tracksValue, i);
			~delay.value(~tracksValue, i);
			~outingL.value(~tracksValue, i);
			~outingR.value(~tracksValue, i);
			~efxL.value(~tracksValue, i);
			~efxR.value(~tracksValue, i);
			~stretching.value(~tracksValue, i); ~stretching2.value(~tracksValue, i);
			~center.value(~tracksValue, i); ~center2.value(~tracksValue, i);
		}});

		~fxActOnWhichView.valueAction_(previousfxActOnWhich); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(previousoutActOnWhich); // Pour éviter que le outL agisse sur le droit
		~outCompChooseView.valueAction_(previousoutCompChoose);

	});

	// obligé de mettre le rand avant le Default afin que le nombre de sliders soit updaté ? autre manière de faire car peut provoquer des erreurs ???
	~randInitView = RoundButton(~rtmCompb, Rect(5*~xSizeMul, 29*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
	.states_([["RI A", Color.white, Color.magenta]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({ var durseq, durseq2;

		var previousfxActOnWhich = ~fxActOnWhich; // Pour éviter que le fxL agisse sur le droit
		var previousoutActOnWhich = ~outActOnWhich; // Pour éviter que le outL agisse sur le droit
		var previousoutCompChoose = ~outCompChoose;
		~fxActOnWhichView.valueAction_(0); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(0); // Pour éviter que le outL agisse sur le droit

		if (~patFlag == 0, {
			~duration2show.value(~tracksValue, ~seqsValue);
			// utilisation de .asCompileString pour pouvoir afficher toute une array
			// ~displayRhythmView.string_(("~rtmView.valueAction_("+~dura[~tracksValue][~seqsValue].asCompileString+".convertRhythm.linlin(0,"+ ~rtmMax[~tracksValue][~seqsValue]+", 0, 1));")).asString;
			// ~probability.value(~tracksValue, ~seqsValue);
			// ~synthese.value(~tracksValue, ~seqsValue);
			// ~enveloppe.value(~tracksValue, ~seqsValue);
			~proDefault.value(~tracksValue, ~seqsValue);
			~synDefault.value(~tracksValue, ~seqsValue);
			~envDefault.value(~tracksValue, ~seqsValue);
			~buffer.value(~tracksValue, ~seqsValue);
			~rate.value(~tracksValue, ~seqsValue); ~rate2f.value(~tracksValue, ~seqsValue);
			// ~spatialisation.value(~tracksValue, ~seqsValue);
			~spaDefault.value(~tracksValue, ~seqsValue);
			~amplitude.value(~tracksValue, ~seqsValue);
			// ~offset.value(~tracksValue, ~seqsValue);
			~offDefault.value(~tracksValue, ~seqsValue);
			~legato.value(~tracksValue, ~seqsValue);
			~panning.value(~tracksValue, ~seqsValue);
			~delay.value(~tracksValue, ~seqsValue);
			~outingL.value(~tracksValue, ~seqsValue);
			~outingR.value(~tracksValue, ~seqsValue);
			~efxL.value(~tracksValue, ~seqsValue);
			~efxR.value(~tracksValue, ~seqsValue);
			// ~fxLDefault.value(~tracksValue, ~seqsValue);
			// ~fxRDefault.value(~tracksValue, ~seqsValue);
			~stretching.value(~tracksValue, ~seqsValue); ~stretching2.value(~tracksValue, ~seqsValue);
			~center.value(~tracksValue, ~seqsValue); ~center2.value(~tracksValue, ~seqsValue);
		}, {~seqs.do {|i|
			~duration2show.value(~tracksValue, i);
			// ~displayRhythm[~tracksValue][i] = (("~rtmView["+~tracksValue+"]["+i+"].valueAction_("+~dura[~tracksValue][i].asCompileString+".convertRhythm.curvelin(1e-17,"+  ~nbTotalBeats[~tracksValue][i].value+" , 0, 1, 4));")).asString;

			durseq = ~dur[~tracksValue][i].size; durseq2 = /*(6.collect({|a| (~pBeat[~tracksValue][i][a] > 0).if ({~nbBeat[~tracksValue][i][a]}, {0}) })).sum -1;*/ durseq-1;
			~gblSeqStop[~tracksValue][i] = durseq2;
			~rtmSeqStop[~tracksValue][i] = durseq2;
			~proSeqStop[~tracksValue][i] = durseq2; ~pro[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~synSeqStop[~tracksValue][i] = durseq2; ~syn[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~envSeqStop[~tracksValue][i] = durseq2; ~env[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~bufSeqStop[~tracksValue][i] = durseq2; ~buf[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~ratSeqStop[~tracksValue][i] = durseq2; ~rat[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~rat2SeqStop[~tracksValue][i] = durseq2; ~rat2[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~spaSeqStop[~tracksValue][i] = durseq2; ~spa[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~ampSeqStop[~tracksValue][i] = durseq2; ~amp[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~offSeqStop[~tracksValue][i] = durseq2; ~off[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~legSeqStop[~tracksValue][i] = durseq2; ~leg[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~panSeqStop[~tracksValue][i] = durseq2; ~pan[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~delSeqStop[~tracksValue][i] = durseq2; ~del[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~outLSeqStop[~tracksValue][i] = durseq2; ~outL[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~outRSeqStop[~tracksValue][i] = durseq2; ~outR[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~fxLSeqStop[~tracksValue][i] = durseq2; ~fxL[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~fxRSeqStop[~tracksValue][i] = durseq2; ~fxR[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~strSeqStop[~tracksValue][i] = durseq2; ~str[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~str2SeqStop[~tracksValue][i] = durseq2; ~str2[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~cenSeqStop[~tracksValue][i] = durseq2; ~cen[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;
			~cen2SeqStop[~tracksValue][i] = durseq2; ~cen2[~tracksValue][i] = {rrand(0.0,1.0)} ! durseq;

			// ~probability.value(~tracksValue, i);
			// ~synthese.value(~tracksValue, i);
			// ~enveloppe.value(~tracksValue, i);
			~proDefault.value(~tracksValue, i);
			~synDefault.value(~tracksValue, i);
			~envDefault.value(~tracksValue, i);
			~buffer.value(~tracksValue, i);
			~rate.value(~tracksValue, i); ~rate2f.value(~tracksValue, i);
			// ~spatialisation.value(~tracksValue, i);
			~spaDefault.value(~tracksValue, i);
			~amplitude.value(~tracksValue, i);
			// ~offset.value(~tracksValue, i);
			~offDefault.value(~tracksValue, i);
			~legato.value(~tracksValue, i);
			~panning.value(~tracksValue, i);
			~delay.value(~tracksValue, i);
			~outingL.value(~tracksValue, i);
			~outingR.value(~tracksValue, i);
			~efxL.value(~tracksValue, i);
			~efxR.value(~tracksValue, i);
			// ~fxLDefault.value(~tracksValue, i);
			// ~fxRDefault.value(~tracksValue, i);
			~stretching.value(~tracksValue, i); ~stretching2.value(~tracksValue, i);
			~center.value(~tracksValue, i); ~center2.value(~tracksValue, i);
		}});

		~fxActOnWhichView.valueAction_(previousfxActOnWhich); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(previousoutActOnWhich); // Pour éviter que le outL agisse sur le droit
		~outCompChooseView.valueAction_(previousoutCompChoose);

	});

	~randSomeView = RoundButton(~rtmCompb, Rect(60*~xSizeMul, 5*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
	.states_([["R BRS", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({
		if (~patFlag == 0, {
			~buffer.value(~tracksValue, ~seqsValue);
			~rate.value(~tracksValue, ~seqsValue); ~rate2f.value(~tracksValue, ~seqsValue);
			~stretching.value(~tracksValue, ~seqsValue); ~stretching2.value(~tracksValue, ~seqsValue);
			~center.value(~tracksValue, ~seqsValue); ~center2.value(~tracksValue, ~seqsValue);
		}, {~seqs.do {|i| // marche ???
			~buffer.value(~tracksValue, i);
			~rate.value(~tracksValue, ~seqsValue); ~rate2f.value(~tracksValue, ~seqsValue);
			~stretching.value(~tracksValue, i); ~stretching2.value(~tracksValue, i);
			~center.value(~tracksValue, i); ~center2.value(~tracksValue, i);
		}});
	});

	~randSomeView2 = RoundButton(~rtmCompb, Rect(60*~xSizeMul, 29*~ySizeMul, 25*~xSizeMul, 20*~ySizeMul))
	.states_([["RAL", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({
		if (~patFlag == 0, {
			~amplitude.value(~tracksValue, ~seqsValue);
			~legato.value(~tracksValue, ~seqsValue);
		}, {~seqs.do {|i|
			~amplitude.value(~tracksValue, i);
			~legato.value(~tracksValue, i);
		}});
	});

	~randSomeView3 = RoundButton(~rtmCompb, Rect(87*~xSizeMul, 29*~ySizeMul, 25*~xSizeMul, 20*~ySizeMul))
	.states_([["RO", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({
		if (~patFlag == 0, {
			~offset.value(~tracksValue, ~seqsValue);
		}, {~seqs.do {|i|
			~offset.value(~tracksValue, i);
		}});
	});

	~randOutView = RoundButton(~rtmCompb, Rect(115*~xSizeMul, 5*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
	.states_([["R POuts", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({
		if (~patFlag == 0, {
			~outingL.value(~tracksValue, ~seqsValue);
			~outingR.value(~tracksValue, ~seqsValue);
			~panning.value(~tracksValue, ~seqsValue);
		}, {~seqs.do {|i|
			~outingL.value(~tracksValue, i);
			~outingR.value(~tracksValue, i);
			~panning.value(~tracksValue, i);
		}});
	});

	~randFxView = RoundButton(~rtmCompb, Rect(115*~xSizeMul, 29*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
	.states_([["R Fxs", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({
		if (~patFlag == 0, {
			~efxL.value(~tracksValue, ~seqsValue);
			~efxR.value(~tracksValue, ~seqsValue);
		}, {~seqs.do {|i|
			~efxL.value(~tracksValue, i);
			~efxR.value(~tracksValue, i);
		}});
	});

	~randNoFxView = RoundButton(~rtmCompb, Rect(170*~xSizeMul, 29*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
	.states_([["NO Fxs", Color.white, Color.blue]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({
		if (~patFlag == 0, {
			~fxLView.valueAction_(0 ! ~dur[~tracksValue][~seqsValue].size);
			~fxRView.valueAction_(0 ! ~dur[~tracksValue][~seqsValue].size);
		}, {~seqs.do {|i|
			~fxLView.valueAction_(0 ! ~dur[~tracksValue][~seqsValue].size);
			~fxRView.valueAction_(0 ! ~dur[~tracksValue][~seqsValue].size);
		}});
	});


	~copyAView = RoundButton(~rtmCompb, Rect(170*~xSizeMul, 5*~ySizeMul, 25*~xSizeMul, 20*~ySizeMul))
	.states_([["CA", Color.red, Color.white]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({~copyA.value(~tracksValue, ~seqsValue);
	});

	~pasteAView = RoundButton(~rtmCompb, Rect(196*~xSizeMul, 5*~ySizeMul, 25*~xSizeMul, 20*~ySizeMul))
	.states_([["PA", Color.red, Color.white]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({~pasteA.value(~tracksValue, ~seqsValue);
	});

	~patFlagView = RoundButton(~rtmCompb, Rect(227*~xSizeMul, 5*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["\SEQ", Color.black, Color.white], ["\ALL", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| ~patFlag = i.value})
	.value_(0).doAction;

	~savePresetFile = 0;

	if (~presetsFileName2.isNil, {

		~savePresetFileView = RoundButton(~rtmCompb, Rect(262*~xSizeMul, 5*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
		.states_([["SaveF", Color.black, Color.white], ["NSave", Color.white, Color.red]])
		.font_(Font("Verdana",10*~fontSizeMul))
		.action_({ |i| ~savePresetFile = i.value;
			if (~savePresetFile == 0, {~presetStoringButtonView.valueAction_(1);
				/* Pour trier les données d'une String selon l'ordre croissant des premiers chiffres
				~presets.keys.asArray;
				~presets.keys.asArray[0];
				~presets.keys.asArray[0].asString.split($ )[0].asFloat;
				*/

				// Initialisation des données au départ et update à chaque fois que l'on store un preset - aupararavant dans ~presetStoringButtonView
				// ~presetList.collect({ |i| i.split($ )[4] }) // Avant l'ajout des buffers
				~presetsTypeList = ~presetList.collect({ |i| i.split($|)[3].split($ )[1] }).addAll(["ALL", "AsD", "AsF"]).as(Set).as(Array).sort; // removeDups -> extension de la librairie wslib requiert un symbole et donc pas pratique pour le mettre dans un PopUp menu qui demande une liste
				// Création de plusieurs listes de presets selon les types
				~presetListAcType = 0 ! (~presetsTypeList.size -1 +2);
				~presetsTypeList.do { |item, s| ~presetListAcType[s] = ~presetList.select({ |i| i.split($|)[3].split($ )[1] == ~presetsTypeList[s] }) };
				~presetListAcType[0] = ~presetList;
				~presetListAcType[1] = ~presetList.reject({ |i| i.split($|)[3].split($ )[1].beginsWith("D") });
				// ~presetListAcType[2] = ~presetList.reject({ |i| var type = i.split($|)[3]; type.endsWith("E") or: {type.endsWith("S")} or: {type.beginsWith("D")} });
				~presetListAcType[2] = ~presetListAcType[1].reject({ |i| var type = i.split($|)[3]; type.endsWith("E") or: {type.endsWith("S")} });
				~presetRandomTypeView.items_(~presetsTypeList).valueAction_(1); // mettre une condition car inutile de déclencher si le nb de types de presets n'a pas changé
			});

			// Juste pour mettre à jour la liste des Presets dans les pistes - même si cela n'a rien à voir avec l'enregistrement
			~nbOfTracksX2.do { |i| /*~tracksView.valueAction_(i);*/ ~presetSeqRandList[i] = ~presetSelection[i].selectIndices({|item, i| item != 0}); };
		});

	},{

		~savePresetFileView = RoundButton(~rtmCompb, Rect(262*~xSizeMul, 5*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
		.states_([["SaveF", Color.black, Color.white], ["NSave", Color.white, Color.red]])
		.font_(Font("Verdana",10*~fontSizeMul))
		.action_({ |i| ~savePresetFile = i.value;
			if (~savePresetFile == 0, {~presetStoringButtonView.valueAction_(1);
				~presetsTypeList2 = ~presetList2.collect({ |i| i.split($|)[3].split($ )[1] }).addAll(["ALL", "AsD", "AsF"]).as(Set).as(Array).sort;
				~presetListAcType2 = 0 ! (~presetsTypeList2.size -1 +2);
				~presetsTypeList2.do { |item, s| ~presetListAcType2[s] = ~presetList2.select({ |i| i.split($|)[3].split($ )[1] == ~presetsTypeList2[s] }) };
				~presetListAcType2[0] = ~presetList2;
				~presetListAcType2[1] = ~presetList2.reject({ |i| i.split($|)[3].split($ )[1].beginsWith("D") });
				~presetListAcType2[2] = ~presetListAcType2[1].reject({ |i| var type = i.split($|)[3]; type.endsWith("E") or: {type.endsWith("S")} });
				~presetRandomType2View.items_(~presetsTypeList2).valueAction_(1);
			});
			~nbOfTracksX2.do { |i| ~presetSeqRandList[i] = ~presetSelection[i].selectIndices({|item, i| item != 0}); };
		});

	});


	~followPreset = 0;
	~followPresetView = RoundButton(~rtmCompb, Rect(226*~xSizeMul /*262*/, 29*~ySizeMul, 75*~xSizeMul, 20*~ySizeMul))
	.states_([["NoFollow", Color.white, Color.red], ["Follow Seq+1", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({ |i| ~followPreset = i.value;
		if (~followPreset == 1, { ~presetsDontTriggerFXView.valueAction_(1); },{ ~presetsDontTriggerFXView.valueAction_(0); });
	});

	~followRetriggerPresetView = RoundButton(~rtmCompb, Rect(305*~xSizeMul, 29*~ySizeMul, 70*~xSizeMul, 20*~ySizeMul))
	.states_([["Retrig Seq+1", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({ |i| var prev, prevFX; prev = ~followPreset; prevFX = ~presetsDontTriggerFX; ~followPreset = 0; ~presetsDontTriggerFX = 1;
		~seqsView.valueAction_(~seqsValue+1); ~presetSeqRangeView.valueAction_(~presetSeqRangeSpec.unmap([~seqsValue, ~seqsValue+1]));
		if (~currentTab == 0, {
			~seqComp5.visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-4)*20*~ySizeMul).max(0).min(~seqComp5MaxVisibleOrigin)
		},{
			~seqCompG1[~tracksValue].visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin)
		});
		~presetSelection2View.valueAction_(~presetSelection2View.value-1);
		~presetSelection2View.valueAction_(~presetSelection2View.value+1); // car pas possible de resélectionner le current item d'une ListView
		~followPreset = prev; ~presetsDontTriggerFX = prevFX;
	});


}.value;






























// GUI MODULES 2

// Possibilité d'overload" si action sur plusieurs paramètres en même temps puisque chaque paramètre peut avoir des actions sur les autres ???
// Comment faire pour avoir un update toutes les 0.1 s ???
// Recap des améliorations à faire et des "bugs" :
// 1. Le changement inapproprié des valeurs du View lorque changement des steps du View (pour "palier" le manque d'une grille / échelle sur le MultiSlider)
// 2. Si changement du Mul, pas de changement du step & du round du Multislider -> donc round et step décalés, multipliés
// 3. Léger pb de rounding de la valeur de l'indexView en correspondance avec le Display

// ~dur non modifié XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX ???
// envir[indexView].value à remplacer par index directement XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX ???
// Mise en place de ~compColor2 & ~multiCompColor2 pour l'offset -> vraiment nécessaire ???

(
~makeModuleWindow = { | envir,
	roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
	comp, display, displayReduceFontPos, displayString1, displayString2,
	multiView, data, dataSpec, multiViewFilled, multiViewDrawLines, multiViewValueThumbSize, multiViewBackground, multiViewFillColor, multiViewStrokeColor,
	seqView, seqStart, seqStop, seqDur, seqSpec, seqSpec2, seqVSpec, seqVSpec2,
	indexView, index,
	rangeView, min, max, rangeSpec, rangeViewMinRange, rangeSliderColor, rangePresetViewView, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
	mulView, mul, mulSpec, mulSliderColor, mulPresetViewView, mulPresetView, mulPresetViewItems, mulPresetViewDefault,
	roundViewView, roundView, roundViewPos, round, roundValue, roundViewItems, roundViewDefault,
	randView, randFunc,
	seqAllView, rangeMode, seqMode,
	copyAView, copyA, pasteAView, pasteA, pasteMView, pasteM, defaultView, default,
	dirView, dir, patView, pat, patSelViewView, patSelView, patSel, block,
	showView, showViewPos, showViewAlign, showViewColor, showViewString,
	readView, readBackgroundColorView, posView
	|

	/*
	~makeModuleWindow.(currentEnvironment,
	// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
	\ratRoundViewFunc, 0, 2, 1, 0, 0.01,
	\ratComp, \ratDisplay, 75, "~ratView.valueAction_(~ratSpec[", "].unmap(~ratMul[",
	\ratView, \rat, \ratSpec, false, true, 10, ~compColor1, ~multiCompColor1, Color.white,
	\ratSeqView, \ratSeqStart, \ratSeqStop, \seqDurRat, \ratSeqSpec, \ratSeqSpec2, \ratSeqVSpec, \ratSeqVSpec2,
	\ratIndexView, \ratIndex,
	// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetViewView, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
	\ratRangeView, \ratMin, \ratMax, \ratRangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \ratRangePresetViewView, \ratRangePresetView, ["0-0.5", "0-1", "0.5-1.5", "0-2", "0-3", "0-4", "0-5", "0-10", "0-20", "0-50", "0-100", "0-128", "36-84", "36-60", "60-84", "48-72"], 3, "-", 128,
	\ratMulView, \ratMul, \ratMulSpec, ~sliderHilightColor, \ratMulPresetViewView, \ratMulPresetView, ["0.01", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
	\ratRoundViewView, \ratRoundView, ~roundViewPos5, \ratRound, \ratRoundValue, ["@ 0.01 EXP", "@ 0.1 EXP", "@ 0.125 EXP", "@ 0.2 EXP", "@ 0.25 EXP", "@ 0.5 EXP", "@ 1 EXP", "@ 0.01 LIN", "@ 0.1 LIN", "@ 0.125 1÷16T LIN", "@ 0.2 LIN", "@ 0.25 1÷8T LIN", "@ 0.5 1÷4T LIN", "@ 1 1÷2T LIN", "@ 2 1T LIN"], 0,
	\ratRandView, \rate,
	\ratSeqAllView, \ratRangeMode, \ratSeqMode,
	\ratCopyAView, \ratCopyA, \ratPasteAView, \ratPasteA, \ratPasteMView, \ratPasteM, \ratDefaultView, \ratDefault,
	\ratDirView, \ratDir, \ratPatView, \ratPat, \ratPatSelViewView, \ratPatSelView, \ratPatSel, \ratBlock,
	\ratShowView, ~nameModPos2, \left, Color.yellow, "RAT",
	\ratReadView, Color.grey(0.6), \ratPosView
	);
	*/



	// Initialisation des Arrays

	envir[dataSpec] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[data] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Special pour ~dur
	envir[index] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[rangeSpec] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[min] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[max] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[mul] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[seqSpec] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[seqVSpec] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[seqSpec2] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[seqVSpec2] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[seqStart] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[seqStop] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[seqDur] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	// ~rtmSeqIndex = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Plus utilisé

	case
	{ [\dur, \pro, \leg, \off, \off2, \off3, \off4, \amp, \rat, \str, \cen, \rat2, \str2, \cen2, \pan, \del].includes(data) }
	{
		// pas de ~synRound / ~spaRound / ~envRound / ~bufRound / ~fxLRound / ~fxRRound
		// spécial pour ~outLRound & ~outRRound
		envir[round] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
		envir[roundValue] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	};

	envir[dir] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // pour sélection du pattern ...
	envir[pat] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[patSel] = 4 ! ~nbOfSeqs ! ~nbOfTracksX2; // Pour initialiser la valeur du random à Pwhite saus exception pour Out / dur / pro ci-dessous
	envir[block] = 0 ! ~nbOfTracksX2;



	// Fonctions

	case
	{ [\rat, \str, \cen, \rat2, \str2, \cen2].includes(data) }
	{
		envir[roundViewFunc] = [
			{ |tr, seq| envir[round][tr][seq]=0.001; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.01; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.1; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.2; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.25; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.5; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=1; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.01; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.1; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.125; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.2; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.25; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.5; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=1; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=2; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])}
		];
	}
	{ [\leg, \amp].includes(data) }
	{
		envir[roundViewFunc] = [
			{ |tr, seq| envir[round][tr][seq]=0.01; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.1; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.125; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.2; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.25; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.5; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=1; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, 4, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.01; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.1; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.125; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.2; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.25; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.5; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=1; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=2; envir[rangeSpec][tr][seq] = ControlSpec(0, rangeMax, \lin, envir[round][tr][seq])}
		];
	}
	{ \dur == data }
	{
		envir[roundViewFunc] = [
			{ |tr, seq| envir[round][tr][seq]=0.00000000000000001; },
			{ |tr, seq| envir[round][tr][seq]=0.01; },
			{ |tr, seq| envir[round][tr][seq]=0.1; },
			{ |tr, seq| envir[round][tr][seq]=0.125; },
			{ |tr, seq| envir[round][tr][seq]=0.2; },
			{ |tr, seq| envir[round][tr][seq]=0.25; },
			{ |tr, seq| envir[round][tr][seq]=0.5; }
		];
	}
	{ [\pro, \amp, \pan].includes(data) }
	{
		envir[roundViewFunc] = [
			{ |tr, seq| envir[round][tr][seq]=0.01; },
			{ |tr, seq| envir[round][tr][seq]=0.1; },
			{ |tr, seq| envir[round][tr][seq]=0.2; },
			{ |tr, seq| envir[round][tr][seq]=0.25; },
			{ |tr, seq| envir[round][tr][seq]=0.5; },
			{ |tr, seq| envir[round][tr][seq]=1; }
		];
	}
	{ [\off, \off2, \off3, \off4].includes(data) }
	{
		envir[roundViewFunc] = [
			{ |tr, seq| envir[round][tr][seq]=0.001; },
			{ |tr, seq| envir[round][tr][seq]=0.01; },
			{ |tr, seq| envir[round][tr][seq]=0.1; },
			{ |tr, seq| envir[round][tr][seq]=0.2; },
			{ |tr, seq| envir[round][tr][seq]=0.25; },
			{ |tr, seq| envir[round][tr][seq]=0.5; },
			{ |tr, seq| envir[round][tr][seq]=1; }
		];
	}
	{ [\del].includes(data) }
	{
		envir[roundViewFunc] = [
			{ |tr, seq| envir[round][tr][seq]=0.001; },
			{ |tr, seq| envir[round][tr][seq]=0.01; },
			{ |tr, seq| envir[round][tr][seq]=0.1; },
			{ |tr, seq| envir[round][tr][seq]=0.2; },
			{ |tr, seq| envir[round][tr][seq]=0.25; },
			{ |tr, seq| envir[round][tr][seq]=0.5; },
			{ |tr, seq| envir[round][tr][seq]=1; }
		];
	};



	case { \dur == data }
	{
		envir[mulSpec] = /*0*/ ControlSpec(/*timeOnset*/ 0.5 * (20 * ~rtmMulMinProtect / (0.5 / 0.01).squared), 10, 4, 0.001, 1) ! ~nbOfSeqs ! ~nbOfTracksX2;
		// envir[mulSpec][tr][seq] = ControlSpec(0.016 10, 4, 0.01, 1); // Mise en place d'une sécurité avec une multiplication
	}
	{ [\rat, \str, \cen, \rat2, \str2, \cen2, \leg].includes(data) }
	{
		envir[mulSpec] = ControlSpec(0.01, 10, 4, 0.01, 1);
	}
	{ \amp == data }
	{
		envir[mulSpec] = ControlSpec(0, rangeMax, \lin, 0.01, 1);
	}
	{ [\pro, \syn, \spa, \env, \buf, \off, \off2, \off3, \off4, \pan, \del, \outL, \outR, \fxL, \fxR].includes(data) }
	{
		// envir[mulSpec] = ControlSpec(0, 1, \lin, 0.001, 1); // avant pour del & envir[mulSpec] = ControlSpec(0, 1, \lin, 0.01, 1); pour les autres
		// envir[mulSpec] = ControlSpec(0.01, 10, 4, 0.01, 1);
		envir[mulSpec] = ControlSpec(0, 10, 4, 0.01, 1);
	};



	// Assignation des données

	~tracks.do { |tr|
		~seqs.do { |seq|

			envir[min][tr][seq] = minDefault;
			envir[max][tr][seq] = maxDefault;
			envir[mul][tr][seq] = 1;



			case { [\dur, \pro, \rat, \str, \cen, \rat2, \str2, \cen2, \leg, \off, \off2, \off3, \off4, \amp, \pan, \del].includes(data) }
			{
				envir[round][tr][seq] = roundDefault;
				envir[roundValue][tr][seq] = roundValueDefault;
				envir[dataSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, roundDefault);
			}
			{ [\syn, \spa, \env, \buf, \fxL, \fxR].includes(data) }
			{
				envir[dataSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, 1);
			}
			{ [\outL, \outR].includes(data) }
			{
				if (~numChannels == 2, {envir[max][tr][seq] = 16}, {envir[max][tr][seq] = ~numChannels} );
				envir[dataSpec][tr][seq] = ControlSpec(envir[min][tr][seq], envir[max][tr][seq], \lin, 1);

				if (~numChannelsConfig == "22-8+Dome-8-4-2-Pair", {envir[dataSpec][tr][seq] = ControlSpec(1, 14, \lin, 1); envir[min][tr][seq] = 1; envir[max][tr][seq] = 14} );

				if (~numChannels == 2, {envir[rangeSpec][tr][seq] = ControlSpec(1, 16, \lin, 1)}, {envir[rangeSpec][tr][seq] = ControlSpec(1, ~numChannels, \lin, 1)} );

				// envir[min][tr][seq] = 1; // Pourquoi répété initialement ???
				// if (~numChannels == 2, {envir[max][tr][seq] = 16}, {envir[max][tr][seq] = ~numChannels} ); // Pourquoi répété initialement ???
			};



			case { \dur == data }
			{
				envir[rangeSpec][tr][seq] = ControlSpec(minDefault, rangeMax, 4);
			}
			{ [\rat, \str, \cen, \rat2, \str2, \cen2, \leg].includes(data) }
			{
				envir[rangeSpec][tr][seq] = ControlSpec(minDefault, rangeMax, /*\exp*/ 4, roundDefault);
			}
			{ \amp == data }
			{
				envir[rangeSpec][tr][seq] = ControlSpec(minDefault, rangeMax, \lin, roundDefault);
			}
			{ [\syn, \spa, \env, \buf, \fxL, \fxR].includes(data) }
			{
				envir[rangeSpec][tr][seq] = ControlSpec(minDefault, rangeMax, \lin, 1);
			}
			{ [\pro, \off, \off2, \off3, \off4, \pan, \del].includes(data) }
			{
				envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, roundDefault);
				/*
				~panSpec;
				~panRangeSpec;
				*/
			};



			// ~dur[tr][seq] = SparseArray.newClear(4, ~rtmSpec[tr][seq].unmap(1)); // Comment créer une Sparse array - intérêt ???
			envir[data][tr][seq] = envir[dataSpec][tr][seq].unmap(dataDefault) !4;
			envir[seqSpec][tr][seq] = ControlSpec(0, envir[data][tr][seq].size, \lin, 1);
			envir[seqVSpec][tr][seq] = ControlSpec(0, envir[data][tr][seq].size-1, \lin, 1);
			envir[seqSpec2][tr][seq] = ControlSpec(0, envir[data][tr][seq].size, \lin, 1);
			envir[seqVSpec2][tr][seq] = ControlSpec(0, envir[data][tr][seq].size-1, \lin, 1);
			envir[seqStart][tr][seq] = 0;
			envir[seqStop][tr][seq] = envir[seqSpec][tr][seq].map(1).asInteger - 1;
			envir[seqDur][tr][seq] = envir[seqStop][tr][seq] - envir[seqStart][tr][seq] + 1;



			case
			{ \dur == data }
			{
				~rtmPatSel[tr][seq] = 0;
			}
			{ \pro == data }
			{
				~proBjorSpec[tr][seq] = ControlSpec(0, ~pro[tr][seq].size, \lin, 1);
				~proBjor[tr][seq] = ~proBjorSpec[tr][seq].map(~pro[tr][seq].size);
				~proBjor2[tr][seq] = ~proBjorSpec[tr][seq].map(~pro[tr][seq].size);
				// Sélection initiale dela ryhtmique euclidienne
				~proPatSel[tr][seq] = 13;
			}
			{ \off == data }
			{
				~offThresh[tr][seq] = 0.4;
			}
			{ \str == data }
			{
				~psPitchDispers[tr][seq] = ~psPitchDispersSpec.default; // Préférable d'utiliser le spec par défault pour les autres aussi XXXXXXXXX
				~psTimeDispers[tr][seq] = ~psTimeDispersSpec.default;
			}
			{ \cen == data }
			{
				~psWindowSize[tr][seq] = ~psWindowSizeSpec.default;
			}
			{ \outL == data }
			{
				~outLPatSel[tr][seq] = 55; // ~controlBus0 -> mais déclaré dans le pattern
			}
			{ \outR == data }
			{
				~outRPatSel[tr][seq] = 55; // ~controlBus0 -> mais déclaré dans le pattern
			};
		};
	};



	// GUI

	// TextDisplay

	envir[display] = TextView(envir[comp], ~displayPos5)
	//.autohidesScrollers_(0)
	.hasVerticalScroller_(false)
	.hasHorizontalScroller_(false)
	.enterInterpretsSelection_(1)
	.font_(Font("arial",10*~fontSizeMul));



	// MultiView

	envir[multiView] = MultiSliderView.new(envir[comp], ~viewPos5);
	envir[multiView].value_(envir[data][~tracksValue][~seqsValue])
	.background_(multiViewBackground)
	.strokeColor_(multiViewStrokeColor)
	.fillColor_(multiViewFillColor)
	.elasticMode_(1)
	.isFilled_(multiViewFilled)
	.drawLines_(multiViewDrawLines)
	.thumbSize_(envir[multiView].bounds.width / (envir[data][~tracksValue][~seqsValue].size))
	.showIndex_(~multiSliderIndex);

	case { \dur == data }
	{
		envir[multiView]
		.valueThumbSize_(multiViewValueThumbSize)
		.action_({ | view |
			view.value.do({|x, i|
				~dur[~tracksValue][~seqsValue][i] = x});

			// Changement des rhythmes en absolu pour relatif
			if (~rtmType[~tracksValue][~seqsValue] == 0, {~dur[~tracksValue][~seqsValue] = ~dur[~tracksValue][~seqsValue] * ~nbTotalBeats[~tracksValue][~seqsValue] / (~dur[~tracksValue][~seqsValue].sum * ~rtmMax[~tracksValue][~seqsValue]);

				// Ajustement du max pour respecter le nb de temps
				if (~rtmSpec[~tracksValue][~seqsValue].map(~dur[~tracksValue][~seqsValue]).sum.round(0.001) != ~nbTotalBeats[~tracksValue][~seqsValue].round(0.001), {~rtmAdjustFunction.value});
				/*
				~rtmSpec[~tracksValue][~seqsValue].map(~dur[~tracksValue][~seqsValue]).sum;
				*/
				/*block {|break|
				100.do { |i|
				if (~rtmSpec[~tracksValue][~seqsValue].map(~dur[~tracksValue][~seqsValue]).sum.round(0.001) != ~nbTotalBeats[~tracksValue][~seqsValue].round(0.001), {~rtmAdjustFunction.value});
				if (~rtmSpec[~tracksValue][~seqsValue].map(~dur[~tracksValue][~seqsValue]).sum.round(0.001) == ~nbTotalBeats[~tracksValue][~seqsValue].round(0.001)) {break.value(i)};
				}
				};*/
			});

			~rtmDisplay.string_("~rtmView.valueAction_(~rtmSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~rtmMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~rtmSpec[~tracksValue][~seqsValue].map(~dur[~tracksValue][~seqsValue]) * ~rtmMul[~tracksValue][~seqsValue]).round(~rtmRound[~tracksValue][~seqsValue]).asCompileString+"));").asString; ~rtmDisplay.setFont((Font("arial",1)), 4, 75);
		});
	}
	{ [\rat, \str, \cen, \rat2, \str2, \cen2, \leg, \amp].includes(data) }
	{
		envir[multiView]
		.valueThumbSize_(multiViewValueThumbSize)
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x});
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue]) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		});
	}
	{ [\pro, \off, \off2, \off3, \off4, \del].includes(data) }
	{
		envir[multiView]
		.valueThumbSize_(multiViewValueThumbSize)
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x});
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		});
	}
	{ [\syn, \spa, \buf, \env].includes(data) }
	{
		envir[multiView]
		.valueThumbSize_(max(10, if ((envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1) > ~multiSliderHeight5, {10}, {~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1)})))
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x});
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).asInteger).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		});
	}
	{ \pan == data }
	{
		envir[multiView]
		.valueThumbSize_(max(10, if (((abs(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue])) / envir[round][~tracksValue][~seqsValue]+1) > ~multiSliderHeight5, {10},
			{~multiSliderHeight5 /((abs(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue])) / envir[round][~tracksValue][~seqsValue]+1)})))
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x });
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		});
	}
	{ [\outR, \fxR].includes(data) }
	{
		envir[multiView]
		.valueThumbSize_(max(10, (~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1))))
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x});
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])).asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		});
	}
	{ \outL == data } // Action sur les 2 OUT en même temps
	{
		envir[multiView]
		.valueThumbSize_(max(10, (~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1))))
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x; if (~outActOnWhich == 1, {~outR[~tracksValue][~seqsValue][i] = x }) });
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])).asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);

			if (~outActOnWhich == 1, {
				if (~zoomMultiSlider == 0, {
					~outRView.valueAction_(~outL[~tracksValue][~seqsValue]);

					// Manière pour agir sur les 2 à la fois mais plus pratique et moins de code que le L agisse sur le R
					/*~outRView.value_(~outL[~tracksValue][~seqsValue]);
					~outRDisplay.string_(("~outRView.valueAction_(~outRSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~outRMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue]) * envir[mul][~tracksValue][~seqsValue]).round(1).asInteger.asCompileString+"));").asString).setFont((Font("arial",1)), 4, displayReduceFontPos);*/
				}, {
					~outRView.value_(~outL[~tracksValue][~seqsValue][(0..max(0,~outLSeqStop[~tracksValue][~seqsValue]))]);
					~outRView.startIndex_(~outRSeqStart[~tracksValue][~seqsValue]);
					~outRView.indexThumbSize_(/*~outRView.bounds.width*/ 333 / ~seqDurOutR[~tracksValue][~seqsValue]);
					~outRSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOutR[~tracksValue][~seqsValue], \lin, 1); // Pour le Text ReadView
					~outRSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOutR[~tracksValue][~seqsValue]-1, \lin, 1); // Pour le Slider ReadView
					~outRReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurOutR[~tracksValue][~seqsValue])*~xSizeMul));
				});
			});

		});
	}
	{ \fxL == data } // Action sur les 2 FX en même temps
	{
		envir[multiView]
		.valueThumbSize_(max(10, (~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1))))
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x; if (~fxActOnWhich == 1, {~fxR[~tracksValue][~seqsValue][i] = x }) });
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])).asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);

			if (~fxActOnWhich == 1, {
				if (~zoomMultiSlider == 0, {
					~fxRView.valueAction_(~fxL[~tracksValue][~seqsValue]);
				}, {
					~fxRView.value_(~fxL[~tracksValue][~seqsValue][(0..max(0,~fxLSeqStop[~tracksValue][~seqsValue]))]);
					~fxRView.startIndex_(~fxRSeqStart[~tracksValue][~seqsValue]);
					~fxRView.indexThumbSize_(/*~fxRView.bounds.width*/ 333 / ~seqDurFxR[~tracksValue][~seqsValue]);
					~fxRSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurFxR[~tracksValue][~seqsValue], \lin, 1); // Pour le Text ReadView
					~fxRSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurFxR[~tracksValue][~seqsValue]-1, \lin, 1); // Pour le Slider ReadView
					~fxRReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurFxR[~tracksValue][~seqsValue])*~xSizeMul));
				});
			});

		});
	};



	// SeqView

	envir[seqView] = SmoothRangeSlider(envir[comp], ~seqViewPos5)
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightNoColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.value_([0, 1])
	.minRange_(1/(envir[data][~tracksValue][~seqsValue].size))
	.step_(1/(envir[data][~tracksValue][~seqsValue].size))
	.doAction;

	case { [\dur, \pro, \rat, \str, \cen, \rat2, \str2, \cen2, \leg, \off, \off2, \off3, \off4, \amp, \syn, \spa, \env, \buf, \pan, \del, \outR, \fxR].includes(data) }
	{
		envir[seqView].action_({ |view| envir[seqStart][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.lo).asInteger; envir[seqStop][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.hi).asInteger-1;
			envir[seqDur][~tracksValue][~seqsValue] = envir[seqStop][~tracksValue][~seqsValue] - envir[seqStart][~tracksValue][~seqsValue] + 1;
			view.string = ("% to % (Dur : %)").format(envir[seqStart][~tracksValue][~seqsValue], envir[seqStop][~tracksValue][~seqsValue], envir[seqDur][~tracksValue][~seqsValue]);

			// Changement de couleur si toute le séquence n'est pas sélectionnée - vraiment nécessaire ???
			if (view.range != 1, {view.background = Color.red}, {view.background = ~sliderBackgroundColor});

			// Test Zoom Multislider sur les buffers
			// Solution 1 Zoom Multislider en utilisant indexThumbSize mais pas du tout précis ->
			// ~bufView.gap = 1;
			/*~bufView.elasticMode_(0).startIndex_(~bufSeqStart[~tracksValue][~seqsValue]);
			~bufView.indexThumbSize_((~bufView.bounds.width - ~seqDurBuf[~tracksValue][~seqsValue] /*pour le gap*/ )  / ~seqDurBuf[~tracksValue][~seqsValue]).postln;
			// ~bufView.indexThumbSize_(~bufView.bounds.width / ~seqDurBuf[~tracksValue][~seqsValue]);
			// ~bufView.indexThumbSize_(1.5)*/

			// Solution 2 Zoom Multislider mais en n'utilisant pas startIndex, donc action seulement sur les 1ers éléments du MultiSlider
			/*~test = (~bufSeqStart[~tracksValue][~seqsValue]..~bufSeqStop[~tracksValue][~seqsValue]);
			~bufView.valueAction_(~buf[~tracksValue][~seqsValue][~test]);
			~bufView.indexThumbSize_(~bufView.bounds.width / ~seqDurBuf[~tracksValue][~seqsValue]);*/

			// Solution 3 Zoom Multislider mais pas de zoom sur la selection de la séquence
			/*~bufView.startIndex_(~bufSeqStart[~tracksValue][~seqsValue]);
			~bufView.indexThumbSize_(~bufView.bounds.width / ~seqDurBuf[~tracksValue][~seqsValue]);*/

			// Solution finale Zoom Multislider
			// ~test = (0..max(0,~bufSeqStop[~tracksValue][~seqsValue]));
			// ~bufView.valueAction_(~buf[~tracksValue][~seqsValue][~test]);
			// Pourquoi la ligne ci-dessous n'a pas d'action sur la quantité de valeurs dans ~buf[~tracksValue][~seqsValue] ??????
			// ~bufSeqStop[~tracksValue][~seqsValue].postln; // Pourquoi ~bufSeqStop peut rendre -1 si un preset généré a un nombre d'évènements inférieur ??????
			// et donc besoin d'utiliser max()

			// Zoom multislider
			if (~zoomMultiSlider == 1, {
				envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				envir[multiView].startIndex_(envir[seqStart][~tracksValue][~seqsValue]);
				envir[multiView].indexThumbSize_(envir[multiView].bounds.width / envir[seqDur][~tracksValue][~seqsValue]);
				envir[seqSpec2][~tracksValue][~seqsValue] = ControlSpec(0, envir[seqDur][~tracksValue][~seqsValue], \lin, 1); // Pour le Text ReadView
				envir[seqVSpec2][~tracksValue][~seqsValue] = ControlSpec(0, envir[seqDur][~tracksValue][~seqsValue]-1, \lin, 1); // Pour le Slider ReadView
				envir[readView].thumbSize_(max(~readViewThumbSize, (333 / envir[seqDur][~tracksValue][~seqsValue])*~xSizeMul));
			});
		})
	}
	{ \outL == data } // Action sur les 2 FX en même temps
	{
		envir[seqView].action_({ |view| envir[seqStart][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.lo).asInteger; envir[seqStop][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.hi).asInteger-1;
			envir[seqDur][~tracksValue][~seqsValue] = envir[seqStop][~tracksValue][~seqsValue] - envir[seqStart][~tracksValue][~seqsValue] + 1;
			view.string = ("% to % (Dur : %)").format(envir[seqStart][~tracksValue][~seqsValue], envir[seqStop][~tracksValue][~seqsValue], envir[seqDur][~tracksValue][~seqsValue]);

			// Changement de couleur si toute le séquence n'est pas sélectionnée - vraiment nécessaire ???
			if (view.range != 1, {view.background = Color.red}, {view.background = ~sliderBackgroundColor});

			if (~outActOnWhich == 1, {
				~outRSeqView.valueAction_(view.value);

				// Manière pour agir sur les 2 à la fois mais plus pratique et moins de code que le L agisse sur le R
				/*~outRSeqView.value_(~outLSeqView.value)/*.doAction*/;
				~outRSeqStart[~tracksValue][~seqsValue] = ~outRSeqSpec[~tracksValue][~seqsValue].map(view.lo).asInteger; ~outRSeqStop[~tracksValue][~seqsValue] = ~outRSeqSpec[~tracksValue][~seqsValue].map(view.hi).asInteger-1;
				~seqDurOutR[~tracksValue][~seqsValue] = ~outRSeqStop[~tracksValue][~seqsValue] - ~outRSeqStart[~tracksValue][~seqsValue] + 1;
				~outRSeqView.string = ("% to % (Dur : %)").format(~outRSeqStart[~tracksValue][~seqsValue], ~outRSeqStop[~tracksValue][~seqsValue], ~seqDurFxR[~tracksValue][~seqsValue]);
				// Changement de couleur si toute le séquence n'est pas sélectionnée - vraiment nécessaire ???
				if (~outRSeqView.range != 1, {~outRSeqView.background = Color.red}, {~outRSeqView.background = ~sliderBackgroundColor});*/
			});

			// Zoom multislider
			if (~zoomMultiSlider == 1, {
				envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				envir[multiView].startIndex_(envir[seqStart][~tracksValue][~seqsValue]);
				envir[multiView].indexThumbSize_(envir[multiView].bounds.width / envir[seqDur][~tracksValue][~seqsValue]);
				envir[seqSpec2][~tracksValue][~seqsValue] = ControlSpec(0, envir[seqDur][~tracksValue][~seqsValue], \lin, 1); // Pour le Text ReadView
				envir[seqVSpec2][~tracksValue][~seqsValue] = ControlSpec(0, envir[seqDur][~tracksValue][~seqsValue]-1, \lin, 1); // Pour le Slider ReadView
				envir[readView].thumbSize_(max(~readViewThumbSize, (333 / envir[seqDur][~tracksValue][~seqsValue])*~xSizeMul));

				if (~outActOnWhich == 1, {
					~outRView.valueAction_(~outR[~tracksValue][~seqsValue][(0..max(0,~outRSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
					~outRView.startIndex_(~outRSeqStart[~tracksValue][~seqsValue]);
					~outRView.indexThumbSize_(~outRView.bounds.width / ~seqDurOutR[~tracksValue][~seqsValue]);
					~outRSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOutR[~tracksValue][~seqsValue], \lin, 1); // Pour le Text ReadView
					~outRSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOutR[~tracksValue][~seqsValue]-1, \lin, 1); // Pour le Slider ReadView
					~outRReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurOutR[~tracksValue][~seqsValue])*~xSizeMul));
				})
			});

		})
	}
	{ \fxL == data } // Action sur les 2 FX en même temps
	{
		envir[seqView].action_({ |view| envir[seqStart][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.lo).asInteger; envir[seqStop][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.hi).asInteger-1;
			envir[seqDur][~tracksValue][~seqsValue] = envir[seqStop][~tracksValue][~seqsValue] - envir[seqStart][~tracksValue][~seqsValue] + 1;
			view.string = ("% to % (Dur : %)").format(envir[seqStart][~tracksValue][~seqsValue], envir[seqStop][~tracksValue][~seqsValue], envir[seqDur][~tracksValue][~seqsValue]);

			// Changement de couleur si toute le séquence n'est pas sélectionnée - vraiment nécessaire ???
			if (view.range != 1, {view.background = Color.red}, {view.background = ~sliderBackgroundColor});

			if (~fxActOnWhich == 1, {~fxRSeqView.valueAction_(view.value) });

			// Zoom multislider
			if (~zoomMultiSlider == 1, {
				envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				envir[multiView].startIndex_(envir[seqStart][~tracksValue][~seqsValue]);
				envir[multiView].indexThumbSize_(envir[multiView].bounds.width / envir[seqDur][~tracksValue][~seqsValue]);
				envir[seqSpec2][~tracksValue][~seqsValue] = ControlSpec(0, envir[seqDur][~tracksValue][~seqsValue], \lin, 1); // Pour le Text ReadView
				envir[seqVSpec2][~tracksValue][~seqsValue] = ControlSpec(0, envir[seqDur][~tracksValue][~seqsValue]-1, \lin, 1); // Pour le Slider ReadView
				envir[readView].thumbSize_(max(~readViewThumbSize, (333 / envir[seqDur][~tracksValue][~seqsValue])*~xSizeMul));

				if (~fxActOnWhich == 1, {
					~fxRView.valueAction_(~fxR[~tracksValue][~seqsValue][(0..max(0,~fxRSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
					~fxRView.startIndex_(~fxRSeqStart[~tracksValue][~seqsValue]);
					~fxRView.indexThumbSize_(~fxRView.bounds.width / ~seqDurFxR[~tracksValue][~seqsValue]);
					~fxRSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurFxR[~tracksValue][~seqsValue], \lin, 1); // Pour le Text ReadView
					~fxRSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurFxR[~tracksValue][~seqsValue]-1, \lin, 1); // Pour le Slider ReadView
					~fxRReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurFxR[~tracksValue][~seqsValue])*~xSizeMul));
				})
			});

		})
	};



	// IndexView

	envir[indexView] = SmoothSlider(envir[comp], ~indexViewPos5)
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightNoColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor);

	case { \dur == data }
	{
		envir[indexView]
		.action_({ |view| envir[index][~tracksValue][~seqsValue] = envir[dataSpec][~tracksValue][~seqsValue].map(view.value);
			if (envir[round][~tracksValue][~seqsValue] < 0.001, {view.string = "At : %".format((envir[index][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(0.001))}, {view.string = "At : %".format((envir[index][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]))});
			// envir[multiView].valueAction_(envir[index][~tracksValue][~seqsValue].curvelin(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], 0, 1, 2) ! envir[data][~tracksValue][~seqsValue].size)
			// Modif pour action sur multislider seulement sur la sélection de la séquence au lieu de toute la séquence
			// envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue].putEach([(envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue])], [envir[dataSpec][~tracksValue][~seqsValue].unmap(envir[index][~tracksValue][~seqsValue])] ));

			// Zoom Multislider
			if (~zoomMultiSlider == 1, {
				envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))].putEach([(envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue])], [envir[dataSpec][~tracksValue][~seqsValue].unmap(envir[index][~tracksValue][~seqsValue])] )); // apparemment pas besoin de flat
			}, { envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue].putEach([(envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue])], [envir[dataSpec][~tracksValue][~seqsValue].unmap(envir[index][~tracksValue][~seqsValue])] ));
			});
		});
	}
	{ [\rat, \str, \cen, \rat2, \str2, \cen2, \leg, \amp ].includes(data) }
	{
		envir[indexView]
		.action_({ |view| envir[index][~tracksValue][~seqsValue] = envir[dataSpec][~tracksValue][~seqsValue].map(view.value);
			view.string = "At : %".format((envir[index][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]));

			// Zoom Multislider
			if (~zoomMultiSlider == 1, {
				envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))].putEach([(envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue])], [envir[dataSpec][~tracksValue][~seqsValue].unmap(envir[index][~tracksValue][~seqsValue])] )); // apparemment pas besoin de flat
			}, { envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue].putEach([(envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue])], [envir[dataSpec][~tracksValue][~seqsValue].unmap(envir[index][~tracksValue][~seqsValue])] ));
			});
		});
	}
	{ [\pro, \off, \off2, \off3, \off4, \del ].includes(data) }
	{
		envir[indexView]
		.action_({ |view| envir[index][~tracksValue][~seqsValue] = envir[dataSpec][~tracksValue][~seqsValue].map(view.value);
			view.string = "At : %".format(((envir[index][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).min( envir[max][~tracksValue][~seqsValue]/*1*/)).round(envir[round][~tracksValue][~seqsValue]));

			// Zoom Multislider
			if (~zoomMultiSlider == 1, {
				envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))].putEach([(envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue])], [envir[dataSpec][~tracksValue][~seqsValue].unmap(envir[index][~tracksValue][~seqsValue])] )); // apparemment pas besoin de flat
			}, { envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue].putEach([(envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue])], [envir[dataSpec][~tracksValue][~seqsValue].unmap(envir[index][~tracksValue][~seqsValue])] ));
			});
		});
	}
	{ [\spa, \buf, \syn, \env, \outL, \outR, \fxL, \fxR].includes(data) }
	{
		envir[indexView]
		.action_({ |view| envir[index][~tracksValue][~seqsValue] = envir[dataSpec][~tracksValue][~seqsValue].map(view.value);
			view.string = "At : %".format((envir[index][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).min( envir[max][~tracksValue][~seqsValue] /*1*/).asInteger)/*.round(1)*/;

			// Zoom Multislider
			if (~zoomMultiSlider == 1, {
				envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))].putEach([(envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue])], [envir[dataSpec][~tracksValue][~seqsValue].unmap(envir[index][~tracksValue][~seqsValue])] )); // apparemment pas besoin de flat
			}, { envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue].putEach([(envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue])], [envir[dataSpec][~tracksValue][~seqsValue].unmap(envir[index][~tracksValue][~seqsValue])] ));
			});
		});
	}
	{ \pan == data }
	{
		envir[indexView]
		.action_({ |view| envir[index][~tracksValue][~seqsValue] = envir[dataSpec][~tracksValue][~seqsValue].map(1 - view.value);
			view.string = "L <--  At : %  --> R".format((envir[index][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]));

			// Zoom Multislider
			if (~zoomMultiSlider == 1, {
				envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))].putEach([(envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue])], (1 - view.value) /*[envir[dataSpec][~tracksValue][~seqsValue].unmap(envir[index][~tracksValue][~seqsValue])]*/ )); // apparemment pas besoin de flat & voir si view.value ne peut pas être utilisé pour les autres modules - plus économique en CPU
			}, { envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue].putEach([(envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue])], (1 - view.value) /*[envir[dataSpec][~tracksValue][~seqsValue].unmap(envir[index][~tracksValue][~seqsValue])]*/ ));
			});
		});
	};

	envir[indexView].valueAction_(envir[dataSpec][~tracksValue][~seqsValue].unmap(dataDefault))
	.doAction;



	// RangeView

	envir[rangeView] = SmoothRangeSlider(envir[comp], ~rangeViewPos5)
	.font_(Font("Verdana", 8*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(rangeSliderColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor);
	// .align = \center; // par défaut

	case { [\rat, \str, \cen, \rat2, \str2, \cen2, \leg].includes(data) }
	{
		envir[rangeView]
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)); envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi));
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n%".format(
				(if ((envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]) > 100, { (envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(1) }, {(envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])})),
				(if ((envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]) > 100, { (envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(1) }, {(envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])}))));
			// Le changement de step provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
			// Le changement de step provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step  si > à 0.1
			// si lancement d'une routine pour automatisation, le tête de lecture visuelle sur le multislider sera perturbé
			if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))});
			envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue]) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		})
		.minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue] * 4))
		.value_([0, 1]);
	}
	{ \dur == data }
	{
		envir[rangeView]
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)); envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi));
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			if (envir[round][~tracksValue][~seqsValue] < 0.001, {
				view.string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(0.001), (envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(0.001)))}, {
				view.string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]), (envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])))});
			// Le changement de step provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
			// Le changement de step provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step  si > à 0.1
			// si lancement d'une routine pour automatisation, le tête de lecture visuelle sur le multislider sera perturbé
			if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))});
			envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
			if (envir[round][~tracksValue][~seqsValue] < 0.001, {
				envir[indexView].string = "At : %".format((envir[index][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(0.001))}, {
				envir[indexView].string = "At : %".format((envir[index][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]))}); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue]) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		})
		.minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue] * 2)); // * 4 initialement ?
		// ~rtmRangeView[0][0].inactive // Comment rendre le slider inactif ???
	}
	{ [\amp].includes(data) }
	{
		envir[rangeView]
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)); envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi));
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]), (envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])));
			// Le changement de step provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
			// Le changement de step provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step  si > à 0.1
			// si lancement d'une routine pour automatisation, le tête de lecture visuelle sur le multislider sera perturbé
			if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))});
			envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue]) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		})
		.minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue] * 2))
		.value_([0, 1]);
	}
	{ [\pro, \off, \off2, \off3, \off4].includes(data) }
	{
		envir[rangeView]
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)); envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi));
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
			view.string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]), (envir[min][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])));
			// Le changement de step provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
			// Le changement de step provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step  si > à 0.1
			// si lancement d'une routine pour automatisation, le tête de lecture visuelle sur le multislider sera perturbé
			if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))});
			envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value * envir[mul][~tracksValue][~seqsValue] )).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		})
		.minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue] * 2))
		.value_([0, 1]); // dissocié de del juste pour value...
	}
	{ [\del].includes(data) }
	{
		envir[rangeView]
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)); envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi));
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
			view.string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]), (envir[min][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])));
			// Le changement de step provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
			// Le changement de step provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step  si > à 0.1
			// si lancement d'une routine pour automatisation, le tête de lecture visuelle sur le multislider sera perturbé
			if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))});
			envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value * envir[mul][~tracksValue][~seqsValue] )).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		})
		.minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue] * 2))
		.value_([0, 0.01]);
	}
	{ [\syn, \env].includes(data) }
	{
		envir[rangeView]
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)).asInteger; envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi)).asInteger;
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, 1);
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue])/*.round(1).asInteger*/, (envir[min][~tracksValue][~seqsValue])/*.round(1).asInteger*/));

			// Le changement de step provoque des changements des valeurs du View surtout si round est 1 -> à améliorer
			envir[multiView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[multiView].valueThumbSize_(max(10, if ((envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1) > ~multiSliderHeight5, {10}, {~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1)})));

			// envir[multiView].value_(envir[data][~tracksValue][~seqsValue]); // Pour récupérer les données dans le multislider
			// Zoom Multislider // vraiment nécessaire ?????????
			if (~zoomMultiSlider == 1, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))]);
			}, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue]) }); // Pour récupérer les données dans le multislider

			envir[indexView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value * envir[mul][~tracksValue][~seqsValue])).asInteger/*round(1)*/)); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]))/*.round(1)*/.asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		})
		.step_(rangeViewMinRange) // (1/(~allSynths2.size - 1)) pour Syn // (1/(~allEnvsGUI.size - 1)) pour Env // (1/(~bufFolderM[~tracksValue][~seqsValue].size - 1)) pour Buf // (1/(~allSpasGUIFinal.size - 1)) pour Spa - intérêt ?????????
		.minRange_(rangeViewMinRange) // (1/~allSynths2.size) pour Syn // (1/~allEnvsGUI.size)) pour Env // (1/~bufFolderM[~tracksValue][~seqsValue].size) pour Buf // & 0 pour le spa ?????????
		.value_([0, 1]);
	}
	{ [\buf].includes(data) }
	{
		envir[rangeView]
		.action_({ |view|
			~bufMinRaw[~tracksValue][~seqsValue] = view.lo; ~bufMaxRaw[~tracksValue][~seqsValue] = view.hi;
			envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)).asInteger; envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi)).asInteger;
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, 1);
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue])/*.round(1).asInteger*/, (envir[min][~tracksValue][~seqsValue])/*.round(1).asInteger*/));

			// Le changement de step provoque des changements des valeurs du View surtout si round est 1 -> à améliorer
			envir[multiView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[multiView].valueThumbSize_(max(10, if ((envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1) > ~multiSliderHeight5, {10}, {~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1)})));

			// envir[multiView].value_(envir[data][~tracksValue][~seqsValue]); // Pour récupérer les données dans le multislider
			// Zoom Multislider // vraiment nécessaire ?????????
			if (~zoomMultiSlider == 1, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))]);
			}, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue]) }); // Pour récupérer les données dans le multislider

			envir[indexView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value * envir[mul][~tracksValue][~seqsValue])).asInteger/*round(1)*/)); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]))/*.round(1)*/.asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		})
		.step_(rangeViewMinRange) // (1/(~allSynths2.size - 1)) pour Syn // (1/(~allEnvsGUI.size - 1)) pour Env // (1/(~bufFolderM[~tracksValue][~seqsValue].size - 1)) pour Buf // (1/(~allSpasGUIFinal.size - 1)) pour Spa - intérêt ?????????
		.minRange_(rangeViewMinRange) // (1/~allSynths2.size) pour Syn // (1/~allEnvsGUI.size)) pour Env // (1/~bufFolderM[~tracksValue][~seqsValue].size) pour Buf // & 0 pour le spa ?????????
		.value_([0, 1]);
	}
	{ [\spa].includes(data) } // était préalablement intégré au dessus - distinction à faire aussi avec Env ?????????
	{
		envir[rangeView]
		.action_({ |view| var string;
			envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)).asInteger; envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi)).asInteger;
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, 1);

			~spaSpecStereo[~tracksValue][~seqsValue] = ControlSpec(0, envir[max][~tracksValue][~seqsValue].min(5), \lin, 1);

			string = ~spaStringFunction.(); // vérifier si le rajout de la fonction affichant en plus la catégorie n'est pas trop lourd en CPU ?????????
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n% \n\n%".format((envir[max][~tracksValue][~seqsValue])/*.round(1).asInteger*/, (envir[min][~tracksValue][~seqsValue])/*.round(1).asInteger*/, string));

			// Le changement de step provoque des changements des valeurs du View surtout si round est 1 -> à améliorer
			envir[multiView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[multiView].valueThumbSize_(max(10, if ((envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1) > ~multiSliderHeight5, {10}, {~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1)})));

			// envir[multiView].value_(envir[data][~tracksValue][~seqsValue]); // Pour récupérer les données dans le multislider
			// Zoom Multislider // vraiment nécessaire ?????????
			if (~zoomMultiSlider == 1, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))]);
			}, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue]) }); // Pour récupérer les données dans le multislider

			envir[indexView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value * envir[mul][~tracksValue][~seqsValue])).asInteger/*.round(1)*/)); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]))/*.round(1)*/.asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		})
		.step_(rangeViewMinRange) // (1/(~allSynths2.size - 1)) pour Syn // (1/(~allEnvsGUI.size - 1)) pour Env // (1/(~bufFolderM[~tracksValue][~seqsValue].size - 1)) pour Buf // (1/(~allSpasGUIFinal.size - 1)) pour Spa - intérêt ?????????
		.minRange_(rangeViewMinRange) // (1/~allSynths2.size) pour Syn // (1/~allEnvsGUI.size)) pour Env // (1/~bufFolderM[~tracksValue][~seqsValue].size) pour Buf // & 0 pour le spa ?????????
		.background_(Color.blue)
		// .value_([0, 0.5]); // car si [0, 1] n'affiche pas le string ?????????
	}
	{ \pan == data }
	{
		envir[rangeView]
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)); envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi));
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
			envir[multiView].valueThumbSize_(max(10,
				if (((abs(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue])) / envir[round][~tracksValue][~seqsValue]+1) > ~multiSliderHeight5, {10}, {
					~multiSliderHeight5 /((abs(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue])) / envir[round][~tracksValue][~seqsValue]+1)}))); // ?????????
			envir[multiView].value_(envir[data][~tracksValue][~seqsValue]); // Pour récupérer les données dans le multislider ?????????
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]), (envir[min][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])));
			// Le changement de step provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
			// Le changement de step provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step  si > à 0.1
			// si lancement d'une routine pour automatisation, le tête de lecture visuelle sur le multislider sera perturbé
			if (envir[round][~tracksValue][~seqsValue]> 0.01, {envir[multiView].step_(1/((abs((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue])))/envir[round][~tracksValue][~seqsValue]))}/*, {envir[multiView].step_(0)}*/);
			envir[indexView].step_(1/((abs((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue])))/envir[round][~tracksValue][~seqsValue]));
			envir[indexView].string_("L <--  At : %  --> R".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value * envir[mul][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		})
		.minRange_(envir[round][~tracksValue][~seqsValue])
		.value_([0.25, 0.75]); // si [0, 1] problème avec le pan -> inversion gauche - droite seulement la première fois que le round est modifié ?????????
	}
	{ [\outR, \fxR].includes(data) }
	{
		envir[rangeView]
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)).asInteger; envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi)).asInteger;
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, 1);
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue])/*.round(1).asInteger*/, (envir[min][~tracksValue][~seqsValue])/*.round(1).asInteger*/));

			// Le changement de step provoque des changements des valeurs du View surtout si round est 1 -> à améliorer
			envir[multiView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[multiView].valueThumbSize_(max(5, (~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue] +1))));
			// ~outLView.value_(~outL[~tracksValue][~seqsValue]); // Pour récupérer les données dans le multislider

			// Zoom Multislider // vraiment nécessaire ?????????
			if (~zoomMultiSlider == 1, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))]);
			}, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue]) }); // Pour récupérer les données dans le multislider

			envir[indexView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value * envir[mul][~tracksValue][~seqsValue])).asInteger/*.round(1)*/)); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]))/*.round(1)*/.asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		})
		.step_(rangeViewMinRange) // if (~numChannels == 2, {(1/16)}, {(1/(~numChannels-1))} ) Pour Out & (1/~numEffects) Pour Fx
		.minRange_(rangeViewMinRange) // if (~numChannels == 2, {(1/16)}, {(1/(~numChannels-1))} ) Pour Out & (1/~numEffects) Pour Fx
		.value_([0, 1]);
	}
	{ \outL == data }
	{
		envir[rangeView]
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)).asInteger; envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi)).asInteger;
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, 1);
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue])/*.round(1).asInteger*/, (envir[min][~tracksValue][~seqsValue])/*.round(1).asInteger*/));

			// Le changement de step provoque des changements des valeurs du View surtout si round est 1 -> à améliorer
			envir[multiView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[multiView].valueThumbSize_(max(5, (~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue] +1))));
			// ~outLView.value_(~outL[~tracksValue][~seqsValue]); // Pour récupérer les données dans le multislider

			// Zoom Multislider // vraiment nécessaire ?????????
			if (~zoomMultiSlider == 1, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))]);
			}, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue]) }); // Pour récupérer les données dans le multislider

			envir[indexView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value * envir[mul][~tracksValue][~seqsValue])).asInteger/*.round(1)*/)); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]))/*.round(1)*/.asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);

			if (~outActOnWhich == 1, {~outRRangeView.valueAction_(view.value) });

			// voire si impact CPU n'est pas trop important ???
			~makeGrid.(~outLComp, ~outLGrid, ~outLMin[~tracksValue][~seqsValue], ~outRMin[~tracksValue][~seqsValue], ~outLMax[~tracksValue][~seqsValue], ~outRMax[~tracksValue][~seqsValue]);
			// ~makeGrid.(~outRComp, ~outRGrid, ~outLMin[~tracksValue][~seqsValue], ~outRMin[~tracksValue][~seqsValue], ~outLMax[~tracksValue][~seqsValue], ~outRMax[~tracksValue][~seqsValue]);

		})
		.step_(rangeViewMinRange) // if (~numChannels == 2, {(1/16)}, {(1/(~numChannels-1))} ) Pour Out & (1/~numEffects) Pour Fx
		.minRange_(rangeViewMinRange) // if (~numChannels == 2, {(1/16)}, {(1/(~numChannels-1))} ) Pour Out & (1/~numEffects) Pour Fx
		.value_([0, 1]);
	}
	{ \fxL == data }
	{
		envir[rangeView]
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)).asInteger; envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi)).asInteger;
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, 1);
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue])/*.round(1).asInteger*/, (envir[min][~tracksValue][~seqsValue])/*.round(1).asInteger*/));

			// Le changement de step provoque des changements des valeurs du View surtout si round est 1 -> à améliorer
			envir[multiView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[multiView].valueThumbSize_(max(5, (~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue] +1))));
			// ~outLView.value_(~outL[~tracksValue][~seqsValue]); // Pour récupérer les données dans le multislider

			// Zoom Multislider // vraiment nécessaire ?????????
			if (~zoomMultiSlider == 1, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue][(0..max(0,envir[seqStop][~tracksValue][~seqsValue]))]);
			}, {envir[multiView].value_(envir[data][~tracksValue][~seqsValue]) }); // Pour récupérer les données dans le multislider

			envir[indexView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value * envir[mul][~tracksValue][~seqsValue])).asInteger/*.round(1)*/)); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]))/*.round(1)*/.asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);

			if (~fxActOnWhich == 1, {~fxRRangeView.valueAction_(view.value) });

			// voire si impact CPU n'est pas trop important ???
			~makeGrid.(~fxLComp, ~fxLGrid, ~fxLMin[~tracksValue][~seqsValue], ~fxRMin[~tracksValue][~seqsValue], ~fxLMax[~tracksValue][~seqsValue], ~fxRMax[~tracksValue][~seqsValue]);
			// ~makeGrid.(~fxRComp, ~fxRGrid, ~fxLMin[~tracksValue][~seqsValue], ~fxRMin[~tracksValue][~seqsValue], ~fxLMax[~tracksValue][~seqsValue], ~fxRMax[~tracksValue][~seqsValue]);

		})
		.step_(rangeViewMinRange) // (1/~numChannels) // Pour Out // intérêt ?????????
		.minRange_(rangeViewMinRange) // (1/~numChannels) // Pour Out
		.value_([0, 1]);
	};

	envir[rangeView].doAction;



	// MulView

	// si changement du Mul, pas de changement du step & du round du Multislider -> donc round et step décalés, multipliés
	// seulement répercussion sur le string du RangeView (avec rounding des valeurs au delà de 100 pour faciliter l'affichage visuel pou Rat)
	envir[mulView] = SmoothSlider(envir[comp], ~mulViewPos5)
	.font_(Font("Verdana", 8*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(mulSliderColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor);
	// .thumbSize_(10) // à retirer pour ne pas l'aligner sur le niveau du slider
	// .stringAlignToKnob = true; // à retirer pour ne pas l'aligner sur le niveau du slider

	case
	{ \outL == data}
	{
		envir[mulView]
		.action_({ |view| envir[mul][~tracksValue][~seqsValue] = envir[mulSpec].map(view.value);
			view.string = "%".format(envir[mul][~tracksValue][~seqsValue]);
			// envir[rangeView].string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])/*.round(1)*/.asInteger, (envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])/*.round(1)*/.asInteger));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value) * envir[mul][~tracksValue][~seqsValue])/*.round(1)*/.asInteger)); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]))/*.round(1)*/.asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);

			if (~outActOnWhich == 1, { ~outRMulView.valueAction_(view.value) });
		});
	}
	{ \fxL == data}
	{
		envir[mulView]
		.action_({ |view| envir[mul][~tracksValue][~seqsValue] = envir[mulSpec].map(view.value);
			view.string = "%".format(envir[mul][~tracksValue][~seqsValue]);
			// envir[rangeView].string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])/*.round(1)*/.asInteger, (envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])/*.round(1)*/.asInteger));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value) * envir[mul][~tracksValue][~seqsValue])/*.round(1)*/.asInteger)); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]))/*.round(1)*/.asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);

			if (~fxActOnWhich == 1, { ~fxRMulView.valueAction_(view.value) });
		});
	}
	/*{ [\dur, \pro, \rat, \str, \cen, \leg].includes(data) }
	{ // obligé de mettre l'action en dessous quand Global est déclaré
	envir[mulView]
	// Pour Rtm
	/*.action_({ |view| ~rtmMul[~tracksValue][~seqsValue] = ~rtmMulSpec[~tracksValue][~seqsValue].map(view.value);
	view.string = "%".format(~rtmMul[~tracksValue][~seqsValue]);
	if (~rtmRound[~tracksValue][~seqsValue] < 0.001,
	{~rtmRangeView.string_("%\n to \n%".format((~rtmMax[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(0.001), (~rtmMin[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(0.001))); ~rtmIndexView.string = "At : %".format((~rtmIndex[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(0.001)); }, {~rtmRangeView.string_("%\n to \n%".format((~rtmMax[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(~rtmRound[~tracksValue][~seqsValue]), (~rtmMin[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(~rtmRound[~tracksValue][~seqsValue]))); ~rtmIndexView.string = "At : %".format((~rtmIndex[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(~rtmRound[~tracksValue][~seqsValue])) }); // léger pb de rounding ?
	~rtmDisplay.string_("~rtmView.valueAction_(~rtmSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~rtmMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~rtmSpec[~tracksValue][~seqsValue].map(~dur[~tracksValue][~seqsValue]) * ~rtmMul[~tracksValue][~seqsValue]).round(~rtmRound[~tracksValue][~seqsValue]).asCompileString+"));").asString; ~rtmDisplay.setFont((Font("arial",1)), 4, 75);
	~nbTotalBeatsView.doAction;
	// Action sur le global
	// ~rtmMulViewG[~tracksValue].valueAction_(~rtmMulSpec[~tracksValue][~seqsValue].unmap(~rtmMul[~tracksValue][~seqsValue]));
	})*/
	// Pour Pro
	/*.action_({ |view| ~proMul[~tracksValue][~seqsValue] = ~proMulSpec[~tracksValue][~seqsValue].map(view.value);
	view.string = "%".format(~proMul[~tracksValue][~seqsValue]);
	~proRangeView.string_("%\n to \n%".format((~proMax[~tracksValue][~seqsValue] * ~proMul[~tracksValue][~seqsValue]).round(~proRound[~tracksValue][~seqsValue]), (~proMin[~tracksValue][~seqsValue] * ~proMul[~tracksValue][~seqsValue]).round(~proRound[~tracksValue][~seqsValue])));
	~proIndexView.string_("At : %".format((~proSpec[~tracksValue][~seqsValue].map(~proIndexView.value) * ~proMul[~tracksValue][~seqsValue]).round(~proRound[~tracksValue][~seqsValue]))); // léger pb de rounding ?
	~proDisplay.string_(("~proView.valueAction_(~proSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~proMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~proSpec[~tracksValue][~seqsValue].map(~pro[~tracksValue][~seqsValue]) * ~proMul[~tracksValue][~seqsValue]).round(~proRound[~tracksValue][~seqsValue]).asCompileString+"));").asString); ~proDisplay.setFont((Font("arial",1)), 4, 75);
	})*/
	// Pour Rat & Leg normalisée
	/*.action_({ |view| envir[mul][~tracksValue][~seqsValue] = envir[mulSpec][~tracksValue][~seqsValue].map(view.value);
	view.string = "%".format(envir[mul][~tracksValue][~seqsValue]);
	envir[rangeView].string_("%\n to \n%".format(
	(if ((envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]) > 100, { (envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(1) }, {(envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])})),
	(if ((envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]) > 100, { (envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(1) }, {(envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])}))));
	envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
	envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue]) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
	})*/
	}*/
	{ [\rat2, \str2, \cen2].includes(data) }
	{
		envir[mulView]
		.action_({ |view| envir[mul][~tracksValue][~seqsValue] = envir[mulSpec].map(view.value);
			view.string = "%".format(envir[mul][~tracksValue][~seqsValue]);
			envir[rangeView].string_("%\n to \n%".format(
				(if ((envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]) > 100, { (envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(1) }, {(envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])})),
				(if ((envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]) > 100, { (envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(1) }, {(envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])}))));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue]) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		});
	}
	{ [\amp].includes(data) }
	{
		envir[mulView]
		.action_({ |view| envir[mul][~tracksValue][~seqsValue] = envir[mulSpec].map(view.value);
			view.string = "%".format(envir[mul][~tracksValue][~seqsValue]);
			envir[rangeView].string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]), (envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue]) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		});
	}
	{ [\syn, \spa, /*\buf,*/ \env, \outR, \fxR].includes(data) } // obligé de mettre l'action en dessous pour \buf quand Global est déclaré
	{
		envir[mulView]
		.action_({ |view| envir[mul][~tracksValue][~seqsValue] = envir[mulSpec].map(view.value);
			view.string = "%".format(envir[mul][~tracksValue][~seqsValue]);
			// envir[rangeView].string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])/*.round(1)*/.asInteger, (envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])/*.round(1)*/.asInteger));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value * envir[mul][~tracksValue][~seqsValue]))/*.round(1)*/.asInteger)); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]))/*.round(1)*/.asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		});
	}
	{ [/*\off,*/ \off2, \off3, \off4, \del].includes(data) } // obligé de mettre l'action en dessous pour \off quand Global est déclaré
	{
		envir[mulView]
		.action_({ |view| envir[mul][~tracksValue][~seqsValue] = envir[mulSpec].map(view.value);
			view.string = "%".format(envir[mul][~tracksValue][~seqsValue]);
			// envir[rangeView].string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]), (envir[min][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])));
			envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value * envir[mul][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		});
	}
	{ \pan == data }
	{
		envir[mulView]
		.action_({ |view| envir[mul][~tracksValue][~seqsValue] = envir[mulSpec].map(view.value);
			view.string = "%".format(envir[mul][~tracksValue][~seqsValue]);
			// envir[rangeView].string_("%\n to \n%".format((envir[max][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]), (envir[min][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])));
			envir[indexView].string_("L <--  At : %  --> R".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value) * envir[mul][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+displayString2+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue] * envir[mul][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 4, displayReduceFontPos);
		});
	};

	// envir[mulView].doAction; // pas nécessaire car déclenché ci-dessous ???



	// MulPresetView
	// Cas spécificque du ~rtmMulSpec, qui s'adapte au nb d'événements de la séquence (rtmSeqSize) est différent pour chaque piste et seq (voire ~rtmMulMinProtect)
	// Car le ~rtmMulView(G) peut faire cracher si trop bas
	// Il serait possible de prendre en compte le nombre de pistes qui jouent (en ajoutant  la multiplication ~playViewValue.sum.max(1) et leur rapidité
	// & faire la calcul de ~rtmMulSpec plus souvent dès que l'on rajoute des pistes ou accélère -> Non dès qu'on bouge rtmMul... un peu trop intense ?

	envir[mulPresetViewView] = View(envir[comp], ~mulPresetViewPos5);

	envir[mulPresetView] = PopUpMenu.new(envir[mulPresetViewView], Rect(0, 0, 65*~xSizeMul, 16*~ySizeMul));

	if (\dur != data, {

		envir[mulPresetView]
		.action_({ |menu| envir[mulView].valueAction_(envir[mulSpec].unmap(menu.item.asFloat)) })
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(~popUpMenuStringColor)
		.font_(Font("Verdana",8*~fontSizeMul));
		envir[mulPresetView].items_(mulPresetViewItems)
		.valueAction_(mulPresetViewDefault);

	},{

		envir[mulPresetView]
		.action_({ |menu| envir[mulView].valueAction_(envir[mulSpec][~tracksValue][~seqsValue].unmap(menu.item.asFloat)) })
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(~popUpMenuStringColor)
		.font_(Font("Verdana",8*~fontSizeMul));
		envir[mulPresetView].items_(mulPresetViewItems)
		.valueAction_(mulPresetViewDefault);

	});



	// RoundView

	if (\buf != data, {

		envir[roundViewView] = View(envir[comp], roundViewPos);

		envir[roundView] = PopUpMenu.new(envir[roundViewView], Rect(0, 0, 140*~xSizeMul, 16*~ySizeMul))
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(~popUpMenuStringColor)
		.font_(Font("Verdana",8*~fontSizeMul));

		case { [\rat, \str, \cen, \rat2, \str2, \cen2, \leg].includes(data) }
		{
			envir[roundView]
			.action_({ |menu| envir[roundViewFunc][menu.value].value(~tracksValue, ~seqsValue);
				envir[roundValue][~tracksValue][~seqsValue] = menu.value;
				// pourquoi envir[rangeSpec] n'est pas rajouté comme pour les autres ci-dessous ?????????
				envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
				envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
				// Pas d'utilisation de step pour le rangeView car pas approprié lorsque ControlSpec est exp
				// envir[rangeView].step_(1/(128/envir[round][~tracksValue][~seqsValue]));
				envir[rangeView].minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue] * 4));
				envir[rangeView].valueAction_(envir[rangeSpec][~tracksValue][~seqsValue].unmap([envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue]]));
				// Le changement de step sur le Multislider provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
				// Le changement de step sur le Multislider provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step si > à 0.1
				if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))}, {envir[multiView].step_(0)});
			})
			.items_(roundViewItems)
			.valueAction_(roundViewDefault);
		}
		{ \dur == data }
		{
			envir[roundView]
			.action_({ |menu| envir[roundViewFunc][menu.value].value(~tracksValue, ~seqsValue);
				envir[roundValue][~tracksValue][~seqsValue] = menu.value;
				envir[rangeSpec][~tracksValue][~seqsValue] = ControlSpec(0, rangeMax, 4);
				envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
				envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
				// Utilisation de step pour le rangeView car approprié lorsque ControlSpec est lin mais pas exp
				envir[rangeView].step_(1/(rangeMax/envir[round][~tracksValue][~seqsValue])); // ~rtmRangeView.step_(1/(1/~rtmRound[~tracksValue][~seqsValue])); // initialement ?
				envir[rangeView].minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue] * 2));
				envir[rangeView].valueAction_(envir[rangeSpec][~tracksValue][~seqsValue].unmap([envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue]]));
				// Le changement de step sur le Multislider provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
				// Le changement de step sur le Multislider provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step si > à 0.1
				if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))}, {envir[multiView].step_(0)});
			})
			.items_(roundViewItems)
			.valueAction_(roundViewDefault);
		}
		{ [\pro, \off, \off2, \off3, \off4, \amp, \del].includes(data) }
		{
			envir[roundView]
			.action_({ |menu| envir[roundViewFunc][menu.value].value(~tracksValue, ~seqsValue);
				envir[roundValue][~tracksValue][~seqsValue] = menu.value;
				envir[rangeSpec][~tracksValue][~seqsValue] = ControlSpec(0, rangeMax, \lin, envir[round][~tracksValue][~seqsValue]);
				envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
				envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
				// Utilisation de step pour le rangeView car approprié lorsque ControlSpec est lin mais pas exp
				envir[rangeView].step_(1/(rangeMax/envir[round][~tracksValue][~seqsValue]));
				envir[rangeView].minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue] * 2)); // * 2 // initialement pour Off & Amp ?
				envir[rangeView].valueAction_(envir[rangeSpec][~tracksValue][~seqsValue].unmap([envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue]]));
				// Le changement de step sur le Multislider provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
				// Le changement de step sur le Multislider provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step si > à 0.1
				if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))}, {envir[multiView].step_(0)});
			})
			.items_(roundViewItems)
			.valueAction_(roundViewDefault);
		}
		{ \pan == data }
		{
			envir[roundView]
			.action_({ |menu| envir[roundViewFunc][menu.value].value(~tracksValue, ~seqsValue);
				envir[roundValue][~tracksValue][~seqsValue] = menu.value;
				envir[rangeSpec][~tracksValue][~seqsValue] = ControlSpec(minDefault, maxDefault, \lin, envir[round][~tracksValue][~seqsValue]);
				envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
				envir[multiView].valueThumbSize_(max(10,
					if (((abs(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue])) / envir[round][~tracksValue][~seqsValue]+1) > ~multiSliderHeight5,
						{10},
						{~multiSliderHeight5 /((abs(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue])) / envir[round][~tracksValue][~seqsValue]+1)})));
				envir[indexView].step_(1/((abs(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue])/envir[round][~tracksValue][~seqsValue])));
				// Utilisation de step pour le rangeView car approprié lorsque ControlSpec est lin mais pas exp
				envir[rangeView].step_(1/(2/envir[round][~tracksValue][~seqsValue]));
				envir[rangeView].minRange_(envir[round][~tracksValue][~seqsValue]);
				envir[rangeView].valueAction_(envir[rangeSpec][~tracksValue][~seqsValue].unmap([envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue]]));
				// Le changement de step sur le Multislider provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
				// Le changement de step sur le Multislider provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step si > à 0.01
				if (envir[round][~tracksValue][~seqsValue]> 0.01, {envir[multiView].step_(1/((abs((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue])))/envir[round][~tracksValue][~seqsValue]))}, {envir[multiView].step_(0)}); // le step peut être nécéssaire même quand envir[round][~tracksValue][~seqsValue]> 0.01, lorsque le range est vraiment très petit, par exemple Links de -0.98 à -1 ?
			})
			.items_(roundViewItems)
			.valueAction_(roundViewDefault);
		}
		{ \syn == data }
		{
			envir[roundView]
			// Si le Range a changé, certains éléments ne peuvent être sélectionnés pour Syn & Spa & Env...
			.action_{ |menu| envir[multiView].valueAction_(envir[dataSpec][~tracksValue][~seqsValue].unmap(menu.value.asInteger) ! envir[data][~tracksValue][~seqsValue].size);

				// Affichage des ranges par défaut du synthé sélectionné comme le fait : ~synRangeDefView.doAction
				/*if (("metaData"++menu.item.split($ )[1]).asSymbol.envirGet.notNil, {
				(menu.item.split($ )[1] + "Arguments :").postln;
				("metaData"++menu.item.split($ )[1]).asSymbol.envirGet.do { |item, index|
				if (item.notNil, {
				~synthDescLibRangeViews[index].valueAction_(~synthDescLibRangeSpecs[index][~tracksValue][~seqsValue].unmap([item.minval, item.maxval])); // affiche les rangeViews par défaut
				~synthDescLibMulViews[index].valueAction_(~synthDescLibMulSpecs[index].unmap(1)); // affiche les mulViews par défaut
				(~synthDescLibNames[index] + "->" + item.units).postln; // // affiche les correspondances
				}) };
				"".postln;
				});*/
			}
			.items_(roundViewItems);
		}
		{ [\spa, \env, \fxL, \fxR].includes(data) }
		{
			envir[roundView]
			// // Si le Range a changé, certains éléments ne peuvent être sélectionnés pour Syn & Spa & Env...
			.action_{ |menu| envir[multiView].valueAction_(envir[dataSpec][~tracksValue][~seqsValue].unmap(menu.value.asInteger) ! envir[data][~tracksValue][~seqsValue].size) }
			.items_(roundViewItems);
		}
		{ [\outL, \outR].includes(data) }
		{
			envir[roundView]
			.action_{ |menu| envir[multiView].valueAction_(envir[dataSpec][~tracksValue][~seqsValue].unmap(menu.value.asInteger +1) ! envir[data][~tracksValue][~seqsValue].size) }
			.items_(roundViewItems);
		};



		// RangePresetView

		envir[rangePresetViewView] = View(envir[comp], ~rangePresetViewPos5);

		envir[rangePresetView] = PopUpMenu.new(envir[rangePresetViewView], Rect(0, 0, 90*~xSizeMul, 16*~ySizeMul))
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(~popUpMenuStringColor)
		.font_(Font("Verdana",8*~fontSizeMul))
		.items_(rangePresetViewItems);


		case { [\dur, \pro, \syn, \rat, \str, \cen, \rat2, \str2, \cen2, \leg, \off, \off2, \off3, \off4, \amp, \del, \outL, \outR, \fxL, \fxR].includes(data) }
		{
			envir[rangePresetView]
			.action_({|menu| envir[rangeView].valueAction_(envir[rangeSpec][~tracksValue][~seqsValue].unmap([menu.item.replace(rangePresetViewSign, " ").split($ )[0].asFloat, menu.item.replace(rangePresetViewSign, " ").split($ )[1].asFloat])) });
		}
		/*{ [\spa, \pan].includes(data) }
		{
		envir[rangePresetView]
		// obligé de mettre l'action en dessous quand Global est déclaré
		// .action_({|menu| ~spaRangeView.valueAction_(~spaRangeSpec[~tracksValue][~seqsValue].unmap([menu.item.replace("->", " ").split($ )[1].asFloat, menu.item.replace("->", " ").split($ )[2].asFloat])) }) // Pour Spa
		// .action_({ |menu| ~panRangePresetViewFunc[menu.value].value(~tracksValue, ~seqsValue)  }) // Pour Pan
		.valueAction_(rangePresetViewDefault);
		}*/
		{ \env == data }
		{
			envir[rangePresetView]
			.action_({ |menu| ~envRangePresetViewFunc[menu.value].value(~tracksValue, ~seqsValue)  });
		};

		envir[rangePresetView].valueAction_(rangePresetViewDefault);

	});



	if (\buf == data, {
		envir[randView] = RoundButton(envir[comp], Rect((104+22)*~xSizeMul, 136*~ySizeMul, 35*~xSizeMul, 16*~ySizeMul) /*~randViewPos5*/);
		envir[seqAllView] = RoundButton(envir[comp], Rect((141+22)*~xSizeMul, 136*~ySizeMul, 35*~xSizeMul, 16*~ySizeMul) /*~seqAllViewPos5*/);
		envir[seqMode] = RoundButton(envir[comp], Rect((178+22)*~xSizeMul, 136*~ySizeMul, 35*~xSizeMul, 16*~ySizeMul) /*~seqModePos5*/);
		envir[copyAView] = RoundButton(envir[comp], Rect((215+22)*~xSizeMul, 136*~ySizeMul, 22*~xSizeMul, 16*~ySizeMul) /*~copyAViewPos5*/);
		envir[pasteAView] = RoundButton(envir[comp], Rect((237+22)*~xSizeMul, 136*~ySizeMul, 22*~xSizeMul, 16*~ySizeMul) /*~pasteAViewPos5*/);
		envir[pasteMView] = RoundButton(envir[comp], Rect((259+22)*~xSizeMul, 136*~ySizeMul, 22*~xSizeMul, 16*~ySizeMul) /*~pasteMViewPos5*/);
		envir[defaultView] = RoundButton(envir[comp], Rect((281+22)*~xSizeMul, 136*~ySizeMul, 24*~xSizeMul, 16*~ySizeMul) /*~defaultViewPos5*/)
	},{
		envir[randView] = RoundButton(envir[comp], ~randViewPos5);
		envir[seqAllView] = RoundButton(envir[comp], ~seqAllViewPos5);
		envir[seqMode] = RoundButton(envir[comp], ~seqModePos5);
		envir[copyAView] = RoundButton(envir[comp], ~copyAViewPos5);
		envir[pasteAView] = RoundButton(envir[comp], ~pasteAViewPos5);
		envir[pasteMView] = RoundButton(envir[comp], ~pasteMViewPos5);
		envir[defaultView] = RoundButton(envir[comp], ~defaultViewPos5)
	});



	envir[randView]
	.states_([["Rand", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({if (~patFlag == 0, {
		envir[randFunc].value(~tracksValue, ~seqsValue)}, {
		~seqs.do {|i|
			envir[randFunc].value(~tracksValue, i);
			envir[data][~tracksValue][i] = {rrand(0.0,1.0)} ! ~dur[~tracksValue][i].size;
		};
	});
	});

	envir[seqAllView]
	.states_([["All Seq", Color.black, ~popUpMenuBackgroundColor]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({envir[seqView].valueAction_([0, 1]);
	});

	envir[rangeMode] = RoundButton(envir[comp], ~rangeModePos5)
	.states_([["\Drag", Color.black, ~popUpMenuBackgroundColor], ["\Jump", Color.black, ~popUpMenuBackgroundColor] /*["\Drag", Color.white, Color.blue], ["\Jump", Color.black, Color.green]*/])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| envir[rangeView].mode_(~modes[i.value])});

	envir[seqMode]
	.states_([["\Drag", Color.black, ~popUpMenuBackgroundColor], ["\Jump", Color.black, ~popUpMenuBackgroundColor] /*["\Drag", Color.white, Color.blue], ["\Jump", Color.black, Color.green]*/])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| envir[seqView].mode_(~modes[i.value])})
	.valueAction_(1);

	envir[copyAView]
	.states_([["CA", Color.red, Color.white]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({envir[copyA].value(~tracksValue, ~seqsValue);
	});

	envir[pasteAView]
	.states_([["PA", Color.red, Color.white]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({envir[pasteA].value(~tracksValue, ~seqsValue);
	});

	envir[pasteMView]
	.states_([["PM", Color.black, Color.white]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({envir[pasteM].value(~tracksValue, ~seqsValue);
	});

	envir[defaultView]
	.states_([["Def", Color.white, Color.blue]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({if (~patFlag == 0, {
		envir[default].value(~tracksValue, ~seqsValue)}, {
		~seqs.do {|i| envir[default].value(~tracksValue, i)}});
	});

	envir[dirView] = RoundButton(envir[comp], ~dirViewPos5)
	.states_([["\>", Color.black, ~popUpMenuBackgroundColor], ["\<", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| envir[dir][~tracksValue][~seqsValue] = i.value;
		envir[block][~tracksValue] = 1;
		if (~patFlag == 1, {~seqs.do {|sequence| envir[dir][~tracksValue][sequence] = i.value} });
	});



	if (\outR != data,
		{envir[patView] = RoundButton(envir[comp], ~patViewPos5)
		},{envir[patView] = RoundButton(~tabGUI, Rect((1536+36)*~xSizeMul, 805*~ySizeMul, 24*~xSizeMul, 16*~ySizeMul))
	});

	envir[patView].states_([["Cyc", Color.black, ~popUpMenuBackgroundColor], ["Pat", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| envir[pat][~tracksValue][~seqsValue] = i.value;
		envir[block][~tracksValue] = 1;
		if (envir[pat][~tracksValue][~seqsValue] == 1, {envir[patSelView].background_(Color.red(0.7)).stringColor_(Color.white)}, {envir[patSelView].background_(~popUpMenuBackgroundColor).stringColor_(~popUpMenuStringColor)} );
		if (~patFlag == 1, {~seqs.do {|sequence| envir[pat][~tracksValue][sequence] = i.value } });
	});



	// PatSelView

	if (\outR != data,
		{
			envir[patSelViewView] = View(envir[comp], ~patSelViewPos5);
			envir[patSelView] = PopUpMenu.new(envir[patSelViewView], Rect(0, 0, 80*~xSizeMul, 16*~ySizeMul))
		},{
			envir[patSelViewView] = View(~tabGUI, Rect(1544*~xSizeMul, (610+216)*~ySizeMul, 52*~xSizeMul, 16*~ySizeMul));
			envir[patSelView] = PopUpMenu.new(envir[patSelViewView], Rect(0, 0, 80*~xSizeMul, 16*~ySizeMul))
	});

	envir[patSelView]
	.allowsReselection_(true)
	.background_(~popUpMenuBackgroundColor)
	.stringColor_(~popUpMenuStringColor)
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({|menu| envir[patSel][~tracksValue][~seqsValue] = menu.value;
		envir[block][~tracksValue] = 1;
		if (~patFlag == 1, {~seqs.do {|sequence| envir[patSel][~tracksValue][sequence] = menu.value }});
	});

	case
	{ [\dur].includes(data) }
	{
		envir[patSelView].items_(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "Rt", "Rt_I", "Pro", "Pro_I", "Du", "Du_I", "Amp", "Amp_I", "Rat", "Rat_I", "Str", "Str_I", "Cen", "Cen_I", "Ra2", "Ra2_I", "St2", "St2_I", "Ce2", "Ce2_I", "Buf", "Buf_I", "Po", "Po_I", "Po2", "Po2_I", "Po3", "Po3_I", "Po4", "Po4_I", "Pan", "Pan_I", "Del", "Del_I", "L", "L_I", "R", "R_I"])
		.valueAction_(0);
	}
	{ [\syn, \env, /*\buf, \off,*/ \fxL, \fxR /*, \del*/].includes(data) }
	{
		envir[patSelView].items_(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "Leh_1", "Leh1I", "Leh_2", "Leh2I"])
		.valueAction_(4); // Initialisation à Pwhite
	}
	{ [\spa].includes(data) }
	{
		if (~acousItems.isNil, {
			envir[patSelView].items_(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "Leh_1", "Leh1I", "Leh_2", "Leh2I", "R +1", "R  -1"]).valueAction_(4); // Initialisation à Pwhite
		},{
			envir[patSelView].items_(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "Leh_1", "Leh1I", "Leh_2", "Leh2I", "R +1", "R  -1", "R +2", "R +2b", "R  -2", "R  -2b", "Mi  1", "Mi  2", "Mi  2b"]).valueAction_(4); // Initialisation à Pwhite
		});
	}
	{ [\leg, \pan, \buf, \off, \off2, \off3, \off4, \del].includes(data) }
	{
		envir[patSelView].items_(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "Leh_1", "Leh1I", "Leh_2", "Leh2I", "Rt", "Rt_I", "Pro", "Pro_I", "Du", "Du_I", "Amp", "Amp_I", "Rat", "Rat_I", "Str", "Str_I", "Cen", "Cen_I", "Ra2", "Ra2_I", "St2", "St2_I", "Ce2", "Ce2_I", "Buf", "Buf_I", "Po", "Po_I", "Po2", "Po2_I", "Po3", "Po3_I", "Po4", "Po4_I", "Pan", "Pan_I", "Del", "Del_I", "L", "L_I", "R", "R_I"])
		.valueAction_(4); // Initialisation à Pwhite
	}
	{ [\amp, \rat, \str, \cen, \rat2, \str2, \cen2].includes(data) }
	{
		envir[patSelView].items_([["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "Leh_1", "Leh1I", "Leh_2", "Leh2I", "Rt", "Rt_I", "Pro", "Pro_I", "Du", "Du_I", "Amp", "Amp_I", "Rat", "Rat_I", "Str", "Str_I", "Cen", "Cen_I", "Ra2", "Ra2_I", "St2", "St2_I", "Ce2", "Ce2_I", "Buf", "Buf_I", "Po", "Po_I", "Po2", "Po2_I", "Po3", "Po3_I", "Po4", "Po4_I", "Pan", "Pan_I", "Del", "Del_I", "L", "L_I", "R", "R_I"], ~controlBusNames/*, ~controlBusNames01, ~controlBusNames0R*/].flatten)
		.valueAction_(4); // Initialisation à Pwhite
	}
	/*{ \leg == data } // DurRe ?????????
	{
	envir[patSelView].items_(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "DurRe"])
	.valueAction_(13);
	/* Dans Init Pattern XXXXXXXXX
	{~legPatSel[track][~seqSeq[track]] == 13 and: { ~legPat[track][~seqSeq[track]] == 1 }} // Inverse de la durée
	{~posLeg[track][~seqSeq[track]] = 0; (1 - ev.durU).yield; ev.durU.postln;
	}
	*/
	}*/
	{ \pro == data }
	{
		envir[patSelView].items_(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", /*"Leh_1", "Leh_2",*/ "Eucli", "EuWe", "Eu2X", "Eu2R", "Eu2S", "Eu2W", "Grids", "Gri_D", "Gri_P", "Gri_R"])
		.valueAction_(13);
	}
	{ \outL == data }
	{
		envir[patSelView].items_(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "Leh_1", "Leh1I", "Leh_2", "Leh2I", "Rt", "Rt_I", "Pro", "Pro_I", "Du", "Du_I", "Amp", "Amp_I", "Rat", "Rat_I", "Str", "Str_I", "Cen", "Cen_I", "Ra2", "Ra2_I", "St2", "St2_I", "Ce2", "Ce2_I", "Buf", "Buf_I", "Po", "Po_I", "Po2", "Po2_I", "Po3", "Po3_I", "Po4", "Po4_I", "Pan", "Pan_I", "Del", "Del_I", "L", "L_I", "R", "R_I", "Sq +1", "Sq -1", "Sq +2", "Sq -2", "Sq Mir"])
		.valueAction_(55); // ~controlBus0 -> mais déclaré dans le pattern
	}
	{ \outR == data }
	{
		envir[patSelView].items_(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "Leh_1", "Leh1I", "Leh_2", "Leh2I", "Rt", "Rt_I", "Pro", "Pro_I", "Du", "Du_I", "Amp", "Amp_I", "Rat", "Rat_I", "Str", "Str_I", "Cen", "Cen_I", "Ra2", "Ra2_I", "St2", "St2_I", "Ce2", "Ce2_I", "Buf", "Buf_I", "Po", "Po_I", "Po2", "Po2_I", "Po3", "Po3_I", "Po4", "Po4_I", "Pan", "Pan_I", "Del", "Del_I", "L", "L_I", "R", "R_I", "L +1", "L -1", "L+1/4", "L-1/4", "L Opp", "Other"])
		.valueAction_(55);
	};



	if (\outL == data, {
		envir[rangeMode].action_({|i| envir[rangeView].mode_(~modes[i.value]); if (~outActOnWhich == 1, { ~outRRangeMode.valueAction_(i.value) }) });
		envir[seqMode].action_({|i| envir[seqView].mode_(~modes[i.value]); if (~outActOnWhich == 1, { ~outRSeqMode.valueAction_(i.value) }) });
		envir[dirView].action_({|i|
			envir[dir][~tracksValue][~seqsValue] = i.value;
			if (~patFlag == 1, {~seqs.do {|sequence| envir[dir][~tracksValue][sequence] = i.value} });
			if (~outActOnWhich == 1, { ~outRDirView.valueAction_(i.value) })
		});
		envir[patView].action_({|i| envir[pat][~tracksValue][~seqsValue] = i.value;
			if (envir[pat][~tracksValue][~seqsValue] == 1, {envir[patSelView].background_(Color.red(0.7)).stringColor_(Color.white)}, {envir[patSelView].background_(~popUpMenuBackgroundColor).stringColor_(~popUpMenuStringColor)} );
			if (~patFlag == 1, {~seqs.do {|sequence| envir[pat][~tracksValue][sequence] = i.value } });
			if (~outActOnWhich == 1, { ~outRPatView.valueAction_(i.value) })
		});
		envir[patSelView].action_({|menu| envir[patSel][~tracksValue][~seqsValue] = menu.value;
			if (~patFlag == 1, {~seqs.do {|sequence| envir[patSel][~tracksValue][sequence] = menu.value }});
			if (~outActOnWhich == 1, { ~outRPatSelView.valueAction_(menu.value) })
		});
	});

	if (\fxL == data, {
		envir[rangeMode].action_({|i| envir[rangeView].mode_(~modes[i.value]); if (~fxActOnWhich == 1, { ~fxRRangeMode.valueAction_(i.value) }) });
		envir[seqMode].action_({|i| envir[seqView].mode_(~modes[i.value]); if (~fxActOnWhich == 1, { ~fxRSeqMode.valueAction_(i.value) }) });
		envir[dirView].action_({|i|
			envir[dir][~tracksValue][~seqsValue] = i.value;
			if (~patFlag == 1, {~seqs.do {|sequence| envir[dir][~tracksValue][sequence] = i.value} });
			if (~fxActOnWhich == 1, { ~fxRDirView.valueAction_(i.value) })
		});
		envir[patView].action_({|i| envir[pat][~tracksValue][~seqsValue] = i.value;
			if (envir[pat][~tracksValue][~seqsValue] == 1, {envir[patSelView].background_(Color.red(0.7)).stringColor_(Color.white)}, {envir[patSelView].background_(~popUpMenuBackgroundColor).stringColor_(~popUpMenuStringColor)} );
			if (~patFlag == 1, {~seqs.do {|sequence| envir[pat][~tracksValue][sequence] = i.value } });
			if (~fxActOnWhich == 1, { ~fxRPatView.valueAction_(i.value) })
		});
		envir[patSelView].action_({|menu| envir[patSel][~tracksValue][~seqsValue] = menu.value;
			if (~patFlag == 1, {~seqs.do {|sequence| envir[patSel][~tracksValue][sequence] = menu.value }});
			if (~fxActOnWhich == 1, { ~fxRPatSelView.valueAction_(menu.value) })
		});
	});



	// ShowView - Names of Modules

	envir[showView] = StaticText(envir[comp], showViewPos)
	.font_(Font("Verdana", 13*~fontSizeMul, bold: true))
	.align_(showViewAlign)
	.acceptsMouse_(0)
	.stringColor_(showViewColor)
	.string_(showViewString);


	// ReadView - Slider shows Pos & Value in module

	// intégré dans les Composite Views mais en dehors des multisliders pour éviter une trop forte augmentation du CPU
	// Comment retirer la bordure car .border accepté que pour les smoothSliders ???

	// .alpha_(0) n'est pas complètement transparent et Color.clear ne marche pas ???
	// aucun intérêt d'avoir .alpha_(0) ou .alpha_(1) pour avoir une couleur transparente ou pas

	envir[readView] = Slider(envir[comp], ~readViewPos5)
	.background_(readBackgroundColorView)
	.knobColor_(Color.red/*black*/)
	.acceptsMouse_(0)
	.thumbSize_(333/4*~xSizeMul);

	// Comment optimiser le code - pour changer la couleur de la barre du bouton ???
	envir[readView].palette = envir[readView].palette.button_(Color.yellow);


	// PosView - Text shows Pos & Value in module

	envir[posView] = StaticText(envir[comp], ~posViewPos5)
	.font_(Font("Verdana", 11*~fontSizeMul, bold: true))
	.align_(\left)
	.acceptsMouse_(0)
	.stringColor_(Color.black);

});










/*
~makeModuleWindow = { | envir,
roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
comp, display, displayReduceFontPos, displayString1, displayString2,
multiView, data, dataSpec, multiViewFilled, multiViewDrawLines, multiViewValueThumbSize, multiViewBackground, multiViewFillColor, multiViewStrokeColor,
seqView, seqStart, seqStop, seqDur, seqSpec, seqSpec2, seqVSpec, seqVSpec2,
indexView, index,
rangeView, min, max, rangeSpec, rangeViewMinRange, rangeSliderColor, rangePresetViewView, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
mulView, mul, mulSpec, mulSliderColor, mulPresetViewView, mulPresetView, mulPresetViewItems, mulPresetViewDefault,
roundViewView, roundView, roundViewPos, round, roundValue, roundViewItems, roundViewDefault,
randView, randFunc,
seqAllView, rangeMode, seqMode,
copyAView, copyA, pasteAView, pasteA, pasteMView, pasteM, defaultView, default,
dirView, dir, patView, pat, patSelViewView, patSelView, patSel, block,
showView, showViewPos, showViewAlign, showViewColor, showViewString,
readView, readBackgroundColorView, posView
|
*/

{

	// GUI RHYTHM 2

	~posRtm = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~rtmType = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour changement en absolu ou relatif
	~sequenceType = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour changement en sequence ou looping

	~rtmAdjustFunction = { // Ajustement du max pour respecter le nb de temps - ne marche pas correctement apparemmment avec le round ?????????
		"Adjusting ~rtmMax -> Dur = ".post; ~rtmSpec[~tracksValue][~seqsValue].map(~dur[~tracksValue][~seqsValue]).sum.postln;
		~rtmMax[~tracksValue][~seqsValue] = /*~dur[~tracksValue][~seqsValue].maxItem * 2*/ ~nbTotalBeats[~tracksValue][~seqsValue];
		~rtmRangeView.valueAction_(~rtmRangeSpec[~tracksValue][~seqsValue].unmap([0, ~rtmMax[~tracksValue][~seqsValue]]));
		~rtmSpec[~tracksValue][~seqsValue] = ControlSpec(~rtmMin[~tracksValue][~seqsValue], ~rtmMax[~tracksValue][~seqsValue], \lin, ~rtmRound[~tracksValue][~seqsValue]);
		if (~rtmType[~tracksValue][~seqsValue] == 0, {~dur[~tracksValue][~seqsValue] = ~dur[~tracksValue][~seqsValue] * ~nbTotalBeats[~tracksValue][~seqsValue] / (~dur[~tracksValue][~seqsValue].sum * ~rtmMax[~tracksValue][~seqsValue]) });
		// ~dur[~tracksValue][~seqsValue] = ~rtmSpec[~tracksValue][~seqsValue].unmap(~dur[~tracksValue][~seqsValue]);
		// view.valueAction_(~dur[~tracksValue][~seqsValue]);
		"Adjusting ~rtmMax -> Dur = ".post; ~rtmSpec[~tracksValue][~seqsValue].map(~dur[~tracksValue][~seqsValue]).sum.postln;
	};

	~rtmTypeView = RoundButton(~rtmComp2, ~miniSlider1Pos5 /*Rect(338, 138+18, 60, 16)*/)
	.states_([["\Relative", Color.blue, Color.white], ["\Absolute", Color.red, Color.white]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({|i| ~rtmType[~tracksValue][~seqsValue] = i.value })
	.valueAction_(0);

	/*~x = EventSource();
	~x.changes.do( {|y| y.postln; if (~playViewValue[~tracksValue] == 1, {
	~play.value(npdef: ~patterns2[~tracksValue], track: ~tracks[~tracksValue], nfade: ~nFade[~tracksValue], pfade: 0, quant: /*~quant[~tracksValue]*/0, stretchdur: 1/1); /*avec quantisation*/ });  } );*/

	// Loops dans les loops dans le Pattern - obligé de relancer le pattern pour changer d'état ???
	// A intégrer dans les presets XXXXXXXXX ?????????

	~rtmTypeView2 = RoundButton(~rtmComp2, ~miniSlider2Pos5 /*Rect(338, 138+18, 60, 16)*/)
	.states_([["\Sequence", Color.blue, Color.white], ["\Looping", Color.red, Color.white]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({ |i|
		// ~x.fire(~sequenceType[~tracksValue][~seqsValue]);
		~sequenceType[~tracksValue][~seqsValue] = i.value;

		[\rtmBlock, \proBlock, \synBlock, \spaBlock, \legBlock, \envBlock, \bufBlock, \ampBlock, \ratBlock, \rat2Block, \offBlock, \strBlock, \str2Block, \cenBlock, \cen2Block, \panBlock, \delBlock, \outLBlock, \outRBlock, \fxLBlock, \fxRBlock].do {|i| currentEnvironment[i][~tracksValue] = 1}; // remis car De Looping à Sequence ne casse pas la boucle -> Ok dans le sens inverse... pose pb avec en dessous ???

		// ci-dessous plus nécessaire car relancement de la boucle avec ci-dessus mais finalement retiré (puis remis) car géré dans le pattern à la fin de chaque séquence ???
		/*if (~playViewValue[~tracksValue] == 1 /*and: {~seqSeqStart[~tracksValue] == ~seqSeqStop[~tracksValue]}*/, {
		~play.value(npdef: ~patterns2[~tracksValue], track: ~tracks[~tracksValue], nfade: ~nFade[~tracksValue], pfade: 0, quant: ~quant[~tracksValue], stretchdur: 1/1); /*avec quantisation*/ });*/
	})
	.valueAction_(0);

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\rtmRoundViewFunc, 0, 2, 1, 0, 0.00000000000000001,
		\rtmComp2, \rtmDisplay, 75, "~rtmView.valueAction_(~rtmSpec[", "].unmap(~rtmMul[",
		\rtmView, \dur, \rtmSpec, true, false, 1, ~compColor1 /*à essayer plus soft*/ /*~rtmCompColor*/, ~multiRtmCompColor, Color.white,
		\rtmSeqView, \rtmSeqStart, \rtmSeqStop, \seqDurRtm, \rtmSeqSpec, \rtmSeqSpec2, \rtmSeqVSpec, \rtmSeqVSpec2,
		\rtmIndexView, \rtmIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\rtmRangeView, \rtmMin, \rtmMax, \rtmRangeSpec, "NoRangeViewMinRange", Color.red, \rtmRangePresetViewView, \rtmRangePresetView, ["0->0.5", "0.5->1", "0->1", "0->2", "0->4"], 3, "->", 60,
		\rtmMulView, \rtmMul, \rtmMulSpec, ~sliderHilightColor, \rtmMulPresetViewView, \rtmMulPresetView, ["0.1", "0.2", "0.25", "0.3", "0.4", "0.5", "0.6", "0.7", "0.75", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 11,
		\rtmRoundViewView, \rtmRoundView, ~roundViewPos5, \rtmRound, \rtmRoundValue, ["@ inf", "@ 0.01", "@ 0.1", "@ 0.125", "@ 0.2", "@ 0.25", "@ 0.5"], 0,
		\rtmRandView, \duration2show,
		\rtmSeqAllView, \rtmRangeMode, \rtmSeqMode,
		\rtmCopyAView, \rtmCopyA, \rtmPasteAView, \rtmPasteA, \rtmPasteMView, \rtmPasteM, \rtmDefaultView, \rtmDefault,
		\rtmDirView, \rtmDir, \rtmPatView, \rtmPat, \rtmPatSelViewView, \rtmPatSelView, \rtmPatSel, \rtmBlock,
		\rtmShowView, ~nameModPos, \center, Color.green, "RTM",
		\rtmReadView, Color.grey(0.6) /*Color.magenta*/ /*~rtmCompColor.alpha_(0)*/, \rtmPosView
	);





	// GUI PROBABILITY

	~posPro = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~proBjorSpec = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // pour Bjorklund
	~proBjor = /*0*/ ~dur[~tracksValue][~seqsValue].size ! ~nbOfSeqs ! ~nbOfTracksX2; // pour Bjorklund
	~proBjorGridsX = 1 ! ~nbOfSeqs ! ~nbOfTracksX2; // pour SC Grids X - Bjorklund en raw
	~proBjor2 = /*0*/ ~dur[~tracksValue][~seqsValue].size ! ~nbOfSeqs ! ~nbOfTracksX2; // pour Bjorklund
	~proBjorGridsY = 1 ! ~nbOfSeqs ! ~nbOfTracksX2; // pour SC Grids Y - Bjorklund en raw
	~proWeight = 1 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~proDrumType = \kick ! ~nbOfSeqs ! ~nbOfTracksX2;
	~proBjor3 = /*0*/ ~dur[~tracksValue][~seqsValue].size ! ~nbOfSeqs ! ~nbOfTracksX2;
	~proBjor4 = /*0*/ ~dur[~tracksValue][~seqsValue].size ! ~nbOfSeqs ! ~nbOfTracksX2;
	~proGridsBias = 1 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~proGridsBias2 = 1 ! ~nbOfSeqs ! ~nbOfTracksX2;

	~proT = 0 ! ~nbOfTracksX2; // Changement du nom de ~proTemp à ~proT, car ~proTemp est déjà utilisé pour faire le copier / coller du module PRO
	~proSelect = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\proRoundViewFunc, 0, 1, 1, 0, 0.01,
		\proComp, \proDisplay, 75, "~proView.valueAction_(~proSpec[", "].unmap(~proMul[",
		\proView, \pro, \proSpec, true, false, 1, ~compColor1 /*à essayer plus soft*/ /*~rtmCompColor*/, ~multiRtmCompColor, Color.white,
		\proSeqView, \proSeqStart, \proSeqStop, \seqDurPro, \proSeqSpec, \proSeqSpec2, \proSeqVSpec, \proSeqVSpec2,
		\proIndexView, \proIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\proRangeView, \proMin, \proMax, \proRangeSpec, "NoRangeViewMinRange", ~sliderHilightNoColor, \proRangePresetViewView, \proRangePresetView, ["0->0.5", "0.5->1", "0->1"], 2, "->", 1,
		\proMulView, \proMul, \proMulSpec, ~sliderHilightColor, \proMulPresetViewView, \proMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\proRoundViewView, \proRoundView, ~roundViewPos5, \proRound, \proRoundValue, ["@ 0.01", "@ 0.1", "@ 0.2", "@ 0.25", "@ 0.5", "@ 1"], 0, // \proRoundValue pas utilisé ???
		\proRandView, \probability,
		\proSeqAllView, \proRangeMode, \proSeqMode,
		\proCopyAView, \proCopyA, \proPasteAView, \proPasteA, \proPasteMView, \proPasteM, \proDefaultView, \proDefault,
		\proDirView, \proDir, \proPatView, \proPat, \proPatSelViewView, \proPatSelView, \proPatSel, \proBlock,
		\proShowView, ~nameModPos, \center, Color.green, "PRO",
		\proReadView, Color.grey(0.6) /*Color.magenta*/ /*~rtmCompColor.alpha_(0)*/, \proPosView
	);


	~drawSCGrids = { // inclure la fonction ~drawSCGrids dans ~proMulView - mais pas fait pour éviter de rajouter une fonction if dans ~proMulView
		if (~visuelSlider == 0, {
			~getSCGridsLevels = ~pro[~tracksValue][~seqsValue].size.collect { |i|
				var level = ScGrids.calculateLevel(\kick, i, ~proBjorGridsX[~tracksValue][~seqsValue], ~proBjorGridsY[~tracksValue][~seqsValue], ~proGridsBias[~tracksValue][~seqsValue] );
				if  ( level >= (1-~gridsDens[~tracksValue][~seqsValue]), {level}, {0});
			};
			{~proView.valueAction_(~getSCGridsLevels)}.defer;
		});
	};


	~proBjorView = SmoothSlider(~proComp, ~miniSlider1Pos5)
	.action_({ |view|
		~proBjor[~tracksValue][~seqsValue] = ~proBjorSpec[~tracksValue][~seqsValue].map(view.value).asInteger;
		~proBjorGridsX[~tracksValue][~seqsValue] = view.value.round(0.001);
		if (~proPatSel[~tracksValue][~seqsValue] > 18 /*and: {~proPat[~tracksValue][~seqsValue] == 1}*/, {
			view.string = "GX : %".format(~proBjorGridsX[~tracksValue][~seqsValue]); ~drawSCGrids.();
		}, {
			view.string = "Hit : %".format(~proBjor[~tracksValue][~seqsValue]);
		});
	}) // Action redéfinie dans le Global
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(Color.magenta)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1/~pro[~tracksValue][~seqsValue].size)
	.value_( 1 /*~proBjorSpec[~tracksValue][~seqsValue].unmap(1)*/)
	.doAction;

	~proBjor2View = SmoothSlider(~proComp, ~miniSlider2Pos5)
	.action_({ |view|
		~proBjor2[~tracksValue][~seqsValue] = ~proBjorSpec[~tracksValue][~seqsValue].map(view.value).asInteger;
		~proBjorGridsY[~tracksValue][~seqsValue] = view.value.round(0.001);
		if (~proPatSel[~tracksValue][~seqsValue] > 18 /*and: {~proPat[~tracksValue][~seqsValue] == 1}*/, {
			view.string = "GY : %".format(~proBjorGridsY[~tracksValue][~seqsValue]); ~drawSCGrids.();
		}, {
			view.string = "Off : %".format(~proBjor2[~tracksValue][~seqsValue]);
		});
	}) // Action redéfinie dans le Global
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(Color.magenta)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1/~pro[~tracksValue][~seqsValue].size)
	.value_( 1 /*~proBjorSpec[~tracksValue][~seqsValue].unmap(1)*/)
	.doAction;

	~proBjor3View = SmoothSlider(~proComp, Rect(274*~xSizeMul, 156*~ySizeMul, 60*~xSizeMul, 18*~ySizeMul))
	.action_({ |view|
		~proBjor3[~tracksValue][~seqsValue] = ~proBjorSpec[~tracksValue][~seqsValue].map(view.value).asInteger;
		~proGridsBias[~tracksValue][~seqsValue] = view.value.round(0.001);
		if (~proPatSel[~tracksValue][~seqsValue] > 18 /*and: {~proPat[~tracksValue][~seqsValue] == 1}*/, {
			// view.string = "Bi : %".format(~proGridsBias[~tracksValue][~seqsValue]);
			if (~proPatSel[~tracksValue][~seqsValue] > 21, { view.string = "GX2 : %".format(~proGridsBias[~tracksValue][~seqsValue]) }, { view.string = "Bi : %".format(~proGridsBias[~tracksValue][~seqsValue]); ~drawSCGrids.(); });
		}, {
			view.string = "H2 : %".format(~proBjor3[~tracksValue][~seqsValue]);
		});
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(Color.magenta)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1/~pro[~tracksValue][~seqsValue].size)
	.value_( 1 /*~proBjorSpec[~tracksValue][~seqsValue].unmap(1)*/)
	.doAction;

	~proBjor4View = SmoothSlider(~proComp, Rect(274*~xSizeMul, 174*~ySizeMul, 60*~xSizeMul, 18*~ySizeMul))
	.action_({ |view|
		~proBjor4[~tracksValue][~seqsValue] = ~proBjorSpec[~tracksValue][~seqsValue].map(view.value).asInteger;
		~proGridsBias2[~tracksValue][~seqsValue] = view.value.round(0.001);

		case
		{ ~proPatSel[~tracksValue][~seqsValue] < 20 } { view.string = "O2 : %".format(~proBjor4[~tracksValue][~seqsValue]) }
		{ ~proPatSel[~tracksValue][~seqsValue] < 22 } { view.string = "Px : %".format(~proGridsBias2[~tracksValue][~seqsValue]) }
		{ ~proPatSel[~tracksValue][~seqsValue] == 22 } { view.string = "GY2 : %".format(~proGridsBias2[~tracksValue][~seqsValue]) }

	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(Color.magenta)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1/~pro[~tracksValue][~seqsValue].size)
	.value_( 1 /*~proBjorSpec[~tracksValue][~seqsValue].unmap(1)*/)
	.doAction;

	~proWeightView = SmoothSlider(~proComp, Rect(212*~xSizeMul, 156*~ySizeMul, 60*~xSizeMul, 18*~ySizeMul))
	.action_({ |view|
		~proWeight[~tracksValue][~seqsValue] = view.value;
		view.string = "We : %".format(~proWeight[~tracksValue][~seqsValue])
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(Color.magenta)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(0.001)
	.value_( 1 /*~proBjorSpec[~tracksValue][~seqsValue].unmap(1)*/)
	.doAction;

	~proDrumTypeView = PopUpMenu.new(~proComp, Rect(212*~xSizeMul, 174*~ySizeMul, 60*~xSizeMul, 18*~ySizeMul))
	.allowsReselection_(true)
	.background_(~popUpMenuBackgroundColor)
	.stringColor_(~popUpMenuStringColor)
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({|menu| ~proDrumType[~tracksValue][~seqsValue] = menu.item; })
	.items_([\kick, \hihat, \snare]);

	// Redéfinition de l'action pour prendre en compte SC Grids et variations d'Euclid
	~proPatSelView.action_({|menu| var dur = 1/~pro[~tracksValue][~seqsValue].size;
		~proPatSel[~tracksValue][~seqsValue] = menu.value;
		~proBlock[~tracksValue] = 1;

		case
		{ ~proPatSel[~tracksValue][~seqsValue] < 14 } { ~proBjor3View.visible_(0); ~proBjor4View.visible_(0); ~proWeightView.visible_(0); ~proDrumTypeView.visible_(0); }
		{ ~proPatSel[~tracksValue][~seqsValue] == 14 } { ~proBjor3View.visible_(1); ~proBjor4View.visible_(0); ~proWeightView.visible_(1); ~proDrumTypeView.visible_(0); }
		{ ~proPatSel[~tracksValue][~seqsValue] == 15 } { ~proBjor3View.visible_(1); ~proBjor4View.visible_(1); ~proWeightView.visible_(0); ~proDrumTypeView.visible_(0); }
		{ ~proPatSel[~tracksValue][~seqsValue] == 16 } { ~proBjor3View.visible_(1); ~proBjor4View.visible_(0); ~proWeightView.visible_(0); ~proDrumTypeView.visible_(0); }
		{ ~proPatSel[~tracksValue][~seqsValue] == 17 } { ~proBjor3View.visible_(1); ~proBjor4View.visible_(0); ~proWeightView.visible_(0); ~proDrumTypeView.visible_(0); }
		{ ~proPatSel[~tracksValue][~seqsValue] == 18 } { ~proBjor3View.visible_(1); ~proBjor4View.visible_(1); ~proWeightView.visible_(1); ~proDrumTypeView.visible_(0); }
		{ ~proPatSel[~tracksValue][~seqsValue] == 19 } { ~proBjor3View.visible_(1); ~proBjor4View.visible_(0); ~proWeightView.visible_(1); ~proDrumTypeView.visible_(1); }
		{ ~proPatSel[~tracksValue][~seqsValue] > 19 } { ~proBjor3View.visible_(1); ~proBjor4View.visible_(1); ~proWeightView.visible_(1); ~proDrumTypeView.visible_(1); };
		// { ~proPatSel[~tracksValue][~seqsValue] == 21 } { ~proBjor3View.visible_(1); ~proBjor4View.visible_(1); ~proWeightView.visible_(1); ~proDrumTypeView.visible_(1); }

		if (~proPatSel[~tracksValue][~seqsValue] > 18, {
			~proBjorView.step_(0.001); ~proBjor2View.step_(0.001); ~proBjor3View.step_(0.001); ~proBjor4View.step_(0.001);
		},{
			~proBjorView.step_(dur); ~proBjor2View.step_(dur); ~proBjor3View.step_(dur); ~proBjor4View.step_(dur);
		});

		~proBjorView.value_(~proBjorGridsX[~tracksValue][~seqsValue]).doAction;
		~proBjor2View.value_(~proBjorGridsY[~tracksValue][~seqsValue]).doAction;
		~proBjor3View.value_(~proGridsBias[~tracksValue][~seqsValue]).doAction;
		~proBjor4View.value_(~proGridsBias2[~tracksValue][~seqsValue]).doAction;

		if (~patFlag == 1, {~seqs.do {|sequence| ~proPatSel[~tracksValue][sequence] = menu.value }});
	});

	// Action mis plus bas car necessité de le déclarer après ~proSelectViewG car action sur le Global
	~proSelectView = RoundButton(~proComp, Rect(337*~xSizeMul, 2*~ySizeMul, 60*~xSizeMul /*30*/, 16*~ySizeMul))
	.states_([["\PROS", Color.blue, Color.white], ["\PRO1", Color.red, Color.white]])
	.font_(Font("Verdana",8*~fontSizeMul));
	/*.action_({|i| ~proSelect[~tracksValue][~seqsValue] = i.value;
	[\rtmBlock, \proBlock, \synBlock, \spaBlock, \legBlock, \envBlock, \bufBlock, \ampBlock, \ratBlock, \rat2Block, \offBlock, \strBlock, \str2Block, \cenBlock, \cen2Block, \panBlock, \delBlock, \outLBlock, \outRBlock, \fxLBlock, \fxRBlock].do {|i| currentEnvironment[i][~tracksValue] = 1};
	})
	.valueAction_(0);*/





	// GUI SYNTHESE

	~posSyn = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~synType = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour changement en mono ou stereo
	~offRateSecondBuf = 1.0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables décalage du 2ème buffer mono quand stéréo
	~offRateRandSecondBuf = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables décalage du 2ème buffer mono quand stéréo

	~synViewItems = (~allSynths2.size.collect {|i| i+~allSynthsGUI2[i]});
	~synRangePresetItems = (["0-5-Buf0", "0-7-BufA", "8-11-In", ("12-"++"~allSynths2.size-1".interpret)++"-Syn", ("0-"++"~allSynths2.size-1".interpret)++"-All"]);

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		"NoRoundViewFunc", 0, (~allSynths2.size -1), 0, "NoRoundValueDefault", "NoRoundDefault",
		\synComp, \synDisplay, 75, "~synView.valueAction_(~synSpec[", "].unmap(~synMul[",
		\synView, \syn, \synSpec, false, true, "NoMultiViewValueThumbSize", ~compColor1, ~multiCompColor1, Color.white,
		\synSeqView, \synSeqStart, \synSeqStop, \seqDurSyn, \synSeqSpec, \synSeqSpec2, \synSeqVSpec, \synSeqVSpec2,
		\synIndexView, \synIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\synRangeView, \synMin, \synMax, \synRangeSpec, (1/~allSynths2.size), ~sliderHilightNoColor, \synRangePresetViewView, \synRangePresetView, ~synRangePresetItems, (~synRangePresetItems.size-1), "-", (~allSynths2.size -1),
		\synMulView, \synMul, \synMulSpec, ~sliderHilightNoColor, \synMulPresetViewView, \synMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\synRoundViewView, \synRoundView, ~roundViewPos5, \synRound, \synRoundValue, ~synViewItems, 0,
		\synRandView, \synthese,
		\synSeqAllView, \synRangeMode, \synSeqMode,
		\synCopyAView, \synCopyA, \synPasteAView, \synPasteA, \synPasteMView, \synPasteM, \synDefaultView, \synDefault,
		\synDirView, \synDir, \synPatView, \synPat, \synPatSelViewView, \synPatSelView, \synPatSel, \synBlock,
		\synShowView, ~nameModPos, \center, Color.yellow, "SYN",
		\synReadView, Color.grey(0.6), \synPosView
	);

	~synTypeView = RoundButton(~synComp, /*~miniSlider1Pos5*/ Rect(338*~xSizeMul, 154*~ySizeMul, 40*~xSizeMul, 18*~ySizeMul))
	.states_([["\BufM", Color.blue, Color.white], ["\BufS", Color.red, Color.white]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({|i| ~synType[~tracksValue][~seqsValue] = i.value })
	.valueAction_(0);

	~offRateRandSecondBufView = RoundButton(~synComp, /*~miniSlider1Pos5*/ Rect(378*~xSizeMul, 154*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
	.states_([["\NR", Color.white, Color.red], ["\R", Color.black, Color.green]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({|i| ~offRateRandSecondBuf[~tracksValue][~seqsValue] = i.value })
	.valueAction_(0);

	~offRateSecondBufSpec = ControlSpec(0, 2, \lin, 0.01);
	~offRateSecondBufView = SmoothSlider(~synComp, ~miniSlider2Pos5)
	.action_({ |view| ~offRateSecondBuf[~tracksValue][~seqsValue] = ~offRateSecondBufSpec.map(view.value);
		view.string = "2B : %".format(~offRateSecondBuf[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(Color.magenta)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~offRateSecondBufSpec.unmap(1))
	.doAction;

	/*
	SynthDescLib.global[\Electribe_SpecVar_StereoFInt].metadata;
	SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].metadata;
	SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].metadata[\comments][1];
	SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].metadata[\comments].do { |i| i.postln; }; "".postln;
	("metaData"++SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].name.split($_)[0]).asSymbol.envirGet
	*/

	~synInfoView = RoundButton(~synComp, Rect(337*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 16*~ySizeMul))
	.states_([["\Inf", Color.blue, Color.white]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i|
		// if (("metaData"++SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].name.split($_)[0]).asSymbol.envirGet.notNil, {
		// Rappuyer une deuxième fois sur RAN dans le module de synthèse provoque une erreur ??? même chose pour DEF ???
		if (SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].notNil, {
			(SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].name.split($_)[0] + "Arguments :").postln;
			("metaData"++SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].name.split($_)[0]).asSymbol.envirGet.do { |item, index|
				if (item.notNil, {
					// ~synthDescLibRangeViews[index].valueAction_(~synthDescLibRangeSpecs[index][~tracksValue][~seqsValue].unmap([item.minval, item.maxval])); // affiche les rangeViews par défaut
					// ~synthDescLibMulViews[index].valueAction_(~synthDescLibMulSpecs[index].unmap(1)); // affiche les mulViews par défaut
					(~synthDescLibNames[index] + "->" + item.units).postln; // // affiche les correspondances
			}) };
			"".postln;
		});
	});

	~synRangeDefView = RoundButton(~synComp, Rect(357*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 16*~ySizeMul))
	.states_([["\Rg", Color.blue, Color.white]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i|
		// if (("metaData"++SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].name.split($_)[0]).asSymbol.envirGet.notNil, {
		// Rappuyer une deuxième fois sur RAN dans le module de synthèse provoque une erreur ??? même chose pour DEF ???
		if (SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].notNil, {
			// (SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].name.split($_)[0] + "Arguments :").postln;
			("metaData"++SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].name.split($_)[0]).asSymbol.envirGet.do { |item, index|
				if (item.notNil, {
					~synthDescLibRangeViews[index].valueAction_(~synthDescLibRangeSpecs[index][~tracksValue][~seqsValue].unmap([item.minval, item.maxval])); // affiche les rangeViews par défaut
					~synthDescLibMulViews[index].valueAction_(~synthDescLibMulSpecs[index].unmap(1)); // affiche les mulViews par défaut
					// (~synthDescLibNames[index] + "->" + item.units).postln; // // affiche les correspondances
			}) };
			// "".postln;
		});
	});

	~synMSDefView = RoundButton(~synComp, Rect(377*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 16*~ySizeMul))
	.states_([["\Def", Color.blue, Color.white]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i|
		// if (("metaData"++SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].name.split($_)[0]).asSymbol.envirGet.notNil, {
		// Rappuyer une deuxième fois sur RAN dans le module de synthèse provoque une erreur ??? même chose pour DEF ??? -> ligne 8760
		if (SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].notNil, {
			// (SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].name.split($_)[0] + "Arguments :").postln;
			("metaData"++SynthDescLib.global[~lastEvent[~tracksValue][\instrument]].name.split($_)[0]).asSymbol.envirGet.do { |item, index|
				if (item.notNil, {
					~synthDescLibIndexViews[index].value_(~synthDescLibSpecs[index][~tracksValue][~seqsValue].unmap(item.default)).doAction; // affiche les multiSliderViews par défaut
					// (~synthDescLibNames[index] + "->" + item.units).postln; // // affiche les correspondances
			}) };
			// "".postln;
		});
	});





	// GUI SPATIALISATION

	~posSpa = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~spaRangePreset = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // NEW

	~spaSpecStereo = ControlSpec(0, 5, \lin, 1) ! ~nbOfSeqs ! ~nbOfTracksX2;


	// Pour la sauvegarde des trajectoires de spatialisation
	~presetsTrajectoryPath = (PathName.new(~currentPath).pathOnly ++ ~presetsTrajectoryFileName);

	// Création du fichier s'il n'existe pas
	if (File.exists(~presetsTrajectoryPath), { }, {File.open(~presetsTrajectoryPath, "w")});
	// Mode w -> Creates an empty file for writing. If a file with the same name already exists its content is erased and thefile is treated as a new empty file.

	// > 21 car indication de DEvent dans le fichier quand tous les presets ont été retiré avec Del donc obligé de réinitialiser la liste des presets avec le Default
	if (File.fileSize(~presetsTrajectoryPath) <= 21, {
		~presetsTrajectory = IdentityDictionary.new;
		// ~presetsTrajectory = ();
	} , {
		~presetsTrajectoryFileW = ZArchive.read(~presetsTrajectoryPath);
		~presetsTrajectory = ~presetsTrajectoryFileW.readItem;
		~presetsTrajectoryFileW.close;
	});


	// Redéfinition du contenu de module de spatialisation dans ~allSpasGUI selon les trajectoires de presets dans _Init GUI 43
	// ~allSpasGUI = ["Stereo", "Traj 0->1", "Traj 1->0", "Traj 0->1->0", "Traj 1->0->1", /*"Bad PanB2", "Bad Pan"*/ "Circ_1_GD", "Circ_1_DG", "CircM_GD", "CircM_DG", "A"];
	~allSpasGUIBase = ~allSpasGUI[0..~allSpasGUI.size -2];
	// ~allSpasGUIAmbi = ~presetsTrajectory['TrajectoryAllList'].size.collect { |i| ~allSpasGUI.last ++ "_" ++ ~presetsTrajectory['TrajectoryAllList'][i] };
	~allSpasGUIAmbi = ~presetsTrajectory['TrajectoryAllList'].size.collect { |i| ~allSpasGUI.last /*~allSpasGUI[~allSpasGUI.size-1]*/  ++ i ++ "_" ++~presetsTrajectory['TrajectoryAllList'][i] };
	~allSpasGUIFinal = ~allSpasGUIBase  ++ ~allSpasGUIAmbi;


	if (~acousItems.isNil, {

		if (~bigStereoOuts.isNil, {

			// ~spaRangePresetItems = (["PA 0->0", "TR 1->4", "PT 0->4", "C1 5->6", "CM 5->12", "CA 5->14", "TC 0->14", "CS 13->14", "AS 15->16", ("AT 17->"++"~allSpasGUIFinal.size -1".interpret), "All 0->"++"~allSpasGUIFinal.size -1".interpret]);
			// ~spaRangePresetItemsG = (["PAN 0->0", "TRA 1->4", "PT 0->4", "CI1 5->6", "CIM 7->12", "CIA 5->14", "T&C 0->14", "CSD 13->14", "ASD 15->16", ("AMT 17->"++"~allSpasGUIFinal.size -1".interpret), "ALL 0->"++"~allSpasGUIFinal.size -1".interpret]);
			~spaRangePresetItems = (["Pan", "Del", "Line", "P & L", "Cir 1", "Cir MR", "Cir MV", "Cir  M", "Cir SD", "Cir  A", "PL & C", "Tra SD", "Traj", "ALL"]);

			~spaRangePresetItemsG = (["2 Pan      - 0-> 0", "2 Del      - 1-> 1", "2 Mob      - 2-> 5", "2 ALL      - 0-> 5", "C   1      - 6-> 7", "C Mul Reg  - 8-> 9", "C Mul Var  -10->13", "C Mul ALL  - 8->13", "C SD       -14->15", "C ALL      - 6->15", "C & 2      - 0->15", "Traj SD    -16->17", ("Traj       -18->"++"17+~allSpasGUIAmbi.size".interpret), "ALL        - 0->"++"~allSpasGUIFinal.size -1".interpret]);

			~spaStringFunction = { // Est ce que le fait de ne pas mettre d'argument à une fonction la rend plus rapide ????????? -> à tester
				case
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == 0} } {~spaRangePresetItems[0]}
				{~spaMin[~tracksValue][~seqsValue] == 1 and: {~spaMax[~tracksValue][~seqsValue] == 1} } {~spaRangePresetItems[1]}
				{~spaMin[~tracksValue][~seqsValue] == 2 and: {~spaMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[2]}
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[3]}
				{~spaMin[~tracksValue][~seqsValue] == 6 and: {~spaMax[~tracksValue][~seqsValue] == 7} } {~spaRangePresetItems[4]}
				{~spaMin[~tracksValue][~seqsValue] == 8 and: {~spaMax[~tracksValue][~seqsValue] == 9} } {~spaRangePresetItems[5]}
				{~spaMin[~tracksValue][~seqsValue] == 10 and: {~spaMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[6]}
				{~spaMin[~tracksValue][~seqsValue] == 8 and: {~spaMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[7]}
				{~spaMin[~tracksValue][~seqsValue] == 14 and: {~spaMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[8]}
				{~spaMin[~tracksValue][~seqsValue] == 6 and: {~spaMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[9]}
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[10]}
				{~spaMin[~tracksValue][~seqsValue] == 16 and: {~spaMax[~tracksValue][~seqsValue] == 17} } {~spaRangePresetItems[11]}
				{~spaMin[~tracksValue][~seqsValue] == 18 and: {~spaMax[~tracksValue][~seqsValue] == (/*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size)} } {~spaRangePresetItems[12]}
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == (~allSpasGUIFinal.size -1)} } {~spaRangePresetItems[13]}

				// Plus rapide en utilisant ~spaRangePreset comme {~spaRangePreset[~tracksValue][~seqsValue] == 0} {string = ~spaRangePresetItems[0]}
				// & création d'une fonction automatique, Mais ne prend pas en compte les actions sur le RangeView lui-même
				// ~spaRangePresetItemsFunctionStringSize = ~spaRangePresetItems.collect{ |item, i| "{~spaRangePreset[~tracksValue][~seqsValue] == "++ i ++"} {~spaRangePresetItems["++ i ++"]}" }.asCompileString.size; // ligne à mettre en dehors de la fonction
				/*("case" ++ ~spaRangePresetItems.collect{ |item, i| "{~spaRangePreset[~tracksValue][~seqsValue] == "++ i ++"} {~spaRangePresetItems["++ i ++"]}" }.asCompileString.copyRange(2, ~spaRangePresetItemsFunctionStringSize-2).replace(","," ").replace("\""," ")).interpret;*/
			};

			~spaRangePresetViewFunc = [
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, 0])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([1, 1])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([2, 5])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, 5])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([6, 7])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([8, 9])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([10, 13])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([8, 13])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([14, 15])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([6, 15])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, 15])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([16, 17])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([18, /*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, ~allSpasGUIFinal.size -1])) }
			];


			// Fonctions en doule pour utiliser ~spaHar XXXXX pour le module SPA de ~makeModuleHarmWindow plus bas - Code à optimiser
			~spaHarRangePresetViewFunc = [
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, 0])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([1, 1])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([2, 5])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, 5])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([6, 7])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([8, 9])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([10, 13])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([8, 13])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([14, 15])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([6, 15])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, 15])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([16, 17])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([18, 17+~allSpasGUIAmbi.size])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, ~allSpasGUIFinal.size -1])) }
			];

			~spaHarStringFunction = {
				case
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == 0} } {~spaRangePresetItems[0]}
				{~spaHarMin[~tracksValue][~seqsValue] == 1 and: {~spaHarMax[~tracksValue][~seqsValue] == 1} } {~spaRangePresetItems[1]}
				{~spaHarMin[~tracksValue][~seqsValue] == 2 and: {~spaHarMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[2]}
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[3]}
				{~spaHarMin[~tracksValue][~seqsValue] == 6 and: {~spaHarMax[~tracksValue][~seqsValue] == 7} } {~spaRangePresetItems[4]}
				{~spaHarMin[~tracksValue][~seqsValue] == 8 and: {~spaHarMax[~tracksValue][~seqsValue] == 9} } {~spaRangePresetItems[5]}
				{~spaHarMin[~tracksValue][~seqsValue] == 10 and: {~spaHarMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[6]}
				{~spaHarMin[~tracksValue][~seqsValue] == 8 and: {~spaHarMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[7]}
				{~spaHarMin[~tracksValue][~seqsValue] == 14 and: {~spaHarMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[8]}
				{~spaHarMin[~tracksValue][~seqsValue] == 6 and: {~spaHarMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[9]}
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[10]}
				{~spaHarMin[~tracksValue][~seqsValue] == 16 and: {~spaHarMax[~tracksValue][~seqsValue] == 17} } {~spaRangePresetItems[11]}
				{~spaHarMin[~tracksValue][~seqsValue] == 18 and: {~spaHarMax[~tracksValue][~seqsValue] == (17+~allSpasGUIAmbi.size)} } {~spaRangePresetItems[12]}
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == (~allSpasGUIFinal.size -1)} } {~spaRangePresetItems[13]}
			};

		},{
			~acousFunction = { ~allSpasGUIFinal = ~allSpasGUIFinal.addAll ( ["AcousF", "AcousR", "AcousB", "AcousL"] ) };
			~acousFunction.();

			~spaRangePresetItems = (["Pan", "Del", "Line", "P & L", "Cir 1", "Cir MR", "Cir MV", "Cir  M", "Cir SD", "Cir  A", "PL & C", "Tra SD", "Traj", "ALL M", "Acou A", "ALL"]);

			~spaRangePresetItemsG = (["2 Pan      - 0-> 0", "2 Del      - 1-> 1", "2 Mob      - 2-> 5", "2 ALL      - 0-> 5", "C   1      - 6-> 7", "C Mul Reg  - 8-> 9", "C Mul Var  -10->13", "C Mul ALL  - 8->13", "C SD       -14->15", "C ALL      - 6->15", "C & 2      - 0->15", "Traj SD    -16->17", ("Traj       -18->"++"17+~allSpasGUIAmbi.size".interpret), ("ALL M      - 0->"++"17+~allSpasGUIAmbi.size".interpret),
				("Acous A    -"++"18+~allSpasGUIAmbi.size".interpret++"->"++"~allSpasGUIFinal.size -1".interpret), "ALL        - 0->"++"~allSpasGUIFinal.size -1".interpret]);

			~spaStringFunction = { // Est ce que le fait de ne pas mettre d'argument à une fonction la rend plus rapide ????????? -> à tester
				case
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == 0} } {~spaRangePresetItems[0]}
				{~spaMin[~tracksValue][~seqsValue] == 1 and: {~spaMax[~tracksValue][~seqsValue] == 1} } {~spaRangePresetItems[1]}
				{~spaMin[~tracksValue][~seqsValue] == 2 and: {~spaMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[2]}
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[3]}
				{~spaMin[~tracksValue][~seqsValue] == 6 and: {~spaMax[~tracksValue][~seqsValue] == 7} } {~spaRangePresetItems[4]}
				{~spaMin[~tracksValue][~seqsValue] == 8 and: {~spaMax[~tracksValue][~seqsValue] == 9} } {~spaRangePresetItems[5]}
				{~spaMin[~tracksValue][~seqsValue] == 10 and: {~spaMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[6]}
				{~spaMin[~tracksValue][~seqsValue] == 8 and: {~spaMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[7]}
				{~spaMin[~tracksValue][~seqsValue] == 14 and: {~spaMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[8]}
				{~spaMin[~tracksValue][~seqsValue] == 6 and: {~spaMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[9]}
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[10]}
				{~spaMin[~tracksValue][~seqsValue] == 16 and: {~spaMax[~tracksValue][~seqsValue] == 17} } {~spaRangePresetItems[11]}
				{~spaMin[~tracksValue][~seqsValue] == 18 and: {~spaMax[~tracksValue][~seqsValue] == (/*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size)} } {~spaRangePresetItems[12]}
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == (17+~allSpasGUIAmbi.size)} } {~spaRangePresetItems[13]}
				{~spaMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size) and: {~spaMax[~tracksValue][~seqsValue] == (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0])} } {~spaRangePresetItems[14]}
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == (~allSpasGUIFinal.size -1)} } {~spaRangePresetItems[15]}
			};

			~spaRangePresetViewFunc = [
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, 0])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([1, 1])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([2, 5])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, 5])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([6, 7])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([8, 9])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([10, 13])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([8, 13])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([14, 15])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([6, 15])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, 15])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([16, 17])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([18, /*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, 17+~allSpasGUIAmbi.size])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size), (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0])])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, ~allSpasGUIFinal.size -1])) }
			];


			// Fonctions en doule pour utiliser ~spaHar XXXXX pour le module SPA de ~makeModuleHarmWindow plus bas - Code à optimiser
			~spaHarStringFunction = {
				case
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == 0} } {~spaRangePresetItems[0]}
				{~spaHarMin[~tracksValue][~seqsValue] == 1 and: {~spaHarMax[~tracksValue][~seqsValue] == 1} } {~spaRangePresetItems[1]}
				{~spaHarMin[~tracksValue][~seqsValue] == 2 and: {~spaHarMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[2]}
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[3]}
				{~spaHarMin[~tracksValue][~seqsValue] == 6 and: {~spaHarMax[~tracksValue][~seqsValue] == 7} } {~spaRangePresetItems[4]}
				{~spaHarMin[~tracksValue][~seqsValue] == 8 and: {~spaHarMax[~tracksValue][~seqsValue] == 9} } {~spaRangePresetItems[5]}
				{~spaHarMin[~tracksValue][~seqsValue] == 10 and: {~spaHarMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[6]}
				{~spaHarMin[~tracksValue][~seqsValue] == 8 and: {~spaHarMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[7]}
				{~spaHarMin[~tracksValue][~seqsValue] == 14 and: {~spaHarMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[8]}
				{~spaHarMin[~tracksValue][~seqsValue] == 6 and: {~spaHarMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[9]}
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[10]}
				{~spaHarMin[~tracksValue][~seqsValue] == 16 and: {~spaHarMax[~tracksValue][~seqsValue] == 17} } {~spaRangePresetItems[11]}
				{~spaHarMin[~tracksValue][~seqsValue] == 18 and: {~spaHarMax[~tracksValue][~seqsValue] == (/*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size)} } {~spaRangePresetItems[12]}
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == (/*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size)} } {~spaRangePresetItems[13]}
				{~spaHarMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size) and: {~spaHarMax[~tracksValue][~seqsValue] == (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0])} } {~spaRangePresetItems[14]}
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == (~allSpasGUIFinal.size -1)} } {~spaRangePresetItems[15]}
			};

			~spaHarRangePresetViewFunc = [
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, 0])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([1, 1])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([2, 5])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, 5])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([6, 7])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([8, 9])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([10, 13])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([8, 13])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([14, 15])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([6, 15])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, 15])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([16, 17])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([18, /*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, /*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size), (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0])])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, ~allSpasGUIFinal.size -1])) }
			];

		});

	},{

		case
		{~numChannelsConfig == "16-Dome-8-6-2-Clock" or: {~numChannelsConfig == "16-Dome-8-6-2-Clock-CC"} or: {~numChannelsConfig == "24-UsineC-3Octo"} or: {~numChannelsConfig == "16-UsineC-2Octo"} or: {~numChannelsConfig == "32-Dome-UQAM-11-11-9-1"}}

		{
			~acousFunction = { ~allSpasGUIFinal = ~allSpasGUIFinal.addAll ( ~acousItems ) };
			~acousFunction.();

			~spaRangePresetItems = (["Pan", "Del", "Line", "P & L", "Cir 1", "Cir MR", "Cir MV", "Cir  M", "Cir SD", "Cir  A", "PL & C", "Tra SD", "Traj", "ALL M", "Acou 1", "Acou 2", "Acou 3", "Acou 4", "Acou A", "ALL"]);

			~spaRangePresetItemsG = (["2 Pan      - 0-> 0", "2 Del      - 1-> 1", "2 Mob      - 2-> 5", "2 ALL      - 0-> 5", "C   1      - 6-> 7", "C Mul Reg  - 8-> 9", "C Mul Var  -10->13", "C Mul ALL  - 8->13", "C SD       -14->15", "C ALL      - 6->15", "C & 2      - 0->15", "Traj SD    -16->17", ("Traj       -18->"++"17+~allSpasGUIAmbi.size".interpret), ("ALL M      - 0->"++"17+~allSpasGUIAmbi.size".interpret),
				("Acous 1    -"++"18+~allSpasGUIAmbi.size".interpret++"->"++"17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0]".interpret),
				("Acous 2    -"++"18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0]".interpret++"->"++"17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[1]".interpret),
				("Acous 3    -"++"18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[1]".interpret++"->"++"17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[2]".interpret),
				("Acous 4    -"++"18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[2]".interpret++"->"++"~allSpasGUIFinal.size -1".interpret),
				("Acous A    -"++"18+~allSpasGUIAmbi.size".interpret++"->"++"~allSpasGUIFinal.size -1".interpret), "ALL        - 0->"++"~allSpasGUIFinal.size -1".interpret]);

			~spaStringFunction = { // Est ce que le fait de ne pas mettre d'argument à une fonction la rend plus rapide ????????? -> à tester
				case
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == 0} } {~spaRangePresetItems[0]}
				{~spaMin[~tracksValue][~seqsValue] == 1 and: {~spaMax[~tracksValue][~seqsValue] == 1} } {~spaRangePresetItems[1]}
				{~spaMin[~tracksValue][~seqsValue] == 2 and: {~spaMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[2]}
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[3]}
				{~spaMin[~tracksValue][~seqsValue] == 6 and: {~spaMax[~tracksValue][~seqsValue] == 7} } {~spaRangePresetItems[4]}
				{~spaMin[~tracksValue][~seqsValue] == 8 and: {~spaMax[~tracksValue][~seqsValue] == 9} } {~spaRangePresetItems[5]}
				{~spaMin[~tracksValue][~seqsValue] == 10 and: {~spaMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[6]}
				{~spaMin[~tracksValue][~seqsValue] == 8 and: {~spaMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[7]}
				{~spaMin[~tracksValue][~seqsValue] == 14 and: {~spaMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[8]}
				{~spaMin[~tracksValue][~seqsValue] == 6 and: {~spaMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[9]}
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[10]}
				{~spaMin[~tracksValue][~seqsValue] == 16 and: {~spaMax[~tracksValue][~seqsValue] == 17} } {~spaRangePresetItems[11]}
				{~spaMin[~tracksValue][~seqsValue] == 18 and: {~spaMax[~tracksValue][~seqsValue] == (/*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size)} } {~spaRangePresetItems[12]}
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == (17+~allSpasGUIAmbi.size)} } {~spaRangePresetItems[13]}
				{~spaMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size) and: {~spaMax[~tracksValue][~seqsValue] == (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0])} } {~spaRangePresetItems[14]}
				{~spaMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0]) and: {~spaMax[~tracksValue][~seqsValue] == (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[1])} } {~spaRangePresetItems[15]}
				{~spaMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[1]) and: {~spaMax[~tracksValue][~seqsValue] == (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[2])} } {~spaRangePresetItems[16]}
				{~spaMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[2]) and: {~spaMax[~tracksValue][~seqsValue] == (~allSpasGUIFinal.size -1)} } {~spaRangePresetItems[17]}
				{~spaMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size) and: {~spaMax[~tracksValue][~seqsValue] == (~allSpasGUIFinal.size -1)} } {~spaRangePresetItems[18]}
				{~spaMin[~tracksValue][~seqsValue] == 0 and: {~spaMax[~tracksValue][~seqsValue] == (~allSpasGUIFinal.size -1)} } {~spaRangePresetItems[19]}
			};

			~spaRangePresetViewFunc = [
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, 0])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([1, 1])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([2, 5])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, 5])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([6, 7])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([8, 9])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([10, 13])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([8, 13])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([14, 15])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([6, 15])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, 15])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([16, 17])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([18, /*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, 17+~allSpasGUIAmbi.size])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size), (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0])])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0]), (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[1])])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[1]), (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[2])])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[2]), (~allSpasGUIFinal.size -1)])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size), ~allSpasGUIFinal.size -1])) },
				{ |tr, seq| ~spaRangeView.valueAction_(~spaRangeSpec[tr][seq].unmap([0, ~allSpasGUIFinal.size -1])) }
			];


			// Fonctions en doule pour utiliser ~spaHar XXXXX pour le module SPA de ~makeModuleHarmWindow plus bas - Code à optimiser
			~spaHarStringFunction = {
				case
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == 0} } {~spaRangePresetItems[0]}
				{~spaHarMin[~tracksValue][~seqsValue] == 1 and: {~spaHarMax[~tracksValue][~seqsValue] == 1} } {~spaRangePresetItems[1]}
				{~spaHarMin[~tracksValue][~seqsValue] == 2 and: {~spaHarMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[2]}
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == 5} } {~spaRangePresetItems[3]}
				{~spaHarMin[~tracksValue][~seqsValue] == 6 and: {~spaHarMax[~tracksValue][~seqsValue] == 7} } {~spaRangePresetItems[4]}
				{~spaHarMin[~tracksValue][~seqsValue] == 8 and: {~spaHarMax[~tracksValue][~seqsValue] == 9} } {~spaRangePresetItems[5]}
				{~spaHarMin[~tracksValue][~seqsValue] == 10 and: {~spaHarMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[6]}
				{~spaHarMin[~tracksValue][~seqsValue] == 8 and: {~spaHarMax[~tracksValue][~seqsValue] == 13} } {~spaRangePresetItems[7]}
				{~spaHarMin[~tracksValue][~seqsValue] == 14 and: {~spaHarMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[8]}
				{~spaHarMin[~tracksValue][~seqsValue] == 6 and: {~spaHarMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[9]}
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == 15} } {~spaRangePresetItems[10]}
				{~spaHarMin[~tracksValue][~seqsValue] == 16 and: {~spaHarMax[~tracksValue][~seqsValue] == 17} } {~spaRangePresetItems[11]}
				{~spaHarMin[~tracksValue][~seqsValue] == 18 and: {~spaHarMax[~tracksValue][~seqsValue] == (/*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size)} } {~spaRangePresetItems[12]}
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == (/*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size)} } {~spaRangePresetItems[13]}
				{~spaHarMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size) and: {~spaHarMax[~tracksValue][~seqsValue] == (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0])} } {~spaRangePresetItems[14]}
				{~spaHarMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0]) and: {~spaHarMax[~tracksValue][~seqsValue] == (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[1])} } {~spaRangePresetItems[15]}
				{~spaHarMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[1]) and: {~spaHarMax[~tracksValue][~seqsValue] == (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[2])} } {~spaRangePresetItems[16]}
				{~spaHarMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[2]) and: {~spaHarMax[~tracksValue][~seqsValue] == (~allSpasGUIFinal.size -1)} } {~spaRangePresetItems[17]}
				{~spaHarMin[~tracksValue][~seqsValue] == (18+~allSpasGUIAmbi.size) and: {~spaHarMax[~tracksValue][~seqsValue] == (~allSpasGUIFinal.size -1)} } {~spaRangePresetItems[18]}
				{~spaHarMin[~tracksValue][~seqsValue] == 0 and: {~spaHarMax[~tracksValue][~seqsValue] == (~allSpasGUIFinal.size -1)} } {~spaRangePresetItems[19]}
			};

			~spaHarRangePresetViewFunc = [
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, 0])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([1, 1])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([2, 5])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, 5])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([6, 7])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([8, 9])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([10, 13])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([8, 13])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([14, 15])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([6, 15])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, 15])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([16, 17])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([18, /*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, /*~allSpasGUIFinal.size*/ 17+~allSpasGUIAmbi.size])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size), (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0])])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[0]), (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[1])])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[1]), (17+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[2])])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size+~bigStereoOutsSizes2[2]), (~allSpasGUIFinal.size -1)])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([(18+~allSpasGUIAmbi.size), ~allSpasGUIFinal.size -1])) },
				{ |tr, seq| ~spaHarRangeView.valueAction_(~spaHarRangeSpec[tr][seq].unmap([0, ~allSpasGUIFinal.size -1])) }
			];

		};

	});


	// ~spaRangePresetItemsLV = (["2 Fix", "2 Del", "2 Mob", "2 ALL", "C 1", "C M Reg", "C M Var", "C M", "C SD", "C ALL", "2 & C", "Traj SD", "Traj", "ALL"]);
	~spaRangePresetItemsLV1 = (["2 Fix", "2 Del", "2 Mob"]); // de 0 à 2
	~spaRangePresetItemsLValues1 = [0, 1, 2];
	~spaRangePresetItemsLFunctions1 = [
		{ ~panRandView.valueAction_(1); ~outLRandView.valueAction_(1); ~outRRandView.valueAction_(1) },
		{ ~panRandView.valueAction_(1); ~delRandView.valueAction_(1); ~outLRandView.valueAction_(1); ~outRRandView.valueAction_(1)},
		{ ~spaRandView.valueAction_(1); ~outLRandView.valueAction_(1); ~outRRandView.valueAction_(1) }
	];

	~spaRangePresetItemsLV2 = (["C 1", "C M Reg", "C M Var", "C M", "C SD"]); // de 4 à 8
	~spaRangePresetItemsLValues2 = (4..8);
	~spaRangePresetItemsLFunctions2 = [
		{ ~outLRandView.valueAction_(1) }, // besoin de ~outRRandView ???
		{ ~panRandView.valueAction_(1); ~outLRandView.valueAction_(1) },
		{ ~panRandView.valueAction_(1); ~outLRandView.valueAction_(1); ~outRRandView.valueAction_(1) },
		{ ~panRandView.valueAction_(1); ~outLRandView.valueAction_(1); ~outRRandView.valueAction_(1) },
		{ ~panRandView.valueAction_(1); ~outLRandView.valueAction_(1) } ];

	~spaRangePresetItemsLV3 = (["T SD", "Traj"]); // de 11 à 12
	~spaRangePresetItemsLValues3 = [11, 12];

	~spaRangePresetItemsLV4 = (["2 ALL", "C ALL", "2 & C", "ALL"]);
	~spaRangePresetItemsLValues4 = [3, 9, 10, 13];
	~spaRangePresetItemsLFunctions4 = [
		{ ~panRandView.valueAction_(1); ~delRandView.valueAction_(1); ~outLRandView.valueAction_(1); ~outRRandView.valueAction_(1) }, { ~panRandView.valueAction_(1); ~outLRandView.valueAction_(1); ~outRRandView.valueAction_(1) }, { ~panRandView.valueAction_(1); ~delRandView.valueAction_(1); ~outLRandView.valueAction_(1); ~outRRandView.valueAction_(1) }, { ~panRandView.valueAction_(1); ~delRandView.valueAction_(1); ~outLRandView.valueAction_(1); ~outRRandView.valueAction_(1) } ];


	~spaRangePreset = ~spaRangePresetItems.size-1 ! ~nbOfSeqs ! ~nbOfTracksX2; // à retirer de l'initialisation du départ avec 0

	~spaViewItems = (~allSpasGUIFinal.size.collect {|i| i+~allSpasGUIFinal[i]});

	~makeModuleWindow.( currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		"NoRoundViewFunc", 0, (~allSpasGUIFinal.size -1), 0, "NoRoundValueDefault", "NoRoundDefault",
		\spaComp, \spaDisplay, 75, "~spaView.valueAction_(~spaSpec[", "].unmap(~spaMul[",
		\spaView, \spa, \spaSpec, false, true, "NoMultiViewValueThumbSize", ~compColor1 /*à essayer plus soft*/ /*~panCompColor*/, ~multiCompColor1, Color.white,
		\spaSeqView, \spaSeqStart, \spaSeqStop, \seqDurSpa, \spaSeqSpec, \spaSeqSpec2, \spaSeqVSpec, \spaSeqVSpec2,
		\spaIndexView, \spaIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\spaRangeView, \spaMin, \spaMax, \spaRangeSpec, 0 /*Pourquoi 0 initialement*/ /*(1/~allSpasGUIFinal.size)*/, ~sliderHilightNoColor /*Color.red*/, \spaRangePresetViewView, \spaRangePresetView, ~spaRangePresetItems, (~spaRangePresetItems.size -1), "-", (~allSpasGUIFinal.size -1),
		\spaMulView, \spaMul, \spaMulSpec, ~sliderHilightNoColor, \spaMulPresetViewView, \spaMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\spaRoundViewView, \spaRoundView, ~roundViewPos5, \spaRound, \spaRoundValue, ~spaViewItems, 0,
		\spaRandView, \spatialisation,
		\spaSeqAllView, \spaRangeMode, \spaSeqMode,
		\spaCopyAView, \spaCopyA, \spaPasteAView, \spaPasteA, \spaPasteMView, \spaPasteM, \spaDefaultView, \spaDefault,
		\spaDirView, \spaDir, \spaPatView, \spaPat, \spaPatSelViewView, \spaPatSelView, \spaPatSel, \spaBlock,
		\spaShowView, ~nameModPos, \center, Color.green, "SPA",
		\spaReadView, Color.grey(0.6), \spaPosView
	);





	// GUI SPATIALISATION 2

	// ~spa2Comp = CompositeView(~tabGUI, Rect(1199, 0, 399, 216)).background = ~panCompColor;

	~spa2CompTabbedView = TabbedView2(~spa2Comp, Rect(0, 0, 399*~xSizeMul, 216*~ySizeMul))
	.lockPosition_(true)
	.lockEdges_(true)
	.backgrounds_([Color(0.8, 0.8, 0.8), Color(0.8, 0.8, 0.8), Color.clear /*~panCompColor*/])
	.unfocusedColors_([~sliderBackgroundColor/*Color.white*/])
	.stringColors_([Color.white])
	.labelColors_([Color.blue])
	.font_(Font("Verdana",11*~fontSizeMul, bold: true))
	.tabHeight_(18*~ySizeMul).tabWidth_(~spa2Comp.bounds.height/4).tabPosition_(\left)/*.tabCurve_(10)*/;

	~tabBufComp = ~spa2CompTabbedView.add("BUF", 0, scroll:true).focusAction={ ~envParTab = 0; ~envParTabView.value_(0) };
	~tabEnvComp = ~spa2CompTabbedView.add("ENV", 1 /*, scroll:true*/).focusAction={ ~envParTab = 1; ~envParTabView.value_(1) };
	~tabSpa2Comp = ~spa2CompTabbedView.add("SPA", 2 /*, scroll:true*/).focusAction={ ~envParTab = 2; ~envParTabView.value_(2) };
	~tabHarComp = ~spa2CompTabbedView.add("MUL", 3 /*, scroll:true*/).focusAction={ ~envParTab = 3; ~envParTabView.value_(3) };
	// ~spa2CompTabbedView.focus(2); // déjà déclenché par ~envParTabView

	~tabHarmComp = TabbedView2(~tabHarComp, Rect(-2*~xSizeMul, -2*~ySizeMul, 349*~xSizeMul, 216*~ySizeMul))
	.lockPosition_(true)
	.lockEdges_(true)
	.backgrounds_([Color(0.8, 0.8, 0.8), Color(0.8, 0.8, 0.8), Color.clear /*~panCompColor*/])
	.unfocusedColors_([~sliderBackgroundColor/*Color.white*/])
	.stringColors_([Color.white])
	.labelColors_([Color.blue])
	.font_(Font("Verdana",11*~fontSizeMul, bold: true))
	.tabHeight_(18*~ySizeMul).tabWidth_(~spa2Comp.bounds.width/8).tabPosition_(\bottom)/*.tabCurve_(10)*/;

	~tabHarmRatComp = ~tabHarmComp.add("RAT"/*, scroll:true*/, 0).focusAction={ ~envParTab = 3; ~envParTabView.value_(3) };
	~tabHarmCenComp = ~tabHarmComp.add("CEN"/*, scroll:true*/, 1).focusAction={ ~envParTab = 4; ~envParTabView.value_(4) };
	~tabHarmDelComp = ~tabHarmComp.add("DEL"/*, scroll:true*/, 2).focusAction={ ~envParTab = 5; ~envParTabView.value_(5) };
	~tabHarmSpaComp = ~tabHarmComp.add("SPA"/*, scroll:true*/, 3).focusAction={ ~envParTab = 6; ~envParTabView.value_(6) };
	~tabHarmAmpComp = ~tabHarmComp.add("AMP"/*, scroll:true*/, 4).focusAction={ ~envParTab = 7; ~envParTabView.value_(7) };
	// ~tabHarmEnvComp = ~tabHarmComp.add("ENV"/*, scroll:true*/, 4);

	~spatTypeComp = CompositeView(~tabSpa2Comp, Rect(2*~xSizeMul, 4*~ySizeMul, 116*~xSizeMul, 210*~ySizeMul)).background = ~popUpMenuBackgroundColor;

	/*StaticText(~spatTypeComp, Rect(68, 2, 46, 46)).background_(~panCompColor).stringColor_(Color.white).align_(\center).font_(Font("Verdana",10/*, bold: true*/))
	.string = "Stereo \nLine \nPanning";*/

	~stereoSpatType = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~stereoSpatTypeView = ListView(~spatTypeComp, Rect(2*~xSizeMul, 2*~ySizeMul, 55*~xSizeMul, 45*~ySizeMul))
	.background_(~panCompColor /*Color./*clear*/grey(0.3, alpha: 0.8)*/)
	.hiliteColor_(Color.yellow(alpha: 1))
	.selectedStringColor_(Color.black)
	.stringColor_(Color.white)
	.font_(Font("Verdana",(11*~fontSizeMul).asInteger, bold: true))
	.items_(["2 EqPo", "2 Virtu", "2 Spec"])
	.action_({ |menu| ~stereoSpatType[~tracksValue][~seqsValue] = menu.value });

	~circSpatType = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~circSpatTypeView = ListView(~spatTypeComp, Rect(60*~xSizeMul, 2*~ySizeMul, 55*~xSizeMul, 31*~ySizeMul))
	.background_(~panCompColor /*Color./*clear*/grey(0.3, alpha: 0.8)*/)
	.hiliteColor_(Color.yellow(alpha: 1))
	.selectedStringColor_(Color.black)
	.stringColor_(Color.white)
	.font_(Font("Verdana",(11*~fontSizeMul).asInteger, bold: true))
	.items_(["C EqPo", "C Vbap"])
	.action_({ |menu| ~circSpatType[~tracksValue][~seqsValue] = menu.value });

	~sdSpatType = 1 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~sdSpatTypeView = ListView(~spatTypeComp, Rect(60*~xSizeMul, 35*~ySizeMul, 55*~xSizeMul, 58*~ySizeMul))
	.background_(Color.red /*~panCompColor*/ /*Color./*clear*/grey(0.3, alpha: 0.8)*/)
	.hiliteColor_(Color.yellow(alpha: 1))
	.selectedStringColor_(Color.black)
	.stringColor_(Color.white)
	.font_(Font("Verdana",(11*~fontSizeMul).asInteger, bold: true))
	.items_(["S Virtu", "S Vbap", "S VDis", "S Ambi"])
	.action_({ |menu| ~sdSpatType[~tracksValue][~seqsValue] = menu.value })
	.valueAction_(1);

	~trajSpatType = 1 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~trajSpatTypeView = ListView(~spatTypeComp, Rect(2*~xSizeMul, 49*~ySizeMul, 55*~xSizeMul, 44*~ySizeMul))
	.background_(Color.red /*~panCompColor*/ /*Color./*clear*/grey(0.3, alpha: 0.8)*/)
	.hiliteColor_(Color.yellow(alpha: 1))
	.selectedStringColor_(Color.black)
	.stringColor_(Color.white)
	.font_(Font("Verdana",(11*~fontSizeMul).asInteger, bold: true))
	.items_(["T Virtu", "T VDis", "T Ambi"])
	.action_({ |menu| ~trajSpatType[~tracksValue][~seqsValue] = menu.value })
	.valueAction_(1);

	/*StaticText(~spatTypeComp, Rect(2, 49, 56, 31)).background_(~panCompColor).stringColor_(Color.white).align_(\center).font_(Font("Verdana",10/*, bold: true*/))
	.string = "Algo /\nMovement";*/

	/*~spaRangePresetItemsListView = ListView(~spatTypeComp, Rect(2, 94, 114, 114))
	.background_(Color.red/*~panCompColor*/ /*Color./*clear*/grey(0.3, alpha: 0.8)*/)
	.hiliteColor_(Color.yellow(alpha: 1))
	.selectedStringColor_(Color.black)
	.stringColor_(Color.white)
	.font_(Font("Verdana",11, bold: true))
	.items_(~spaRangePresetItemsLV)
	.enterKeyAction_({ |menu| ~spaRangePresetView.valueAction_(menu.value) }) // Pas de AllowsReselection_(true) // A implémenter XXXXXXXXX
	.action_({ |menu| ~spaRangePresetView.valueAction_(menu.value) })
	.value_(~spaRangePresetItems.size - 1);*/

	// Remplacement de la ListView par de simples boutons afin de pouvoir permettre la resélection d'un élément déjà sélectionné à tout moment
	// de plus, le fait d'avoir un élément sélectionné est trompeur car c'est la sélection dans le RangeSlider de la spatialisation qui importe XXX

	~spaRangePresetItemsLV1Buttons = 0 ! ~spaRangePresetItemsLV1.size;
	~spaRangePresetItemsLV2Buttons = 0 ! ~spaRangePresetItemsLV2.size;
	~spaRangePresetItemsLV3Buttons = 0 ! ~spaRangePresetItemsLV3.size;
	~spaRangePresetItemsLV4Buttons = 0 ! ~spaRangePresetItemsLV4.size;

	~spaRangePresetItemsLV1.do { |val, i|
		~spaRangePresetItemsLV1Buttons[i] = RoundButton(~spatTypeComp, Rect(2*~xSizeMul, (95+(14*i))*~ySizeMul, 55*~xSizeMul, 14*~ySizeMul))
		.states_([[~spaRangePresetItemsLV1[i].asString, Color.white, Color.blue]])
		.font_(Font("Verdana",9*~fontSizeMul, true))
		.action_({ ~spaRangePresetView.valueAction_(~spaRangePresetItemsLValues1[i]); ~spaRangePresetItemsLFunctions1[i].();
			if (~harTrig[~tracksValue][~seqsValue] == 1, {/*~spaHarRangePresetView.valueAction_(~spaRangePresetItemsLValues1[i]);*/ ~spaHarRandView.valueAction_(1)} );
		})
	};

	~spaRangePresetItemsLV2.do { |val, i|
		~spaRangePresetItemsLV2Buttons[i] = RoundButton(~spatTypeComp, Rect(2*~xSizeMul, (137+(14*i))*~ySizeMul, 55*~xSizeMul, 14*~ySizeMul))
		.states_([[~spaRangePresetItemsLV2[i].asString, Color.white, ~panCompColor]])
		.font_(Font("Verdana",9*~fontSizeMul, true))
		.action_({ ~spaRangePresetView.valueAction_(~spaRangePresetItemsLValues2[i]); ~spaRandView.valueAction_(1); ~spaRangePresetItemsLFunctions2[i].();
			if (~harTrig[~tracksValue][~seqsValue] == 1, {/*~spaHarRangePresetView.valueAction_(~spaRangePresetItemsLValues2[i]);*/ ~spaHarRandView.valueAction_(1)} );
		})
	};

	~spaRangePresetItemsLV3.do { |val, i|
		~spaRangePresetItemsLV3Buttons[i] = RoundButton(~spatTypeComp, Rect(58*~xSizeMul, (95+(18*i))*~ySizeMul, 55*~xSizeMul, 18*~ySizeMul))
		.states_([[~spaRangePresetItemsLV3[i].asString, Color.white, Color.magenta /*~panCompColor*/]])
		.font_(Font("Verdana",9*~fontSizeMul, true))
		.action_({ ~spaRangePresetView.valueAction_(~spaRangePresetItemsLValues3[i]); ~spaRandView.valueAction_(1);
			if (~harTrig[~tracksValue][~seqsValue] == 1, {/*~spaHarRangePresetView.valueAction_(~spaRangePresetItemsLValues3[i]);*/ ~spaHarRandView.valueAction_(1)} );
		})
	};

	~spaRangePresetItemsLV4.do { |val, i|
		~spaRangePresetItemsLV4Buttons[i] = RoundButton(~spatTypeComp, Rect(58*~xSizeMul, (131+(18*i))*~ySizeMul, 55*~xSizeMul, 18*~ySizeMul))
		.states_([[~spaRangePresetItemsLV4[i].asString, Color.white, Color.blue]])
		.font_(Font("Verdana",9*~fontSizeMul, true))
		.action_({ ~spaRangePresetView.valueAction_(~spaRangePresetItemsLValues4[i]); ~spaRandView.valueAction_(1); ~spaRangePresetItemsLFunctions4[i].();
			if (~harTrig[~tracksValue][~seqsValue] == 1, {/*~spaHarRangePresetView.valueAction_(~spaRangePresetItemsLValues4[i]);*/ ~spaHarRandView.valueAction_(1)} );
		})
	};



	~spatParametersComp = CompositeView(~tabSpa2Comp, Rect(120*~xSizeMul, 4*~ySizeMul, 258*~xSizeMul, 210*~ySizeMul)).background_(~popUpMenuBackgroundColor);
	~spatParametersCompFlowLayout = FlowLayout(~spatParametersComp.bounds, (2*~xSizeMul)@(2*~ySizeMul), (1*~xSizeMul)@(1*~ySizeMul));
	~spatParametersComp.decorator_(~spatParametersCompFlowLayout);

	/*StaticText(~spatParametersComp, Rect(80, 2, 170, 18)).background_(~panCompColor).stringColor_(Color.white).align_(\center).font_(Font("Verdana",10/*, bold: true*/))
	.string = " Virtual Pan & Trajectories";*/

	~dbRollOffSpec = [-24, 0, \lin, 1, -6 ].asSpec;
	~dbRollOff = ~dbRollOffSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~dbRollOffView = EZSlider.new2(~spatParametersComp, (171*~xSizeMul)@(17*~ySizeMul), "dbRollOff", ~dbRollOffSpec,
		{ |ez| ~dbRollOff[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~dbRollOffSpec.default, numberWidth:30*~xSizeMul, labelWidth:55*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~virtualMSpatTypeRandView = RoundButton(~spatParametersComp, Rect(2*~xSizeMul, 2*~ySizeMul, 38*~xSizeMul, 16*~ySizeMul))
	.states_([["Rand", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul/*, bold: true*/))
	.action_({ |a|
		~dbRollOffView.valueAction_(~dbRollOffSpec.map(1.0.rand));
		~speakRadView.valueAction_(~speakRadSpec.map(1.0.rand));
		~orientationView.valueAction_(~orientationSpec.map(1.0.rand));
		~vmPointScaleView.valueAction_(~vmPointScaleSpec.map(1.0.rand));
		~vbPointScaleView.valueAction_(~vbPointScaleSpec.map(1.0.rand));
		~ambPointScaleView.valueAction_(~ambPointScaleSpec.map(1.0.rand));
		~trajSpatLoopView.valueAction_(2.rand);
		~trajSpatRateView.valueAction_(~trajSpatRateSpec.map(1.0.rand));
		~trajSpatTimeTypeView.valueAction_(3.rand);
		~trajSpatTypeView.valueAction_(3.rand);
		~stereoSpatTypeView.valueAction_(3.rand);
		~circSpatTypeView.valueAction_(2.rand);
		~sdSpatTypeView.valueAction_(4.rand);
		~spaLagTimeView.valueAction_(~spaLagTimeSpec.map(1.0.rand));
		~spaLagCurveView.valueAction_(~spaLagCurveSpec.map(1.0.rand));
		~sdFreqRangeView.valueAction_(~sdFreqRangeSpec.map([0.5.rand, 0.5.rand + 0.5]));
		~sdDbRangeView.valueAction_(~sdDbRangeSpec.map([0.5.rand, 0.5.rand + 0.5]));
		~spec2spaCurveView.valueAction_(~spec2spaCurveSpec.map(1.0.rand));
		~vbapSpreadView.valueAction_(~vbapSpreadSpec.map(1.0.rand));
		~circSpreadView.valueAction_(~circSpreadSpec.map(1.0.rand));
		~circSpeedRangeView.valueAction_(~circSpeedRangeSpec.map([0.5.rand, 0.5.rand + 0.5]));
		~vbapX2OffView.valueAction_(~vbapX2OffSpec.map(1.0.rand));
	});

	~virtualMSpatTypeDefView = RoundButton(~spatParametersComp, Rect(2*~xSizeMul, 2*~ySizeMul, 38*~xSizeMul, 16*~ySizeMul))
	.states_([["Def", Color.white, Color.blue]])
	.font_(Font("Verdana",9*~fontSizeMul/*, bold: true*/))
	.action_({ |a|
		~dbRollOffView.valueAction_(~dbRollOffSpec.default);
		~speakRadView.valueAction_(~speakRadSpec.default);
		~orientationView.valueAction_(~orientationSpec.default);
		~vmPointScaleView.valueAction_(~vmPointScaleSpec.default);
		~vbPointScaleView.valueAction_(~vbPointScaleSpec.default);
		~ambPointScaleView.valueAction_(~ambPointScaleSpec.default);
		~trajSpatLoopView.valueAction_(0);
		~trajSpatRateView.valueAction_(~trajSpatRateSpec.default);
		~trajSpatTimeTypeView.valueAction_(0);
		~trajSpatTypeView.valueAction_(1);
		~stereoSpatTypeView.valueAction_(0);
		~circSpatTypeView.valueAction_(0);
		~sdSpatTypeView.valueAction_(2);
		~spaLagTimeView.valueAction_(~spaLagTimeSpec.default);
		~spaLagCurveView.valueAction_(~spaLagCurveSpec.default);
		~sdFreqRangeView.valueAction_([~sdFreqRangeSpec.default, 6000]);
		~sdDbRangeView.valueAction_([~sdDbRangeSpec.default, 50]);
		~spec2spaCurveView.valueAction_(~spec2spaCurveSpec.default);
		~vbapSpreadView.valueAction_(~vbapSpreadSpec.default);
		~circSpreadView.valueAction_(~circSpreadSpec.default);
		~circSpeedRangeView.valueAction_([~circSpeedRangeSpec.default, 66]);
		~vbapX2OffView.valueAction_(~vbapX2OffSpec.default);
	});

	~speakRadSpec = [0, 1, \lin, 0, 0.3].asSpec;
	~speakRad = ~speakRadSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~speakRadView = EZSlider.new2(~spatParametersComp, (125*~xSizeMul)@(17*~ySizeMul), "spRad", ~speakRadSpec,
		{ |ez| ~speakRad[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~speakRadSpec.default, numberWidth:30*~xSizeMul, labelWidth:35*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~orientationSpec = [0, ~numChannels, \lin, 0.5, 0.5].asSpec;
	~orientation = ~orientationSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~orientationView = EZSlider.new2(~spatParametersComp, (125*~xSizeMul)@(17*~ySizeMul), "orient", ~orientationSpec,
		{ |ez| ~orientation[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~orientationSpec.default, numberWidth:30*~xSizeMul, labelWidth:35*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	/*~trajSpatTypeComp = CompositeView(~tabSpa2Comp, Rect(120, 88, 258, 126)).background_(~popUpMenuBackgroundColor);
	~trajSpatTypeComp.decorator_(FlowLayout(~trajSpatTypeComp.bounds, 2@2, 1@1));*/

	/*StaticText(~trajSpatTypeComp, Rect(80, 2, 170, 18)).background_(~panCompColor).stringColor_(Color.white).align_(\center).font_(Font("Verdana",10/*, bold: true*/))
	.string = " Traj 2D Panning (Amb & Vir)";*/

	/*~trajSpatTypeRandView = RoundButton(~trajSpatTypeComp, Rect(2, 2, 40, 16))
	.states_([["Rand", Color.white, Color.red]])
	.font_(Font("Verdana",9/*, bold: true*/))
	.action_({ |a|
	~pointScaleView.valueAction_(~pointScaleSpec.map(1.0.rand));
	~ambPointScaleView.valueAction_(~ambPointScaleSpec.map(1.0.rand));
	~trajSpatLoopView.valueAction_(2.rand);
	~trajSpatRateView.valueAction_(~trajSpatRateSpec.map(1.0.rand));
	~trajSpatTimeTypeView.valueAction_(3.rand);
	~trajSpatTypeView.valueAction_(2.rand);
	~spaLagTimeView.valueAction_(~spaLagTimeSpec.map(1.0.rand));
	});

	~trajSpatTypeDefView = RoundButton(~trajSpatTypeComp, Rect(2, 2, 40, 16))
	.states_([["Def", Color.white, Color.blue]])
	.font_(Font("Verdana",9/*, bold: true*/))
	.action_({ |a|
	~pointScaleView.valueAction_(~pointScaleSpec.default);
	~ambPointScaleView.valueAction_(~ambPointScaleSpec.default);
	~trajSpatLoopView.valueAction_(0);
	~trajSpatRateView.valueAction_(~trajSpatRateSpec.default);
	~trajSpatTimeTypeView.valueAction_(1);
	~trajSpatTypeView.valueAction_(0);
	~spaLagTimeView.valueAction_(~spaLagTimeSpec.default);
	});*/

	~vmPointScaleSpec = [0.1, 200, \exp, 0.1, 1].asSpec;
	~vmPointScale = ~vmPointScaleSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~vmPointScaleView = EZSlider.new2(~spatParametersComp, (125*~xSizeMul)@(17*~ySizeMul), "VM Px", ~vmPointScaleSpec,
		{ |ez| ~vmPointScale[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~vmPointScaleSpec.default, numberWidth:30*~xSizeMul, labelWidth:35*~xSizeMul, layout:\horz)
	.setColors(Color.blue /*~sliderBackgroundColor*/,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~ambPointScaleSpec = ControlSpec(0.1, 2, \lin, 0.01, 0.5);
	~ambPointScale = ~ambPointScaleSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~ambPointScaleView = EZSlider.new2(~spatParametersComp, (125*~xSizeMul)@(17*~ySizeMul), "Am Px", ~ambPointScaleSpec,
		{ |ez| ~ambPointScale[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~ambPointScaleSpec.default, numberWidth:30*~xSizeMul, labelWidth:35*~xSizeMul, layout:\horz)
	.setColors(Color.blue /*~sliderBackgroundColor*/,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~vbPointScaleSpec = [0.1, 200, \exp, 0.1, 1].asSpec;
	~vbPointScale = ~vbPointScaleSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~vbPointScaleView = EZSlider.new2(~spatParametersComp, (125*~xSizeMul)@(17*~ySizeMul), "VB Px", ~vbPointScaleSpec,
		{ |ez| ~vbPointScale[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~vbPointScaleSpec.default, numberWidth:30*~xSizeMul, labelWidth:35*~xSizeMul, layout:\horz)
	.setColors(Color.blue /*~sliderBackgroundColor*/,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~vbapSpreadSpec = ControlSpec(0, 100, 4, 0.01, 0.2);
	~vbapSpread = ~vbapSpreadSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~vbapSpreadView = EZSlider.new2(~spatParametersComp, (125*~xSizeMul)@(17*~ySizeMul), "VB W", ~vbapSpreadSpec,
		{ |ez| ~vbapSpread[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~vbapSpreadSpec.default, numberWidth:30*~xSizeMul, labelWidth:35*~xSizeMul, layout:\horz)
	.setColors(Color.blue/*~sliderBackgroundColor*/,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~vbapX2OffSpec = ControlSpec(0, 360, \lin, 1, 180);
	~vbapX2Off = ~vbapX2OffSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~vbapX2OffView = EZSlider.new2(~spatParametersComp, (125*~xSizeMul)@(17*~ySizeMul), "VB O2", ~vbapX2OffSpec,
		{ |ez| ~vbapX2Off[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~vbapX2OffSpec.default, numberWidth:30*~xSizeMul, labelWidth:35*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~circSpreadSpec = ControlSpec(0, ~numChannels, 1, 0.1, 2);
	~circSpread = ~circSpreadSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~circSpreadView = EZSlider.new2(~spatParametersComp, (125*~xSizeMul)@(17*~ySizeMul), "Cir W", ~circSpreadSpec,
		{ |ez| ~circSpread[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~circSpreadSpec.default, numberWidth:30*~xSizeMul, labelWidth:35*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~circSpeedRangeSpec = ControlSpec(0.2, 100, 4 /*\exp*/, 0.1, 0.2);
	~circSpeedRangeMin = ~circSpeedRangeSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~circSpeedRangeMax = 66 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~circSpeedRangeView = EZRanger.new(~spatParametersComp, (141*~xSizeMul)@(17*~ySizeMul), "C Sp", ~circSpeedRangeSpec /*\freq*/,
		{ |ez| ~circSpeedRangeMin[~tracksValue][~seqsValue] = ez.value[0]; ~circSpeedRangeMax[~tracksValue][~seqsValue] = ez.value[1]; }, unitWidth:0, initVal:[~circSpeedRangeSpec.default, 66], numberWidth:30*~xSizeMul, labelWidth:25*~xSizeMul, labelHeight:17, layout:\horz /*\line2*/)
	.setColors(~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/, knobColor: Color.red)
	.font_(Font("Verdana",10*~fontSizeMul));

	~spec2spaCurveSpec = ControlSpec(-8, 8, \lin, 0.1, 7);
	~spec2spaCurve = ~spec2spaCurveSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~spec2spaCurveView = EZSlider.new2(~spatParametersComp, (110*~xSizeMul)@(17*~ySizeMul), "Sp2 C", ~spec2spaCurveSpec,
		{ |ez| ~spec2spaCurve[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~spec2spaCurveSpec.default, numberWidth:30*~xSizeMul, labelWidth:35*~xSizeMul, /*labelHeight:18,*/ layout:\horz /*\line2*/)
	.setColors(~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~trajSpatTimeType = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~trajSpatTimeTypeView = ListView(~spatParametersComp, Rect(2*~xSizeMul, 2*~ySizeMul, 43*~xSizeMul, 45*~ySizeMul))
	.background_(~panCompColor /*Color./*clear*/grey(0.3, alpha: 0.8)*/)
	.hiliteColor_(Color.yellow(alpha: 1))
	.selectedStringColor_(Color.black)
	.stringColor_(Color.white)
	.font_(Font("Verdana",(11*~fontSizeMul).asInteger, bold: true))
	.items_(["Adap", "Traj", "Slid"])
	.action_({ |menu| ~trajSpatTimeType[~tracksValue][~seqsValue] = menu.value })
	.valueAction_(0);

	~trajSpatLoop = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~trajSpatLoopView = RoundButton(~spatParametersComp, Rect(2*~xSizeMul, 2*~ySizeMul, 42*~xSizeMul, 16*~ySizeMul))
	.states_([["\NoLoop", Color.white, Color.red], ["\Loop", Color.black, Color.green]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({|i| ~trajSpatLoop[~tracksValue][~seqsValue] = i.value });

	~trajSpatRateSpec = ControlSpec(0.1, 50, \exp, 0.01, 1);
	~trajSpatRate = ~trajSpatRateSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~trajSpatRateView = EZSlider.new2(~spatParametersComp, (164*~xSizeMul)@(17*~ySizeMul), "TrajRate", ~trajSpatRateSpec,
		{ |ez| ~trajSpatRate[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~trajSpatRateSpec.default, numberWidth:30*~xSizeMul, labelWidth:50*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	// ~spatParametersCompFlowLayout.shift(200, 0); // ne marche pas ???
	// ~spatParametersCompFlowLayout.left_(58).top_(147);
	// ~spatParametersCompFlowLayout.left_(58).top_(165);
	~spatParametersCompFlowLayout.left_(48*~xSizeMul).top_(137*~ySizeMul);

	// juste pour le lissage des spatialisations liées à l'analyse des paramètres spectraux ou d'intensité
	// essayer avec des valeurs 0.02 / 0.2 / 0.5 / 1 / 2 / 5 ...
	~spaLagTimeSpec = ControlSpec(0.05, 5, 2 /*\exp*/, 0.01, 0.1);
	~spaLagTime = ~spaLagTimeSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~spaLagTimeView = EZSlider.new2(~spatParametersComp, (207*~xSizeMul)@(17*~ySizeMul), "SD Lag", ~spaLagTimeSpec,
		{ |ez| ~spaLagTime[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~spaLagTimeSpec.default, numberWidth:40*~xSizeMul, labelWidth:50*~xSizeMul, /*labelHeight:18,*/ layout:\horz /*\line2*/)
	.setColors(Color.blue/*~sliderBackgroundColor*/,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~spatParametersCompFlowLayout.left_(48*~xSizeMul).top_(155*~ySizeMul);

	~spaLagCurveSpec = ControlSpec(-8, 8, \lin, 0.1, 0);
	~spaLagCurve = ~spaLagCurveSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~spaLagCurveView = EZSlider.new2(~spatParametersComp, (207*~xSizeMul)@(17*~ySizeMul), "SD F Cur", ~spaLagCurveSpec,
		{ |ez| ~spaLagCurve[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~spaLagCurveSpec.default, numberWidth:40*~xSizeMul, labelWidth:50*~xSizeMul, /*labelHeight:18,*/ layout:\horz /*\line2*/)
	.setColors(Color.blue/*~sliderBackgroundColor*/,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~spatParametersCompFlowLayout.left_(2*~xSizeMul).top_(174*~ySizeMul);
	// \freq.asSpec
	~sdFreqRangeSpec = ControlSpec(20, 8000, 2 /*\exp*/, 1, 20);
	~sdFreqRangeMin = ~sdFreqRangeSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~sdFreqRangeMax = 6000 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~sdFreqRangeView = EZRanger.new(~spatParametersComp, (253*~xSizeMul)@(17*~ySizeMul), "SD Freq", ~sdFreqRangeSpec /*\freq*/,
		{ |ez| ~sdFreqRangeMin[~tracksValue][~seqsValue] = ez.value[0]; ~sdFreqRangeMax[~tracksValue][~seqsValue] = ez.value[1]; }, unitWidth:0, initVal:[~sdFreqRangeSpec.default, 6000], numberWidth:40*~xSizeMul, labelWidth:45*~xSizeMul, labelHeight:17, layout:\horz /*\line2*/)
	.setColors(Color.blue/*~sliderBackgroundColor*/,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/, knobColor: Color.red)
	.font_(Font("Verdana",10*~fontSizeMul));

	~spatParametersCompFlowLayout.left_(2*~xSizeMul).top_(192*~ySizeMul);
	~sdDbRangeSpec = ControlSpec(0, 70, \lin /*\exp*/, 0.1, 0);
	~sdDbRangeMin = ~sdDbRangeSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~sdDbRangeMax = 50 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~sdDbRangeView = EZRanger.new(~spatParametersComp, (253*~xSizeMul)@(17*~ySizeMul), "SD dB", ~sdDbRangeSpec /*\freq*/,
		{ |ez| ~sdDbRangeMin[~tracksValue][~seqsValue] = ez.value[0]; ~sdDbRangeMax[~tracksValue][~seqsValue] = ez.value[1]; }, unitWidth:0, initVal:[~sdDbRangeSpec.default, 50], numberWidth:40*~xSizeMul, labelWidth:45*~xSizeMul, labelHeight:17, layout:\horz /*\line2*/)
	.setColors(Color.blue/*~sliderBackgroundColor*/,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/, knobColor: Color.red)
	.font_(Font("Verdana",10*~fontSizeMul));

}.value;





{
	// GUI LEGATO

	~posLeg = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~legType = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour changement en leg ou sus
	~legLoop = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour mise en mode Loop et fin du Leg bloqué à 30s

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\legRoundViewFunc, 0, 2, 1, 0, 0.01,
		\legComp, \legDisplay, 75, "~legView.valueAction_(~legSpec[", "].unmap(~legMul[",
		\legView, \leg, \legSpec, true, false, 1, ~compColor1, ~multiCompColor1, /*~compColor2, ~multiCompColor2,*/ Color.white,
		\legSeqView, \legSeqStart, \legSeqStop, \seqDurLeg, \legSeqSpec, \legSeqSpec2, \legSeqVSpec, \legSeqVSpec2,
		\legIndexView, \legIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\legRangeView, \legMin, \legMax, \legRangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \legRangePresetViewView, \legRangePresetView, ["0->0.5", "0->1", "0->2", "0->3", "0->4", "0->5", "0->10", "0->20", "0->50"], 2, "->", 50,
		\legMulView, \legMul, \legMulSpec, ~sliderHilightColor, \legMulPresetViewView, \legMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\legRoundViewView, \legRoundView, ~roundViewPos5, \legRound, \legRoundValue, ["@ 0.01 EXP", "@ 0.1 EXP", "@ 0.125 EXP", "@ 0.2 EXP", "@ 0.25 EXP", "@ 0.5 EXP", "@ 1 EXP", "@ 0.01 LIN", "@ 0.1 LIN", "@ 0.125 LIN", "@ 0.2 LIN", "@ 0.25 LIN", "@ 0.5 LIN", "@ 1 LIN", "@ 2 LIN"], 0,
		\legRandView, \legato,
		\legSeqAllView, \legRangeMode, \legSeqMode,
		\legCopyAView, \legCopyA, \legPasteAView, \legPasteA, \legPasteMView, \legPasteM, \legDefaultView, \legDefault,
		\legDirView, \legDir, \legPatView, \legPat, \legPatSelViewView, \legPatSelView, \legPatSel, \legBlock,
		\legShowView, ~nameModPos, \center, Color.yellow, "DUR",
		\legReadView, Color.grey(0.6), \legPosView
	);

	~legTypeView = RoundButton(~legComp, Rect(337*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
	.states_([["\LEG", Color.blue, Color.white], ["\SUS", Color.red, Color.white]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| ~legType[~tracksValue][~seqsValue] = i.value })
	.valueAction_(0);

	~legLoopView = RoundButton(~legComp, Rect(367*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
	.states_([["\Loop", Color.white, Color.red], ["\Loop", Color.black, Color.green]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| ~legLoop[~tracksValue][~seqSeq[~tracksValue]] = i.value;

		if (~legLoop[~tracksValue][~seqSeq[~tracksValue]] == 0, { "Loop Deactivated".postln; }, { "Loop Activated".postln; });

		if (~lemurConnected1 == 1, {
			if (~legLoop[~tracksValue][~seqSeq[~tracksValue]] == 0, { // ~currentSeq = ~seqSeq[tr] dans le pattern  - non décalage
				~lemurAdress1.sendMsg( *[ ["/ParC/Loop"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
			},{
				~lemurAdress1.sendMsg( *[ ["/ParC/Loop"] ++ ["@color"] ++ [~greenLemurColor, ~greenLemurColor]  ].flatten(1) );
			});
		});

	})
	.valueAction_(0);





	// GUI ENVELOPPE

	~posEnv = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	// ~segs = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // segs seulement pour env - à suppimer ou à réutiliser en topView ???
	// ~endPhase = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // endPhase seulement pour env - à suppimer ou à réutiliser en topView ???
	~envType  = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour min

	~envRangePresetViewFunc = [ // valable que si toutes les enveloppes des synthés sont chargés
		{ |tr, seq| ~envRangeView.valueAction_(~envRangeSpec[tr][seq].unmap([0, 3])) },
		{ |tr, seq| ~envRangeView.valueAction_(~envRangeSpec[tr][seq].unmap([4, 7])) },
		{ |tr, seq| ~envRangeView.valueAction_(~envRangeSpec[tr][seq].unmap([8, 13])) },
		{ |tr, seq| ~envRangeView.valueAction_(~envRangeSpec[tr][seq].unmap([14, 15])) },
		{ |tr, seq| ~envRangeView.valueAction_(~envRangeSpec[tr][seq].unmap([0, 7])) },
		{ |tr, seq| ~envRangeView.valueAction_(~envRangeSpec[tr][seq].unmap([0, 13])) },
		{ |tr, seq| ~envRangeView.valueAction_(~envRangeSpec[tr][seq].unmap([0, ~allEnvsGUI.size-1])) }
	];

	~envViewItems = (~allEnvsGUI.size.collect {|i| i+~allEnvsGUI[i]});

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		"NoRoundViewFunc", 0, (~allEnvsGUI.size -1), 0, "NoRoundValueDefault", "NoRoundDefault",
		\envComp, \envDisplay, 75, "~envView.valueAction_(~envSpec[", "].unmap(~envMul[",
		\envView, \env, \envSpec, false, true, "NoMultiViewValueThumbSize", ~compColor1, ~multiCompColor1, Color.white,
		\envSeqView, \envSeqStart, \envSeqStop, \seqDurEnv, \envSeqSpec, \envSeqSpec2, \envSeqVSpec, \envSeqVSpec2,
		\envIndexView, \envIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\envRangeView, \envMin, \envMax, \envRangeSpec, (1/~allEnvsGUI.size), ~sliderHilightNoColor, \envRangePresetViewView, \envRangePresetView, ["Line", "Perc", "Spec", "Exp", "LP", "LPS", "ALL"], 6, "->", (~allEnvsGUI.size-1),
		\envMulView, \envMul, \envMulSpec, ~sliderHilightNoColor, \envMulPresetViewView, \envMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\envRoundViewView, \envRoundView, ~roundViewPos5, \envRound, \envRoundValue, ~envViewItems, 0,
		\envRandView, \enveloppe,
		\envSeqAllView, \envRangeMode, \envSeqMode,
		\envCopyAView, \envCopyA, \envPasteAView, \envPasteA, \envPasteMView, \envPasteM, \envDefaultView, \envDefault,
		\envDirView, \envDir, \envPatView, \envPat, \envPatSelViewView, \envPatSelView, \envPatSel, \envBlock,
		\envShowView, ~nameModPos, \center, Color.yellow, "ENV",
		\envReadView, Color.grey(0.6), \envPosView
	);

	~envParTabView = RoundButton(~envComp, ~miniSlider1Pos5 /*Rect(338, 138+18, 60, 16)*/)
	.states_([["\Buf Par", Color.white, Color.blue], ["\Env Par", Color.white, Color.blue], ["\Spa Par", Color.white, Color.blue], ["\MI Rat Par", Color.white, Color.blue], ["\MI Cen Par", Color.white, Color.blue], ["\MI Del Par", Color.white, Color.blue], ["\MI Spa Par", Color.white, Color.blue], ["\MI Amp Par", Color.white, Color.blue]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({|i| ~envParTab = i.value;
		// if (~envParTab == 0, {~spa2CompTabbedView.focus(~envParTab+1)}, {~spa2CompTabbedView.focus(~envParTab+1)} )
		case
		{~envParTab == 0}
		{ ~tabHarmComp.focus(0); ~spa2CompTabbedView.focus(0) }
		{~envParTab == 1}
		{ ~tabHarmComp.focus(0); ~spa2CompTabbedView.focus(1) }
		{~envParTab == 2}
		{ ~tabHarmComp.focus(0); ~spa2CompTabbedView.focus(2) }
		{~envParTab == 3}
		{ ~tabHarmComp.focus(0); ~spa2CompTabbedView.focus(3) }
		{~envParTab == 4}
		{ ~tabHarmComp.focus(1); ~spa2CompTabbedView.focus(3) }
		{~envParTab == 5}
		{ ~tabHarmComp.focus(2); ~spa2CompTabbedView.focus(3) }
		{~envParTab == 6}
		{ ~tabHarmComp.focus(3); ~spa2CompTabbedView.focus(3) }
		{~envParTab == 7}
		{ ~tabHarmComp.focus(4); ~spa2CompTabbedView.focus(3) }
	});

	/*
	~segsSpec = ControlSpec(0, 4000, \lin, 1);
	~segsView = SmoothSlider(~envComp, Rect(338, 170+18, 60, 14))
	.action_({ |view| ~segs[~tracksValue][~seqsValue] = ~segsSpec.map(view.value);
	view.string = "Seg : %".format(~segs[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~segsSpec.unmap(10))
	.doAction;

	~endPhaseSpec = ControlSpec(0, 4000, \lin, 0.1);
	~endPhaseView = SmoothSlider(~envComp, Rect(338, 184+18, 60, 14))
	.action_({ |view| ~endPhase[~tracksValue][~seqsValue] = ~endPhaseSpec.map(view.value);
	view.string = "End : %".format(~endPhase[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~endPhaseSpec.unmap(10))
	.doAction;
	*/

	~envTypeView = RoundButton(~envComp, Rect(338*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul))
	.states_([["\MIN", Color.black, Color.green], ["\N M", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| ~envType[~tracksValue][~seqsValue] = i.value })
	.valueAction_(0);





	// GUI ENVELOPPE 2

	~tabEnvComp.decorator_(FlowLayout(~tabEnvComp.bounds, (3*~xSizeMul)@(5*~ySizeMul), (3*~xSizeMul)@(1*~ySizeMul)));
	~envSliderNames = ["Line ", "Perc " /*"Line1", "Line2", "Perc1", "Perc2"*/];

	~envNum = 2;

	~atkView = 0 ! ~envNum;
	~relView = 0 ! ~envNum;
	~atkCurveView = 0 ! ~envNum;
	~relCurveView = 0 ! ~envNum;

	~atkSpec = 0 ! ~envNum;
	~atkCurveSpec = 0 ! ~envNum;
	~relSpec = 0 ! ~envNum;
	~relCurveSpec = 0 ! ~envNum;

	~atkDefault = [0.001, 0.01 /*, 0.001, 0.01*/];
	~atkCurveSpecDefault = [0, -4 /*, -4, -8*/];
	~relDefault = [0.01, 0.1 /*, 0.005, 0.1*/];
	~relCurveSpecDefault = [0, -4 /*, -4, -8*/];

	~envNum.do { |i|
		~atkSpec[i] = ControlSpec(0.001, 0.5, 2, 0.001, ~atkDefault[i]);
		~atkCurveSpec[i] = ControlSpec(-8, 8, \lin, 1, ~atkCurveSpecDefault[i]);
		~relSpec[i] = ControlSpec(0.001, 0.5, 2, 0.001, ~relDefault[i]);
		~relCurveSpec[i] = ControlSpec(-8, 8, \lin, 1, ~relCurveSpecDefault[i]);
	};

	~atk = {~atkDefault ! ~nbOfSeqs} ! ~nbOfTracksX2;
	~rel = {~relDefault ! ~nbOfSeqs} ! ~nbOfTracksX2;
	~atkCurve = {~atkCurveSpecDefault ! ~nbOfSeqs} ! ~nbOfTracksX2;
	~relCurve = {~relCurveSpecDefault ! ~nbOfSeqs} ! ~nbOfTracksX2;

	~envNum.do { |i|

		~atkView[i] = EZSlider.new2(~tabEnvComp, (185*~xSizeMul)@(18*~ySizeMul), "Atk"+(i+1).asString+"", ~atkSpec[i],
			{ |ez| ~atk[~tracksValue][~seqsValue][i] = ez.value }, unitWidth:0, initVal:~atkSpec[i].default, numberWidth:40*~xSizeMul, labelWidth:45*~xSizeMul, layout:\horz, initAction:true)
		.setColors(/*Color.grey*/ ~sliderBackgroundColor, Color.white /*, numBackground:~sliderBackgroundColor, numNormalColor:Color.white*/)
		.font_(Font("Verdana",10*~fontSizeMul));

		~relView[i] = EZSlider.new2(~tabEnvComp, (185*~xSizeMul)@(18*~ySizeMul), "Rel"+(i+1).asString+"", ~relSpec[i],
			{ |ez| ~rel[~tracksValue][~seqsValue][i] = ez.value }, unitWidth:0, initVal:~relSpec[i].default, numberWidth:40*~xSizeMul, labelWidth:45*~xSizeMul, layout:\horz, initAction:true)
		.setColors(/*Color.grey*/ ~sliderBackgroundColor, Color.white /*, numBackground:~sliderBackgroundColor, numNormalColor:Color.white*/)
		.font_(Font("Verdana",10*~fontSizeMul));

	};

	~envNum.do { |i|

		~atkCurveView[i] = EZSlider.new2(~tabEnvComp, (185*~xSizeMul)@(18*~ySizeMul), "Atk"+~envSliderNames[i], ~atkCurveSpec[i],
			{ |ez| ~atkCurve[~tracksValue][~seqsValue][i] = ez.value }, unitWidth:0, initVal:~atkCurveSpec[i].default, numberWidth:40*~xSizeMul, labelWidth:45*~xSizeMul, layout:\horz, initAction:true)
		.setColors(/*Color.grey*/ ~panCompColor, Color.white /*, numBackground:~sliderBackgroundColor, numNormalColor:Color.white*/)
		.font_(Font("Verdana",10*~fontSizeMul));

		~relCurveView[i] = EZSlider.new2(~tabEnvComp, (185*~xSizeMul)@(18*~ySizeMul), "Rel"+~envSliderNames[i], ~relCurveSpec[i],
			{ |ez| ~relCurve[~tracksValue][~seqsValue][i] = ez.value }, unitWidth:0, initVal:~relCurveSpec[i].default, numberWidth:40*~xSizeMul, labelWidth:45*~xSizeMul, layout:\horz, initAction:true)
		.setColors(/*Color.grey*/ ~panCompColor, Color.white /*, numBackground:~sliderBackgroundColor, numNormalColor:Color.white*/)
		.font_(Font("Verdana",10*~fontSizeMul));

	};

	~w1Spec = ControlSpec(0.001, 0.998, \lin, 0.001, 0.998);
	~w2Spec = ControlSpec(0.001, 0.998, \lin, 0.001, 0.4);

	~w1 = ~w1Spec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~w2 = ~w2Spec.default ! ~nbOfSeqs ! ~nbOfTracksX2;

	~w1View = EZSlider.new2(~tabEnvComp, (185*~xSizeMul)@(18*~ySizeMul), "W1 ", ~w1Spec,
		{ |ez| ~w1[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~w1Spec.default, numberWidth:40*~xSizeMul, labelWidth:45*~xSizeMul, layout:\horz, initAction:true)
	.setColors(/*Color.grey*/ ~sliderBackgroundColor, Color.white /*, numBackground:~sliderBackgroundColor, numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~w2View = EZSlider.new2(~tabEnvComp, (185*~xSizeMul)@(18*~ySizeMul), "W2 ", ~w2Spec,
		{ |ez| ~w2[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~w2Spec.default, numberWidth:40*~xSizeMul, labelWidth:45*~xSizeMul, layout:\horz, initAction:true)
	.setColors(/*Color.grey*/ ~sliderBackgroundColor, Color.white /*, numBackground:~sliderBackgroundColor, numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~envParTabView.valueAction_(2);

	~chaoticEnvStringView = 0 ! 3;
	3.do { |i|
		~chaoticEnvStringView[i] = TextView(~tabEnvComp, (375*~xSizeMul)@(30*~ySizeMul))
		//.autohidesScrollers_(0)
		.hasVerticalScroller_(false)
		.hasHorizontalScroller_(false)
		.enterInterpretsSelection_(1)
		.font_(Font("arial",10*~fontSizeMul))
		.string_("~chaoticEnv["++i++"] = " ++ ~chaoticEnvString[i] ++ "; ~bufEnvFunc.(~server1, 0, "++i++");");
	};

	~envPlotShowView = RoundButton(~tabEnvComp, /*~miniSlider1Pos5*/ (80*~xSizeMul)@(18*~ySizeMul) /*Rect(338, 138+18, 60, 16)*/)
	.states_([["\Show Envs", Color.white, Color.blue], ["\Close Envs", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({|i| ~envPlotShow = i.value;
		if (~envPlotShow == 1,
			{
				var atk1, atk2, rel1, rel2, atkCLine, atkCPerc, relCLine, relCPerc, w1, w2, holdT1, fadeT1, holdT2, fadeT2;
				~durplotenv = 1; ~durplotamp = 1;
				atk1 = ~atk[~tracksValue][~seqsValue][0];
				atk2 = ~atk[~tracksValue][~seqsValue][1];
				rel1 = ~rel[~tracksValue][~seqsValue][0];
				rel2 = ~rel[~tracksValue][~seqsValue][1];
				atkCLine = ~atkCurve[~tracksValue][~seqsValue][0];
				atkCPerc = ~atkCurve[~tracksValue][~seqsValue][1];
				relCLine = ~relCurve[~tracksValue][~seqsValue][0];
				relCPerc = ~relCurve[~tracksValue][~seqsValue][1];
				w1 = ~w1[~tracksValue][~seqsValue];
				w2 = ~w2[~tracksValue][~seqsValue];
				holdT1 = ~durplotenv * w1;
				fadeT1 = 1 - w1 * ~durplotenv * 0.5;
				holdT2 = ~durplotenv * w2;
				fadeT2 = 1 - w2 * ~durplotenv * 0.5;

				/*q = q ? ();
				q.makeSinc = { |q, num=1, size=400|
				dup({ |x| x = x.linlin(0, size-1, -pi, pi) * num; sin(x) / x }, size);
				};*/

				[
					/*
					Env.linen(atk1, ~durplotenv-atk1-rel1, rel1, ~durplotamp, [atkCLine, relCLine]), // ne prenait pas en compte relCurve
					Env.linen(atk2, ~durplotenv-atk2-rel2, rel2, ~durplotamp, [atkCLine, relCLine]),
					*/
					Env([0, 1, 1, 0], [atk1, ~durplotenv-atk1-rel1, rel1], [atkCLine, 0, relCLine]),
					Env([0, 1, 1, 0], [atk2, ~durplotenv-atk2-rel2, rel2], [atkCLine, 0, relCLine]),
					// Env.sine/*(durenv, amp)*/,
					Env([0, 1, 1, 0], [fadeT1, holdT1, fadeT1], \sin),
					Env([0, 1, 1, 0], [fadeT2, holdT2, fadeT2], \sin), // \welch
					Env.perc(atk1, 1-atk1, ~durplotamp, [atkCPerc, relCPerc]), // pas besoin de amp - par défaut 1 ???
					Env.perc(atk2, 1-atk2, ~durplotamp, [atkCPerc, relCPerc]),
					Env.perc(1-rel1, rel1, ~durplotamp, [atkCPerc, relCPerc]),
					Env.perc(1-rel2, rel2, ~durplotamp, [atkCPerc, relCPerc]),
					/*
					~chaoticEnv[0] = Env.saw2(segs: 700, amp: 1, startPhase: 0, endPhase: 1900pi, dur: 1).range(0, 1);
					~chaoticEnv[1] = Env.triangle2(segs: 700, amp: 1, startPhase: 0, endPhase: 401pi, dur: 1).range(0, 1);
					~chaoticEnv[2] = Env.square2(segs: 1000, amp: 1, startPhase: 0, endPhase: 401pi, dur: 1).range(0, 1);
					*/
					~chaoticEnv[0], // Bad Fadeout
					~chaoticEnv[1],
					~chaoticEnv[2],
					Env([~durplotamp, 0.001], [~durplotenv], \exp),
					Env([0.001, ~durplotamp], [~durplotenv], \exp)
				].plot(bounds:Rect(316*~xSizeMul,/*300*/-100*~ySizeMul,1200*~xSizeMul,1100*~ySizeMul))
			},{
				if ( Window.allWindows.notNil, { Window.allWindows[Window.allWindows.size-1].close; });
		})
	});





	// GUI SYN 2 pour les Buffers

	~tabBufComp.decorator_(FlowLayout(~tabEnvComp.bounds, (3*~xSizeMul)@(5*~ySizeMul), (3*~xSizeMul)@(1*~ySizeMul)));


	// Pour supprimer un sous-dossier de sons

	~delFolderOfSounds = {
		var bufFolderVal = ~bufFolderView.value;
		// Pour libérer les buffers du dossier
		~soundm[~arrayOfFolderNames[bufFolderVal].asSymbol].deepCollect(3, {|item| item.free});

		// Pour deleter les sons et le chemin des fichiers sons dans les Identity Dictionary
		~soundsFolderDict.removeAt(~arrayOfFolderNames[bufFolderVal].asSymbol);
		~soundm.removeAt(~arrayOfFolderNames[bufFolderVal].asSymbol);

		// Pour deleter les sons dans les arrays
		~arrayOfFolderPaths.removeAt(bufFolderVal);
		~arrayOfFolderNames.removeAt(bufFolderVal);
		~arrayOfFolderNames2 = ~arrayOfFolderNames.collect{|item, i| i+"-"+item};

		// Pour refaire un classement - vraiment nécessaire de le refaire en entier ???
		// ~sortingClassicFunc[0].value;
		// Pour éviter de tout reclasser, permet de juste de reclasser les regroupemment (2 lettres & ALL)
		(
			~soundmAllSoundFiles = ~arrayOfFolderNames.collect { |item, i| ~soundm[~arrayOfFolderNames[i].asSymbol]}.flatten;
			if (~foldersStructure == 1, { ~foldersStructureFunction.() });
		);

		// Pour mettre à jour le pop up menu
		if (~foldersStructure == 1, {
			~bufFolderView.items_(~arrayOfFolderNames2 ++ ~kindOfFolders.collect{|item, i| (i+~arrayOfFolderNames2.size) +"-"+item} ++ ["ALL"]);
			~arrayOfFolderNamesALL = ~arrayOfFolderNames ++ ~kindOfFolders ++ ["ALL"];
		}, {
			~bufFolderView.items_(~arrayOfFolderNames2 ++ ["ALL"]);
			~arrayOfFolderNamesALL = ~arrayOfFolderNames ++ ["ALL"];
		});
		~bufFolderSize = ~arrayOfFolderNamesALL.size; ~bufFolderSize1 = ~bufFolderSize-1;

		~bufFolderView.valueAction_(bufFolderVal-1);

		// Voir aussi ~bufFolderM dans le pattern ???
	};
	// ~delFolderOfSounds.();


	// Pour ajouter un sous-dossier de sons - pas de tri de dossier et de reclassement XXXXXXXXX

	~addFolderOfSounds =
	{(
		Dialog.openPanel({ arg path; var pathn, folderName, folderNameSymbol;

			pathn = PathName(PathName(path).pathOnly);
			folderName = PathName(path).folderName;
			folderNameSymbol = folderName.asSymbol;

			// Pour ajouter les sons dans l'Identity Dictionary -> pas vraiment nécessaire
			~soundsFolderDict.put(folderNameSymbol, pathn);

			// Pour ajouter les sons dans les arrays
			~arrayOfFolderPaths.add(pathn);
			~arrayOfFolderNames = ~arrayOfFolderNames.add(folderName);
			~arrayOfFolderNames2 = ~arrayOfFolderNames.collect{|item, i| i+"-"+item};

			// Pour mettre à jour le pop up menu
			if (~foldersStructure == 1, {
				~bufFolderView.items_(~arrayOfFolderNames2 ++ ~kindOfFolders.collect{|item, i| (i+~arrayOfFolderNames2.size) +"-"+item} ++ ["ALL"]);
				~arrayOfFolderNamesALL = ~arrayOfFolderNames ++ ~kindOfFolders ++ ["ALL"];
			}, {
				~bufFolderView.items_(~arrayOfFolderNames2 ++ ["ALL"]);
				~arrayOfFolderNamesALL = ~arrayOfFolderNames ++ ["ALL"];
			});
			~bufFolderSize = ~arrayOfFolderNamesALL.size; ~bufFolderSize1 = ~bufFolderSize-1;

			// Pour loader les fichiers sons
			~addBufferFolder.(folderNameSymbol, pathn);

		},{
			"cancelled".postln;
		});
	)};

	// Pour refaire un classement - vraiment nécessaire de le refaire en entier ???
	// ~sortingClassicFunc[0].value;
	// Pour éviter de tout reclasser, permet de juste de reclasser les regroupemment (2 lettres & ALL)
	// mais à refaire le classement dans le dossier en question XXXXXXXXX
	/*
	(
	~soundmAllSoundFiles = ~arrayOfFolderNames.collect { |item, i| ~soundm[~arrayOfFolderNames[i].asSymbol]}.flatten;
	if (~foldersStructure == 1, { ~foldersStructureFunction.() });

	// Pour mettre à jour le pop up menu
	if (~foldersStructure == 1, {
	~bufFolderView.items_(~arrayOfFolderNames2 ++ ~kindOfFolders ++ 'ALL');
	}, {
	~bufFolderView.items_(~arrayOfFolderNames2 ++ 'ALL');
	});
	)
	*/


	~delFolderOfSoundsView = RoundButton(~tabBufComp, /*~miniSlider1Pos5*/ (60*~xSizeMul)@(20*~ySizeMul) /*Rect(338, 138+18, 60, 16)*/)
	.states_([["\Del Bufs", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul, bold: true))
	.action_({|i| ~delFolderOfSounds.() });

	~addFolderOfSoundsView = RoundButton(~tabBufComp, /*~miniSlider1Pos5*/ (60*~xSizeMul)@(20*~ySizeMul) /*Rect(338, 138+18, 60, 16)*/)
	.states_([["\Add Bufs", Color.black, Color.yellow]])
	.font_(Font("Verdana",9*~fontSizeMul, bold: true))
	.action_({|i| ~addFolderOfSounds.() });

	~folderOfSoundsSizeView = RoundButton(~tabBufComp, /*~miniSlider1Pos5*/ (60*~xSizeMul)@(20*~ySizeMul) /*Rect(338, 138+18, 60, 16)*/)
	.states_([["\Size Bufs", Color.white, Color.blue]])
	.font_(Font("Verdana",9*~fontSizeMul, bold: true))
	.action_({|i| /*~listingSoundFolders =*/ ("du -m -L "++ ~soundsFolder ++" | sort -nr").unixCmd/*GetStdOut*/ });

	~grainSizeSpec = [0.0001, 200, \exp, 0.0001, 60].asSpec;
	~grainSize = ~grainSizeSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~grainSizeView = EZSlider.new2(~tabBufComp, (370*~xSizeMul)@(22*~ySizeMul), "grain size", ~grainSizeSpec,
		{ |ez| ~grainSize[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~grainSizeSpec.default, numberWidth:60*~xSizeMul, labelWidth:70*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~grainSize2Spec = [1, 200, \exp, 0.0001, 60].asSpec;
	~grain2Size = ~grainSize2Spec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~grain2SizeView = EZSlider.new2(~tabBufComp, (370*~xSizeMul)@(22*~ySizeMul), "grain size 2", ~grainSize2Spec,
		{ |ez| ~grain2Size[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~grainSize2Spec.default, numberWidth:60*~xSizeMul, labelWidth:70*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));


	~lehmerInitSpec = [0, 1, \lin, 0.001, 0.5].asSpec;
	~lehmerInit1 = ~lehmerInitSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~lehmerInit1View = EZSlider.new2(~tabBufComp, (370*~xSizeMul)@(18*~ySizeMul), "lehmer In 1", ~lehmerInitSpec,
		{ |ez| ~lehmerInit1[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~lehmerInitSpec.default, numberWidth:60*~xSizeMul, labelWidth:70*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*//*~sliderBackgroundColor*/ Color.black,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	~lehmerASpec = [0, 2, \lin, 0.001, 1].asSpec;
	~lehmerA1 = ~lehmerASpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~lehmerA1View = EZSlider.new2(~tabBufComp, (370*~xSizeMul)@(18*~ySizeMul), "lehmer A 1", ~lehmerASpec,
		{ |ez| ~lehmerA1[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~lehmerASpec.default, numberWidth:60*~xSizeMul, labelWidth:70*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*//*~sliderBackgroundColor*/ Color.black,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul)); //.adaptToControlStep;

	~lehmerBSpec = [0, 1, \lin, 0.001, 0.1].asSpec;
	~lehmerB1 = ~lehmerBSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~lehmerB1View = EZSlider.new2(~tabBufComp, (370*~xSizeMul)@(18*~ySizeMul), "lehmer B 1", ~lehmerBSpec,
		{ |ez| ~lehmerB1[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~lehmerBSpec.default, numberWidth:60*~xSizeMul, labelWidth:70*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*//*~sliderBackgroundColor*/ Color.black,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul)); //.adaptToControlStep;

	~lehmerInitSpec = [0, 1, \lin, 0.001, 0.5].asSpec;
	~lehmerInit2 = ~lehmerInitSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~lehmerInit2View = EZSlider.new2(~tabBufComp, (370*~xSizeMul)@(18*~ySizeMul), "lehmer In 2", ~lehmerInitSpec,
		{ |ez| ~lehmerInit2[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~lehmerInitSpec.default, numberWidth:60*~xSizeMul, labelWidth:70*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul)); //.adaptToControlStep;

	~lehmerASpec = [0, 2, \lin, 0.001, 1].asSpec;
	~lehmerA2 = ~lehmerASpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~lehmerA2View = EZSlider.new2(~tabBufComp, (370*~xSizeMul)@(18*~ySizeMul), "lehmer A 2", ~lehmerASpec,
		{ |ez| ~lehmerA2[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~lehmerASpec.default, numberWidth:60*~xSizeMul, labelWidth:70*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul)); //.adaptToControlStep;

	~lehmerBSpec = [0, 1, \lin, 0.001, 0.1].asSpec;
	~lehmerB2 = ~lehmerBSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
	~lehmerB2View = EZSlider.new2(~tabBufComp, (370*~xSizeMul)@(18*~ySizeMul), "lehmer B 2", ~lehmerBSpec,
		{ |ez| ~lehmerB2[~tracksValue][~seqsValue] = ez.value }, unitWidth:0, initVal:~lehmerBSpec.default, numberWidth:60*~xSizeMul, labelWidth:70*~xSizeMul, layout:\horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul)); //.adaptToControlStep;

	~lehmerReInit1 = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~lehmerReInit1View = RoundButton(~tabBufComp, /*~miniSlider1Pos5*/ (80*~xSizeMul)@(20*~ySizeMul) /*Rect(338, 138+18, 60, 16)*/)
	.states_([["\Re Init L 1", Color.black, Color.green], ["\No Init L 1", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul, bold: true))
	.action_({|i| ~lehmerReInit1[~tracksValue][~seqsValue] = i.value }).valueAction_(0);

	~lehmerReInit2 = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~lehmerReInit2View = RoundButton(~tabBufComp, /*~miniSlider1Pos5*/ (80*~xSizeMul)@(20*~ySizeMul) /*Rect(338, 138+18, 60, 16)*/)
	.states_([["\Re Init L 2", Color.black, Color.green], ["\No Init L 2", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul, bold: true))
	.action_({|i| ~lehmerReInit2[~tracksValue][~seqsValue] = i.value }).valueAction_(0);

}.value;





{
	// GUI BUFFER

	~posBuf = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~bufFolderM = {0 ! ~nbOfSeqs} ! ~nbOfTracksX2 ! 2; // pour chargement des fichiers monos
	~bufFolderValue = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // pour chargement des fichiers monos au lieu du round

	~bufMinRaw = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // spécifique au Buffer lors du changement de dossier car sinon problème de rounding
	~bufMaxRaw = 1 ! ~nbOfSeqs ! ~nbOfTracksX2;

	/*
	~bufFolderMtest = 0 ! ~arrayOfFolderNames.size;
	~bufFolderMtest.size.do { |i| ~bufFolderMtest[i] = ~soundm[~arrayOfFolderNames[i].asSymbol] }
	~bufFolderMtest[1]
	*/

	~foldersStructureFunctionStringSize = ~kindOfFolders.size.collect { |i| "{bufFolderValue == (~arrayOfFolderPaths.size+"+i+")} {~bufFolderM[server][tr][seq] = ~soundmSpecificSoundFiles["+i+"] }" }.asCompileString.size;
	~foldersStructureFunctionString = ~kindOfFolders.size.collect { |i| "{bufFolderValue == (~arrayOfFolderPaths.size+"+i+")} {~bufFolderM[server][tr][seq] = ~soundmSpecificSoundFiles["+i+"] }" }.asCompileString.copyRange(2, ~foldersStructureFunctionStringSize-2).replace(","," ").replace("\""," ");

	if (~foldersStructure == 1, {

		("
~bufFolderFunc = { |tr, seq, bufFolderValue, server|
case // Affichage de tous les sous-dossiers + assemblage de sous dossiers
// {~bufFolderView.item != 'Kik & Hit' and: {~bufFolderView.item != 'Insultes'} }
{bufFolderValue < ~arrayOfFolderPaths.size}
// {~bufFolderM[tr][seq] = {~soundm[server][~arrayOfFolderPaths[~bufFolderView.value].folderName.asSymbol]}.bench;
{~bufFolderM[server][tr][seq] = /*~bufFolderMtest[bufFolderValue]*/ ~soundm[server][~arrayOfFolderNames[bufFolderValue].asSymbol]} // Pour prendre en compte les alias modifiés XXX & gain de perfo x par 3

// {~bufFolderView.item == 'Insultes'}
// {~bufFolderM[tr][seq] = ~soundm[server]['ins']}
// {~bufFolderView.item == 'InsultesOMax'}
// {~bufFolderM[tr][seq] = ~soundm[server]['insOMax']}

// {~bufFolderView.item == 'Kik & Hit'}
// {~bufFolderM[tr][seq] = /*~soundm[0]['4 Kik'] ++ ~soundm[0]['3 Hit']*/ ~soundmKikHitSoundFiles }

/*{~bufFolderView.item == ~kindOfFolders[0]} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[0] }
{~bufFolderView.item == ~kindOfFolders[1]} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[1] }
{~bufFolderView.item == ~kindOfFolders[2]} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[2] }
{~bufFolderView.item == ~kindOfFolders[3]} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[3] }
{~bufFolderView.item == ~kindOfFolders[4]} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[4] }
{~bufFolderView.item == ~kindOfFolders[5]} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[5] }*/
// Pour que PresetGetQuickFunction fonctionne XXXXXXXXX
/*{bufFolderValue == ~arrayOfFolderPaths.size} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[0] }
{bufFolderValue == (~arrayOfFolderPaths.size+1)} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[1] }
{bufFolderValue == (~arrayOfFolderPaths.size+2)} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[2] }
{bufFolderValue == (~arrayOfFolderPaths.size+3)} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[3] }
{bufFolderValue == (~arrayOfFolderPaths.size+4)} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[4] }
{bufFolderValue == (~arrayOfFolderPaths.size+5)} {~bufFolderM[tr][seq] = ~soundmSpecificSoundFiles[5] }*/

// {~bufFolderView.item == 'ALL'}
{bufFolderValue == (~arrayOfFolderPaths.size+~soundmSpecificSoundFiles.size)} // Pour que PresetGetQuickFunction fonctionne XXXXXXXXX
// {~bufFolderM[tr][seq] = ~arrayOfFolderPaths.size.collect { |i| ~soundm[server][~arrayOfFolderPaths[i].folderName.asSymbol]}}.flatten;
// ~arrayOfFolderPaths[10].folderName // Pourquoi renvoie le dossier général et non les sous-dossiers ???
{~bufFolderM[server][tr][seq] = /*~arrayOfFolderNames.collect { |item, i| ~soundm[server][~arrayOfFolderNames[i].asSymbol]}.flatten*/ ~soundmAllSoundFiles } "

			+~foldersStructureFunctionString+

			/*
			{~arrayOfFolderPaths.size.collect { |i| ~soundm[~arrayOfFolderNames[i].asSymbol]}.flatten}.bench;
			{~arrayOfFolderNames.collect { |item, i| ~soundm[~arrayOfFolderNames[i].asSymbol]}.flatten}.bench; // ne change rien ??????
			{~soundm[~arrayOfFolderPaths[0].folderName.asSymbol]}.bench;
			{~soundm[~arrayOfFolderNames[0].asSymbol]}.bench; // 3 x plus rapide
			*/

			"; ~bufRangeSpec[tr][seq] = ControlSpec(0, ~bufFolderM[server][tr][seq].size-1, \\lin, 1);" +
			"};
").interpret;

	}, {
		~bufFolderFunc = { |tr, seq, bufFolderValue, server|
			case // Affichage de tous les sous-dossiers + assemblage de sous dossiers
			// {~bufFolderView.item != 'Kik & Hit' and: {~bufFolderView.item != 'Insultes'} }
			{bufFolderValue < ~arrayOfFolderPaths.size}
			// {~bufFolderM[tr][seq] = {~soundm[~arrayOfFolderPaths[~bufFolderView.value].folderName.asSymbol]}.bench;
			{~bufFolderM[server][tr][seq] = ~soundm[server][~arrayOfFolderNames[bufFolderValue].asSymbol]} // Pour prendre en compte les alias modifiés XXX & gain de perfo x par 3

			// {~bufFolderView.item == 'ALL'}
			{bufFolderValue == (~arrayOfFolderPaths.size+1)} // Pour que PresetGetQuickFunction fonctionne XXXXXXXXX
			// {~bufFolderM[tr][seq] = ~arrayOfFolderPaths.size.collect { |i| ~soundm[~arrayOfFolderPaths[i].folderName.asSymbol]}}.flatten;
			// ~arrayOfFolderPaths[10].folderName // Pourquoi renvoie le dossier général et non les sous-dossiers ???
			{~bufFolderM[server][tr][seq] = /*~arrayOfFolderNames.collect { |item, i| ~soundm[~arrayOfFolderNames[i].asSymbol]}.flatten*/ ~soundmAllSoundFiles };
			~bufRangeSpec[tr][seq] = ControlSpec(0, ~bufFolderM[server][tr][seq].size-1, \lin, 1);
		};
	});

	~tracks.do { |tr|
		~seqs.do { |seq|
			// ~bufFolderM[tr][seq] = ~soundm['DR Kik']; // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX - à modifier si changement de la structure sonore
			~bufFolderValue[tr][seq] = /*4*/ /*38*/ ~defaultFolder.min(/*0*/ ~arrayOfFolderNames.size-1); // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX - à modifier si changement de la structure sonore
			~bufFolderM[0][tr][seq] = ~soundm[0][~arrayOfFolderNames[~bufFolderValue[tr][seq]].asSymbol];
			if (~server2.notNil, { ~bufFolderM[1][tr][seq] = ~soundm[1][~arrayOfFolderNames[~bufFolderValue[tr][seq]].asSymbol]; }); // Intéret ????
	}};

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		"NoRoundViewFunc", 0, (~bufFolderM[0][0][0].size -1), 0, "NoRoundValueDefault", "NoRoundDefault",
		\bufComp, \bufDisplay, 75, "~bufView.valueAction_(~bufSpec[", "].unmap(~bufMul[",
		\bufView, \buf, \bufSpec, false, true, "NoMultiViewValueThumbSize", ~compColor1, ~multiCompColor1, Color.white,
		\bufSeqView, \bufSeqStart, \bufSeqStop, \seqDurBuf, \bufSeqSpec, \bufSeqSpec2, \bufSeqVSpec, \bufSeqVSpec2,
		\bufIndexView, \bufIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\bufRangeView, \bufMin, \bufMax, \bufRangeSpec, (1/~bufFolderM[0][0][0].size), ~sliderHilightNoColor, "NoRangePresetViewView", "NoRangePresetView" /*~bufFolderView*/, "NoRangePresetViewItems", "NoRangePresetViewDefault", "NoRangePresetViewSign", (~bufFolderM[0][0][0].size -1),
		\bufMulView, \bufMul, \bufMulSpec, ~sliderHilightNoColor, \bufMulPresetViewView, \bufMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\bufRoundViewView, \bufRoundView, ~roundViewPos5, \bufRound, \bufRoundValue, 0, 0, // ligne pas utilisée
		\bufRandView, \buffer,
		\bufSeqAllView, \bufRangeMode, \bufSeqMode,
		\bufCopyAView, \bufCopyA, \bufPasteAView, \bufPasteA, \bufPasteMView, \bufPasteM, \bufDefaultView, \bufDefault,
		\bufDirView, \bufDir, \bufPatView, \bufPat, \bufPatSelViewView, \bufPatSelView, \bufPatSel, \bufBlock,
		\bufShowView, ~nameModPos, \center, Color.yellow, "BUF",
		\bufReadView, Color.grey(0.6), \bufPosView
	);

	// Section remise aussi plus bas, mais avec une action différente
	~bufFolderViewView = View(~bufComp, Rect(2*~xSizeMul, 136*~ySizeMul, 122*~xSizeMul, 16*~ySizeMul) /*~roundViewPos5*/); // Pour afficher les dossiers-sons dans leur intégralité dans le PopUp menu

	~seqSeq = 0 ! ~nbOfTracksX2; // nécessaire de le déclarer avant ~bufFolderView

	~bufFolderView = PopUpMenu.new(~bufFolderViewView, Rect(0,0,210*~xSizeMul,16*~ySizeMul))
	.action_({ |a| var serv, seq;

		if (~server2.isNil or: {(~tracksValue/2).asInteger < ~serverTrackSwitch}, {serv = 0}, {serv = 1});
		if (~curSeqTrig == 1, { seq = ~seqsValue },{ seq = ~seqSeq[~tracksValue] });

		~bufFolderValue[~tracksValue][seq] = a.value;
		~bufFolderFunc.value(~tracksValue, seq, ~bufFolderValue[~tracksValue][seq], /*0*/ serv);
		// ~bufRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, ~bufFolderM[~tracksValue][~seqsValue].size-1, \lin, 1); // intégré dans ~bufFolderFunc ci-dessus

		// ~bufMax[~tracksValue][~seqsValue] = ~bufFolderM[~tracksValue][~seqsValue].size -1; // Pour retitrer la protection dans le pattern à \prepbuf -> ???
		// ~bufMax[~tracksValue][~seqsValue] = ~bufMax[~tracksValue][~seqsValue].min(~bufFolderM[~tracksValue][~seqsValue].size -1); // Pour retitrer la protection dans le pattern à \prepbuf -> ???
		// \prepbuf,	(Pfunc({ |ev| var seq = ~seqSeq[track]; (~bufSpec[track][seq].map(ev.prepbufU) * ~bufMul[track][seq]).min(~bufFolderM[track][seq].size-1) }))/*.trace(prefix: "buf Nb -> ")*/,

		~bufSpec[~tracksValue][seq] = ControlSpec(~bufMin[~tracksValue][seq], ~bufMax[~tracksValue][seq], \lin, 1);
		/* ~bufRangeView.controlSpec_(ControlSpec(0, ~bufFolder[~tracksValue][~seqsValue].size-1, \lin, 1)); */
		~bufRangeView.step_(1/(~bufFolderM[serv][~tracksValue][seq].size - 1));
		~bufRangeView.minRange_(1/(~bufFolderM[serv][~tracksValue][seq].size) * 1);
		~bufRangeView.string = "%\n to \n%".format((~bufMax[~tracksValue][seq] * ~bufMul[~tracksValue][seq]).round(1), (~bufMin[~tracksValue][seq] * ~bufMul[~tracksValue][seq]).round(1));
		// ~bufRangeView.valueAction_([0, ~bufRangeSpec[~tracksValue][~seqsValue].unmap(~bufFolderM[~tracksValue][~seqsValue].size-1)]).doAction; /*~buffer.value(~tracksValue, ~seqsValue);*/
		~bufRangeView/*.valueAction_(~bufRangeSpec[~tracksValue][~seqsValue].unmap([~bufMin[~tracksValue][~seqsValue], ~bufMax[~tracksValue][~seqsValue]]))*/.doAction;
		// ~bufRangeView.valueAction_(~bufRangeSpec[~tracksValue][~seqsValue].unmap([~bufMin[~tracksValue][~seqsValue], ~bufMax[~tracksValue][~seqsValue]])).doAction;
		// Le .doAction précédent pour mettre à jour les données quand on change le ~bufFolderViewView si le ~bufRangeView reste identique
		// voire si le .doAction ne fait pas redondance avec les actions de ~bufRangeView ????????? - XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		// Pourquoi besoin de relancer le string alors que le valueAction devrait suffire ???

		// ~bufRangeView.string = "%\n to \n%".format((~bufMax[~tracksValue][~seqsValue] * ~bufMul[~tracksValue][~seqsValue]).round(1), (~bufMin[~tracksValue][~seqsValue] * ~bufMul[~tracksValue][~seqsValue]).round(1));
		~bufView.valueThumbSize_(max(10, if ((~bufMax[~tracksValue][seq] - ~bufMin[~tracksValue][seq]+1) > ~multiSliderHeight5,
			{10}, {~multiSliderHeight5 / (~bufMax[~tracksValue][seq] - ~bufMin[~tracksValue][seq]+1) })));
		~bufView.step_(1/(((~bufMax[~tracksValue][seq])-(~bufMin[~tracksValue][seq]))));
		~bufIndexView.step_(1/(~bufMax[~tracksValue][seq] - ~bufMin[~tracksValue][seq]));
		~bufIndexView.string_("At : %".format((~bufSpec[~tracksValue][seq].map(~bufIndexView.value) * ~bufMul[~tracksValue][seq]).round(1))); // léger pb de rounding ?

		if (~lemurConnected1 == 1, {
			// ~lemurAdress1.sendMsg("/ParC/BufM/value", ~bufFolderValue[~tracksValue][~seqsValue]);
			~lemurAdress1.sendMsg( *["/ParC/BufM", "@content", ~bufFolderView.items[~bufFolderValue[~tracksValue][seq]] ]);
			~lemurAdress1.sendMsg( *["/ParC/BufMenuL", "@content", ~bufFolderView.items[~bufFolderValue[~tracksValue][seq]] ]);
			~lemurAdress1.sendMsg("/ParC/BufLed/value", ~bufFolderValue[~tracksValue][seq] /*a.value*/ * ~bufFolderSize1.reciprocal); // à Optimiser ???
		});
	})
	.allowsReselection_(true)
	.background_(Color.magenta(0.7)/*green*/)
	.stringColor_(Color.white/*black*/)
	.font_(Font("Verdana",10*~fontSizeMul));

	// Affichage de tous les sous-dossiers + assemblage de sous dossiers
	// ~bufFolderView.items_(~arrayOfFolderPaths.size.collect { |i| ~arrayOfFolderPaths[i].folderName.copyRange(0, 13).asSymbol}/*++'Insultes'++'InsultesOMax'*/++'Kik & Hit'++'ALL sans Ins');
	// pour afficher seulement les 13 premiers caractères
	// ~bufFolderView.items_(~arrayOfFolderNames.collect { |item, i| item.copyRange(0, 13).asSymbol} /*++'Insultes'++'InsultesOMax'*/ ++ 'Kik & Hit' ++ 'ALL');
	~arrayOfFolderNames2 = ~arrayOfFolderNames.collect { |item, i| i+"-"+item};

	if (~foldersStructure == 1, {
		~bufFolderView.items_(~arrayOfFolderNames2 /*++'Insultes'++'InsultesOMax'*/ /*++ 'Kik & Hit'*/ ++ ~kindOfFolders.collect{|item, i| (i+~arrayOfFolderNames2.size) +"-"+item} ++ ["ALL"]);
		~arrayOfFolderNamesALL = ~arrayOfFolderNames ++ ~kindOfFolders ++ ["ALL"];
	}, {
		~bufFolderView.items_(~arrayOfFolderNames2 /*++'Insultes'++'InsultesOMax'*/ /*++ 'Kik & Hit'*/ ++ ["ALL"]);
		~arrayOfFolderNamesALL = ~arrayOfFolderNames ++ ["ALL"];
	});
	~bufFolderSize = ~arrayOfFolderNamesALL.size; ~bufFolderSize1 = ~bufFolderSize-1;
	// if (~arrayOfFolderPaths.size > 5, {~bufFolderView.valueAction_(4)}, {~bufFolderView.valueAction_(0)}); // Sous-dossier Kik par défaut

	~bufFolderView.valueAction_(~bufFolderValue[0][0]);


	/* déjà mis en place au début avec SMIR
	// .as(Set).as(Array) ou removeDups (wslib) pour les symbols
	~kindOfFolders = ~arrayOfFolderNames.collect {|i| i.split($ )[0] }.as(Set).as(Array);
	~soundmSpecificSoundFiles = List.new ! ~kindOfFolders.size;
	~kindOfFolders.do { |atem, a| ~arrayOfFolderNames.do { |item, i| if (~arrayOfFolderNames[i].split($ )[0] == atem, { ~soundmSpecificSoundFiles[a].add(~soundm[~arrayOfFolderNames[i].asSymbol]) }) } };
	~kindOfFolders.do { |item, i| ~soundmSpecificSoundFiles[i] = ~soundmSpecificSoundFiles[i].asArray.flatten };
	// Post << ~soundmSpecificSoundFiles[0]
	*/

	/*
	~arrayOfFolderPaths[25]
	~arrayOfFolderPaths.size
	[~arrayOfFolderPaths[~bufFolderView.value].folderName.asSymbol]
	a = ~arrayOfFolderPaths.size.collect { |i| ~sounds[~arrayOfFolderPaths[i].folderName.asSymbol]}
	a.flat.size
	*/

	~bufRangePresetView = RoundButton.new(~bufComp, Rect(328*~xSizeMul, 136*~ySizeMul, 30*~xSizeMul, 16*~ySizeMul) /*~rangePresetViewPos5*/)
	.states_([["AllR", Color.black, ~popUpMenuBackgroundColor]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({~bufRangeView.valueAction_([ 0, ~bufRangeSpec[~tracksValue][~seqsValue].unmap(~bufFolderM[0][~tracksValue][~seqsValue].size - 1) ]);
	});

	if (~twister.notNil, {
		// obligé de répéter cette info du _Init Midi Twister car au départ la taille des dossiers sons n'est pas connue
		16.do { |i| ~bufFolValues[i] = NumericControlValue(spec:[0, ~bufFolderView.items.size-1]); ~bufFolValues[i].value_(~bufFolderValue[i][~seqSeq[i]]) };
		// ~twister.knobs[5].knobCV = ~bufFolValues[~tracksValue];
	});





	// GUI AMPLITUDE
	// voire pour transformer la courbe linéaire en courbe db plus perceptive ???

	~posAmp = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~ampRat = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // amprat seulement pour amp
	~aAmp = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // amprat seulement pour amp

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\ampRoundViewFunc, 0, 1, 1, 0, 0.01,
		\ampComp, \ampDisplay, 75, "~ampView.valueAction_(~ampSpec[", "].unmap(~ampMul[",
		\ampView, \amp, \ampSpec, true, false, 1, ~compColor1, ~multiCompColor1, /*~compColor2, ~multiCompColor2,*/ Color.white,
		\ampSeqView, \ampSeqStart, \ampSeqStop, \seqDurAmp, \ampSeqSpec, \ampSeqSpec2, \ampSeqVSpec, \ampSeqVSpec2,
		\ampIndexView, \ampIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\ampRangeView, \ampMin, \ampMax, \ampRangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \ampRangePresetViewView, \ampRangePresetView, ["0->0.5", "0.5->1", "0->1", "0->1.2", "0->1.5"], 2, "->", 1.5,
		\ampMulView, \ampMul, \ampMulSpec, ~sliderHilightColor, \ampMulPresetViewView, \ampMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.2", "1.5"], 10,
		\ampRoundViewView, \ampRoundView, ~roundViewPos5, \ampRound, \ampRoundValue, ["@ 0.01", "@ 0.1", "@ 0.2", "@ 0.25", "@ 0.5", "@ 1"], 0,
		\ampRandView, \amplitude,
		\ampSeqAllView, \ampRangeMode, \ampSeqMode,
		\ampCopyAView, \ampCopyA, \ampPasteAView, \ampPasteA, \ampPasteMView, \ampPasteM, \ampDefaultView, \ampDefault,
		\ampDirView, \ampDir, \ampPatView, \ampPat, \ampPatSelViewView, \ampPatSelView, \ampPatSel, \ampBlock,
		\ampShowView, ~nameModPos, \center, Color.yellow, "AMP",
		\ampReadView, Color.grey(0.6), \ampPosView
	);

	~ampRatSpec = ControlSpec(0, 16000, 10, 0.1);
	~ampRatView = SmoothSlider(~ampComp, ~miniSlider1Pos5)
	.action_({ |view| ~ampRat[~tracksValue][~seqsValue] = ~ampRatSpec.map(view.value);
		view.string = "A : %".format(~ampRat[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(~sliderBackgroundColor /*Color.magenta*/)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~ampRatSpec.unmap(0))
	.doAction;

	~aAmpSpec = ControlSpec(0, 1, \lin, 0.01);
	~aAmpView = SmoothSlider(~ampComp, ~miniSlider2Pos5)
	.action_({ |view| ~aAmp[~tracksValue][~seqsValue] = ~aAmpSpec.map(view.value);
		view.string = "AA : %".format(~aAmp[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(~sliderBackgroundColor /*Color.magenta*/)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~aAmpSpec.unmap(0))
	.doAction;

}.value;





{

	// GUI OFFSET

	~posOff = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~offThresh = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // thresh seulement pour off

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\offRoundViewFunc, 0, 1, 0, 0, 0.01,
		\offComp, \offDisplay, 75, "~offView.valueAction_(~offSpec[", "].unmap(~offMul[",
		\offView, \off, \offSpec, false, true, 10,  ~compColor1, ~multiCompColor1, /*~compColor2, ~multiCompColor2,*/ Color.white,
		\offSeqView, \offSeqStart, \offSeqStop, \seqDurOff, \offSeqSpec, \offSeqSpec2, \offSeqVSpec, \offSeqVSpec2,
		\offIndexView, \offIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\offRangeView, \offMin, \offMax, \offRangeSpec, "NoRangeViewMinRange", ~sliderHilightNoColor, \offRangePresetViewView, \offRangePresetView, ["0->0.5", "0.5->1", "0->1"], 2, "->", 1,
		\offMulView, \offMul, \offMulSpec, ~sliderHilightNoColor, \offMulPresetViewView, \offMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\offRoundViewView, \offRoundView, ~roundViewPos5, \offRound, \offRoundValue, ["@ 0.001", "@ 0.01", "@ 0.1", "@ 0.2", "@ 0.25", "@ 0.5", "@ 1"], 0,
		\offRandView, \offset,
		\offSeqAllView, \offRangeMode, \offSeqMode,
		\offCopyAView, \offCopyA, \offPasteAView, \offPasteA, \offPasteMView, \offPasteM, \offDefaultView, \offDefault,
		\offDirView, \offDir, \offPatView, \offPat, \offPatSelViewView, \offPatSelView, \offPatSel, \offBlock,
		\offShowView, ~nameModPos2, \left, Color.yellow, "POS",
		\offReadView, Color.grey(0.6), \offPosView
	);

	~offThreshSpec = ControlSpec(0, 1, \lin, 0.01);
	~offThreshView = SmoothSlider(~offComp, ~miniSlider1Pos5)
	.action_({ |view| ~offThresh[~tracksValue][~seqsValue] = ~offThreshSpec.map(view.value);
		view.string = "Th : %".format(~offThresh[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(/*~sliderBackgroundColor*/ Color.magenta)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(0.4)
	.doAction;

	// à supprimer - Version EZSmoothSlider
	/*~offThreshView= EZSmoothSlider(~offComp, Rect(322, 207, 77, 12), nil, ControlSpec(0, 1, \lin, 0.01),
	{|ez| ~offThresh[~tracksValue][~seqsValue] = ez.value.postln; }, layout:\horz, margin: 2@2, unitWidth: 0, numberWidth: 0, initVal: 0.5, initAction: true)
	.setColors(Color.grey,Color.white, Color.yellow,Color.grey, Color.white, Color.yellow,nil, Color.red, Color.grey(0.7));*/

	~posOff2 = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\off2RoundViewFunc, 0, 1, 0, 0, 0.01,
		\off2Comp, \off2Display, 78, "~off2View.valueAction_(~off2Spec[", "].unmap(~off2Mul[",
		\off2View, \off2, \off2Spec, false, true, 10,  ~compColor1, ~multiCompColor1, /*~compColor2, ~multiCompColor2,*/ Color.white,
		\off2SeqView, \off2SeqStart, \off2SeqStop, \seqDurOff2, \off2SeqSpec, \off2SeqSpec2, \off2SeqVSpec, \off2SeqVSpec2,
		\off2IndexView, \off2Index,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\off2RangeView, \off2Min, \off2Max, \off2RangeSpec, "NoRangeViewMinRange", ~sliderHilightNoColor, \off2RangePresetViewView, \off2RangePresetView, ["0->0.5", "0.5->1", "0->1"], 2, "->", 1,
		\off2MulView, \off2Mul, \off2MulSpec, ~sliderHilightNoColor, \off2MulPresetViewView, \off2MulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\off2RoundViewView, \off2RoundView, ~roundViewPos5, \off2Round, \off2RoundValue, ["@ 0.001", "@ 0.01", "@ 0.1", "@ 0.2", "@ 0.25", "@ 0.5", "@ 1"], 0,
		\off2RandView, \offset2,
		\off2SeqAllView, \off2RangeMode, \off2SeqMode,
		\off2CopyAView, \off2CopyA, \off2PasteAView, \off2PasteA, \off2PasteMView, \off2PasteM, \off2DefaultView, \off2Default,
		\off2DirView, \off2Dir, \off2PatView, \off2Pat, \off2PatSelViewView, \off2PatSelView, \off2PatSel, \off2Block,
		\off2ShowView, ~nameModPos2, \left, Color.yellow, "POS 2",
		\off2ReadView, Color.grey(0.6), \off2PosView
	);

	~posOff3 = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\off3RoundViewFunc, 0, 1, 0, 0, 0.01,
		\off3Comp, \off3Display, 78, "~off3View.valueAction_(~off3Spec[", "].unmap(~off3Mul[",
		\off3View, \off3, \off3Spec, false, true, 10,  ~compColor1, ~multiCompColor1, /*~compColor2, ~multiCompColor2,*/ Color.white,
		\off3SeqView, \off3SeqStart, \off3SeqStop, \seqDurOff3, \off3SeqSpec, \off3SeqSpec2, \off3SeqVSpec, \off3SeqVSpec2,
		\off3IndexView, \off3Index,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\off3RangeView, \off3Min, \off3Max, \off3RangeSpec, "NoRangeViewMinRange", ~sliderHilightNoColor, \off3RangePresetViewView, \off3RangePresetView, ["0->0.5", "0.5->1", "0->1"], 2, "->", 1,
		\off3MulView, \off3Mul, \off3MulSpec, ~sliderHilightNoColor, \off3MulPresetViewView, \off3MulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\off3RoundViewView, \off3RoundView, ~roundViewPos5, \off3Round, \off3RoundValue, ["@ 0.001", "@ 0.01", "@ 0.1", "@ 0.2", "@ 0.25", "@ 0.5", "@ 1"], 0,
		\off3RandView, \offset3,
		\off3SeqAllView, \off3RangeMode, \off3SeqMode,
		\off3CopyAView, \off3CopyA, \off3PasteAView, \off3PasteA, \off3PasteMView, \off3PasteM, \off3DefaultView, \off3Default,
		\off3DirView, \off3Dir, \off3PatView, \off3Pat, \off3PatSelViewView, \off3PatSelView, \off3PatSel, \off3Block,
		\off3ShowView, ~nameModPos2, \left, Color.yellow, "POS 3",
		\off3ReadView, Color.grey(0.6), \off3PosView
	);

	~posOff4 = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\off4RoundViewFunc, 0, 1, 0, 0, 0.01,
		\off4Comp, \off4Display, 78, "~off4View.valueAction_(~off4Spec[", "].unmap(~off4Mul[",
		\off4View, \off4, \off4Spec, false, true, 10,  ~compColor1, ~multiCompColor1, /*~compColor2, ~multiCompColor2,*/ Color.white,
		\off4SeqView, \off4SeqStart, \off4SeqStop, \seqDurOff4, \off4SeqSpec, \off4SeqSpec2, \off4SeqVSpec, \off4SeqVSpec2,
		\off4IndexView, \off4Index,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\off4RangeView, \off4Min, \off4Max, \off4RangeSpec, "NoRangeViewMinRange", ~sliderHilightNoColor, \off4RangePresetViewView, \off4RangePresetView, ["0->0.5", "0.5->1", "0->1"], 2, "->", 1,
		\off4MulView, \off4Mul, \off4MulSpec, ~sliderHilightNoColor, \off4MulPresetViewView, \off4MulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\off4RoundViewView, \off4RoundView, ~roundViewPos5, \off4Round, \off4RoundValue, ["@ 0.001", "@ 0.01", "@ 0.1", "@ 0.2", "@ 0.25", "@ 0.5", "@ 1"], 0,
		\off4RandView, \offset4,
		\off4SeqAllView, \off4RangeMode, \off4SeqMode,
		\off4CopyAView, \off4CopyA, \off4PasteAView, \off4PasteA, \off4PasteMView, \off4PasteM, \off4DefaultView, \off4Default,
		\off4DirView, \off4Dir, \off4PatView, \off4Pat, \off4PatSelViewView, \off4PatSelView, \off4PatSel, \off4Block,
		\off4ShowView, ~nameModPos2, \left, Color.yellow, "POS 4",
		\off4ReadView, Color.grey(0.6), \off4PosView
	);





	// GUI RATE 1 & 2

	~posRat = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~posRat2 = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~freqRat = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // freqrat seulement pour rat
	~fAmp = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // freqrat seulement pour rat

	~ratSynth = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\ratRoundViewFunc, 0, 2, 1, 0, 0.01,
		\ratComp, \ratDisplay, 75, "~ratView.valueAction_(~ratSpec[", "].unmap(~ratMul[",
		\ratView, \rat, \ratSpec, false, true, 10, ~compColor1, ~multiCompColor1, Color.white,
		\ratSeqView, \ratSeqStart, \ratSeqStop, \seqDurRat, \ratSeqSpec, \ratSeqSpec2, \ratSeqVSpec, \ratSeqVSpec2,
		\ratIndexView, \ratIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\ratRangeView, \ratMin, \ratMax, \ratRangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \ratRangePresetViewView, \ratRangePresetView, ["0-0.5", "0-1", "0.5-1.5", "0-2", "0-3", "0-4", "0-5", "0-10", "0-20", "0-50", "0-100", "0-128", "36-84", "36-60", "60-84", "48-72"], 3, "-", 128,
		\ratMulView, \ratMul, \ratMulSpec, ~sliderHilightColor, \ratMulPresetViewView, \ratMulPresetView, ["0.01", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\ratRoundViewView, \ratRoundView, ~roundViewPos5, \ratRound, \ratRoundValue, ["@ 0.001 EXP", "@ 0.01 EXP", "@ 0.1 EXP", "@ 0.2 EXP", "@ 0.25 EXP", "@ 0.5 EXP", "@ 1 EXP", "@ 0.01 LIN", "@ 0.1 LIN", "@ 0.125 1÷16T LIN", "@ 0.2 LIN", "@ 0.25 1÷8T LIN", "@ 0.5 1÷4T LIN", "@ 1 1÷2T LIN", "@ 2 1T LIN"], 0,
		\ratRandView, \rate,
		\ratSeqAllView, \ratRangeMode, \ratSeqMode,
		\ratCopyAView, \ratCopyA, \ratPasteAView, \ratPasteA, \ratPasteMView, \ratPasteM, \ratDefaultView, \ratDefault,
		\ratDirView, \ratDir, \ratPatView, \ratPat, \ratPatSelViewView, \ratPatSelView, \ratPatSel, \ratBlock,
		\ratShowView, ~nameModPos2, \left, Color.yellow, "RAT",
		\ratReadView, Color.grey(0.6), \ratPosView
	);

	~freqRatSpec = ControlSpec(0, 16000, 10, 0.1); // Pourquoi exp ne fonctionne pas ??? -> ne peut avoir 0
	~freqRatView = SmoothSlider(~ratComp, ~miniSlider1Pos5)
	.action_({ |view| ~freqRat[~tracksValue][~seqsValue] = ~freqRatSpec.map(view.value);
		view.string = "F : %".format(~freqRat[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(~sliderBackgroundColor /*Color.magenta*/)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~freqRatSpec.unmap(0))
	.doAction;

	~fAmpSpec = ControlSpec(0, 2, \lin, 0.01);
	~fAmpView = SmoothSlider(~ratComp, ~miniSlider2Pos5)
	.action_({ |view| ~fAmp[~tracksValue][~seqsValue] = ~fAmpSpec.map(view.value);
		view.string = "FA : %".format(~fAmp[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(~sliderBackgroundColor /*Color.magenta*/)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~fAmpSpec.unmap(0))
	.doAction;

	~makeModuleWindow.( currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\rat2RoundViewFunc, 0, 2, 1, 0, 0.01,
		\rat2Comp, \rat2Display, 78, "~rat2View.valueAction_(~rat2Spec[", "].unmap(~rat2Mul[",
		\rat2View, \rat2, \rat2Spec, false, true, 10, ~compColor1, ~multiCompColor1, Color.red,
		\rat2SeqView, \rat2SeqStart, \rat2SeqStop, \seqDurRat2, \rat2SeqSpec, \rat2SeqSpec2, \rat2SeqVSpec, \rat2SeqVSpec2,
		\rat2IndexView, \rat2Index,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\rat2RangeView, \rat2Min, \rat2Max, \rat2RangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \rat2RangePresetViewView, \rat2RangePresetView, ["0-0.5", "0-1", "0.5-1.5", "0-2", "0-3", "0-4", "0-5", "0-6", "0-10", "0-20", "0-50", "0-100", "0-128", "36-84", "36-60", "60-84", "48-72"], 3, "-", 128,
		\rat2MulView, \rat2Mul, \rat2MulSpec, ~sliderHilightColor, \rat2MulPresetViewView, \rat2MulPresetView, ["0.01", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\rat2RoundViewView, \rat2RoundView, ~roundViewPos5, \rat2Round, \rat2RoundValue, ["@ 0.001 EXP", "@ 0.01 EXP", "@ 0.1 EXP", "@ 0.2 EXP", "@ 0.25 EXP", "@ 0.5 EXP", "@ 1 EXP", "@ 0.01 LIN", "@ 0.1 LIN", "@ 0.125 1÷16T LIN", "@ 0.2 LIN", "@ 0.25 1÷8T LIN", "@ 0.5 1÷4T LIN", "@ 1 1÷2T LIN", "@ 2 1T LIN"], 0,
		\rat2RandView, \rate2f,
		\rat2SeqAllView, \rat2RangeMode, \rat2SeqMode,
		\rat2CopyAView, \rat2CopyA, \rat2PasteAView, \rat2PasteA, \rat2PasteMView, \rat2PasteM, \rat2DefaultView, \rat2Default,
		\rat2DirView, \rat2Dir, \rat2PatView, \rat2Pat, \rat2PatSelViewView, \rat2PatSelView, \rat2PatSel, \rat2Block,
		\rat2ShowView, ~nameModPos2, \left, Color.yellow, "RAT 2",
		\rat2ReadView, Color.grey(0.6), \rat2PosView
	);





	// GUI STRETCHER 1 & 2

	~posStr = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~posStr2 = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~psPitchDispers = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // ~pspitchDispers seulement pour str
	~psTimeDispers = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // ~pspitchDispers seulement pour str

	~psPitchDispersSpec = ControlSpec(0, 0.5, \lin, 0.01, 0);
	~psTimeDispersSpec = ControlSpec(0, 0.2, \lin, 0.01, 0.05);

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\strRoundViewFunc, 0, 2, 1, 0, 0.01,
		\strComp, \strDisplay, 75, "~strView.valueAction_(~strSpec[", "].unmap(~strMul[",
		\strView, \str, \strSpec, false, true, 10, ~compColor1, ~multiCompColor1, Color.white,
		\strSeqView, \strSeqStart, \strSeqStop, \seqDurStr, \strSeqSpec, \strSeqSpec2, \strSeqVSpec, \strSeqVSpec2,
		\strIndexView, \strIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\strRangeView, \strMin, \strMax, \strRangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \strRangePresetViewView, \strRangePresetView, ["0-0.5", "0-1", "0.5-1.5", "0-2", "0-3", "0-4", "0-5", "0-6", "0-10", "0-20", "0-50", "0-100", "0-128", "36-84", "36-60", "60-84", "48-72"], 3, "-", 128,
		\strMulView, \strMul, \strMulSpec, ~sliderHilightColor, \strMulPresetViewView, \strMulPresetView, ["0.01", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\strRoundViewView, \strRoundView, ~roundViewPos5, \strRound, \strRoundValue, ["@ 0.001 EXP", "@ 0.01 EXP", "@ 0.1 EXP", "@ 0.2 EXP", "@ 0.25 EXP", "@ 0.5 EXP", "@ 1 EXP", "@ 0.01 LIN", "@ 0.1 LIN", "@ 0.125 1÷16T LIN", "@ 0.2 LIN", "@ 0.25 1÷8T LIN", "@ 0.5 1÷4T LIN", "@ 1 1÷2T LIN", "@ 2 1T LIN"], 0,
		\strRandView, \stretching,
		\strSeqAllView, \strRangeMode, \strSeqMode,
		\strCopyAView, \strCopyA, \strPasteAView, \strPasteA, \strPasteMView, \strPasteM, \strDefaultView, \strDefault,
		\strDirView, \strDir, \strPatView, \strPat, \strPatSelViewView, \strPatSelView, \strPatSel, \strBlock,
		\strShowView, ~nameModPos2, \left, Color.yellow, "STR",
		\strReadView, Color.grey(0.6), \strPosView
	);

	~psPitchDispersView = SmoothSlider(/*~strComp, ~miniSlider1Pos5*/ ~tabGUI, Rect(738*~xSizeMul, 1019*~ySizeMul, 60*~xSizeMul, 18*~ySizeMul) )
	.action_({ |view| ~psPitchDispers[~tracksValue][~seqsValue] = ~psPitchDispersSpec.map(view.value);
		view.string = "PDis : %".format(~psPitchDispers[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(~sliderBackgroundColor /*Color.magenta*/)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~psPitchDispersSpec.unmap(~psPitchDispersSpec.default))
	.doAction;

	~psTimeDispersView = SmoothSlider(/*~strComp, ~miniSlider2Pos5*/ ~tabGUI, Rect(738*~xSizeMul, 1037*~ySizeMul, 60*~xSizeMul, 18*~ySizeMul))
	.action_({ |view| ~psTimeDispers[~tracksValue][~seqsValue] = ~psTimeDispersSpec.map(view.value);
		view.string = "TDis : %".format(~psTimeDispers[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(~sliderBackgroundColor /*Color.magenta*/)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~psTimeDispersSpec.unmap(~psTimeDispersSpec.default))
	.doAction;

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\str2RoundViewFunc, 0, 2, 1, 0, 0.01,
		\str2Comp, \str2Display, 78, "~str2View.valueAction_(~str2Spec[", "].unmap(~str2Mul[",
		\str2View, \str2, \str2Spec, false, true, 10, ~compColor1, ~multiCompColor1, Color.red,
		\str2SeqView, \str2SeqStart, \str2SeqStop, \seqDurStr2, \str2SeqSpec, \str2SeqSpec2, \str2SeqVSpec, \str2SeqVSpec2,
		\str2IndexView, \str2Index,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\str2RangeView, \str2Min, \str2Max, \str2RangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \str2RangePresetViewView, \str2RangePresetView, ["0-0.5", "0-1", "0.5-1.5", "0-2", "0-3", "0-4", "0-5", "0-6", "0-10", "0-20", "0-50", "0-100", "0-128", "36-84", "36-60", "60-84", "48-72"], 3, "-", 128,
		\str2MulView, \str2Mul, \str2MulSpec, ~sliderHilightColor, \str2MulPresetViewView, \str2MulPresetView, ["0.01", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\str2RoundViewView, \str2RoundView, ~roundViewPos5, \str2Round, \str2RoundValue, ["@ 0.001 EXP", "@ 0.01 EXP", "@ 0.1 EXP", "@ 0.2 EXP", "@ 0.25 EXP", "@ 0.5 EXP", "@ 1 EXP", "@ 0.01 LIN", "@ 0.1 LIN", "@ 0.125 1÷16T LIN", "@ 0.2 LIN", "@ 0.25 1÷8T LIN", "@ 0.5 1÷4T LIN", "@ 1 1÷2T LIN", "@ 2 1T LIN"], 0,
		\str2RandView, \stretching2,
		\str2SeqAllView, \str2RangeMode, \str2SeqMode,
		\str2CopyAView, \str2CopyA, \str2PasteAView, \str2PasteA, \str2PasteMView, \str2PasteM, \str2DefaultView, \str2Default,
		\str2DirView, \str2Dir, \str2PatView, \str2Pat, \str2PatSelViewView, \str2PatSelView, \str2PatSel, \str2Block,
		\str2ShowView, ~nameModPos2, \left, Color.yellow, "STR 2",
		\str2ReadView, Color.grey(0.6), \str2PosView
	);





	// GUI CENTER 1 & 2

	~posCen = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~posCen2 = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~psWindowSize = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // ~pspitchDispers seulement pour cen

	~transComp = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;

	~psWindowSizeSpec = ControlSpec(0.05, 1, \lin, 0.01, 0.2);

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\cenRoundViewFunc, 0, 128, 60, 11, 0.25,
		\cenComp, \cenDisplay, 75, "~cenView.valueAction_(~cenSpec[", "].unmap(~cenMul[",
		\cenView, \cen, \cenSpec, false, true, 10, ~compColor1, ~multiCompColor1, Color.white,
		\cenSeqView, \cenSeqStart, \cenSeqStop, \seqDurCen, \cenSeqSpec, \cenSeqSpec2, \cenSeqVSpec, \cenSeqVSpec2,
		\cenIndexView, \cenIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\cenRangeView, \cenMin, \cenMax, \cenRangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \cenRangePresetViewView, \cenRangePresetView, ["0-0.5", "0-1", "0.5-1.5", "0-2", "0-3", "0-4", "0-5", "0-6", "0-10", "0-20", "0-50", "0-100", "0-128", "36-84", "36-60", "60-84", "48-72"], 12, "-", 128,
		\cenMulView, \cenMul, \cenMulSpec, ~sliderHilightColor, \cenMulPresetViewView, \cenMulPresetView, ["0.01", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\cenRoundViewView, \cenRoundView, ~roundViewPos5, \cenRound, \cenRoundValue, ["@ 0.001 EXP", "@ 0.01 EXP", "@ 0.1 EXP", "@ 0.2 EXP", "@ 0.25 EXP", "@ 0.5 EXP", "@ 1 EXP", "@ 0.01 LIN", "@ 0.1 LIN", "@ 0.125 1÷16T LIN", "@ 0.2 LIN", "@ 0.25 1÷8T LIN", "@ 0.5 1÷4T LIN", "@ 1 1÷2T LIN", "@ 2 1T LIN"], 11,
		\cenRandView, \center,
		\cenSeqAllView, \cenRangeMode, \cenSeqMode,
		\cenCopyAView, \cenCopyA, \cenPasteAView, \cenPasteA, \cenPasteMView, \cenPasteM, \cenDefaultView, \cenDefault,
		\cenDirView, \cenDir, \cenPatView, \cenPat, \cenPatSelViewView, \cenPatSelView, \cenPatSel, \cenBlock,
		\cenShowView, ~nameModPos2, \left, Color.yellow, "CEN",
		\cenReadView, Color.grey(0.6), \cenPosView
	);

	~psWindowSizeView = SmoothSlider(/*~cenComp, ~miniSlider1Pos5*/ ~tabGUI, Rect(1137*~xSizeMul, 1019*~ySizeMul, 60*~xSizeMul, 18*~ySizeMul) )
	.action_({ |view| ~psWindowSize[~tracksValue][~seqsValue] = ~psWindowSizeSpec.map(view.value);
		if (~psWindowSize[~tracksValue][~seqsValue] > 0.2,
			{ ~psTimeDispersSpec = ControlSpec(0, ~psWindowSize[~tracksValue][~seqsValue], \lin, 0.01, 0.05);
			},{
				~psTimeDispersSpec = ControlSpec(0, 0.2, \lin, 0.01, 0.05);
		});
		~psTimeDispersView.valueAction_(~psTimeDispersSpec.unmap(~psTimeDispers[~tracksValue][~seqsValue]));
		view.string = "WinS : %".format(~psWindowSize[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(~sliderBackgroundColor /*Color.magenta*/)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~psWindowSizeSpec.unmap(~psWindowSizeSpec.default))
	.doAction;

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\cen2RoundViewFunc, 0, 128, 60, 11, 0.25,
		\cen2Comp, \cen2Display, 78, "~cen2View.valueAction_(~cen2Spec[", "].unmap(~cen2Mul[",
		\cen2View, \cen2, \cen2Spec, false, true, 10, ~compColor1, ~multiCompColor1, Color.red,
		\cen2SeqView, \cen2SeqStart, \cen2SeqStop, \seqDurCen2, \cen2SeqSpec, \cen2SeqSpec2, \cen2SeqVSpec, \cen2SeqVSpec2,
		\cen2IndexView, \cen2Index,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\cen2RangeView, \cen2Min, \cen2Max, \cen2RangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \cen2RangePresetViewView, \cen2RangePresetView, ["0-0.5", "0-1", "0.5-1.5", "0-2", "0-3", "0-4", "0-5", "0-6", "0-10", "0-20", "0-50", "0-100", "0-128", "36-84", "36-60", "60-84", "48-72"], 12, "-", 128,
		\cen2MulView, \cen2Mul, \cen2MulSpec, ~sliderHilightColor, \cen2MulPresetViewView, \cen2MulPresetView, ["0.01", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\cen2RoundViewView, \cen2RoundView, ~roundViewPos5, \cen2Round, \cen2RoundValue, ["@ 0.001 EXP", "@ 0.01 EXP", "@ 0.1 EXP", "@ 0.2 EXP", "@ 0.25 EXP", "@ 0.5 EXP", "@ 1 EXP", "@ 0.01 LIN", "@ 0.1 LIN", "@ 0.125 1÷16T LIN", "@ 0.2 LIN", "@ 0.25 1÷8T LIN", "@ 0.5 1÷4T LIN", "@ 1 1÷2T LIN", "@ 2 1T LIN"], 11,
		\cen2RandView, \center2,
		\cen2SeqAllView, \cen2RangeMode, \cen2SeqMode,
		\cen2CopyAView, \cen2CopyA, \cen2PasteAView, \cen2PasteA, \cen2PasteMView, \cen2PasteM, \cen2DefaultView, \cen2Default,
		\cen2DirView, \cen2Dir, \cen2PatView, \cen2Pat, \cen2PatSelViewView, \cen2PatSelView, \cen2PatSel, \cen2Block,
		\cen2ShowView, ~nameModPos2, \left, Color.yellow, "CEN 2",
		\cen2ReadView, Color.grey(0.6), \cen2PosView
	);

}.value;





{
	// GUI PANNING

	~posPan = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~panRat = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // panrat seulement pour pan
	~pAmp = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // panrat seulement pour pan

	~panRangePresetViewFunc = [
		{ |tr, seq| ~panRangeView.valueAction_(~panRangeSpec[tr][seq].unmap([-1, -0.98])) },
		{ |tr, seq| ~panRangeView.valueAction_(~panRangeSpec[tr][seq].unmap([-0.01, 0.01])) },
		{ |tr, seq| ~panRangeView.valueAction_(~panRangeSpec[tr][seq].unmap([0.98, 1])) },
		{ |tr, seq| ~panRangeView.valueAction_(~panRangeSpec[tr][seq].unmap([-1, 0])) },
		{ |tr, seq| ~panRangeView.valueAction_(~panRangeSpec[tr][seq].unmap([0, 1])) },
		{ |tr, seq| ~panRangeView.valueAction_(~panRangeSpec[tr][seq].unmap([-0.5, 0.5])) },
		{ |tr, seq| ~panRangeView.valueAction_(~panRangeSpec[tr][seq].unmap([-1, 1])) }
	];

	~panRangePresetViewFuncG = [
		{ |tr, seq| ~panMax[tr][seq] = -1; ~panMin[tr][seq] = -0.98; ~panSpec[tr][seq] = ControlSpec(~panMin[tr][seq], ~panMax[tr][seq], \lin, ~panRound[tr][seq]) }, // L
		{ |tr, seq| ~panMax[tr][seq] = -0.01; ~panMin[tr][seq] = 0.01; ~panSpec[tr][seq] = ControlSpec(~panMin[tr][seq], ~panMax[tr][seq], \lin, ~panRound[tr][seq]) }, // C
		{ |tr, seq| ~panMax[tr][seq] = 0.98; ~panMin[tr][seq] = 1; ~panSpec[tr][seq] = ControlSpec(~panMin[tr][seq], ~panMax[tr][seq], \lin, ~panRound[tr][seq]) }, // R
		{ |tr, seq| ~panMax[tr][seq] = -1; ~panMin[tr][seq] = 0; ~panSpec[tr][seq] = ControlSpec(~panMin[tr][seq], ~panMax[tr][seq], \lin, ~panRound[tr][seq]) }, // L -> C
		{ |tr, seq| ~panMax[tr][seq] = 0; ~panMin[tr][seq] = 1; ~panSpec[tr][seq] = ControlSpec(~panMin[tr][seq], ~panMax[tr][seq], \lin, ~panRound[tr][seq]) }, // R -> C
		{ |tr, seq| ~panMax[tr][seq] = -0.5; ~panMin[tr][seq] = 0.5; ~panSpec[tr][seq] = ControlSpec(~panMin[tr][seq], ~panMax[tr][seq], \lin, ~panRound[tr][seq]) }, // LC -> RC
		{ |tr, seq| ~panMax[tr][seq] = -1; ~panMin[tr][seq] = 1; ~panSpec[tr][seq] = ControlSpec(~panMin[tr][seq], ~panMax[tr][seq], \lin, ~panRound[tr][seq]) } // L -> R
	];

	~panRangePresetItems = ["Links", "Centre", "Right", "L->C", "R->C", "LC-RC", "L->R"];
	~panRangePresetItemsG = ["L", "C", "R", "LC", "RC", "MID", "ALL"];
	~panRangePreset = ~panRangePresetItems.size-1 ! ~nbOfSeqs ! ~nbOfTracksX2;

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\panRoundViewFunc, 1, -1, 0, 0, 0.01,
		\panComp, \panDisplay, 75, "~panView.valueAction_(~panSpec[", "].unmap(~panMul[",
		\panView, \pan, \panSpec, false, true, "NoMultiViewValueThumbSize", ~compColor1 /*à essayer plus soft*/ /*~panCompColor*/, ~multiPanCompColor, Color.white,
		\panSeqView, \panSeqStart, \panSeqStop, \seqDurPan, \panSeqSpec, \panSeqSpec2, \panSeqVSpec, \panSeqVSpec2,
		\panIndexView, \panIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\panRangeView, \panMin, \panMax, \panRangeSpec, "NoRangeViewMinRange", ~sliderHilightNoColor, \panRangePresetViewView, \panRangePresetView, ~panRangePresetItems, (~panRangePresetItems.size-1), "->", 1,
		\panMulView, \panMul, \panMulSpec, ~sliderHilightColor, \panMulPresetViewView, \panMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\panRoundViewView, \panRoundView, ~roundViewPos5, \panRound, \panRoundValue, ["@ 0.01", "@ 0.1", "@ 0.2", "@ 0.25", "@ 0.5", "@ 1"], 0,
		\panRandView, \panning,
		\panSeqAllView, \panRangeMode, \panSeqMode,
		\panCopyAView, \panCopyA, \panPasteAView, \panPasteA, \panPasteMView, \panPasteM, \panDefaultView, \panDefault,
		\panDirView, \panDir, \panPatView, \panPat, \panPatSelViewView, \panPatSelView, \panPatSel, \panBlock,
		\panShowView, ~nameModPos, \center, Color.green, "PAN",
		\panReadView, Color.grey(0.6) /*Color.blue*/ /*~panCompColor.alpha_(0)*/, \panPosView
	);

	~panRatSpec = ControlSpec(0, 16000, 10, 0.1); // Pourquoi exp ne fonctionne pas ???
	~panRatView = SmoothSlider(~panComp, ~miniSlider1Pos5)
	.action_({ |view| ~panRat[~tracksValue][~seqsValue] = ~panRatSpec.map(view.value);
		view.string = "P : %".format(~panRat[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(~sliderBackgroundColor /*Color.magenta*/)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~panRatSpec.unmap(0))
	.doAction;

	~pAmpSpec = ControlSpec(0, 1, \lin, 0.01);
	~pAmpView = SmoothSlider(~panComp, ~miniSlider2Pos5)
	.action_({ |view| ~pAmp[~tracksValue][~seqsValue] = ~pAmpSpec.map(view.value);
		view.string = "PA : %".format(~pAmp[~tracksValue][~seqsValue]);
	})
	.font_(Font("Verdana", 9*~fontSizeMul))
	.background_(~sliderBackgroundColor /*Color.magenta*/)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~pAmpSpec.unmap(0))
	.doAction;





	// GUI DEL

	~posDel = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		\delRoundViewFunc, 0, 0.01, 0, 0, 0.001,
		\delComp, \delDisplay, 75, "~delView.valueAction_(~delSpec[", "].unmap(~delMul[",
		\delView, \del, \delSpec, false, true, 10,  ~compColor1, ~multiCompColor1, /*~compColor2, ~multiCompColor2,*/ Color.white,
		\delSeqView, \delSeqStart, \delSeqStop, \seqDurDel, \delSeqSpec, \delSeqSpec2, \delSeqVSpec, \delSeqVSpec2,
		\delIndexView, \delIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\delRangeView, \delMin, \delMax, \delRangeSpec, "NoRangeViewMinRange", ~sliderHilightNoColor, \delRangePresetViewView, \delRangePresetView, ["0->0.005", "0->0.01", "0->0.02", "0->0.05", "0->0.1", "0->0.2", "0->0.5", "0->1"], 1, "->", 1,
		\delMulView, \delMul, \delMulSpec, ~sliderHilightNoColor, \delMulPresetViewView, \delMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\delRoundViewView, \delRoundView, ~roundViewPos5, \delRound, \delRoundValue, ["@ 0.001", "@ 0.01", "@ 0.1", "@ 0.2", "@ 0.25", "@ 0.5", "@ 1"], 0,
		\delRandView, \delay,
		\delSeqAllView, \delRangeMode, \delSeqMode,
		\delCopyAView, \delCopyA, \delPasteAView, \delPasteA, \delPasteMView, \delPasteM, \delDefaultView, \delDefault,
		\delDirView, \delDir, \delPatView, \delPat, \delPatSelViewView, \delPatSelView, \delPatSel, \delBlock,
		\delShowView, ~nameModPos, \center, Color.green, "DEL",
		\delReadView, Color.grey(0.6), \delPosView
	);





	// GUI OUT L & R

	~posOutL = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~posOutR = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern

	~outRandOnBothView = RoundButton(~tabGUI, Rect(1259*~xSizeMul, 784*~ySizeMul/*-216*/, 42*~xSizeMul, 16*~ySizeMul)) // décaler de 399 & 216 pour ajuster la position
	.states_([["\Rand 2", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| ~randOutView.valueAction_(1) });

	~outActOnWhichView = RoundButton(~tabGUI, Rect(1536*~xSizeMul, 802*~ySizeMul/*-216*/, 36*~xSizeMul, 22*~ySizeMul))
	.states_([["\Act \n on 1", Color.white, Color.blue], ["Act \n on 2", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| ~outActOnWhich = i.value; if (~outActOnWhich == 1, { ~outCompChooseView.valueAction_(0) }) })
	.valueAction_(0).doAction;

	~outLGrid = UserView(/*~outStackCompL*/ ~outLComp, Rect(2*~xSizeMul, 18*~ySizeMul, 333*~xSizeMul, 116*~ySizeMul) /*~outLView.bounds*/).mouseDownAction_(false).mouseUpAction_(false).mouseMoveAction_(false);
	~outRGrid = UserView(/*~outStackCompL*/ ~outRComp, Rect(2*~xSizeMul, 18*~ySizeMul, 333*~xSizeMul, 116*~ySizeMul) /*~outLView.bounds*/).mouseDownAction_(false).mouseUpAction_(false).mouseMoveAction_(false);

	~makeGrid = { | view, name, minL, minR, maxL, maxR |
		// name = UserView(/*~outStackCompL*/ view, Rect(2, 18, 333, 116) /*~outLView.bounds*/).clearOnRefresh_(true)
		var links = maxL-minL;
		var right = maxR-minR;
		var nbLines = links+1;
		var prevL;
		if (links == right and: {prevL != links}, {
			name.drawFunc_({
				Pen.strokeColor = Color.black;
				// 5.do{ arg i; Pen.line(((~outLView.bounds.width/5)*i)@~outLView.bounds.height,((~outLView.bounds.width/5)*i)@0); };
				case
				{nbLines <= 3}
				{nbLines.do{ arg j; Pen.line(2@((name.bounds.height-8/nbLines).floor*j+3), name.bounds.width-2@((name.bounds.height-8/nbLines).floor*j+3))}}
				{nbLines == 4}
				{nbLines.do{ arg j; Pen.line(2@((name.bounds.height-6/nbLines).floor*j+3), name.bounds.width-2@((name.bounds.height-6/nbLines).floor*j+3))}}
				{nbLines == 5}
				{nbLines.do{ arg j; Pen.line(2@((name.bounds.height-4/nbLines).floor*j+3), name.bounds.width-2@((name.bounds.height-4/nbLines).floor*j+3))}}
				{nbLines > 5 and:{nbLines < 8}}
				{nbLines.do{ arg j; Pen.line(2@((name.bounds.height-4/nbLines).floor*j+2), name.bounds.width-2@((name.bounds.height-4/nbLines).floor*j+2))}}
				{nbLines.inclusivelyBetween(8,16)}
				{nbLines.do{ arg j; Pen.line(2@((name.bounds.height-4/nbLines).floor*j+1), name.bounds.width-2@((name.bounds.height-4/nbLines).floor*j+1))}};
				Pen.stroke;
			});
			name.refresh; // "Act".postln;
		});
		prevL = links;
	};

	// ~makeGrid.(~outLComp, ~numChannels, ~outLGrid, ~numChannels, ~numChannels); // intégré dans le RangeView
	// ~makeGrid.(~outRComp, ~numChannels, ~outRGrid, ~numChannels, ~numChannels);

	/*
	u = UserView(~outLView, Rect(0, 0, 333, 116));
	/*x =  \freq.asSpec.grid;
	y =  \amp.asSpec.grid;*/
	x =  ControlSpec(0, 5, \lin).grid;
	y =  \amp.asSpec.grid;
	~drawGrid = DrawGrid(Rect(2, 18, 333, 116), nil,y);
	// GridLines
	u.drawFunc = {~drawGrid.draw};
	*/

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		"NoRoundViewFunc", 1, "NoMaxDefault", ~rightChannel, "NoRoundValueDefault", "NoRoundDefault",
		\outRComp, \outRDisplay, 77, "~outRView.valueAction_(~outRSpec[", "].unmap(~outRMul[",
		\outRView, \outR, \outRSpec, false, false, "NoMultiViewValueThumbSize", Color(0.32, 0.32, 0.32, 0) /*~compColor1*/ /*à essayer plus soft*/ /*~panCompColor*/, Color.yellow /*~multiPanCompColor*/, Color.red,
		\outRSeqView, \outRSeqStart, \outRSeqStop, \seqDurOutR, \outRSeqSpec, \outRSeqSpec2, \outRSeqVSpec, \outRSeqVSpec2,
		\outRIndexView, \outRIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\outRRangeView, \outRMin, \outRMax, \outRRangeSpec, if (~numChannels == 2, {(1/16)}, {(1/(~numChannels-1))} ) /*(1/~numChannels)*/, ~sliderHilightNoColor, \outRRangePresetViewView, \outRRangePresetView, ["1->2", "1->3", "3->5", "4->5", "1->5", "1->6", "1->7", "1->8", "1->14", "1->16", "1->32"], if (~numChannelsConfig == "22-8+Dome-8-4-2-Pair", {8}, {10}), "->", "NoRangeMax",
		\outRMulView, \outRMul, \outRMulSpec, ~sliderHilightNoColor, \outRMulPresetViewView, \outRMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\outRRoundViewView, \outRRoundView, Rect(2*~xSizeMul, 136*~ySizeMul, 57*~xSizeMul, 16*~ySizeMul) /*~roundViewPos5*/, \outRRound, \outRRoundValue, ["L Tr 1", "R Tr 1", "L Tr 2", "R Tr 2", "L Tr 3", "R Tr 3", "L Tr 4", "R Tr 4", "L Tr 5", "R Tr 5", "L Tr 6", "R Tr 6", "L Tr 7", "R Tr 7", "L Tr 8", "R Tr 8"], 1, // roundView & roundViewDefault à modifier selon le nombre de canaux
		\outRRandView, \outingR,
		\outRSeqAllView, \outRRangeMode, \outRSeqMode,
		\outRCopyAView, \outRCopyA, \outRPasteAView, \outRPasteA, \outRPasteMView, \outRPasteM, \outRDefaultView, \outRDefault,
		\outRDirView, \outRDir, \outRPatView, \outRPat, \outRPatSelViewView, \outRPatSelView, \outRPatSel, \outRBlock,
		\outRShowView, ~nameModPos2, \left, Color.green, "OUT    R",
		\outRReadView, Color.grey(0.6) /*Color.blue*/ /*~panCompColor.alpha_(0)*/, \outRPosView
	);

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		"NoRoundViewFunc", 1, "NoMaxDefault", ~linksChannel, "NoRoundValueDefault", "NoRoundDefault",
		\outLComp, \outLDisplay, 77, "~outLView.valueAction_(~outLSpec[", "].unmap(~outLMul[",
		\outLView, \outL, \outLSpec, false, false, "NoMultiViewValueThumbSize", Color(0.32, 0.32, 0.32, 0) /*~compColor1*/ /*à essayer plus soft*/ /*~panCompColor*/, /*Color.new255(25, 25, 112)*/ ~multiPanCompColor, Color.white,
		\outLSeqView, \outLSeqStart, \outLSeqStop, \seqDurOutL, \outLSeqSpec, \outLSeqSpec2, \outLSeqVSpec, \outLSeqVSpec2,
		\outLIndexView, \outLIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\outLRangeView, \outLMin, \outLMax, \outLRangeSpec, if (~numChannels == 2, {(1/16)}, {(1/(~numChannels-1))} ) /*(1/~numChannels)*/, ~sliderHilightNoColor, \outLRangePresetViewView, \outLRangePresetView, ["1->2", "1->3", "3->5", "4->5", "1->5", "1->6", "1->7", "1->8", "1->14", "1->16", "1->32"], if (~numChannelsConfig == "22-8+Dome-8-4-2-Pair", {8}, {10}), "->", "NoRangeMax",
		\outLMulView, \outLMul, \outLMulSpec, ~sliderHilightNoColor, \outLMulPresetViewView, \outLMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\outLRoundViewView, \outLRoundView, Rect(2*~xSizeMul, 136*~ySizeMul, 57*~xSizeMul, 16*~ySizeMul) /*~roundViewPos5*/, \outLRound, \outLRoundValue, ["L Tr 1", "R Tr 1", "L Tr 2", "R Tr 2", "L Tr 3", "R Tr 3", "L Tr 4", "R Tr 4", "L Tr 5", "R Tr 5", "L Tr 6", "R Tr 6", "L Tr 7", "R Tr 7", "L Tr 8", "R Tr 8"], 0, // roundView & roundViewDefault à modifier selon le nombre de canaux
		\outLRandView, \outingL,
		\outLSeqAllView, \outLRangeMode, \outLSeqMode,
		\outLCopyAView, \outLCopyA, \outLPasteAView, \outLPasteA, \outLPasteMView, \outLPasteM, \outLDefaultView, \outLDefault,
		\outLDirView, \outLDir, \outLPatView, \outLPat, \outLPatSelViewView, \outLPatSelView, \outLPatSel, \outLBlock,
		\outLShowView, ~nameModPos2, \left, Color.green, "OUT L",
		\outLReadView, Color.grey(0.6) /*Color.blue*/ /*~panCompColor.alpha_(0)*/, \outLPosView
	);





	// GUI FX L & R

	// Ligne d'effets

	~posFxL = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern
	~posFxR = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Déclaration variables pour le Pattern

	~numEffects = 5;

	~fxLGrid = UserView(/*~fxStackCompL*/ ~fxLComp, Rect(2*~xSizeMul, 18*~ySizeMul, 333*~xSizeMul, 116*~ySizeMul) /*~fxLView.bounds*/).mouseDownAction_(false).mouseUpAction_(false).mouseMoveAction_(false);
	~fxRGrid = UserView(/*~fxStackCompL*/ ~fxRComp, Rect(2*~xSizeMul, 18*~ySizeMul, 333*~xSizeMul, 116*~ySizeMul) /*~fxLView.bounds*/).mouseDownAction_(false).mouseUpAction_(false).mouseMoveAction_(false);

	// ~makeGrid.(~fxLComp, ~numEffects+1, ~fxLGrid, ~numChannels, ~numChannels); // intégré dans le RangeView
	// ~makeGrid.(~fxRComp, ~numEffects+1, ~fxRGrid, ~numChannels, ~numChannels);

	~fxRandOnBothView = RoundButton(~tabGUI, Rect(1259*~xSizeMul, (784+216)*~ySizeMul, 42*~xSizeMul, 16*~ySizeMul))
	.states_([["\Rand 2", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| ~randFxView.valueAction_(1); /*var previousfxActOnWhich = ~fxActOnWhich; ~fxActOnWhichView.valueAction_(0); ~fxLRandView.valueAction_(1); ~fxRRandView.valueAction_(1); ~fxActOnWhichView.valueAction_(previousfxActOnWhich)*/ });

	~fxActOnWhichView = RoundButton(~tabGUI, Rect(1536*~xSizeMul, (802+216)*~ySizeMul, 30*~xSizeMul, 38*~ySizeMul))
	.states_([["\Act \n on 1", Color.white, Color.blue], ["Act \n on 2", Color.white, Color.red]])
	.font_(Font("Verdana",9*~fontSizeMul))
	.action_({|i| ~fxActOnWhich = i.value; if (~fxActOnWhich == 1, { ~outCompChooseView.valueAction_(0) }) })
	.valueAction_(1);

	// Ordre inversé pour que FxL agisse sur FxR
	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		"NoRoundViewFunc", 0, ~numEffects, 0, "NoRoundValueDefault", "NoRoundDefault",
		\fxRComp, \fxRDisplay, 75, "~fxRView.valueAction_(~fxRSpec[", "].unmap(~fxRMul[",
		\fxRView, \fxR, \fxRSpec, false, false, "NoMultiViewValueThumbSize", Color(0.32, 0.32, 0.32, 0) /*~compColor1*/ /*à essayer plus soft*/ /*~fxCompColor*/, Color.yellow /*~multiFxCompColor*/, Color.red,
		\fxRSeqView, \fxRSeqStart, \fxRSeqStop, \seqDurFxR, \fxRSeqSpec, \fxRSeqSpec2, \fxRSeqVSpec, \fxRSeqVSpec2,
		\fxRIndexView, \fxRIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\fxRRangeView, \fxRMin, \fxRMax, \fxRRangeSpec, (1/~numEffects), ~sliderHilightNoColor, \fxRRangePresetViewView, \fxRRangePresetView, ["0->4", "0->5", "0->8"], 1, "->", ~numEffects,
		\fxRMulView, \fxRMul, \fxRMulSpec, ~sliderHilightNoColor, \fxRMulPresetViewView, \fxRMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\fxRRoundViewView, \fxRRoundView, Rect(2*~xSizeMul, 136*~ySizeMul, 57*~xSizeMul, 16*~ySizeMul) /*~roundViewPos5*/, \fxRRound, \fxRRoundValue, ["No Fx", "Fx 1", "Fx 2", "Fx 3", "Fx 4"], 0,
		\fxRRandView, \efxR,
		\fxRSeqAllView, \fxRRangeMode, \fxRSeqMode,
		\fxRCopyAView, \fxRCopyA, \fxRPasteAView, \fxRPasteA, \fxRPasteMView, \fxRPasteM, \fxRDefaultView, \fxRDefault,
		\fxRDirView, \fxRDir, \fxRPatView, \fxRPat, \fxRPatSelViewView, \fxRPatSelView, \fxRPatSel, \fxRBlock,
		\fxRShowView, ~nameModPos2, \left, Color.green /*Color.new255(255, 165, 0)*/, "FX    R",
		\fxRReadView, Color.grey(0.6) /*Color.green*/ /*~fxCompColor.alpha_(0)*/, \fxRPosView
	);

	~makeModuleWindow.(currentEnvironment,
		// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
		"NoRoundViewFunc", 0, ~numEffects, 0, "NoRoundValueDefault", "NoRoundDefault",
		\fxLComp, \fxLDisplay, 75, "~fxLView.valueAction_(~fxLSpec[", "].unmap(~fxLMul[",
		\fxLView, \fxL, \fxLSpec, false, false, "NoMultiViewValueThumbSize", Color(0.32, 0.32, 0.32, 0) /*~compColor1*/ /*à essayer plus soft*/ /*~fxCompColor*/, ~multiFxCompColor /*Color.new255(25, 25, 112)*/, Color.white,
		\fxLSeqView, \fxLSeqStart, \fxLSeqStop, \seqDurFxL, \fxLSeqSpec, \fxLSeqSpec2, \fxLSeqVSpec, \fxLSeqVSpec2,
		\fxLIndexView, \fxLIndex,
		// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign, rangeMax,
		\fxLRangeView, \fxLMin, \fxLMax, \fxLRangeSpec, (1/~numEffects), ~sliderHilightNoColor, \fxLRangePresetViewView, \fxLRangePresetView, ["0->4", "0->5", "0->8"], 1, "->", ~numEffects,
		\fxLMulView, \fxLMul, \fxLMulSpec, ~sliderHilightNoColor, \fxLMulPresetViewView, \fxLMulPresetView, ["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"], 10,
		\fxLRoundViewView, \fxLRoundView, Rect(2*~xSizeMul, 136*~ySizeMul, 57*~xSizeMul, 16*~ySizeMul) /*~roundViewPos5*/, \fxLRound, \fxLRoundValue, ["No Fx", "Fx 1", "Fx 2", "Fx 3", "Fx 4"], 0,
		\fxLRandView, \efxL,
		\fxLSeqAllView, \fxLRangeMode, \fxLSeqMode,
		\fxLCopyAView, \fxLCopyA, \fxLPasteAView, \fxLPasteA, \fxLPasteMView, \fxLPasteM, \fxLDefaultView, \fxLDefault,
		\fxLDirView, \fxLDir, \fxLPatView, \fxLPat, \fxLPatSelViewView, \fxLPatSelView, \fxLPatSel, \fxLBlock,
		\fxLShowView, ~nameModPos2, \left, Color.green /*Color.new255(255, 165, 0)*/, "FX L",
		\fxLReadView, Color.grey(0.6) /*Color.green*/ /*~fxCompColor.alpha_(0)*/, \fxLPosView
	);

}.value;





// Pour les ranges par défaut des multisliders utilisés dans le module syn
~synthDescLibRangeViews = [~ratRangeView, ~rat2RangeView, ~strRangeView, ~str2RangeView, ~cenRangeView, ~cen2RangeView, ~offRangeView, ~off2RangeView, ~off3RangeView, ~off4RangeView];
~synthDescLibRangeSpecs = [~ratRangeSpec, ~rat2RangeSpec, ~strRangeSpec, ~str2RangeSpec, ~cenRangeSpec, ~cen2RangeSpec, ~offRangeSpec, ~off2RangeSpec, ~off3RangeSpec, ~off4RangeSpec];
~synthDescLibMulViews = [~ratMulView, ~rat2MulView, ~strMulView, ~str2MulView, ~cenMulView, ~cen2MulView, ~offMulView, ~off2MulView, ~off3MulView, ~off4MulView];
~synthDescLibMulSpecs = [~ratMulSpec, ~rat2MulSpec, ~strMulSpec, ~str2MulSpec, ~cenMulSpec, ~cen2MulSpec, ~offMulSpec, ~off2MulSpec, ~off3MulSpec, ~off4MulSpec];
~synthDescLibSpecs = [~ratSpec, ~rat2Spec, ~strSpec, ~str2Spec, ~cenSpec, ~cen2Spec, ~offSpec, ~off2Spec, ~off3Spec, ~off4Spec];
~synthDescLibIndexViews = [~ratIndexView, ~rat2IndexView, ~strIndexView, ~str2IndexView, ~cenIndexView, ~cen2IndexView, ~offIndexView, ~off2IndexView, ~off3IndexView, ~off4IndexView];
~synthDescLibNames = ["RAT ", "RAT2", "STR ", "STR2", "CEN ", "CEN2", "OFF ", "OFF2", "OFF3", "OFF4"];





/*
{ // Fonction Value pour RAT... pour éviter ERROR: Selector table too big: too many classes, method selectors or function definitions in this function

// GUI RATE

~ratRoundViewFunc = [
{ |tr, seq| ~ratRound[~tracksValue][~seqsValue]=0.01; ~ratRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, 128, 4, ~ratRound[~tracksValue][~seqsValue])},
{ |tr, seq| ~ratRound[~tracksValue][~seqsValue]=0.1; ~ratRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, 128, 4, ~ratRound[~tracksValue][~seqsValue])},
{ |tr, seq| ~ratRound[~tracksValue][~seqsValue]=0.2; ~ratRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, 128, 4, ~ratRound[~tracksValue][~seqsValue])},
{ |tr, seq| ~ratRound[~tracksValue][~seqsValue]=0.5; ~ratRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, 128, 4, ~ratRound[~tracksValue][~seqsValue])},
{ |tr, seq| ~ratRound[~tracksValue][~seqsValue]=0.01; ~ratRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, 128, \lin, ~ratRound[~tracksValue][~seqsValue])},
{ |tr, seq| ~ratRound[~tracksValue][~seqsValue]=0.1; ~ratRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, 128, \lin, ~ratRound[~tracksValue][~seqsValue])},
{ |tr, seq| ~ratRound[~tracksValue][~seqsValue]=0.125; ~ratRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, 128, \lin, ~ratRound[~tracksValue][~seqsValue])},
{ |tr, seq| ~ratRound[~tracksValue][~seqsValue]=0.25; ~ratRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, 128, \lin, ~ratRound[~tracksValue][~seqsValue])},
{ |tr, seq| ~ratRound[~tracksValue][~seqsValue]=0.5; ~ratRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, 128, \lin, ~ratRound[~tracksValue][~seqsValue])},
{ |tr, seq| ~ratRound[~tracksValue][~seqsValue]=1; ~ratRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, 128, \lin, ~ratRound[~tracksValue][~seqsValue])},
{ |tr, seq| ~ratRound[~tracksValue][~seqsValue]=2; ~ratRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, 128, \lin, ~ratRound[~tracksValue][~seqsValue])}
];


~tracks.collect { |tr|
~seqs.collect { |seq|

~ratRound[tr][seq] = 0.01;
~ratMin[tr][seq] = 0.0;
~ratMax[tr][seq] = 2.0;
~ratMul[tr][seq] = 1;

~ratRangeSpec[tr][seq] = ControlSpec(0, 128, \exp, ~ratRound[tr][seq]);
~ratSpec[tr][seq] = ControlSpec(~ratMin[tr][seq], ~ratMax[tr][seq], \lin, ~ratRound[tr][seq]);
~rat[tr][seq] = ~ratSpec[tr][seq].unmap(1) !4;
~ratSeqSpec[tr][seq] = ControlSpec(0, ~rat[tr][seq].size, \lin, 1);
~ratSeqSpec2[tr][seq] = ControlSpec(0, ~rat[tr][seq].size, \lin, 1);
~ratMulSpec[tr][seq] = ControlSpec(0.01, 10, 4, 0.01, 1);

~ratSeqStart[tr][seq] = 0;
~ratSeqStop[tr][seq] = ~ratSeqSpec[tr][seq].map(1).asInteger - 1;
~seqDurRat[tr][seq] = ~ratSeqStop[tr][seq] - ~ratSeqStart[tr][seq] + 1;
~ratRoundValue[tr][seq] = 0;

}};


~ratDisplay = TextView(~ratComp, ~displayPos5)
.hasVerticalScroller_(false)
.hasHorizontalScroller_(false)
.enterInterpretsSelection_(1)
.font_(Font("arial",10));

~ratView = MultiSliderView.new(~ratComp, ~viewPos5);
~ratView.value_(~rat[~tracksValue][~seqsValue])
.background_(~compColor1)
.strokeColor_(Color.white)
.fillColor_(~multiCompColor1)
.elasticMode_(1)
.isFilled_(false)
.drawLines_(true)
.thumbSize_(~ratView.bounds.width / (~rat[~tracksValue][~seqsValue].size))
.valueThumbSize_(10)
.showIndex_(true)
.action_({ | view |
view.value.do({|x, i|
~rat[~tracksValue][~seqsValue][i] = x});
~ratDisplay.string_(("~ratView.valueAction_(~ratSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~ratMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~ratSpec[~tracksValue][~seqsValue].map(~rat[~tracksValue][~seqsValue]) * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue]).asCompileString+"));").asString); ~ratDisplay.setFont((Font("arial",1)), 4, 75);
});

~ratSeqView = SmoothRangeSlider(~ratComp, ~seqViewPos5)
.action_({ |view| ~ratSeqStart[~tracksValue][~seqsValue] = ~ratSeqSpec[~tracksValue][~seqsValue].map(view.lo).asInteger; ~ratSeqStop[~tracksValue][~seqsValue] = ~ratSeqSpec[~tracksValue][~seqsValue].map(view.hi).asInteger-1;
~seqDurRat[~tracksValue][~seqsValue] = ~ratSeqStop[~tracksValue][~seqsValue] - ~ratSeqStart[~tracksValue][~seqsValue] + 1;
view.string = ("% to % (Dur : %)").format(~ratSeqStart[~tracksValue][~seqsValue], ~ratSeqStop[~tracksValue][~seqsValue], ~seqDurRat[~tracksValue][~seqsValue]);
// Changement de couleur si toute le séquence n'est pas sélectionnée - vraiment nécessaire ???
if (view.range != 1, {view.background = Color.red}, {view.background = ~sliderBackgroundColor});
// Zoom multislider
if (~zoomMultiSlider == 1, {
~ratView.valueAction_(~rat[~tracksValue][~seqsValue][(0..max(0,~ratSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
~ratView.startIndex_(~ratSeqStart[~tracksValue][~seqsValue]);
~ratView.indexThumbSize_(~ratView.bounds.width / ~seqDurRat[~tracksValue][~seqsValue]);
~ratSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurRat[~tracksValue][~seqsValue], \lin, 1); // Pour le Slider ReadView
});
})
.font_(Font("Verdana", 10))
.background_(~sliderBackgroundColor)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor)
.value_([0, 1])
.minRange_(1/(~rat[~tracksValue][~seqsValue].size))
.step_(1/(~rat[~tracksValue][~seqsValue].size))
.doAction;

~ratIndexView = SmoothSlider(~ratComp, ~indexViewPos5)
.action_({ |view| ~ratIndex[~tracksValue][~seqsValue] = ~ratSpec[~tracksValue][~seqsValue].map(view.value);
view.string = "At : %".format((~ratIndex[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue]));
// ~ratView.valueAction_(~ratIndex[~tracksValue][~seqsValue].curvelin(~ratMin[~tracksValue][~seqsValue], ~ratMax[~tracksValue][~seqsValue], 0, 1, 2) ! ~rat[~tracksValue][~seqsValue].size)
// Modif pour action sur multislider seulement sur la sélection de la séquence au lieu de toute la séquence
// ~ratView.valueAction_(~rat[~tracksValue][~seqsValue].putEach([(~ratSeqStart[~tracksValue][~seqsValue]..~ratSeqStop[~tracksValue][~seqsValue])], [~ratSpec[~tracksValue][~seqsValue].unmap(~ratIndex[~tracksValue][~seqsValue])] ));

// Zoom Multislider
if (~zoomMultiSlider == 1, {
~ratView.valueAction_(~rat[~tracksValue][~seqsValue][(0..max(0,~ratSeqStop[~tracksValue][~seqsValue]))].putEach([(~ratSeqStart[~tracksValue][~seqsValue]..~ratSeqStop[~tracksValue][~seqsValue])], [~ratSpec[~tracksValue][~seqsValue].unmap(~ratIndex[~tracksValue][~seqsValue])] )); // apparemment pas besoin de flat
}, { ~ratView.valueAction_(~rat[~tracksValue][~seqsValue].putEach([(~ratSeqStart[~tracksValue][~seqsValue]..~ratSeqStop[~tracksValue][~seqsValue])], [~ratSpec[~tracksValue][~seqsValue].unmap(~ratIndex[~tracksValue][~seqsValue])] ));
});
})
.valueAction_(~ratSpec[~tracksValue][~seqsValue].unmap(1)) // pour initialiser les valeurs du View au chargement
.font_(Font("Verdana", 10))
.background_(~sliderBackgroundColor)
.hilightColor_(~sliderHilightColor)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor)
.doAction;

~ratRangeView = SmoothRangeSlider(~ratComp, ~rangeViewPos5)
.action_({ |view| ~ratMin[~tracksValue][~seqsValue] = (~ratRangeSpec[~tracksValue][~seqsValue].map(view.lo)); ~ratMax[~tracksValue][~seqsValue] = (~ratRangeSpec[~tracksValue][~seqsValue].map(view.hi));
~ratSpec[~tracksValue][~seqsValue] = ControlSpec(~ratMin[~tracksValue][~seqsValue], ~ratMax[~tracksValue][~seqsValue], \lin, ~ratRound[~tracksValue][~seqsValue]);
// view.string = "%\n to \n%".format(~ratMax[~tracksValue][~seqsValue], ~ratMin[~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
view.string_("%\n to \n%".format(
(if ((~ratMax[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]) > 100, { (~ratMax[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(1) }, {(~ratMax[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue])})),
(if ((~ratMin[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]) > 100, { (~ratMin[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(1) }, {(~ratMin[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue])}))));
// Le changement de step provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
// Le changement de step provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step  si > à 0.1
// si lancement d'une routine pour automatisation, le tête de lecture visuelle sur le multislider sera perturbé
if (~ratRound[~tracksValue][~seqsValue]> 0.1, {~ratView.step_(1/(((~ratMax[~tracksValue][~seqsValue])-(~ratMin[~tracksValue][~seqsValue]))/~ratRound[~tracksValue][~seqsValue]))});
~ratIndexView.step_(1/(((~ratMax[~tracksValue][~seqsValue])-(~ratMin[~tracksValue][~seqsValue]))/~ratRound[~tracksValue][~seqsValue]));
~ratIndexView.string_("At : %".format((~ratSpec[~tracksValue][~seqsValue].map(~ratIndexView.value) * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue]))); // léger pb de rounding ?
~ratDisplay.string_(("~ratView.valueAction_(~ratSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~ratMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~ratSpec[~tracksValue][~seqsValue].map(~rat[~tracksValue][~seqsValue]) * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue]).asCompileString+"));").asString); ~ratDisplay.setFont((Font("arial",1)), 4, 75);
})
.font_(Font("Verdana", 8))
.background_(~sliderBackgroundColor)
.hilightColor_(~sliderHilightColor)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor)
.value_([0, 1])
.minRange_(~ratRangeSpec[~tracksValue][~seqsValue].unmap(~ratRound[~tracksValue][~seqsValue] * 4))
// .align = \center; // par défaut
.doAction;

// si changement du Mul, pas de changement du step & du round du Multislider -> donc round et step décalés, multipliés
// seulement répercusion sur le string du RangeView avec rounding des valeurs au delà de 100 pour faciliter l'affichage visuel
// obligé de mettre l'action en dessous quand Global est déclaré
~ratMulView = SmoothSlider(~ratComp, ~mulViewPos5)
/*.action_({ |view| ~ratMul[~tracksValue][~seqsValue] = ~ratMulSpec[~tracksValue][~seqsValue].map(view.value);
view.string = "%".format(~ratMul[~tracksValue][~seqsValue]);
~ratRangeView.string_("%\n to \n%".format(
(if ((~ratMax[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]) > 100, { (~ratMax[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(1) }, {(~ratMax[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue])})),
(if ((~ratMin[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]) > 100, { (~ratMin[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(1) }, {(~ratMin[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue])}))));
~ratIndexView.string_("At : %".format((~ratSpec[~tracksValue][~seqsValue].map(~ratIndexView.value) * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue]))); // léger pb de rounding ?
~ratDisplay.string_(("~ratView.valueAction_(~ratSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~ratMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~ratSpec[~tracksValue][~seqsValue].map(~rat[~tracksValue][~seqsValue]) * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue]).asCompileString+"));").asString); ~ratDisplay.setFont((Font("arial",1)), 4, 75);
})*/
.font_(Font("Verdana", 8))
.background_(~sliderBackgroundColor)
.hilightColor_(~sliderHilightColor)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor)
// .thumbSize_(10) // à retirer pour ne pas l'aligner sur le niveau du slider
// .stringAlignToKnob = true; // à retirer pour ne pas l'aligner sur le niveau du slider
.doAction;

~ratMulPresetView = PopUpMenu.new(~ratComp, ~mulPresetViewPos5)
.action_({ |menu| ~ratMulView.valueAction_(~ratMulSpec[~tracksValue][~seqsValue].unmap(menu.item.asFloat)) })
.allowsReselection_(true)
.background_(~popUpMenuBackgroundColor)
.stringColor_(~popUpMenuStringColor)
.font_(Font("Verdana",8));
~ratMulPresetView.items_(["0.01", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1", "1.5", "2", "3", "4", "5", "10"])
.valueAction_(10);

~ratRoundView = PopUpMenu.new(~ratComp, ~roundViewPos5)
.action_({ |menu| ~ratRoundViewFunc[menu.value].value(~tracksValue, ~seqsValue);
~ratRoundValue[~tracksValue][~seqsValue] = menu.value;
~ratSpec[~tracksValue][~seqsValue] = ControlSpec(~ratMin[~tracksValue][~seqsValue], ~ratMax[~tracksValue][~seqsValue], \lin, ~ratRound[~tracksValue][~seqsValue]);
~ratIndexView.step_(1/(((~ratMax[~tracksValue][~seqsValue])-(~ratMin[~tracksValue][~seqsValue]))/~ratRound[~tracksValue][~seqsValue]));
// Pas d'utilisation de step pour le rangeView car pas approprié lorsque ControlSpec est exp
// ~ratRangeView.step_(1/(128/~ratRound[~tracksValue][~seqsValue]));
~ratRangeView.minRange_(~ratRangeSpec[~tracksValue][~seqsValue].unmap(~ratRound[~tracksValue][~seqsValue] * 4));
~ratRangeView.valueAction_(~ratRangeSpec[~tracksValue][~seqsValue].unmap([~ratMin[~tracksValue][~seqsValue], ~ratMax[~tracksValue][~seqsValue]]));
// Le changement de step sur le Multislider provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
// Le changement de step sur le Multislider provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step si > à 0.1
if (~ratRound[~tracksValue][~seqsValue]> 0.1, {~ratView.step_(1/(((~ratMax[~tracksValue][~seqsValue])-(~ratMin[~tracksValue][~seqsValue]))/~ratRound[~tracksValue][~seqsValue]))}, {~ratView.step_(0)});
})
.allowsReselection_(true)
.background_(~popUpMenuBackgroundColor)
.stringColor_(~popUpMenuStringColor)
.font_(Font("Verdana",8));
~ratRoundView.items_(["@ 0.01 EXP", "@ 0.1 EXP", "@ 0.2 EXP", "@ 0.5 EXP", "@ 0.01 LIN", "@ 0.1 LIN", "@ 0.125 1÷16T LIN", "@ 0.25 1÷8T LIN", "@ 0.5 1÷4T LIN", "@ 1 1÷2T LIN", "@ 2 1T LIN"])
.valueAction_(0);

~ratRangePresetView = PopUpMenu.new(~ratComp, ~rangePresetViewPos5)
.action_({|menu| ~ratRangeView.valueAction_(~ratRangeSpec[~tracksValue][~seqsValue].unmap([menu.item.replace("-", " ").split($ )[0].asFloat, menu.item.replace("-", " ").split($ )[1].asFloat])) })
.allowsReselection_(true)
.background_(~popUpMenuBackgroundColor)
.stringColor_(~popUpMenuStringColor)
.font_(Font("Verdana",8));
~ratRangePresetView.items_(["0-0.5", "0-1", "0.5-1.5", "0-2", "0-3", "0-4", "0-5", "0-10", "0-20", "0-50", "0-100", "0-128", "36-84", "36-60", "60-84", "48-72"])
.valueAction_(3);

~freqRatSpec = ControlSpec(0, 16000, 10, 0.1); // Pourquoi exp ne fonctionne pas ???
~freqRatView = SmoothSlider(~ratComp, ~miniSlider1Pos5)
.action_({ |view| ~freqRat[~tracksValue][~seqsValue] = ~freqRatSpec.map(view.value);
view.string = "F : %".format(~freqRat[~tracksValue][~seqsValue]);
})
.font_(Font("Verdana", 9))
.background_(Color.magenta)
.hilightColor_(~sliderHilightColor)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor)
.valueAction_(~freqRatSpec.unmap(0))
.doAction;

~fAmpSpec = ControlSpec(0, 2, \lin, 0.01);
~fAmpView = SmoothSlider(~ratComp, ~miniSlider2Pos5)
.action_({ |view| ~fAmp[~tracksValue][~seqsValue] = ~fAmpSpec.map(view.value);
view.string = "FA : %".format(~fAmp[~tracksValue][~seqsValue]);
})
.font_(Font("Verdana", 9))
.background_(Color.magenta)
.hilightColor_(~sliderHilightColor)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor)
.valueAction_(~fAmpSpec.unmap(0))
.doAction;

~ratRandView = RoundButton(~ratComp, ~randViewPos5)
.states_([["Rand", Color.white, Color.red]])
.font_(Font("Verdana",8))
.action_({if (~patFlag == 0, {
~rate.value(~tracksValue, ~seqsValue)}, {
~seqs.do {|i|
~rate.value(~tracksValue, i);
~rat[~tracksValue][i] = {rrand(0.0,1.0)} ! ~dur[~tracksValue][i].size;
};
});
});

~ratSeqAllView = RoundButton(~ratComp, ~seqAllViewPos5)
.states_([["All Seq", Color.white, Color.blue]])
.font_(Font("Verdana",8))
.action_({~ratSeqView.valueAction_([0, 1]);
});

~ratRangeMode = RoundButton(~ratComp, ~rangeModePos5)
.states_([["\Drag", Color.white, Color.blue], ["\Jump", Color.black, Color.green]])
.font_(Font("Verdana",8))
.action_({|i| ~ratRangeView.mode_(~modes[i.value])});

~ratSeqMode = RoundButton(~ratComp, ~seqModePos5)
.states_([["\Drag", Color.white, Color.blue], ["\Jump", Color.black, Color.green]])
.font_(Font("Verdana",8))
.action_({|i| ~ratSeqView.mode_(~modes[i.value])})
.valueAction_(1);

~ratCopyAView = RoundButton(~ratComp, ~copyAViewPos5)
.states_([["CA", Color.red, Color.white]])
.font_(Font("Verdana",8))
.action_({~ratCopyA.value(~tracksValue, ~seqsValue);
});

~ratPasteAView = RoundButton(~ratComp, ~pasteAViewPos5)
.states_([["PA", Color.red, Color.white]])
.font_(Font("Verdana",8))
.action_({~ratPasteA.value(~tracksValue, ~seqsValue);
});

~ratPasteMView = RoundButton(~ratComp, ~pasteMViewPos5)
.states_([["PM", Color.black, Color.white]])
.font_(Font("Verdana",8))
.action_({~ratPasteM.value(~tracksValue, ~seqsValue);
});

~ratDefaultView = RoundButton(~ratComp, ~defaultViewPos5)
.states_([["Def", Color.white, Color.blue]])
.font_(Font("Verdana",8))
.action_({if (~patFlag == 0, {
~ratDefault.value(~tracksValue, ~seqsValue)}, {
~seqs.do {|i| ~ratDefault.value(~tracksValue, i)}});
});

~ratDirView = RoundButton(~ratComp, ~dirViewPos5)
.states_([["\>", Color.white, Color.blue], ["\<", Color.black, Color.green]])
.font_(Font("Verdana",8))
.action_({|i| ~ratDir[~tracksValue][~seqsValue] = i.value;
if (~patFlag == 1, {~seqs.do {|sequence| ~ratDir[~tracksValue][sequence] = i.value} });
});

~ratPatView = RoundButton(~ratComp, ~patViewPos5)
.states_([["Cyc", Color.white, Color.blue], ["Pat", Color.white, Color.red]])
.font_(Font("Verdana",8))
.action_({|i| ~ratPat[~tracksValue][~seqsValue] = i.value;
if (~ratPat[~tracksValue][~seqsValue] == 1, {~ratPatSelView.background_(Color.red).stringColor_(Color.white)}, {~ratPatSelView.background_(~popUpMenuBackgroundColor).stringColor_(~popUpMenuStringColor)} );
if (~patFlag == 1, {~seqs.do {|sequence| ~ratPat[~tracksValue][sequence] = i.value } });
});

~ratPatSelView = PopUpMenu.new(~ratComp, ~patSelViewPos5)
.action_({|menu| ~ratPatSel[~tracksValue][~seqsValue] = menu.value;
if (~patFlag == 1, {~seqs.do {|sequence| ~ratPatSel[~tracksValue][sequence] = menu.value }});
})
.allowsReselection_(true)
.background_(~popUpMenuBackgroundColor)
.stringColor_(~popUpMenuStringColor)
.font_(Font("Verdana",8));
~ratPatSelView.items_([["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch"], ~controlBusNames/*, ~controlBusNames01, ~controlBusNames0R*/].flatten)
.valueAction_(0);

}.value;
*/









( // Harmonisation

/*
// Multiples Chorus

~ratHarSeq[0][0]
~cenHarSeq[0][0]
~ampHarSeq[0][0]
~delHarSeq[0][0]
~spaHarSeq[0][0]

// A utiliser au lieu de la vitesse de lecture ??????
-96.midiratio
-12.midiratio
0.midiratio // 1
1.midiratio // 1.05
12.midiratio // 2
24.midiratio
36.midiratio
48.midiratio
60.midiratio
72.midiratio
84.midiratio
96.midiratio
80.midiratio
-80.midiratio
*/

~makeRandHarFunction = { | envir, funcName, data, multiView, dataDur, durData, seqView, seqStart, seqStop, seqSpec /*, index, seqVSpec, readView*/ |

	envir[funcName] = { | tr, seq |
		var dur = ~harIndex[~tracksValue][~seqsValue];

		if (envir[seqView].range == 1 || envir[data][~tracksValue][~seqsValue].size != dur, {
			envir[data][~tracksValue][~seqsValue] = {rrand(0.0,1.0)} ! dur;
			envir[multiView].valueAction_(envir[data][~tracksValue][~seqsValue]);
		}, {
			envir[multiView].valueAction_( envir[data][~tracksValue][~seqsValue].putEach((envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]), {rrand(0.0,1.0)} ! envir[durData][~tracksValue][~seqsValue]) );
		});

		envir[seqSpec][tr][seq] = ControlSpec(0, dur /*envir[dataDur][tr][seq].size*/, \lin, 1, 1);
		// envir[seqVSpec][tr][seq] = ControlSpec(0, envir[dataDur][tr][seq].size-1, \lin, 1, 1);
		// envir[readView].thumbSize_(max(~readViewThumbSize, 333 / envir[dataDur][tr][seq].size));
		envir[seqView].step_(1/(dur))
		.minRange_(1/(dur))
		.valueAction_(envir[seqView].value) // Léger bug visuel quand le nb de valeurs dans le multislider change et est inférieur -> OK maintenant
		.doAction; // nécessaire sinon toujours bug visuel quand le nb de valeurs dans le multislider change et est supérieur et pas de mise à jour si range = 1
	}
};

~ratHarDefault = { | track, seq |
	var seqDur = ~harIndex[track][seq]; // ~dur[track][seq].size;
	~ratHarRoundView.valueAction_(0);
	~ratHarRangePresetView.valueAction_(14);

	~ratHarSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
	~ratHarSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
	~ratHarSeqView.valueAction_([0, 1]); // pour englober toute la séquence
	// ~ratView.valueAction_(~ratSpec[track][seq].unmap(1) ! ~rat[track][seq].size);
	~ratHar[track][seq] = /*~ratSpec[track][seq].unmap(1)*/ 0.5 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
	~ratHarView.valueAction_(~ratHar[~tracksValue][~seqsValue]);

	~ratHarSeqMode.valueAction_(1);
	~ratHarRangeMode.valueAction_(0);
};

~cenHarDefault = { | track, seq |
	var seqDur = ~harIndex[track][seq];
	~cenHarRoundView.valueAction_(0);
	~cenHarRangePresetView.valueAction_(13);

	~cenHarSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
	~cenHarSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
	~cenHarSeqView.valueAction_([0, 1]); // pour englober toute la séquence
	// ~cenView.valueAction_(~cenSpec[track][seq].unmap(1) ! ~cen[track][seq].size);
	~cenHar[track][seq] = /*~cenSpec[track][seq].unmap(1)*/ 0.5 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
	~cenHarView.valueAction_(~cenHar[~tracksValue][~seqsValue]);

	~cenHarSeqMode.valueAction_(1);
	~cenHarRangeMode.valueAction_(0);
};

~delHarDefault = { | track, seq |
	var seqDur = ~harIndex[track][seq];
	~delHarRoundView.valueAction_(0);
	~delHarRangePresetView.valueAction_(1);

	~delHarSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
	~delHarSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
	~delHarSeqView.valueAction_([0, 1]); // pour englober toute la séquence
	// ~delView.valueAction_(~delSpec[track][seq].unmap(1) ! ~del[track][seq].size);
	~delHar[track][seq] = /*~delSpec[track][seq].unmap(1)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
	~delHarView.valueAction_(~delHar[~tracksValue][~seqsValue]);

	~delHarSeqMode.valueAction_(1);
	~delHarRangeMode.valueAction_(0);
};

~spaHarDefault = { | track, seq |
	var seqDur = ~harIndex[track][seq];
	~spaHarRoundView.valueAction_(0);
	~spaHarRangePresetView.valueAction_(~spaRangePresetItems.size-1);

	~spaHarSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
	~spaHarSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
	~spaHarSeqView.valueAction_([0, 1]); // pour englober toute la séquence
	// ~spaView.valueAction_(~spaSpec[track][seq].unmap(1) ! ~spa[track][seq].size);
	~spaHar[track][seq] = /*~spaSpec[track][seq].unmap(1)*/ 0 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
	~spaHarView.valueAction_(~spaHar[~tracksValue][~seqsValue]);

	~spaHarSeqMode.valueAction_(1);
	~spaHarRangeMode.valueAction_(0);
};

~ampHarDefault = { | track, seq |
	var seqDur = ~harIndex[track][seq];
	~ampHarRoundView.valueAction_(0);

	~ampHarSeqSpec[track][seq] = ControlSpec(0, seqDur, \lin, 1, 1);
	~ampHarSeqView.step_(1/seqDur).minRange_(1/seqDur).doAction;
	~ampHarSeqView.valueAction_([0, 1]); // pour englober toute la séquence
	~ampHar[track][seq] = /*~ratSpec[track][seq].unmap(1)*/ 0.5 ! seqDur; // pour mettre à jour le nb de valeurs dans le MultiSlider si besoin
	~ampHarView.valueAction_(~ampHar[~tracksValue][~seqsValue]);

	~ampHarSeqMode.valueAction_(1);
};

~spaHarSpecStereo = ControlSpec(0, 5, \lin, 1) ! ~nbOfSeqs ! ~nbOfTracksX2;

~makeModuleHarmWindow = { | envir,
	roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
	comp, display, displayReduceFontPos, displayString1,
	multiView, data, dataSeq, dataSpec, multiViewFilled, multiViewDrawLines, multiViewValueThumbSize, multiViewBackground, multiViewFillColor, multiViewStrokeColor,
	seqView, seqStart, seqStop, seqDur, seqSpec,
	rangeView, min, max, rangeSpec, rangeViewMinRange, rangeSliderColor, rangePresetViewView, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign,
	roundViewView, roundView, roundViewPos, round, roundValue, roundViewItems, roundViewDefault,
	randView, randFunc,
	seqAllView, rangeMode, seqMode,
	defaultView, default,
	showView, showViewPos, showViewAlign, showViewColor, showViewString
	|

	// Initialisation des Arrays
	envir[dataSpec] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[data] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[dataSeq] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	if ([\ampHar] != data, {
		envir[min] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
		envir[max] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
		envir[rangeSpec] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2
	});
	envir[seqSpec] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[seqStart] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[seqStop] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	envir[seqDur] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;


	if ( [\spaHar] != data, {
		// pas de ~synRound / ~spaRound / ~envRound / ~bufRound / ~fxLRound / ~fxRRound
		// spécial pour ~outLRound & ~outRRound
		envir[round] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
		envir[roundValue] = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	});


	// Fonctions

	case { [\ratHar, \cenHar].includes(data) }
	{
		envir[roundViewFunc] = [
			{ |tr, seq| envir[round][tr][seq]=0.01; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.1; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.125; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.2; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.25; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.5; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=1; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=2; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])}
		];
	}
	{ [\delHar].includes(data) }
	{
		envir[roundViewFunc] = [
			{ |tr, seq| envir[round][tr][seq]=0.001; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq]) },
			{ |tr, seq| envir[round][tr][seq]=0.01; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.1; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.2; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.25; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=0.5; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])},
			{ |tr, seq| envir[round][tr][seq]=1; envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, envir[round][tr][seq])}
		];
	}
	{ [\ampHar].includes(data) }
	{
		envir[roundViewFunc] = [
			{ |tr, seq| envir[round][tr][seq]=0.01; },
			{ |tr, seq| envir[round][tr][seq]=0.1; },
			{ |tr, seq| envir[round][tr][seq]=0.125; },
			{ |tr, seq| envir[round][tr][seq]=0.2; },
			{ |tr, seq| envir[round][tr][seq]=0.25; },
			{ |tr, seq| envir[round][tr][seq]=0.5; }
		];
		envir[dataSeq] = 0.5 ! ~nbOfSeqs ! ~nbOfTracksX2; // Necessité de les initialiser à 0.5 pour l'amplitude sinon pas de son XXXXXX
	};


	// Assignation des données
	~tracks.do { |tr|
		~seqs.do { |seq|

			envir[min][tr][seq] = minDefault;
			envir[max][tr][seq] = maxDefault;

			case
			{ [\ratHar, \cenHar, \delHar, \ampHar].includes(data) }
			{
				envir[round][tr][seq] = roundDefault;
				envir[roundValue][tr][seq] = roundValueDefault;
				envir[dataSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, roundDefault);
			}
			{ [\spaHar].includes(data) }
			{
				envir[dataSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, 1);
				envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault /*rangeMax*/, \lin, 1);
			};


			case
			{ [\ratHar, \cenHar].includes(data) }
			{
				envir[min][tr][seq] = -12 /*6*/; // liée à ~ratHarRangePresetView.value
				envir[max][tr][seq] = 12 /*6*/;
				envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, roundDefault);
			}
			{ [\delHar].includes(data) }
			{
				envir[max][tr][seq] = 0.01;
				envir[rangeSpec][tr][seq] = ControlSpec(minDefault, maxDefault, \lin, roundDefault);
			};


			envir[data][tr][seq] = envir[dataSpec][tr][seq].unmap(dataDefault) ! 3;
			envir[seqSpec][tr][seq] = ControlSpec(0, envir[data][tr][seq].size, \lin, 1);
			envir[seqStart][tr][seq] = 0;
			envir[seqStop][tr][seq] = envir[seqSpec][tr][seq].map(1).asInteger - 1;
			envir[seqDur][tr][seq] = envir[seqStop][tr][seq] - envir[seqStart][tr][seq] + 1;

		};
	};


	// GUI

	// TextDisplay

	envir[display] = TextView(envir[comp], ~displayHarPos5)
	//.autohidesScrollers_(0)
	.hasVerticalScroller_(false)
	.hasHorizontalScroller_(false)
	.enterInterpretsSelection_(1)
	.font_(Font("arial",10*~fontSizeMul));

	// MultiView

	envir[multiView] = MultiSliderView.new(envir[comp], ~viewHarPos5);
	envir[multiView].value_(envir[data][~tracksValue][~seqsValue])
	.background_(multiViewBackground)
	.strokeColor_(multiViewStrokeColor)
	.fillColor_(multiViewFillColor)
	.elasticMode_(1)
	.isFilled_(multiViewFilled)
	.drawLines_(multiViewDrawLines)
	.thumbSize_(envir[multiView].bounds.width / (envir[data][~tracksValue][~seqsValue].size))
	.showIndex_(~multiSliderIndex);

	case
	{ [\ratHar].includes(data) }
	{
		envir[multiView]
		.valueThumbSize_(multiViewValueThumbSize)
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x});
			envir[dataSeq][~tracksValue][~seqsValue] = envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			envir[dataSeq][~tracksValue][~seqsValue] = [1] ++ envir[dataSpec][~tracksValue][~seqsValue].map(envir[dataSeq][~tracksValue][~seqsValue]).midiratio;
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+"].unmap("+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 7, displayReduceFontPos);
		});
	}
	{ [\cenHar].includes(data) }
	{
		envir[multiView]
		.valueThumbSize_(multiViewValueThumbSize)
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x});
			envir[dataSeq][~tracksValue][~seqsValue] = envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			envir[dataSeq][~tracksValue][~seqsValue] = [0] ++ envir[dataSpec][~tracksValue][~seqsValue].map(envir[dataSeq][~tracksValue][~seqsValue]);
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+"].unmap("+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 7, displayReduceFontPos);
		});
	}
	{ [\delHar].includes(data) }
	{
		envir[multiView]
		.valueThumbSize_(multiViewValueThumbSize)
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x});
			envir[dataSeq][~tracksValue][~seqsValue] = envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			envir[dataSeq][~tracksValue][~seqsValue] = [0] ++ envir[dataSpec][~tracksValue][~seqsValue].map(envir[dataSeq][~tracksValue][~seqsValue]);
			// envir[dataSeq][~tracksValue][~seqsValue] = [0] ++ envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+"].unmap("+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 7, displayReduceFontPos);
		});
	}
	{ [\ampHar].includes(data) }
	{
		envir[multiView]
		.valueThumbSize_(multiViewValueThumbSize)
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x});
			envir[dataSeq][~tracksValue][~seqsValue] = [0.5] ++ envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+"].unmap("+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 7, displayReduceFontPos);
		});
	}
	{ [\spaHar].includes(data) }
	{
		envir[multiView]
		.valueThumbSize_(max(10, if ((envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1) > ~multiSliderHeight5, {10}, {~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1)})))
		.action_({ | view |
			view.value.do({|x, i|
				envir[data][~tracksValue][~seqsValue][i] = x});
			// Suppression du envir[dataSpec] pour la spatialisation car traitement dans le pattern à cause de la stéréo
			envir[dataSeq][~tracksValue][~seqsValue] = /*envir[dataSpec][~tracksValue][~seqsValue].map*/ ( envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]] ) /*.asInteger*/;
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+"].unmap("+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue])).round(1).asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 7, displayReduceFontPos); // intérêt du .asInteger pas intégré -> pour ne pas voir de décimale - round(1) vraiment nécessaire ?????????
		});
	};


	// SeqView

	envir[seqView] = SmoothRangeSlider(envir[comp], ~seqViewHarPos5)
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightNoColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.value_([0, 1])
	.minRange_(1/(envir[data][~tracksValue][~seqsValue].size))
	.step_(1/(envir[data][~tracksValue][~seqsValue].size));

	case
	{ [\ratHar].includes(data) }
	{
		envir[seqView].action_({ |view| envir[seqStart][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.lo).asInteger; envir[seqStop][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.hi).asInteger-1;
			envir[seqDur][~tracksValue][~seqsValue] = envir[seqStop][~tracksValue][~seqsValue] - envir[seqStart][~tracksValue][~seqsValue] + 1;
			envir[dataSeq][~tracksValue][~seqsValue] = envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			envir[dataSeq][~tracksValue][~seqsValue] = [1] ++ envir[dataSpec][~tracksValue][~seqsValue].map(envir[dataSeq][~tracksValue][~seqsValue]).midiratio;
			view.string = ("% to % (Dur : %)").format(envir[seqStart][~tracksValue][~seqsValue], envir[seqStop][~tracksValue][~seqsValue], envir[seqDur][~tracksValue][~seqsValue]);
		})
	}
	{ [\cenHar].includes(data) }
	{
		envir[seqView].action_({ |view| envir[seqStart][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.lo).asInteger; envir[seqStop][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.hi).asInteger-1;
			envir[seqDur][~tracksValue][~seqsValue] = envir[seqStop][~tracksValue][~seqsValue] - envir[seqStart][~tracksValue][~seqsValue] + 1;
			envir[dataSeq][~tracksValue][~seqsValue] = envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			envir[dataSeq][~tracksValue][~seqsValue] = [0] ++ envir[dataSpec][~tracksValue][~seqsValue].map(envir[dataSeq][~tracksValue][~seqsValue]);
			view.string = ("% to % (Dur : %)").format(envir[seqStart][~tracksValue][~seqsValue], envir[seqStop][~tracksValue][~seqsValue], envir[seqDur][~tracksValue][~seqsValue]);
		})
	}
	{ [\delHar].includes(data) }
	{
		envir[seqView].action_({ |view| envir[seqStart][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.lo).asInteger; envir[seqStop][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.hi).asInteger-1;
			envir[seqDur][~tracksValue][~seqsValue] = envir[seqStop][~tracksValue][~seqsValue] - envir[seqStart][~tracksValue][~seqsValue] + 1;
			envir[dataSeq][~tracksValue][~seqsValue] = envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			envir[dataSeq][~tracksValue][~seqsValue] = [0] ++ envir[dataSpec][~tracksValue][~seqsValue].map(envir[dataSeq][~tracksValue][~seqsValue]);
			view.string = ("% to % (Dur : %)").format(envir[seqStart][~tracksValue][~seqsValue], envir[seqStop][~tracksValue][~seqsValue], envir[seqDur][~tracksValue][~seqsValue]);
		})
	}
	{ \ampHar == data }
	{
		envir[seqView].action_({ |view| envir[seqStart][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.lo).asInteger; envir[seqStop][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.hi).asInteger-1;
			envir[seqDur][~tracksValue][~seqsValue] = envir[seqStop][~tracksValue][~seqsValue] - envir[seqStart][~tracksValue][~seqsValue] + 1;
			envir[dataSeq][~tracksValue][~seqsValue] = [0.5] ++ envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			view.string = ("% to % (Dur : %)").format(envir[seqStart][~tracksValue][~seqsValue], envir[seqStop][~tracksValue][~seqsValue], envir[seqDur][~tracksValue][~seqsValue]);
		})
	}
	{ [\spaHar].includes(data) }
	{
		envir[seqView].action_({ |view| envir[seqStart][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.lo).asInteger; envir[seqStop][~tracksValue][~seqsValue] = envir[seqSpec][~tracksValue][~seqsValue].map(view.hi).asInteger-1;
			envir[seqDur][~tracksValue][~seqsValue] = envir[seqStop][~tracksValue][~seqsValue] - envir[seqStart][~tracksValue][~seqsValue] + 1;
			// Suppression du envir[dataSpec] pour la spatialisation car traitement dans le pattern à cause de la stéréo
			envir[dataSeq][~tracksValue][~seqsValue] = /*envir[dataSpec][~tracksValue][~seqsValue].map*/ ( envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]] ) /*.asInteger*/;
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+"].unmap("+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue])).round(1).asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 7, displayReduceFontPos); // intérêt du .asInteger pas intégré -> pour ne pas voir de décimale - round(1) vraiment nécessaire ?????????
			view.string = ("% to % (Dur : %)").format(envir[seqStart][~tracksValue][~seqsValue], envir[seqStop][~tracksValue][~seqsValue], envir[seqDur][~tracksValue][~seqsValue]);
		})
	};
	envir[seqView].doAction;



	// RangeView

	case
	{ [\ratHar].includes(data) }
	{
		envir[rangeView] = SmoothRangeSlider(envir[comp], ~rangeViewHarPos5)
		.font_(Font("Verdana", 8*~fontSizeMul))
		.background_(~sliderBackgroundColor)
		.hilightColor_(rangeSliderColor)
		.stringColor_(Color.white)
		.border_(~border)
		.borderColor_(~borderColor)
		// .align = \center; // par défaut
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)); envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi));
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
			envir[dataSeq][~tracksValue][~seqsValue] = envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			envir[dataSeq][~tracksValue][~seqsValue] = [1] ++ envir[dataSpec][~tracksValue][~seqsValue].map(envir[dataSeq][~tracksValue][~seqsValue]).midiratio;
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n%".format(
				(envir[max][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]),
				(envir[min][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])));
			// Le changement de step provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
			// Le changement de step provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step  si > à 0.1
			// si lancement d'une routine pour automatisation, le tête de lecture visuelle sur le multislider sera perturbé
			if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))});
			// envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
			// envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value)).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+"].unmap("+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 7, displayReduceFontPos);
		})
		// .minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue])) // RETIRE HARMONISATION
		.minRange_((/*envir[max][~tracksValue][~seqsValue]*/ maxDefault / 2 / envir[round][~tracksValue][~seqsValue]).reciprocal)
		// ~ratHarRangeSpec[~tracksValue][~seqsValue].unmap(~ratHarRound[~tracksValue][~seqsValue])
		.value_([envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue]])
		.doAction;
	}
	{ [\cenHar].includes(data) }
	{
		envir[rangeView] = SmoothRangeSlider(envir[comp], ~rangeViewHarPos5)
		.font_(Font("Verdana", 8*~fontSizeMul))
		.background_(~sliderBackgroundColor)
		.hilightColor_(rangeSliderColor)
		.stringColor_(Color.white)
		.border_(~border)
		.borderColor_(~borderColor)
		// .align = \center; // par défaut
		.action_({ |view| envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)); envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi));
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
			envir[dataSeq][~tracksValue][~seqsValue] = envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			envir[dataSeq][~tracksValue][~seqsValue] = [0] ++ envir[dataSpec][~tracksValue][~seqsValue].map(envir[dataSeq][~tracksValue][~seqsValue]);
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n%".format(
				(envir[max][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]),
				(envir[min][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])));
			// Le changement de step provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
			// Le changement de step provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step  si > à 0.1
			// si lancement d'une routine pour automatisation, le tête de lecture visuelle sur le multislider sera perturbé
			if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))});
			// envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
			// envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value)).round(envir[round][~tracksValue][~seqsValue]))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+"].unmap("+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 7, displayReduceFontPos);
		})
		// .minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue])) // RETIRE HARMONISATION
		.minRange_((/*envir[max][~tracksValue][~seqsValue]*/ maxDefault / 2 / envir[round][~tracksValue][~seqsValue]).reciprocal)
		// ~ratHarRangeSpec[~tracksValue][~seqsValue].unmap(~ratHarRound[~tracksValue][~seqsValue])
		.value_([envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue]])
		.doAction;
	}
	{ [\delHar].includes(data) }
	{ envir[rangeView] = SmoothRangeSlider(envir[comp], ~rangeViewHarPos5)
		.font_(Font("Verdana", 8*~fontSizeMul))
		.background_(~sliderBackgroundColor)
		.hilightColor_(rangeSliderColor)
		.stringColor_(Color.white)
		.border_(~border)
		.borderColor_(~borderColor)
		.action_({ |view| var string;
			envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)); envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi));
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
			envir[dataSeq][~tracksValue][~seqsValue] = envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]];
			envir[dataSeq][~tracksValue][~seqsValue] = [0] ++ envir[dataSpec][~tracksValue][~seqsValue].map(envir[dataSeq][~tracksValue][~seqsValue]);

			view.string_("%\n to \n%".format(
				(envir[max][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue]),
				(envir[min][~tracksValue][~seqsValue]).round(envir[round][~tracksValue][~seqsValue])));

			if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))});

			// envir[indexView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			// envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value)).round(1))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+"].unmap("+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue])).round(envir[round][~tracksValue][~seqsValue]).asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 7, displayReduceFontPos);
		})
		.minRange_((/*envir[max][~tracksValue][~seqsValue]*/ maxDefault / 2 / envir[round][~tracksValue][~seqsValue]).reciprocal)
		.valueAction_([envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue]]); // aucun effet -> déjà fait dans fonction default ?
	}
	{ [\spaHar].includes(data) }
	{ envir[rangeView] = SmoothRangeSlider(envir[comp], ~rangeViewHarPos5)
		.font_(Font("Verdana", 8*~fontSizeMul))
		.background_(~sliderBackgroundColor)
		.hilightColor_(rangeSliderColor)
		.stringColor_(Color.white)
		.border_(~border)
		.borderColor_(~borderColor)
		.action_({ |view| var string;
			envir[min][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.lo)).asInteger; envir[max][~tracksValue][~seqsValue] = (envir[rangeSpec][~tracksValue][~seqsValue].map(view.hi)).asInteger;
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, 1);
			envir[dataSeq][~tracksValue][~seqsValue] = /*envir[dataSpec][~tracksValue][~seqsValue].map*/ ( envir[data][~tracksValue][~seqsValue][envir[seqStart][~tracksValue][~seqsValue]..envir[seqStop][~tracksValue][~seqsValue]] ) /*.asInteger*/;

			~spaHarSpecStereo[~tracksValue][~seqsValue] = ControlSpec(0, envir[max][~tracksValue][~seqsValue].min(5), \lin, 1);

			string = ~spaHarStringFunction.(); // vérifier si le rajout de la fonction affichant en plus la catégorie n'est pas trop lourd en CPU ?????????
			// view.string = "%\n to \n%".format(envir[max][~tracksValue][~seqsValue], envir[min][~tracksValue][~seqsValue]); pour prise en compte du mul ci-dessous
			view.string_("%\n to \n% \n\n%".format((envir[max][~tracksValue][~seqsValue]).round(1), (envir[min][~tracksValue][~seqsValue]).round(1), string));

			envir[multiView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			envir[multiView].valueThumbSize_(max(10, if ((envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1) > ~multiSliderHeight5, {10}, {~multiSliderHeight5 / (envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]+1)})));
			envir[multiView].value_(envir[data][~tracksValue][~seqsValue]);

			// envir[indexView].step_(1/(envir[max][~tracksValue][~seqsValue] - envir[min][~tracksValue][~seqsValue]));
			// envir[indexView].string_("At : %".format((envir[dataSpec][~tracksValue][~seqsValue].map(envir[indexView].value)).round(1))); // léger pb de rounding ?
			envir[display].string_((displayString1+~tracksValue+"]["+~seqsValue+"].unmap("+(envir[dataSpec][~tracksValue][~seqsValue].map(envir[data][~tracksValue][~seqsValue])).round(1).asInteger.asCompileString+"));").asString); envir[display].setFont((Font("arial",1)), 7, displayReduceFontPos);
		})
		.valueAction_([0, 1]);
	};



	// RoundView

	envir[roundViewView] = View(envir[comp], ~roundViewHarPos5);

	envir[roundView] = PopUpMenu.new(envir[roundViewView], Rect(0, 0, 130*~xSizeMul, 16*~ySizeMul))
	.allowsReselection_(true)
	.background_(~popUpMenuBackgroundColor)
	.stringColor_(~popUpMenuStringColor)
	.font_(Font("Verdana",8*~fontSizeMul))
	.items_(roundViewItems);

	case { [\ratHar, \cenHar, \delHar].includes(data) }
	{
		envir[roundView]
		.action_({ |menu| envir[roundViewFunc][menu.value].value(~tracksValue, ~seqsValue);
			envir[roundValue][~tracksValue][~seqsValue] = menu.value;
			// pourquoi envir[rangeSpec] n'est pas rajouté comme pour les autres ci-dessous ?????????
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
			// envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
			// Pas d'utilisation de step pour le rangeView car pas approprié lorsque ControlSpec est exp
			// envir[rangeView].step_(1/(128/envir[round][~tracksValue][~seqsValue]));
			// envir[rangeView].minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue])); // RETIRE HARMONISATION
			envir[rangeView].minRange_((/*envir[max][~tracksValue][~seqsValue]*/ maxDefault / 2 / envir[round][~tracksValue][~seqsValue]).reciprocal);
			envir[rangeView].valueAction_(envir[rangeSpec][~tracksValue][~seqsValue].unmap([envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue]]));
			// Le changement de step sur le Multislider provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
			// Le changement de step sur le Multislider provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step si > à 0.1
			if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))}, {envir[multiView].step_(0)});
		})
		.valueAction_(roundViewDefault);
	}
	{ [\ampHar].includes(data) }
	{
		envir[roundView]
		.action_({ |menu| envir[roundViewFunc][menu.value].value(~tracksValue, ~seqsValue);
			envir[roundValue][~tracksValue][~seqsValue] = menu.value;
			// pourquoi envir[rangeSpec] n'est pas rajouté comme pour les autres ci-dessous ?????????
			envir[dataSpec][~tracksValue][~seqsValue] = ControlSpec(envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue], \lin, envir[round][~tracksValue][~seqsValue]);
			// envir[indexView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]));
			// Pas d'utilisation de step pour le rangeView car pas approprié lorsque ControlSpec est exp
			// envir[rangeView].step_(1/(128/envir[round][~tracksValue][~seqsValue]));
			// envir[rangeView].minRange_(envir[rangeSpec][~tracksValue][~seqsValue].unmap(envir[round][~tracksValue][~seqsValue])); // RETIRE HARMONISATION
			// envir[rangeView].minRange_((/*envir[max][~tracksValue][~seqsValue]*/ maxDefault / 2 / envir[round][~tracksValue][~seqsValue]).reciprocal);
			// envir[rangeView].valueAction_(envir[rangeSpec][~tracksValue][~seqsValue].unmap([envir[min][~tracksValue][~seqsValue], envir[max][~tracksValue][~seqsValue]]));
			// Le changement de step sur le Multislider provoque des changements des valeurs du View surtout si round > 1 -> à améliorer
			// Le changement de step sur le Multislider provoque des légers changements des valeurs du View avec 1 round de 0.01 -> annulation du step si > à 0.1
			if (envir[round][~tracksValue][~seqsValue]> 0.1, {envir[multiView].step_(1/(((envir[max][~tracksValue][~seqsValue])-(envir[min][~tracksValue][~seqsValue]))/envir[round][~tracksValue][~seqsValue]))}, {envir[multiView].step_(0)});
		})
		.valueAction_(roundViewDefault);
	}
	{ \spaHar == data }
	{
		envir[roundView]
		.action_{ |menu| envir[multiView].valueAction_(envir[dataSpec][~tracksValue][~seqsValue].unmap(menu.value/*.asInteger*/) ! envir[data][~tracksValue][~seqsValue].size); }
		.value_(roundViewDefault);
	};



	// RangePresetView

	envir[rangePresetViewView] = View(envir[comp], ~rangePresetViewHarPos5);

	envir[rangePresetView] = PopUpMenu.new(envir[rangePresetViewView], Rect(0, 0, 100*~xSizeMul, 16*~ySizeMul););

	case
	{[\ratHar, \cenHar, \delHar].includes(data)}
	{
		envir[rangePresetView]
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(~popUpMenuStringColor)
		.font_(Font("Verdana",8*~fontSizeMul))
		.items_(rangePresetViewItems)
		.action_({|menu| envir[rangeView].valueAction_(envir[rangeSpec][~tracksValue][~seqsValue].unmap([menu.item.replace(rangePresetViewSign, " ").split($ )[0].asFloat, menu.item.replace(rangePresetViewSign, " ").split($ )[1].asFloat])) })
		.valueAction_(rangePresetViewDefault);
	}
	{\spaHar == data}
	{
		envir[rangePresetView]
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(~popUpMenuStringColor)
		.font_(Font("Verdana",8*~fontSizeMul))
		.items_(rangePresetViewItems)
		.action_({|menu| ~spaHarRangePresetViewFunc[menu.value].value(~tracksValue, ~seqsValue) })
		.valueAction_(rangePresetViewDefault);
	};



	envir[randView] = RoundButton(envir[comp], ~randViewHarPos5);
	envir[seqAllView] = RoundButton(envir[comp], ~seqAllViewHarPos5);
	envir[seqMode] = RoundButton(envir[comp], ~seqModeHarPos5);
	envir[defaultView] = RoundButton(envir[comp], ~defaultViewHarPos5);



	envir[randView]
	.states_([["Rand", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({if (~patFlag == 0, {
		envir[randFunc].value(~tracksValue, ~seqsValue)}, {
		~seqs.do {|i|
			envir[randFunc].value(~tracksValue, i);
			envir[data][~tracksValue][i] = {rrand(0.0,1.0)} ! ~harIndex[~tracksValue][i];
		};
	});
	});

	envir[seqAllView]
	.states_([["All Seq", Color.black, ~popUpMenuBackgroundColor]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({envir[seqView].valueAction_([0, 1]);
	});


	if ( [\ratHar, \cenHar, \spaHar, \delHar].includes(data), {
		envir[rangeMode] = RoundButton(envir[comp], ~rangeModeHarPos5)
		.states_([["\Drag", Color.black, ~popUpMenuBackgroundColor], ["\Jump", Color.black, ~popUpMenuBackgroundColor] /*["\Drag", Color.white, Color.blue], ["\Jump", Color.black, Color.green]*/])
		.font_(Font("Verdana",8*~fontSizeMul))
		.action_({|i| envir[rangeView].mode_(~modes[i.value])});
	});

	envir[seqMode]
	.states_([["\Drag", Color.black, ~popUpMenuBackgroundColor], ["\Jump", Color.black, ~popUpMenuBackgroundColor] /*["\Drag", Color.white, Color.blue], ["\Jump", Color.black, Color.green]*/])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| envir[seqView].mode_(~modes[i.value])})
	.valueAction_(1);

	envir[defaultView]
	.states_([["Def", Color.white, Color.blue]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({if (~patFlag == 0, {
		envir[default].value(~tracksValue, ~seqsValue)}, {
		~seqs.do {|i| envir[default].value(~tracksValue, i)}});
	})
	.valueAction_(1);



	// ShowView - Names of Modules

	envir[showView] = StaticText(envir[comp], showViewPos)
	.font_(Font("Verdana", 13*~fontSizeMul, bold: true))
	.align_(showViewAlign)
	.acceptsMouse_(0)
	.stringColor_(showViewColor)
	.string_(showViewString);

});



// IndexView
~harNbSpec = ControlSpec(3, 100, \lin, 1, 3);
~harIndex = ~harNbSpec.default ! ~nbOfSeqs ! ~nbOfTracksX2;
~harTrig = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
/*~tracks.do { |tr|
~seqs.do { |seq|
~harNbSpec[tr][seq] = ControlSpec(1, 100, \lin, 1, 7);
~harIndex[tr][seq] = ~harNbSpec[tr][seq].default;
}};*/

~harIndexView = SmoothSlider(~tabHarComp, Rect(342*~xSizeMul, 2*~ySizeMul, 35*~xSizeMul, 90*~ySizeMul))
.font_(Font("Verdana", 10*~fontSizeMul))
.background_(~sliderBackgroundColor)
.hilightColor_(~sliderHilightColor)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor)
.step_(0.01)
.action_({ |view| ~harIndex[~tracksValue][~seqsValue] = ~harNbSpec.map(view.value);
	view.string = "M :\n%".format((~harIndex[~tracksValue][~seqsValue]).round(1).asInteger);
})
.valueAction_(~harNbSpec.unmap(~harIndex[~tracksValue][~seqsValue]))
.doAction;

~harDefView = RoundButton(~tabHarComp, Rect(305*~xSizeMul, 149*~ySizeMul, 35*~xSizeMul, 20*~ySizeMul))
.states_([["Def A", Color.white, Color.blue]])
.font_(Font("Verdana",9*~fontSizeMul))
.action_({if (~patFlag == 0, {
	~ratHarDefault.value(~tracksValue, ~seqsValue);
	~cenHarDefault.value(~tracksValue, ~seqsValue);
	~delHarDefault.value(~tracksValue, ~seqsValue);
	~ampHarDefault.value(~tracksValue, ~seqsValue);
	~spaHarDefault.value(~tracksValue, ~seqsValue);
}, {
	~seqs.do {|i|
		~ratHarDefault.value(~tracksValue, i);
		~cenHarDefault.value(~tracksValue, i);
		~delHarDefault.value(~tracksValue, i);
		~ampHarDefault.value(~tracksValue, i);
		~spaHarDefault.value(~tracksValue, i)
}});
});

~harRandView = RoundButton(~tabHarComp, Rect(305*~xSizeMul, 169*~ySizeMul, 35*~xSizeMul, 20*~ySizeMul))
.states_([["Rand A", Color.white, Color.red]])
.font_(Font("Verdana",9*~fontSizeMul))
.action_({if (~patFlag == 0, {
	~rateHar.value(~tracksValue, ~seqsValue);
	~centerHar.value(~tracksValue, ~seqsValue);
	~delayHar.value(~tracksValue, ~seqsValue);
	~amplitudeHar.value(~tracksValue, ~seqsValue);
	~spatialisationHar.value(~tracksValue, ~seqsValue);
}, {
	~seqs.do {|i|
		~rateHar.value(~tracksValue, i);
		~centerHar.value(~tracksValue, i);
		~delayHar.value(~tracksValue, i);
		~amplitudeHar.value(~tracksValue, i);
		~spatialisationHar.value(~tracksValue, i);
		/*~ratHar[~tracksValue][i] = {rrand(0.0,1.0)} ! ~harIndex[~tracksValue][i];
		~ampHar[~tracksValue][i] = {rrand(0.0,1.0)} ! ~harIndex[~tracksValue][i];*/
	};
});
});

/*~harSpaDefView = RoundButton(~tabHarComp, Rect(342*~xSizeMul, 173*~ySizeMul, 38*~xSizeMul, 20*~ySizeMul))
.states_([["De Spa", Color.white, Color.blue]])
.font_(Font("Verdana",9*~fontSizeMul))
.action_({if (~patFlag == 0, {
	~spaHarDefault.value(~tracksValue, ~seqsValue);
}, {
	~seqs.do {|i| ~spaHarDefault.value(~tracksValue, i) };
});
});*/

/*~harSpaRandView = RoundButton(~tabHarComp, Rect(342*~xSizeMul, 193*~ySizeMul, 38*~xSizeMul, 20*~ySizeMul))
.states_([["Ra Spa", Color.white, Color.red]])
.font_(Font("Verdana",9*~fontSizeMul))
.action_({if (~patFlag == 0, {
	~spatialisationHar.value(~tracksValue, ~seqsValue);
}, {
	~seqs.do {|i| ~spatialisationHar.value(~tracksValue, i) };
});
});*/

~harTrigView = RoundButton(~spaComp /*~tabHarComp*/, Rect(338*~xSizeMul, 154*~ySizeMul, 40*~xSizeMul, 22*~ySizeMul) /*Rect(305, 191, 35, 22)*/)
.states_([["Mul X", Color.white, Color.red],["Mul X", Color.black, Color.green]])
.font_(Font("Verdana",10*~fontSizeMul, bold: true))
.action_({ |i| ~harTrig[~tracksValue][~seqsValue] = i.value;
});





(
~makeModuleHarmWindow.(currentEnvironment,
	// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
	\ratHarRoundViewFunc, -84, 84, 0, 0, 0.01,
	\tabHarmRatComp, \ratHarDisplay, 47, "~ratHarView.valueAction_(~ratHarSpec[",/* "].unmap(~ratMul[",*/
	\ratHarView, \ratHar, \ratHarSeq, \ratHarSpec, false, true, 10, ~compColor1, ~multiCompColor1, Color.white,
	\ratHarSeqView, \ratHarSeqStart, \ratHarSeqStop, \seqDurRatHar, \ratHarSeqSpec,
	// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign,
	\ratHarRangeView, \ratHarMin, \ratHarMax, \ratHarRangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \ratHarRangePresetViewView, \ratHarRangePresetView, ["0->6", "0->12", "0->24", "0->48", "0->60", "0->84", "0->-6", "0->-12", "0->-24", "0->-48", "0->-60", "0->-84", "-1->1", "-6->6", "-12->12", "-24->24", "-48->48", "-60->60", "-84->84"], 14, "->",
	\ratHarRoundViewView, \ratHarRoundView, ~roundViewPos5, \ratHarRound, \ratHarRoundValue, ["@ 0.01 LIN", "@ 0.1 LIN", "@ 0.125 1÷16T LIN", "@ 0.2 LIN", "@ 0.25 1÷8T LIN", "@ 0.5 1÷4T LIN", "@ 1 1÷2T LIN", "@ 2 1T LIN"], 0,
	\ratHarRandView, \rateHar,
	\ratHarSeqAllView, \ratHarRangeMode, \ratHarSeqMode,
	\ratHarDefaultView, \ratHarDefault,
	\ratShowView, ~nameModHarPos, \left, Color.yellow, "RAT M"
);

~makeRandHarFunction.(currentEnvironment, \rateHar, \ratHar, \ratHarView, \dur, \seqDurRatHar, \ratHarSeqView, \ratHarSeqStart, \ratHarSeqStop, \ratHarSeqSpec/*, \ratHarIndex, \ratSeqVSpec, \ratReadView*/);

~outLHarSpatType = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
~outLHarSpatTypeView = ListView(~tabHarComp, Rect(342*~xSizeMul, 94*~ySizeMul, 41*~xSizeMul, 39*~ySizeMul))
.background_(~panCompColor /*Color./*clear*/grey(0.3, alpha: 0.8)*/)
.hiliteColor_(Color.yellow(alpha: 1))
.selectedStringColor_(Color.black)
.stringColor_(Color.white)
.font_(Font("Verdana",(9*~fontSizeMul).asInteger, bold: true))
.items_(["Out L", "Seq L", "Ran L"])
.action_({ |menu| ~outLHarSpatType[~tracksValue][~seqsValue] = menu.value });

~outRHarSpatType = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
~outRHarSpatTypeView = ListView(~tabHarComp, Rect(342*~xSizeMul, 134*~ySizeMul, 41*~xSizeMul, 39*~ySizeMul))
.background_(~panCompColor /*Color./*clear*/grey(0.3, alpha: 0.8)*/)
.hiliteColor_(Color.yellow(alpha: 1))
.selectedStringColor_(Color.black)
.stringColor_(Color.white)
.font_(Font("Verdana",(9*~fontSizeMul).asInteger, bold: true))
.items_(["Out R", "Seq R", "Ran R"])
.action_({ |menu| ~outRHarSpatType[~tracksValue][~seqsValue] = menu.value });

~makeModuleHarmWindow.(currentEnvironment,
	// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
	\cenHarRoundViewFunc, -84, 84, 0, 0, 0.01,
	\tabHarmCenComp, \cenHarDisplay, 47, "~cenHarView.valueAction_(~cenHarSpec[",/* "].unmap(~cenMul[",*/
	\cenHarView, \cenHar, \cenHarSeq, \cenHarSpec, false, true, 10, ~compColor1, ~multiCompColor1, Color.white,
	\cenHarSeqView, \cenHarSeqStart, \cenHarSeqStop, \seqDurCenHar, \cenHarSeqSpec,
	// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign,
	\cenHarRangeView, \cenHarMin, \cenHarMax, \cenHarRangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \cenHarRangePresetViewView, \cenHarRangePresetView, ["0->6", "0->12", "0->24", "0->48", "0->60", "0->84", "0->-6", "0->-12", "0->-24", "0->-48", "0->-60", "0->-84", "-1->1", "-6->6", "-12->12", "-24->24", "-48->48", "-60->60", "-84->84"], 13, "->",
	\cenHarRoundViewView, \cenHarRoundView, ~roundViewPos5, \cenHarRound, \cenHarRoundValue, ["@ 0.01 LIN", "@ 0.1 LIN", "@ 0.125 1÷16T LIN", "@ 0.2 LIN", "@ 0.25 1÷8T LIN", "@ 0.5 1÷4T LIN", "@ 1 1÷2T LIN", "@ 2 1T LIN"], 0,
	\cenHarRandView, \centerHar,
	\cenHarSeqAllView, \cenHarRangeMode, \cenHarSeqMode,
	\cenHarDefaultView, \cenHarDefault,
	\cenShowView, ~nameModHarPos, \left, Color.yellow, "CEN M"
);

~makeRandHarFunction.(currentEnvironment, \centerHar, \cenHar, \cenHarView, \dur, \seqDurCenHar, \cenHarSeqView, \cenHarSeqStart, \cenHarSeqStop, \cenHarSeqSpec/*, \cenHarIndex, \cenSeqVSpec, \cenReadView*/);

~makeModuleHarmWindow.(currentEnvironment,
	// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
	\delHarRoundViewFunc, 0, 1, 0, 0, 0.001,
	\tabHarmDelComp, \delHarDisplay, 47, "~delHarView.valueAction_(~delHarSpec[",/* "].unmap(~delMul[",*/
	\delHarView, \delHar, \delHarSeq, \delHarSpec, false, true, 10, ~compColor1, ~multiCompColor1, Color.white,
	\delHarSeqView, \delHarSeqStart, \delHarSeqStop, \seqDurDelHar, \delHarSeqSpec,
	// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign,
	\delHarRangeView, \delHarMin, \delHarMax, \delHarRangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \delHarRangePresetViewView, \delHarRangePresetView, ["0->0.005", "0->0.01", "0->0.02", "0->0.05", "0->0.1", "0->0.2", "0->0.5", "0->1"], 1, "->",
	\delHarRoundViewView, \delHarRoundView, ~roundViewPos5, \delHarRound, \delHarRoundValue, ["@ 0.001", "@ 0.01", "@ 0.1", "@ 0.2", "@ 0.25", "@ 0.5", "@ 1"], 0,
	\delHarRandView, \delayHar,
	\delHarSeqAllView, \delHarRangeMode, \delHarSeqMode,
	\delHarDefaultView, \delHarDefault,
	\delShowView, ~nameModHarPos, \left, Color.yellow, "DEL M"
);

~makeRandHarFunction.(currentEnvironment, \delayHar, \delHar, \delHarView, \dur, \seqDurDelHar, \delHarSeqView, \delHarSeqStart, \delHarSeqStop, \delHarSeqSpec/*, \delHarIndex, \delSeqVSpec, \delReadView*/);

~makeModuleHarmWindow.(currentEnvironment,
	// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
	\ampHarRoundViewFunc, 0, 1, 0.5, 0, 0.01,
	\tabHarmAmpComp, \ampHarDisplay, 47, "~ampHarView.valueAction_(~ampHarSpec[",/* "].unmap(~ampMul[",*/
	\ampHarView, \ampHar, \ampHarSeq, \ampHarSpec, false, true, 10, ~compColor1, ~multiCompColor1, Color.white,
	\ampHarSeqView, \ampHarSeqStart, \ampHarSeqStop, \seqDurAmpHar, \ampHarSeqSpec,
	// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign,
	\ampHarRangeView, \ampHarMin, \ampHarMax, \ampHarRangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \ampHarRangePresetViewView, \ampHarRangePresetView, ["0->6", "0->12", "0->24", "0->48", "0->60", "0->84", "-12->12", "-24->24", "-48->48", "-60->60", "-84->84"], 6, "->",
	\ampHarRoundViewView, \ampHarRoundView, ~roundViewPos5, \ampHarRound, \ampHarRoundValue, ["@ 0.01", "@ 0.1", "@ 0.2", "@ 0.25", "@ 0.5", "@ 1"], 0,
	\ampHarRandView, \amplitudeHar,
	\ampHarSeqAllView, \ampHarRangeMode, \ampHarSeqMode,
	\ampHarDefaultView, \ampHarDefault,
	\ampShowView, ~nameModHarPos, \left, Color.yellow, "AMP M"
);

~makeRandHarFunction.(currentEnvironment, \amplitudeHar, \ampHar, \ampHarView, \dur, \seqDurAmpHar, \ampHarSeqView, \ampHarSeqStart, \ampHarSeqStop, \ampHarSeqSpec/*, \ampHarIndex, \ratSeqVSpec, \ratReadView*/);

~makeModuleHarmWindow.(currentEnvironment,
	// roundViewFunc, minDefault, maxDefault, dataDefault, roundValueDefault, roundDefault,
	"NoRoundViewFunc", 0, (~allSpasGUIFinal.size -1), 0, /*0, 1,*/ "NoRoundValueDefault", "NoRoundDefault",
	\tabHarmSpaComp, \spaHarDisplay, 47, "~spaHarView.valueAction_(~spaHarSpec[",/* "].unmap(~spaMul[",*/
	\spaHarView, \spaHar, \spaHarSeq, \spaHarSpec, false, true, 10, ~compColor1, ~multiCompColor1, Color.white,
	\spaHarSeqView, \spaHarSeqStart, \spaHarSeqStop, \seqDurSpaHar, \spaHarSeqSpec,
	// rangeView, min, max, rangeSpec, rangeViewMinRange, sliderColor, rangePresetView, rangePresetViewItems, rangePresetViewDefault, rangePresetViewSign,
	\spaHarRangeView, \spaHarMin, \spaHarMax, \spaHarRangeSpec, "NoRangeViewMinRange", ~sliderHilightColor, \spaHarRangePresetViewView, \spaHarRangePresetView, ~spaRangePresetItems, (~spaRangePresetItems.size-1), "-",
	\spaHarRoundViewView, \spaHarRoundView, ~roundViewPos5, \spaHarRound, \spaHarRoundValue, ~spaViewItems, 0,
	\spaHarRandView, \spatialisationHar,
	\spaHarSeqAllView, \spaHarRangeMode, \spaHarSeqMode,
	\spaHarDefaultView, \spaHarDefault,
	\spaShowView, ~nameModHarPos, \left, Color.yellow, "SPA M"
);

~makeRandHarFunction.(currentEnvironment, \spatialisationHar, \spaHar, \spaHarView, \dur, \seqDurSpaHar, \spaHarSeqView, \spaHarSeqStart, \spaHarSeqStop, \spaHarSeqSpec/*, \cenHarIndex, \cenSeqVSpec, \cenReadView*/);

);

/*~ratHarSpec
~ratHarRangeView.minRange
~ratHarView.valueAction_(~ratHarSpec[ 0 ][ 0 ].unmap( [ 30.0, 42.0, 42.0, 42.0 ] ));
envir[rangeView]*/






























// Fonctions pour la sauvegarde de l'organisation des séquences à l'intérieur des pistes :
// MultiSlider, RangeSlider, Xfade et Quantisation de la piste
// & Preset pour chaque séquence

~presetsTracks = IdentityDictionary.new;


~presetTrackSetFunction = { | index |
	~presetsTracks.put(index,
		Array.with(
			~tracks.collect { |x|
				[
					~seqSpec.map(~seq[x]),
					[~seqSeqStart[x], ~seqSeqStop[x]],
					[~presetSeqStart[x], ~presetSeqStop[x]],
					[~pFade[x], ~quant[x]],
					// ~presetSeqNbSelectValue[x], // supprimé
					~presetSeqNbSelectDurValue[x]
				];
			},
			~tracks.collect { |x|
				~seqs.collect { |y|
					~presetSelection[x][y];
			}},
	))
};


~presetSeqRandList = 0 ! ~nbOfTracksX2;

// si changement du nb de séquences
~presetTrackGetFunction = { | index, nbOfCurSeqs, trackSwitch | var presetList;

	{
		// presetList = ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asSymbol }; // obligé de convertir la liste de presets en symbol au lieu de String pour vérification si le preset existe dans la presetList
		presetList = ~presets.keys.asArray.collect{ |i| i.asSymbol }; // obligé de convertir la liste de presets en symbol au lieu de String pour vérification si le preset existe dans la presetList
		// ~presetList.includes(~presetsTracks['test'/*index*/][1][0/*x*/][0/*y*/]);

		~tracks.do { |x|

			~tracksView.valueAction_(x);
			~seqView.valueAction_(~seqSpec.unmap(~presetsTracks[index][0][x][0]));
			~seqSeqView.valueAction_([ ~seqSeqSpec.unmap(~presetsTracks[index][0][x][1][0]), ~seqSeqSpec.unmap(~presetsTracks[index][0][x][1][1]+1) ]); // 1er RangeSlider
			~presetSeqRangeView.valueAction_([ ~presetSeqRangeSpec.unmap(~presetsTracks[index][0][x][2][0]), ~presetSeqRangeSpec.unmap(~presetsTracks[index][0][x][2][1]+1) ]); // 2eme RangeSlider
			~pFadeView.valueAction_(~pFadeSpec.unmap(~presetsTracks[index][0][x][3][0]));
			~quantView.valueAction_(~quantSpec.unmap(~presetsTracks[index][0][x][3][1]));

			nbOfCurSeqs.do { |y|

				/*~presetSeqNbSelectView[i].valueAction_(~presetsTracks[index][0][x][4][i] ? i);*/ ~presetSeqNbSelectDurViewG[x][y].valueAction_(~presetsTracks[index][0][x][4/*5*/][y] ? 1);

				// Changement des séquences et attribution graphique des presets
				/*~seqsView.valueAction_(y);
				// if (~presetsTracks[index][1][x][y].asInteger != 0, {
				if (presetList.includes(~presetsTracks[index][1][x][y].asSymbol), {
				~presetSelectionView.valueAction_(~presetSelectionView.items.find([ ~presetsTracks[index][1][x][y] ]));
				});*/

				// -> + rapide sans attribution graphique des presets
				if (presetList.includes(~presetsTracks[index][1][x][y].asSymbol), { // Protection -> seulement si le preset existe dans la presetList (il a pu être supprimé)

					// Avec if certains presets ne se chargent pas -> donc essai avec try ??? - à voir pourquoi ????
					// try {~presetGetFunctionQuick.value(/*~presetList.choose.asSymbol.postln*/ ~presetsTracks[index][1][x][y].asSymbol, x, y)};

					~presetGetFunctionQuick.value(/*~presetList.choose.asSymbol.postln*/ ~presetsTracks[index][1][x][y].asSymbol, x, y); // Apparemment OK

					/*if (~presetsTracks[index][1][x][y].asInteger != 0, {
					~presetGetFunctionQuick.value(/*~presetList.choose.asSymbol.postln*/ ~presetsTracks[index][1][x][y].asSymbol, x, y);
					});*/

					~presetSelection[x][y] = ~presetsTracks[index][1][x][y];
					~presetSeqTextViewG[x][y].string_(~presetsTracks[index][1][x][y]);

				});
			};
		};

		~nbOfTracksX2.do { |i| /*~tracksView.valueAction_(i);*/ ~presetSeqRandList[i] = ~presetSelection[i].selectIndices({|item, i| item != 0}); };

		// ~seqABVisibleAllViewG[0].valueAction_(1).valueAction_(0); // Ligne nécessaire pour remettre toutes les pistes sur A // provoque une erreur si Lemur connectée ???

		// /*(0,2..14)*/ [ 2, 4, 6, 8, 10, 12, 14, 0 ].do { |i| ~tracksView.valueAction_(i) }; ~seqsView.valueAction_(0);
		trackSwitch.do { |i| ~tracksView.valueAction_(i) }; ~seqsView.valueAction_(0);

		if (~twister.notNil, {
			~twister.knobs[8..15].do { |i, id|
				if (id > 2, {i.ledColor_(Color.magenta)}, {i.ledColor_(Color.green)});
			};
			~twister.knobs[8+(~tracksValue/2).asInteger].ledColor_(Color.red);

			~retriggerPresetAllTracksView.valueAction_(1);
			1.wait;
			~seqABVisibleAllViewG/*[0]*/.valueAction_(0).valueAction_(1);
		});

		1.wait;

		~presetsDontTriggerFX = 0;
		~aControllerConnected = ~aControllerConnectedValue; ~lemurConnected1 = ~lemurConnectedValue; ~lemurConnected2 = ~lemurConnectedValue2;
		("Final Step 2 : TracksPresets loaded :" +~presetsTracksFileName).postln;

	}.fork(AppClock);

};





/*
// Essai pour tout mettre dans un Identity Dictionary d'un Identity Dictionary pour être plus lisible ???
// mais comment assigner un array / collection à un symbole ???
~presetTrackSet2Function.value('test')

~presetTrackSet2Function = { | index |
~presetsTracks.put(index,
IdentityDictionary.with(*[

~tracks.collect { |x|
\seqSpec[x] -> ~seqSpec.map(~seq[x])
}
])
)
};
*/



















(
// Variations sur les pistes

/*~savePresetTrackRanges = { |index, track| // juste pour 1 piste
var presetType, data, seqRange, durRange;
// data = Array.new;
if ( ~lemurNewSeqs[track].size == 0, {
if (~presetSeqStart[track] - ~presetSeqStop[track] == 0, {
presetType = 1;
data = [ presetType, ~presetSeqStart[track]+1, ~presetSeqNbSelectDurValue[track][~presetSeqStart[track]] ];

}, {
// seqRange = Array.new; durRange = Array.new;
presetType = 2;
seqRange = [~presetSeqStart[track]+1, ~presetSeqStop[track]+1];
durRange = ( ~presetSeqStart[track]..~presetSeqStop[track] ).collect { |i| ~presetSeqNbSelectDurValue[track][i] };
data = [ presetType, seqRange, durRange ];

});
}, {
// seqRange = Array.new; durRange = Array.new;
presetType = 3;
seqRange = ~lemurNewSeqs[track];
durRange = ~lemurNewSeqs[track].collect { |i| ~presetSeqNbSelectDurValue[track][i-1] };
data = [ presetType, seqRange, durRange ];

});
/*presetType.postln;
data.postln;*/
~presetTracksVariations.put(index, data);
};
~savePresetTrackRanges.('1', ~tracksValue);*/

~controlRandLineCollectionPVars = { | par = \rater, func = 0, val = 1.0, post = 1, serv = 0, pat = #[0.5, 1, 2] |
	var col, collectSize, server, ch;
	if (serv == 0, { server = currentEnvironment[\server1] }, { server = currentEnvironment[\server2] } );
	if (~serverProtect == 0, { ~serverProtect = 1; // Vraiment nécessaire ???

		server.getQueryTree2({ |data| ~serverCollection[serv] = data;

			if (~numChannels >= 32 or: {~numChannels == 8} or: {~numChannels == 4} and: {~serverFX == 0}, { ch = 1 }, { ch = 0 } ); // à cause de 1052 Local1InputLevels qui est la seulement avec le 32 hP ???
			col = ~serverCollection[serv]['children'][ch]['children'];
			~synthsIDCollection = ~nbOfTracks.collect { |t| col[t]['children'].collect { |i| i['id'] } }.flatten;

			if (~synthsIDCollection.size != 0, {

				collectSize = ~nbOfControlBus.min(~synthsIDCollection.size);
				// ~synthsIDCollection = ~synthsIDCollection.clumps( collectSize.partition(6, (collectSize/6).floor).postln; );
				~synthsIDCollectionC = ~synthsIDCollection.clumps( ~synthsIDCollection.size.partition(collectSize, (~synthsIDCollection.size/collectSize).floor); );
				collectSize.do { |i|
					case
					{ func == 0 } // Val détermine le range de la valeur aléatoire
					{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( {val.rand}.value ) }	}
					{ func == 1 } // Val détermine le multiplicateur de la série
					{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( Array.series(collectSize, 1, val)[i] ) } } // Array.series(~synthsIDCollection.size, 1)
					{ func == 2 } // Val ne détermine rien
					{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( Array.fill(collectSize, Pxrand(pat, inf).iter)[i] ) } } // Array.fill(~synthsIDCollection.size, Pxrand([0.5, 1, 2], inf).iter);
					{ func > 2 } // Val ne détermine rien
					{ ~controlBusSynth[serv][~nbOfControlBus-1-i].source = { DC.kr( Array.fill(collectSize, Pseq(pat, inf).iter)[i] ) } };
					~synthsIDCollectionC[i].do { |a| server.sendMsg( "/n_map", a, par, ~controlBus[serv][~nbOfControlBus-1-i].index ) };
				};
				if (post == 1, { ("Server" + serv + " / Speed Range:" + val + "->" + ~synthsIDCollectionC).postln/*.sort*/; } );
			});
		})
	},{
		"getQueryTree still in action".postln;
	});
	~serverProtect = 0;
};



~savePresetTracksRanges = { |index, tracks|
	var presetType, data, seqRange, durRange, ordRange;
	data = 0 ! (tracks.size+1); // data.postln;
	data[0] = tracks;
	tracks.collect { |track, trackID|
		if ( ~lemurNewSeqs[track].size == 0, {
			if (~presetSeqStart[track] - ~presetSeqStop[track] == 0, {
				presetType = 1;
				data[trackID+1] = [ presetType, ~presetSeqStart[track]+1, ~presetSeqNbSelectDurValue[track][~presetSeqStart[track]], ~presetSeqNb2Value[track][~presetSeqStart[track]] ];

			}, {
				// seqRange = Array.new; durRange = Array.new;
				presetType = 2;
				seqRange = [~presetSeqStart[track]+1, ~presetSeqStop[track]+1];
				durRange = ( ~presetSeqStart[track]..~presetSeqStop[track] ).collect { |i| ~presetSeqNbSelectDurValue[track][i] };
				ordRange = ( ~presetSeqStart[track]..~presetSeqStop[track] ).collect { |i| ~presetSeqNb2Value[track][i] };
				data[trackID+1] = [ presetType, seqRange, durRange, ordRange ];

			});
		}, {
			// seqRange = Array.new; durRange = Array.new;
			presetType = 3;
			seqRange = ~lemurNewSeqs[track];
			durRange = ~lemurNewSeqs[track].collect { |i| ~presetSeqNbSelectDurValue[track][i-1] };
			ordRange = ~lemurNewSeqs[track].collect { |i| ~presetSeqNb2Value[track][i-1] };
			data[trackID+1] = [ presetType, seqRange, durRange, ordRange ];

		});
	};
	/*presetType.postln;
	data.postln;*/
	~presetTracksVariations.put(index, data);
	("Preset" + index + "saved");
};



~presetVarsRatWait2 = 0;
~presetVarsRatWaitTime = 0.1;
~presetVarsRatWaitT2 = Task.new( { ~presetVarsRatWait2 = 1; 0.1.wait; ~presetVarsRatWaitT2.stop; } );
~presetVarsRatWaitF2 = { ~presetVarsRatWaitT2.reset; ~presetVarsRatWaitT2.start };



~loadPresetTracksRanges = { |tabbedPresetVarsPage, index, newTracks|
	var a, data;
	data = ~presetTracksVariations[index];
	a = ~ryRatRange.rand; if (a > 0, { a = a+~ryRatBase }, { a = a-~ryRatBase });
	~prevTrigAll = ~trigAllView.value;

	if (~presetRyRatSwitch == 1 or: { ~presetRyRat2Switch == 1 } and: { tabbedPresetVarsPage.envirGet.inclusivelyBetween(6, 9) } , { // différence avec en dessous ~tabbedPresetVarsPage
		/*~nbOfServers.do { |s|*/
		// ~controlBusFunc.(~controlBusTypeArg, (-1) /*(-0.7)*/, 5, s) // Test de changement de vitesse de lecture quand changement de Preset

		if (~presetVarsRatWait2 == 0 and: { ~presetVarsRatWaitT2.isPlaying == false }, {

			if (~presetRyRatSwitch == 1, { /*"S".postln;*/ ~controlRandLineCollectionPVars.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: 0) });
			if (~presetRyRat2Switch == 1, { /*"R".postln;*/ ~controlRandLineCollectionPVars.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: 1) });

			{
				~presetVarsRatWaitF2.(); (/*~presetVarsRatWaitTime+0.01*/0.1+0.1).wait;
				if (~presetVarsRatWaitT2.isPlaying == false, { ~presetVarsRatWait2 = 0 } );
			}.fork;

		}, {
		});
		/*} */
	});

	data[0].do { |i, id|
		case
		{ data[id+1][0] == 1 }
		{
			if ( ~lemurNewSeqs[i].size != 0, { ~lemurNewSeqs[i] = 0; ~lemurNewSeqs[i] = ~presetSeqStart[i] } );
			if (newTracks.isNil, {
				~presetSeqRangeViewG[i].value_([ ~presetSeqRangeSpec.unmap(data[id+1][1]-1), ~presetSeqRangeSpec.unmap(data[id+1][1]) ]).doAction;
			},{
				~presetSeqRangeViewG[newTracks[id]].value_([ ~presetSeqRangeSpec.unmap(data[id+1][1]-1), ~presetSeqRangeSpec.unmap(data[id+1][1]) ]).doAction;
			});
			~presetSeqNbSelectDurViewG[i][data[id+1][1]-1].valueAction_(data[id+1][2]);
			try { if (~presetSeqNb2Value[i][data[id+1][1]-1] != data[id+1][3], { ~presetSeqNb2ViewG[i][data[id+1][1]-1].valueAction_(data[id+1][3]) }/*, {"Order identical".postln}*/) };

			if (newTracks.isNil, {
				~seqCompG1[i].visibleOrigin = 0@( (~presetSeqStart[i]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin); // pour inclure le mouvement des Views des Tracks
			},{
				~seqCompG1[newTracks[id]].visibleOrigin = 0@( (~presetSeqStart[newTracks[id]]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin);
			});
		}
		{ data[id+1][0] == 2 }
		{
			if ( ~lemurNewSeqs[i].size != 0, { ~lemurNewSeqs[i] = 0; ~lemurNewSeqs[i] = ~presetSeqStart[i] } );
			// ~presetSeqRangeViewG[i].valueAction_([ ~presetSeqRangeSpec.unmap(data[id+1][1][0]-1), ~presetSeqRangeSpec.unmap(data[id+1][1][1]) ]).doAction;
			if (newTracks.isNil, {
				~presetSeqRangeViewG[i].value_([ ~presetSeqRangeSpec.unmap(data[id+1][1][0]-1), ~presetSeqRangeSpec.unmap(data[id+1][1][1]) ]).doAction;
			},{
				~presetSeqRangeViewG[newTracks[id]].value_([ ~presetSeqRangeSpec.unmap(data[id+1][1][0]-1), ~presetSeqRangeSpec.unmap(data[id+1][1][1]) ]).doAction;
			});
			// (data[id+1][1][1] - data[id+1][1][0]+1).postln;
			(data[id+1][1][1] - data[id+1][1][0]+1).do { |a, at|
				// ~presetSeqNbSelectDurViewG[i][data[id+1][1][0]-1+at].postln;
				~presetSeqNbSelectDurViewG[i][data[id+1][1][0]-1+at].valueAction_(data[id+1][2][at]);
				try { if (~presetSeqNb2Value[i][data[id+1][1][0]-1+at] != data[id+1][3][at], { ~presetSeqNb2ViewG[i][data[id+1][1][0]-1+at].valueAction_(data[id+1][3][at]) }/*, {"Order identical".postln}*/) };
				// try { ~presetSeqNb2ViewG[i][data[id+1][1][0]-1+at].valueAction_(data[id+1][3][at]) };
			};

			if (newTracks.isNil, {
				~seqCompG1[i].visibleOrigin = 0@( (~presetSeqStart[i]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin); // pour inclure le mouvement des Views des Tracks
			},{
				~seqCompG1[newTracks[id]].visibleOrigin = 0@( (~presetSeqStart[newTracks[id]]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin);
			});
		}
		{ data[id+1][0] == 3 }
		{
			~lemurNewSeqsUpdate.( i, data[id+1][1] );
			data[id+1][1].do { |a, at|
				~presetSeqNbSelectDurViewG[i][a-1].valueAction_(data[id+1][2][at]);
				try { if (~presetSeqNb2Value[i][a-1] != data[id+1][3][at], { ~presetSeqNb2ViewG[i][a-1].valueAction_(data[id+1][3][at]) }/*, {"Order identical".postln}*/) };
			}
		};
	};
	("Preset" + index + "called");
};

);


















~bufSequence = {{0 ! 2} ! ~nbOfSeqs} ! ~nbOfTracksX2; // Pour sélectionner les meilleurs Buffers les plus appropriés d'une séquence
~bufSequenceNb = 0 ! 2; // Pour l'index dans la séquence de Buffers
~presetNotes = 0 ! ~nbOfSeqs ! ~nbOfTracksX2; // Pour intégrer des notes des actions à réaliser sur un Preset spécifique

// Function to update the main window of Composite Views
(
~updateALLView = {

	// Sélection du preset par défaut de la séquence -> Déclenchement seulement s'il y a des presets et quand "Up" pour faciliter la constition de la liste des presets quand plusieurs lus à la suite
	if (~presetSelection[~tracksValue][~seqsValue] != 0 and:{ ~updatePresetSelection == 0}, {
		/*presetIndex = ~presetSelectionView.items.indexOfEqual(~presetSelection[~tracksValue][~seqsValue]); // Avant le ~presetsFileName2
		// ~presetSelectionView.value_(presetIndex); // aucun effet ???
		~presetSelectionView.selection_(presetIndex);*/
		~presetGetFunction.value(~presetSelection[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/.asSymbol);

		if (~presetSelection[~tracksValue][~seqsValue] != 0, { // mis aussi plus haut pour ~presetGetFunction
			~presetStoringNameView.value_(~presetSelection[~tracksValue][~seqsValue].split($|)[3][1..30] )
		});

		/*if (~twister.notNil, { // vraiment necessaire ???
		~ratValues[~tracksValue].value_(~ratMulSpec.unmap(~ratMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~rtmValues[~tracksValue].value_(~rtmMulSpec[~tracksValue][~seqsValue].unmap(~rtmMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~legValues[~tracksValue].value_(~legMulSpec.unmap(~legMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~strValues[~tracksValue].value_(~strMulSpec.unmap(~strMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~cenValues[~tracksValue].value_(~cenMulSpec.unmap(~cenMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~proValues[~tracksValue].value_(~proMulSpec.unmap(~proMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~bufFolValues[~tracksValue].value_(~bufFolderValue[~tracksValue][~seqsValue]);
		~bufValues[~tracksValue].value_(~bufMulSpec.unmap(~bufMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~offValues[~tracksValue].value_(~offMulSpec.unmap(~offMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		// ~offValue.value_(~offMulSpec.unmap(~offMul[~tracksValue][~seqsValue]));
		});*/

		~seqsColorizeFunction.(~tracksValue, ~seqsValue);

	},{

		var presetIndex;
		var serv;
		// Utilisation seulement du ~dur car le nb d'éléments dans toutes les séquences est le même
		var rtmSeqSize = ~dur[~tracksValue][~seqsValue].size;
		var rtmThumbSize = max((333 / rtmSeqSize)*~xSizeMul, ~readViewThumbSize);
		var rtmSeqStep = 1 / rtmSeqSize;
		var rtmSeqSpec = ControlSpec(0, rtmSeqSize, \lin, 1);
		var ratHarSeqSize, ratHarSeqSpec, ratHarSeqStep; // Pour les Miroirs Multiples

		var previousfxActOnWhich = ~fxActOnWhich; // Pour éviter que le fxL agisse sur le droit
		var previousoutActOnWhich = ~outActOnWhich; // Pour éviter que le outL agisse sur le droit
		var previousoutCompChoose = ~outCompChoose;

		if (~server2.isNil or: {(~tracksValue/2).asInteger < ~serverTrackSwitch}, {serv = 0}, {serv = 1});

		~fxActOnWhichView.valueAction_(0); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(0); // Pour éviter que le outL agisse sur le droit


		// Données Séquence
		~seqView.valueAction_(~seq[~tracksValue]);
		~seqSeqView.valueAction_([~seqSeqSpec.unmap(~seqSeqStart[~tracksValue]), ~seqSeqSpec.unmap(~seqSeqStop[~tracksValue]+1)]);

		~pFadeView.valueAction_(~pFadeSpec.unmap(~pFade[~tracksValue]));
		~quantView.valueAction_(~quantSpec.unmap(~quant[~tracksValue]));

		if (~presetSelection[~tracksValue][~seqsValue] != 0, { // mis aussi plus haut pour ~presetGetFunction
			~presetStoringNameView.value_(
				// ~presetSelection[~tracksValue][~seqsValue].split($|)[3].split($ )[1] ++ " " ++ ~presetSelection[~tracksValue][~seqsValue].split($|)[3].split($ )[2]) })
				~presetSelection[~tracksValue][~seqsValue].split($|)[3][1..30];
		)});

		~playControlView[~tracksValue].value_(~playViewValue[~tracksValue]);
		~xqControlView[~tracksValue].value_(~xqViewValue[~tracksValue]);
		~multiStereoView.value_(~multiStereo[~tracksValue][~seqsValue]);


		// Données Fx
		// Suppression de l'update incluant les effets puisqu'ils sont globaux
		// (~fxSelectView.size-1).do { |a| ~fxSelectView[a].valueAction_(~fxSelect[a][~tracksValue][~seqsValue]) };


		// Données rythmiques 7
		~configBeatsView.value_(~configBeatsValue[~tracksValue][~seqsValue]);
		~nbTotalBeatsView.valueAction_(~nbTotalBeatsSpec.unmap(~nbTotalBeats[~tracksValue][~seqsValue]));
		// Pouquoi parfois pb de rounding ???
		~displayRhythmView.string_(~displayRhythm[~tracksValue][~seqsValue]);
		6.do { |nb|
			if (~selectBeatValue[~tracksValue][~seqsValue][nb] != 0, { ~selectBeatView[nb].value_(~selectBeatValue[~tracksValue][~seqsValue][nb]) }); // voir impact CPU ???
			~pBeatView[nb].valueAction_(~pBeat[~tracksValue][~seqsValue][nb]);
			~nbBeatView[nb].valueAction_(~nbBeat[~tracksValue][~seqsValue][nb]);
			~sumBeatView[nb].valueAction_(~sumBeat[~tracksValue][~seqsValue][nb]);
			~minSumBeatView[nb].valueAction_(~minSumBeat[~tracksValue][~seqsValue][nb]);
		};


		// Données du Round 4
		~rtmRoundView.valueAction_(~rtmRoundValue[~tracksValue][~seqsValue]);
		~proRoundView.valueAction_(~proRoundValue[~tracksValue][~seqsValue]);
		~legRoundView.valueAction_(~legRoundValue[~tracksValue][~seqsValue]);

		// ~bufRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, ~bufFolderM[~tracksValue][~seqsValue].size-1, \lin, 1); // intégré dans ~bufFolderFunc ci-dessous
		// redondant - à optimiser ??? -> lignes ci-dessous déjà intégré dans ~bufFolderView, mais nécessaire pour avoir un preset dont le BufRangeView est correct - voir EtendueOnde et changer et revenir avec des presets avec d'autres dossier sons avec peu de fichiers sons (ex : PZ Baka)
		// -> Contenu de l'action de ~bufFolderView mis ci-dessus pour optimisation
		~bufFolderFunc.value(~tracksValue, ~seqsValue, ~bufFolderValue[~tracksValue][~seqsValue] /*~presets[index][\bufFolderView]*/, /*0*/ serv );
		~bufSpec[~tracksValue][~seqsValue] = ControlSpec(~bufMin[~tracksValue][~seqsValue], ~bufMax[~tracksValue][~seqsValue], \lin, 1);
		~bufRangeView.step_(1/(~bufFolderM[/*0*/ serv ][~tracksValue][~seqsValue].size - 1));
		~bufRangeView.minRange_(1/(~bufFolderM[/*0*/ serv ][~tracksValue][~seqsValue].size) * 1);
		~bufRangeView.string = "%\n to \n%".format((~bufMax[~tracksValue][~seqsValue] * ~bufMul[~tracksValue][~seqsValue]).round(1), (~bufMin[~tracksValue][~seqsValue] * ~bufMul[~tracksValue][~seqsValue]).round(1));
		~bufRangeView.valueAction_(~bufRangeSpec[~tracksValue][~seqsValue].unmap([~bufMin[~tracksValue][~seqsValue], ~bufMax[~tracksValue][~seqsValue]])).doAction; // nécessaire pour mise à jour quand changement de track ou seq & annulé en dessous - autre moyen pour faire la mise à jour ???
		~bufView.valueThumbSize_(max(10, if ((~bufMax[~tracksValue][~seqsValue] - ~bufMin[~tracksValue][~seqsValue]+1) > ~multiSliderHeight5,
			{10}, {~multiSliderHeight5 / (~bufMax[~tracksValue][~seqsValue] - ~bufMin[~tracksValue][~seqsValue]+1) })));
		~bufView.step_(1/(((~bufMax[~tracksValue][~seqsValue])-(~bufMin[~tracksValue][~seqsValue]))));
		~bufIndexView.step_(1/(~bufMax[~tracksValue][~seqsValue] - ~bufMin[~tracksValue][~seqsValue]));
		~bufIndexView.string_("At : %".format((~bufSpec[~tracksValue][~seqsValue].map(~bufIndexView.value) * ~bufMul[~tracksValue][~seqsValue]).asInteger/*.round(1)*/)); // léger pb de rounding ?
		~bufFolderView.value_(~bufFolderValue[~tracksValue][~seqsValue]);
		// ~bufFolderView.valueAction_(~bufFolderValue[~tracksValue][~seqsValue]); // retiré car contenu de l'action mis ci-dessus pour optimisation / mais remis pour mettre à jour le ~bufFolderView quand des PresetTracks sont chargés lorsqu'aucun contôleur n'est branché / puis retiré car met en rouge la sequence quand on change de piste

		~offRoundView.valueAction_(~offRoundValue[~tracksValue][~seqsValue]); ~off2RoundView.valueAction_(~off2RoundValue[~tracksValue][~seqsValue]); ~off3RoundView.valueAction_(~off3RoundValue[~tracksValue][~seqsValue]); ~off4RoundView.valueAction_(~off4RoundValue[~tracksValue][~seqsValue]);
		~ratRoundView.valueAction_(~ratRoundValue[~tracksValue][~seqsValue]); ~rat2RoundView.valueAction_(~rat2RoundValue[~tracksValue][~seqsValue]);
		~ampRoundView.valueAction_(~ampRoundValue[~tracksValue][~seqsValue]);
		~strRoundView.valueAction_(~strRoundValue[~tracksValue][~seqsValue]); ~str2RoundView.valueAction_(~str2RoundValue[~tracksValue][~seqsValue]);
		~cenRoundView.valueAction_(~cenRoundValue[~tracksValue][~seqsValue]); ~cen2RoundView.valueAction_(~cen2RoundValue[~tracksValue][~seqsValue]);
		~panRoundView.valueAction_(~panRoundValue[~tracksValue][~seqsValue]);
		~delRoundView.valueAction_(~delRoundValue[~tracksValue][~seqsValue]);


		// Données du RangeSlider 1
		~rtmRangeView.valueAction_(~rtmRangeSpec[~tracksValue][~seqsValue].unmap([~rtmMin[~tracksValue][~seqsValue], ~rtmMax[~tracksValue][~seqsValue]]));
		~proRangeView.valueAction_(~proRangeSpec[~tracksValue][~seqsValue].unmap([~proMin[~tracksValue][~seqsValue], ~proMax[~tracksValue][~seqsValue]]));
		~synRangeView.valueAction_(~synRangeSpec[~tracksValue][~seqsValue].unmap([~synMin[~tracksValue][~seqsValue], ~synMax[~tracksValue][~seqsValue]]));
		~spaRangeView.valueAction_(~spaRangeSpec[~tracksValue][~seqsValue].unmap([~spaMin[~tracksValue][~seqsValue], ~spaMax[~tracksValue][~seqsValue]]));
		~legRangeView.valueAction_(~legRangeSpec[~tracksValue][~seqsValue].unmap([~legMin[~tracksValue][~seqsValue], ~legMax[~tracksValue][~seqsValue]]));
		~envRangeView.valueAction_(~envRangeSpec[~tracksValue][~seqsValue].unmap([~envMin[~tracksValue][~seqsValue], ~envMax[~tracksValue][~seqsValue]]));
		// ~bufRangeView.valueAction_(~bufRangeSpec[~tracksValue][~seqsValue].unmap([~bufMin[~tracksValue][~seqsValue], ~bufMax[~tracksValue][~seqsValue]])).doAction; // placé avant & dans ~bufFolderView
		~offRangeView.valueAction_(~offRangeSpec[~tracksValue][~seqsValue].unmap([~offMin[~tracksValue][~seqsValue], ~offMax[~tracksValue][~seqsValue]]));
		~off2RangeView.valueAction_(~off2RangeSpec[~tracksValue][~seqsValue].unmap([~off2Min[~tracksValue][~seqsValue], ~off2Max[~tracksValue][~seqsValue]]));
		~off3RangeView.valueAction_(~off3RangeSpec[~tracksValue][~seqsValue].unmap([~off3Min[~tracksValue][~seqsValue], ~off3Max[~tracksValue][~seqsValue]]));
		~off4RangeView.valueAction_(~off4RangeSpec[~tracksValue][~seqsValue].unmap([~off4Min[~tracksValue][~seqsValue], ~off4Max[~tracksValue][~seqsValue]]));
		~ratRangeView.valueAction_(~ratRangeSpec[~tracksValue][~seqsValue].unmap([~ratMin[~tracksValue][~seqsValue], ~ratMax[~tracksValue][~seqsValue]]));
		~rat2RangeView.valueAction_(~rat2RangeSpec[~tracksValue][~seqsValue].unmap([~rat2Min[~tracksValue][~seqsValue], ~rat2Max[~tracksValue][~seqsValue]]));
		~ampRangeView.valueAction_(~ampRangeSpec[~tracksValue][~seqsValue].unmap([~ampMin[~tracksValue][~seqsValue], ~ampMax[~tracksValue][~seqsValue]]));
		~strRangeView.valueAction_(~strRangeSpec[~tracksValue][~seqsValue].unmap([~strMin[~tracksValue][~seqsValue], ~strMax[~tracksValue][~seqsValue]]));
		~str2RangeView.valueAction_(~str2RangeSpec[~tracksValue][~seqsValue].unmap([~str2Min[~tracksValue][~seqsValue], ~str2Max[~tracksValue][~seqsValue]]));
		~cenRangeView.valueAction_(~cenRangeSpec[~tracksValue][~seqsValue].unmap([~cenMin[~tracksValue][~seqsValue], ~cenMax[~tracksValue][~seqsValue]]));
		~cen2RangeView.valueAction_(~cen2RangeSpec[~tracksValue][~seqsValue].unmap([~cen2Min[~tracksValue][~seqsValue], ~cen2Max[~tracksValue][~seqsValue]]));
		~panRangeView.valueAction_(~panRangeSpec[~tracksValue][~seqsValue].unmap([~panMin[~tracksValue][~seqsValue], ~panMax[~tracksValue][~seqsValue]]));
		~delRangeView.valueAction_(~delRangeSpec[~tracksValue][~seqsValue].unmap([~delMin[~tracksValue][~seqsValue], ~delMax[~tracksValue][~seqsValue]]));
		~outLRangeView.valueAction_(~outLRangeSpec[~tracksValue][~seqsValue].unmap([~outLMin[~tracksValue][~seqsValue], ~outLMax[~tracksValue][~seqsValue]]));
		~outRRangeView.valueAction_(~outRRangeSpec[~tracksValue][~seqsValue].unmap([~outRMin[~tracksValue][~seqsValue], ~outRMax[~tracksValue][~seqsValue]]));
		~fxLRangeView.valueAction_(~fxLRangeSpec[~tracksValue][~seqsValue].unmap([~fxLMin[~tracksValue][~seqsValue], ~fxLMax[~tracksValue][~seqsValue]]));
		~fxRRangeView.valueAction_(~fxRRangeSpec[~tracksValue][~seqsValue].unmap([~fxRMin[~tracksValue][~seqsValue], ~fxRMax[~tracksValue][~seqsValue]]));


		// Données du Multislider 0
		/*~dur[~tracksValue][~seqsValue] = 0 ! ~dur[~tracksValue][~seqsValue].size;*/ // Pas besoin d'initialiser les données de taille l'array -> déjà fait par rand ou def
		/*~pro[~tracksValue][~seqsValue] = 0 ! ~pro[~tracksValue][~seqsValue].size; ... */

		if (~zoomMultiSlider == 0, {

			~rtmView.valueAction_(~dur[~tracksValue][~seqsValue]);
			~proView.valueAction_(~pro[~tracksValue][~seqsValue]);
			~synView.valueAction_(~syn[~tracksValue][~seqsValue]);
			~spaView.valueAction_(~spa[~tracksValue][~seqsValue]);
			~legView.valueAction_(~leg[~tracksValue][~seqsValue]);
			~envView.valueAction_(~env[~tracksValue][~seqsValue]);
			~bufView.valueAction_(~buf[~tracksValue][~seqsValue]);
			~offView.valueAction_(~off[~tracksValue][~seqsValue]); ~off2View.valueAction_(~off2[~tracksValue][~seqsValue]); ~off3View.valueAction_(~off3[~tracksValue][~seqsValue]); ~off4View.valueAction_(~off4[~tracksValue][~seqsValue]);
			~ratView.valueAction_(~rat[~tracksValue][~seqsValue]); ~rat2View.valueAction_(~rat2[~tracksValue][~seqsValue]);
			~ampView.valueAction_(~amp[~tracksValue][~seqsValue]);
			~strView.valueAction_(~str[~tracksValue][~seqsValue]); ~str2View.valueAction_(~str2[~tracksValue][~seqsValue]);
			~cenView.valueAction_(~cen[~tracksValue][~seqsValue]); ~cen2View.valueAction_(~cen2[~tracksValue][~seqsValue]);
			~panView.valueAction_(~pan[~tracksValue][~seqsValue]);
			~delView.valueAction_(~del[~tracksValue][~seqsValue]);
			~outLView.valueAction_(~outL[~tracksValue][~seqsValue]);
			~outRView.valueAction_(~outR[~tracksValue][~seqsValue]);
			~fxLView.valueAction_(~fxL[~tracksValue][~seqsValue]);
			~fxRView.valueAction_(~fxR[~tracksValue][~seqsValue]);

			[~rtmReadView, ~proReadView, ~synReadView, ~spaReadView, ~legReadView, ~envReadView, ~bufReadView, ~ampReadView, ~ratReadView, ~rat2ReadView, ~offReadView, ~off2ReadView, ~off3ReadView, ~off4ReadView, ~strReadView, ~str2ReadView, ~cenReadView, ~cen2ReadView, ~panReadView, ~delReadView, ~outLReadView, ~outRReadView, ~fxLReadView, ~fxRReadView].do{ |i| i.thumbSize_(rtmThumbSize) };

		}, {

			~rtmView.valueAction_(~dur[~tracksValue][~seqsValue][(0..max(0,~rtmSeqStop[~tracksValue][~seqsValue]))]);
			~rtmView.startIndex_(~rtmSeqStart[~tracksValue][~seqsValue]);
			~rtmView.indexThumbSize_(~rtmView.bounds.width / ~seqDurRtm[~tracksValue][~seqsValue]);

			~proView.valueAction_(~pro[~tracksValue][~seqsValue][(0..max(0,~proSeqStop[~tracksValue][~seqsValue]))]);
			~proView.startIndex_(~proSeqStart[~tracksValue][~seqsValue]);
			~proView.indexThumbSize_(~proView.bounds.width / ~seqDurPro[~tracksValue][~seqsValue]);

			~synView.valueAction_(~syn[~tracksValue][~seqsValue][(0..max(0,~synSeqStop[~tracksValue][~seqsValue]))]);
			~synView.startIndex_(~synSeqStart[~tracksValue][~seqsValue]);
			~synView.indexThumbSize_(~synView.bounds.width / ~seqDurSyn[~tracksValue][~seqsValue]);

			~spaView.valueAction_(~spa[~tracksValue][~seqsValue][(0..max(0,~spaSeqStop[~tracksValue][~seqsValue]))]);
			~spaView.startIndex_(~rtmSeqStart[~tracksValue][~seqsValue]);
			~spaView.indexThumbSize_(~spaView.bounds.width / ~seqDurSpa[~tracksValue][~seqsValue]);

			~legView.valueAction_(~leg[~tracksValue][~seqsValue][(0..max(0,~legSeqStop[~tracksValue][~seqsValue]))]);
			~legView.startIndex_(~legSeqStart[~tracksValue][~seqsValue]);
			~legView.indexThumbSize_(~legView.bounds.width / ~seqDurLeg[~tracksValue][~seqsValue]);

			~envView.valueAction_(~env[~tracksValue][~seqsValue][(0..max(0,~envSeqStop[~tracksValue][~seqsValue]))]);
			~envView.startIndex_(~envSeqStart[~tracksValue][~seqsValue]);
			~envView.indexThumbSize_(~envView.bounds.width / ~seqDurEnv[~tracksValue][~seqsValue]);

			~bufView.valueAction_(~buf[~tracksValue][~seqsValue][(0..max(0,~bufSeqStop[~tracksValue][~seqsValue]))]);
			~bufView.startIndex_(~bufSeqStart[~tracksValue][~seqsValue]);
			~bufView.indexThumbSize_(~bufView.bounds.width / ~seqDurBuf[~tracksValue][~seqsValue]);

			~offView.valueAction_(~off[~tracksValue][~seqsValue][(0..max(0,~offSeqStop[~tracksValue][~seqsValue]))]);
			~offView.startIndex_(~offSeqStart[~tracksValue][~seqsValue]);
			~offView.indexThumbSize_(~offView.bounds.width / ~seqDurOff[~tracksValue][~seqsValue]);
			~off2View.valueAction_(~off2[~tracksValue][~seqsValue][(0..max(0,~off2SeqStop[~tracksValue][~seqsValue]))]);
			~off2View.startIndex_(~off2SeqStart[~tracksValue][~seqsValue]);
			~off2View.indexThumbSize_(~off2View.bounds.width / ~seqDurOff2[~tracksValue][~seqsValue]);
			~off3View.valueAction_(~off3[~tracksValue][~seqsValue][(0..max(0,~off3SeqStop[~tracksValue][~seqsValue]))]);
			~off3View.startIndex_(~off3SeqStart[~tracksValue][~seqsValue]);
			~off3View.indexThumbSize_(~off3View.bounds.width / ~seqDurOff3[~tracksValue][~seqsValue]);
			~off4View.valueAction_(~off4[~tracksValue][~seqsValue][(0..max(0,~off4SeqStop[~tracksValue][~seqsValue]))]);
			~off4View.startIndex_(~off4SeqStart[~tracksValue][~seqsValue]);
			~off4View.indexThumbSize_(~off4View.bounds.width / ~seqDurOff4[~tracksValue][~seqsValue]);

			~ratView.valueAction_(~rat[~tracksValue][~seqsValue][(0..max(0,~ratSeqStop[~tracksValue][~seqsValue]))]);
			~ratView.startIndex_(~ratSeqStart[~tracksValue][~seqsValue]);
			~ratView.indexThumbSize_(~ratView.bounds.width / ~seqDurRat[~tracksValue][~seqsValue]);
			~rat2View.valueAction_(~rat2[~tracksValue][~seqsValue][(0..max(0,~rat2SeqStop[~tracksValue][~seqsValue]))]);
			~rat2View.startIndex_(~rat2SeqStart[~tracksValue][~seqsValue]);
			~rat2View.indexThumbSize_(~rat2View.bounds.width / ~seqDurRat2[~tracksValue][~seqsValue]);

			~ampView.valueAction_(~amp[~tracksValue][~seqsValue][(0..max(0,~ampSeqStop[~tracksValue][~seqsValue]))]);
			~ampView.startIndex_(~ampSeqStart[~tracksValue][~seqsValue]);
			~ampView.indexThumbSize_(~ampView.bounds.width / ~seqDurAmp[~tracksValue][~seqsValue]);

			~strView.valueAction_(~str[~tracksValue][~seqsValue][(0..max(0,~strSeqStop[~tracksValue][~seqsValue]))]);
			~strView.startIndex_(~strSeqStart[~tracksValue][~seqsValue]);
			~strView.indexThumbSize_(~strView.bounds.width / ~seqDurStr[~tracksValue][~seqsValue]);
			~str2View.valueAction_(~str2[~tracksValue][~seqsValue][(0..max(0,~str2SeqStop[~tracksValue][~seqsValue]))]);
			~str2View.startIndex_(~str2SeqStart[~tracksValue][~seqsValue]);
			~str2View.indexThumbSize_(~str2View.bounds.width / ~seqDurStr2[~tracksValue][~seqsValue]);

			~cenView.valueAction_(~cen[~tracksValue][~seqsValue][(0..max(0,~cenSeqStop[~tracksValue][~seqsValue]))]);
			~cenView.startIndex_(~cenSeqStart[~tracksValue][~seqsValue]);
			~cenView.indexThumbSize_(~cenView.bounds.width / ~seqDurCen[~tracksValue][~seqsValue]);
			~cen2View.valueAction_(~cen2[~tracksValue][~seqsValue][(0..max(0,~cen2SeqStop[~tracksValue][~seqsValue]))]);
			~cen2View.startIndex_(~cen2SeqStart[~tracksValue][~seqsValue]);
			~cen2View.indexThumbSize_(~cen2View.bounds.width / ~seqDurCen2[~tracksValue][~seqsValue]);

			~panView.valueAction_(~pan[~tracksValue][~seqsValue][(0..max(0,~panSeqStop[~tracksValue][~seqsValue]))]);
			~panView.startIndex_(~panSeqStart[~tracksValue][~seqsValue]);
			~panView.indexThumbSize_(~panView.bounds.width / ~seqDurPan[~tracksValue][~seqsValue]);

			~delView.valueAction_(~del[~tracksValue][~seqsValue][(0..max(0,~delSeqStop[~tracksValue][~seqsValue]))]);
			~delView.startIndex_(~delSeqStart[~tracksValue][~seqsValue]);
			~delView.indexThumbSize_(~delView.bounds.width / ~seqDurDel[~tracksValue][~seqsValue]);

			~outLView.valueAction_(~outL[~tracksValue][~seqsValue][(0..max(0,~outLSeqStop[~tracksValue][~seqsValue]))]);
			~outLView.startIndex_(~outLSeqStart[~tracksValue][~seqsValue]);
			~outLView.indexThumbSize_(~outLView.bounds.width / ~seqDurOutL[~tracksValue][~seqsValue]);

			~outRView.valueAction_(~outR[~tracksValue][~seqsValue][(0..max(0,~outRSeqStop[~tracksValue][~seqsValue]))]);
			~outRView.startIndex_(~outRSeqStart[~tracksValue][~seqsValue]);
			~outRView.indexThumbSize_(~outRView.bounds.width / ~seqDurOutR[~tracksValue][~seqsValue]);

			~fxLView.valueAction_(~fxL[~tracksValue][~seqsValue][(0..max(0,~fxLSeqStop[~tracksValue][~seqsValue]))]);
			~fxLView.startIndex_(~fxLSeqStart[~tracksValue][~seqsValue]);
			~fxLView.indexThumbSize_(~fxLView.bounds.width / ~seqDurFxL[~tracksValue][~seqsValue]);

			~fxRView.valueAction_(~fxR[~tracksValue][~seqsValue][(0..max(0,~fxRSeqStop[~tracksValue][~seqsValue]))]);
			~fxRView.startIndex_(~fxRSeqStart[~tracksValue][~seqsValue]);
			~fxRView.indexThumbSize_(~fxRView.bounds.width / ~seqDurFxR[~tracksValue][~seqsValue]);

		});


		// Pas nécessaire car les SeqSpec sont initiés auparavant
		// Changement du SeqRangeSpec  - Utilité d'avoir des SeqSpec différents pour chaque module ???
		/*~gblSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~gblSeqIndexSpec[~tracksValue][~seqsValue] = rtmSeqSpec; // Pourquoi garder un controlSpec identique au précédent ???
		~rtmSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~proSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~synSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~spaSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~legSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~envSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~bufSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~offSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~ratSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~ampSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~strSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~cenSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~panSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~outLSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~outRSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~fxLSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~fxRSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;*/

		// ~bufSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurBuf[~tracksValue][~seqsValue], \lin, 1, 1); // Pour le Slider ~bufReadView


		~gblSeqIndexView.step_(rtmSeqStep)
		.value_(~gblSeqIndexSpec[~tracksValue][~seqsValue].unmap(~gblSeqIndex[~tracksValue][~seqsValue]));
		~gblSeqIndexView.string = "At : %".format(~gblSeqIndex[~tracksValue][~seqsValue].asInteger);
		// if (~gblSeqIndex[~tracksValue][~seqsValue] != 0, {~gblSeqIndexView.value_(~gblSeqIndexSpec[~tracksValue][~seqsValue].unmap(~gblSeqIndex[~tracksValue][~seqsValue]))}, {~gblSeqIndexView.value_(0)});
		// .doAction // Pas possible de l'utiliser car déclenche tous les seqsView

		~gblSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep)
		.value_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~gblSeqView.string = ("% to % (Dur :"+(~gblSeqStop[~tracksValue][~seqsValue] - ~gblSeqStart[~tracksValue][~seqsValue] + 1).asInteger+")").format(~gblSeqStart[~tracksValue][~seqsValue].asInteger, ~gblSeqStop[~tracksValue][~seqsValue].asInteger);
		/* if (~gblSeqStart[~tracksValue][~seqsValue] == 0 and: { ~gblSeqStop[~tracksValue][~seqsValue] == (rtmSeqSize -1) },
		{~gblSeqView.value_([0, 1]); ~gblSeqView.string = ("% to % (Dur :"+(rtmSeqSize)+")").format(0, rtmSeqSize -1)},
		{~gblSeqView.value_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1])); ~gblSeqView.string = ("% to % (Dur :"+(~gblSeqStop[~tracksValue][~seqsValue] - ~gblSeqStart[~tracksValue][~seqsValue] + 1)+")").format(~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue] )});*/
		// .doAction // Pas possible de l'utiliser car déclenche tous les seqsView


		// Données du SeqRangeSlider 2
		// Rajout de .doAction pour presetGetFunctionQuick et visualisation des presets sur des séquences ≠ de celles visualisées (aussi pour le gbl ci-dessus) pour modif de l'affichage si les données n'ont pas changé ???
		~rtmSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~rtmSeqSpec[~tracksValue][~seqsValue].unmap([~rtmSeqStart[~tracksValue][~seqsValue], ~rtmSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~proSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~proSeqSpec[~tracksValue][~seqsValue].unmap([~proSeqStart[~tracksValue][~seqsValue], ~proSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~synSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~synSeqSpec[~tracksValue][~seqsValue].unmap([~synSeqStart[~tracksValue][~seqsValue], ~synSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~spaSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~spaSeqSpec[~tracksValue][~seqsValue].unmap([~spaSeqStart[~tracksValue][~seqsValue], ~spaSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~legSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~legSeqSpec[~tracksValue][~seqsValue].unmap([~legSeqStart[~tracksValue][~seqsValue], ~legSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~envSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~envSeqSpec[~tracksValue][~seqsValue].unmap([~envSeqStart[~tracksValue][~seqsValue], ~envSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~bufSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~bufSeqSpec[~tracksValue][~seqsValue].unmap([~bufSeqStart[~tracksValue][~seqsValue], ~bufSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~offSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~offSeqSpec[~tracksValue][~seqsValue].unmap([~offSeqStart[~tracksValue][~seqsValue], ~offSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~off2SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~off2SeqSpec[~tracksValue][~seqsValue].unmap([~off2SeqStart[~tracksValue][~seqsValue], ~off2SeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~off3SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~off3SeqSpec[~tracksValue][~seqsValue].unmap([~off3SeqStart[~tracksValue][~seqsValue], ~off3SeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~off4SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~off4SeqSpec[~tracksValue][~seqsValue].unmap([~off4SeqStart[~tracksValue][~seqsValue], ~off4SeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~ratSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~ratSeqSpec[~tracksValue][~seqsValue].unmap([~ratSeqStart[~tracksValue][~seqsValue], ~ratSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~rat2SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~rat2SeqSpec[~tracksValue][~seqsValue].unmap([~rat2SeqStart[~tracksValue][~seqsValue], ~rat2SeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~ampSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~ampSeqSpec[~tracksValue][~seqsValue].unmap([~ampSeqStart[~tracksValue][~seqsValue], ~ampSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~strSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~strSeqSpec[~tracksValue][~seqsValue].unmap([~strSeqStart[~tracksValue][~seqsValue], ~strSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~str2SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~str2SeqSpec[~tracksValue][~seqsValue].unmap([~str2SeqStart[~tracksValue][~seqsValue], ~str2SeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~cenSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~cenSeqSpec[~tracksValue][~seqsValue].unmap([~cenSeqStart[~tracksValue][~seqsValue], ~cenSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~cen2SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~cen2SeqSpec[~tracksValue][~seqsValue].unmap([~cen2SeqStart[~tracksValue][~seqsValue], ~cen2SeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~panSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~panSeqSpec[~tracksValue][~seqsValue].unmap([~panSeqStart[~tracksValue][~seqsValue], ~panSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~delSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~delSeqSpec[~tracksValue][~seqsValue].unmap([~delSeqStart[~tracksValue][~seqsValue], ~delSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~outLSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~outLSeqSpec[~tracksValue][~seqsValue].unmap([~outLSeqStart[~tracksValue][~seqsValue], ~outLSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~outRSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~outRSeqSpec[~tracksValue][~seqsValue].unmap([~outRSeqStart[~tracksValue][~seqsValue], ~outRSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~fxLSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~fxLSeqSpec[~tracksValue][~seqsValue].unmap([~fxLSeqStart[~tracksValue][~seqsValue], ~fxLSeqStop[~tracksValue][~seqsValue]+1])).doAction;
		~fxRSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~fxRSeqSpec[~tracksValue][~seqsValue].unmap([~fxRSeqStart[~tracksValue][~seqsValue], ~fxRSeqStop[~tracksValue][~seqsValue]+1])).doAction;


		// Données du MulSlider 3
		~synMulView.valueAction_(~synMulSpec.unmap(~synMul[~tracksValue][~seqsValue]));
		~spaMulView.valueAction_(~spaMulSpec.unmap(~spaMul[~tracksValue][~seqsValue]));
		~envMulView.valueAction_(~envMulSpec.unmap(~envMul[~tracksValue][~seqsValue]));

		~rtmMulView.value_(~rtmMulSpec[~tracksValue][~seqsValue].unmap(~rtmMul[~tracksValue][~seqsValue])).doAction;
		~proMulView.value_(~proMulSpec.unmap(~proMul[~tracksValue][~seqsValue])).doAction;
		~legMulView.value_(~legMulSpec.unmap(~legMul[~tracksValue][~seqsValue])).doAction;
		~ratMulView.value_(~ratMulSpec.unmap(~ratMul[~tracksValue][~seqsValue])).doAction;
		// ~offMulView.value_(~offMulSpec.unmap(~offMul[~tracksValue][~seqsValue])).doAction;
		~strMulView.value_(~strMulSpec.unmap(~strMul[~tracksValue][~seqsValue])).doAction;
		~cenMulView.value_(~cenMulSpec.unmap(~cenMul[~tracksValue][~seqsValue])).doAction;
		~bufMulView.value_(~bufMulSpec.unmap(~bufMul[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue])).doAction; // Changement GUI 221
		// ~bufMul[~tracksValue][~seqSeq[~tracksValue]]/*[~seqsValue]*/.postln; ~bufMul[~tracksValue][~seqsValue].postln;
		// 2 mises à jour successives : [~seqSeq[~tracksValue]] donne une première bonne valeur, alors [~seqsValue] donne une première mauvaise valeur qui est bien updaté par la suite
		~offMulView.value_(~offMulSpec.unmap(~offMul[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue])).doAction; // Changement GUI 221
		~off2MulView.valueAction_(~off2MulSpec.unmap(~off2Mul[~tracksValue][~seqsValue]));
		~off3MulView.valueAction_(~off3MulSpec.unmap(~off3Mul[~tracksValue][~seqsValue]));
		~off4MulView.valueAction_(~off4MulSpec.unmap(~off4Mul[~tracksValue][~seqsValue]));

		/*if (~twister.notNil, {
		~ratValues[~tracksValue].value_(~ratMulSpec.unmap(~ratMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~rtmValues[~tracksValue].value_(~rtmMulSpec[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/.unmap(~rtmMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~proValues[~tracksValue].value_(~proMulSpec.unmap(~proMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~legValues[~tracksValue].value_(~legMulSpec.unmap(~legMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~strValues[~tracksValue].value_(~strMulSpec.unmap(~strMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~cenValues[~tracksValue].value_(~cenMulSpec.unmap(~cenMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~bufFolValues[~tracksValue].value_(~bufFolderValue[~tracksValue][~seqsValue]);
		~bufValues[~tracksValue].value_(~bufMulSpec.unmap(~bufMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~offValues[~tracksValue].value_(~offMulSpec.unmap(~offMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		// ~offValue.value_(~offMulSpec.unmap(~offMul[~tracksValue][~seqsValue]));
		},{
		/*~rtmMulView.value_(~rtmMulSpec[~tracksValue][~seqsValue].unmap(~rtmMul[~tracksValue][~seqsValue])).doAction;
		~proMulView.value_(~proMulSpec.unmap(~proMul[~tracksValue][~seqsValue])).doAction;
		~legMulView.value_(~legMulSpec.unmap(~legMul[~tracksValue][~seqsValue])).doAction;
		~ratMulView.value_(~ratMulSpec.unmap(~ratMul[~tracksValue][~seqsValue])).doAction;
		// ~offMulView.value_(~offMulSpec.unmap(~offMul[~tracksValue][~seqsValue])).doAction;
		~strMulView.value_(~strMulSpec.unmap(~strMul[~tracksValue][~seqsValue])).doAction;
		~cenMulView.value_(~cenMulSpec.unmap(~cenMul[~tracksValue][~seqsValue])).doAction;
		~bufMulView.valueAction_(~bufMulSpec.unmap(~bufMul[~tracksValue][~seqsValue])).doAction;
		~offMulView.valueAction_(~offMulSpec.unmap(~offMul[~tracksValue][~seqsValue])).doAction;*/
		});*/ // Pour mise à jour du Twister

		~rat2MulView.valueAction_(~rat2MulSpec.unmap(~rat2Mul[~tracksValue][~seqsValue]));
		~ampMulView.valueAction_(~ampMulSpec.unmap(~ampMul[~tracksValue][~seqsValue]));
		~str2MulView.valueAction_(~str2MulSpec.unmap(~str2Mul[~tracksValue][~seqsValue]));
		~cen2MulView.valueAction_(~cen2MulSpec.unmap(~cen2Mul[~tracksValue][~seqsValue]));
		~panMulView.valueAction_(~panMulSpec.unmap(~panMul[~tracksValue][~seqsValue]));
		~delMulView.valueAction_(~delMulSpec.unmap(~delMul[~tracksValue][~seqsValue]));
		~outLMulView.valueAction_(~outLMulSpec.unmap(~outLMul[~tracksValue][~seqsValue]));
		~outRMulView.valueAction_(~outRMulSpec.unmap(~outRMul[~tracksValue][~seqsValue]));
		~fxLMulView.valueAction_(~fxLMulSpec.unmap(~fxLMul[~tracksValue][~seqsValue]));
		~fxRMulView.valueAction_(~fxRMulSpec.unmap(~fxRMul[~tracksValue][~seqsValue]));


		// Données du Pattern 5
		~rtmDirView.valueAction_(~rtmDir[~tracksValue][~seqsValue]);
		~proDirView.valueAction_(~proDir[~tracksValue][~seqsValue]);
		~synDirView.valueAction_(~synDir[~tracksValue][~seqsValue]);
		~spaDirView.valueAction_(~spaDir[~tracksValue][~seqsValue]);
		~legDirView.valueAction_(~legDir[~tracksValue][~seqsValue]);
		~envDirView.valueAction_(~envDir[~tracksValue][~seqsValue]);
		~bufDirView.valueAction_(~bufDir[~tracksValue][~seqsValue]);
		~offDirView.valueAction_(~offDir[~tracksValue][~seqsValue]); ~off2DirView.valueAction_(~off2Dir[~tracksValue][~seqsValue]); ~off3DirView.valueAction_(~off3Dir[~tracksValue][~seqsValue]); ~off4DirView.valueAction_(~off4Dir[~tracksValue][~seqsValue]);
		~ratDirView.valueAction_(~ratDir[~tracksValue][~seqsValue]); ~rat2DirView.valueAction_(~rat2Dir[~tracksValue][~seqsValue]);
		~ampDirView.valueAction_(~ampDir[~tracksValue][~seqsValue]);
		~strDirView.valueAction_(~strDir[~tracksValue][~seqsValue]); ~str2DirView.valueAction_(~str2Dir[~tracksValue][~seqsValue]);
		~cenDirView.valueAction_(~cenDir[~tracksValue][~seqsValue]); ~cen2DirView.valueAction_(~cen2Dir[~tracksValue][~seqsValue]);
		~panDirView.valueAction_(~panDir[~tracksValue][~seqsValue]);
		~delDirView.valueAction_(~delDir[~tracksValue][~seqsValue]);
		~outLDirView.valueAction_(~outLDir[~tracksValue][~seqsValue]);
		~outRDirView.valueAction_(~outRDir[~tracksValue][~seqsValue]);
		~fxLDirView.valueAction_(~fxLDir[~tracksValue][~seqsValue]);
		~fxRDirView.valueAction_(~fxRDir[~tracksValue][~seqsValue]);

		~rtmPatView.valueAction_(~rtmPat[~tracksValue][~seqsValue]);
		~proPatView.value_(~proPat[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue]).doAction; // A mettre sur tout ??? pour action sur le global // Changement GUI 221
		~synPatView.valueAction_(~synPat[~tracksValue][~seqsValue]);
		~spaPatView.value_(~spaPat[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue]).doAction; // A mettre sur tout ??? pour action sur le global // Changement GUI 221
		~legPatView.valueAction_(~legPat[~tracksValue][~seqsValue]);
		~envPatView.valueAction_(~envPat[~tracksValue][~seqsValue]);
		~bufPatView.valueAction_(~bufPat[~tracksValue][~seqsValue]);
		~offPatView.valueAction_(~offPat[~tracksValue][~seqsValue]); ~off2PatView.valueAction_(~off2Pat[~tracksValue][~seqsValue]); ~off3PatView.valueAction_(~off3Pat[~tracksValue][~seqsValue]); ~off4PatView.valueAction_(~off4Pat[~tracksValue][~seqsValue]);
		~ratPatView.valueAction_(~ratPat[~tracksValue][~seqsValue]); ~rat2PatView.valueAction_(~rat2Pat[~tracksValue][~seqsValue]);
		~ampPatView.valueAction_(~ampPat[~tracksValue][~seqsValue]);
		~strPatView.valueAction_(~strPat[~tracksValue][~seqsValue]); ~str2PatView.valueAction_(~str2Pat[~tracksValue][~seqsValue]);
		~cenPatView.valueAction_(~cenPat[~tracksValue][~seqsValue]); ~cen2PatView.valueAction_(~cen2Pat[~tracksValue][~seqsValue]);
		~panPatView.valueAction_(~panPat[~tracksValue][~seqsValue]);
		~delPatView.valueAction_(~delPat[~tracksValue][~seqsValue]);
		~outLPatView.valueAction_(~outLPat[~tracksValue][~seqsValue]);
		~outRPatView.valueAction_(~outRPat[~tracksValue][~seqsValue]);
		// Permet d'éviter un pattern aléatoire sur les sorties si stéréo - à supprimer
		/*if (~numChannels == 2, {
		~outLRoundView.valueAction_(~linksChannel -1); ~outRRoundView.valueAction_(~rightChannel -1);
		}, {
		~outLPatView.valueAction_(~outLPat[~tracksValue][~seqsValue]);
		~outRPatView.valueAction_(~outRPat[~tracksValue][~seqsValue]);
		}
		);*/
		~fxLPatView.valueAction_(~fxLPat[~tracksValue][~seqsValue]);
		~fxRPatView.valueAction_(~fxRPat[~tracksValue][~seqsValue]);

		~rtmPatSelView.valueAction_(~rtmPatSel[~tracksValue][~seqsValue]);
		// ~proPatSelView.valueAction_(~proPatSel[~tracksValue][~seqsValue]); // remis plus bas car agit sur le step et l'apparition des données
		~synPatSelView.valueAction_(~synPatSel[~tracksValue][~seqsValue]);
		~spaPatSelView.valueAction_(~spaPatSel[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue]); // Changement GUI 221
		~legPatSelView.valueAction_(~legPatSel[~tracksValue][~seqsValue]);
		~envPatSelView.valueAction_(~envPatSel[~tracksValue][~seqsValue]);
		~bufPatSelView.valueAction_(~bufPatSel[~tracksValue][~seqsValue]);
		~offPatSelView.valueAction_(~offPatSel[~tracksValue][~seqsValue]); ~off2PatSelView.valueAction_(~off2PatSel[~tracksValue][~seqsValue]); ~off3PatSelView.valueAction_(~off3PatSel[~tracksValue][~seqsValue]); ~off4PatSelView.valueAction_(~off4PatSel[~tracksValue][~seqsValue]);
		~ratPatSelView.valueAction_(~ratPatSel[~tracksValue][~seqsValue]); ~rat2PatSelView.valueAction_(~rat2PatSel[~tracksValue][~seqsValue]);
		~ampPatSelView.valueAction_(~ampPatSel[~tracksValue][~seqsValue]);
		~strPatSelView.valueAction_(~strPatSel[~tracksValue][~seqsValue]); ~str2PatSelView.valueAction_(~str2PatSel[~tracksValue][~seqsValue]);
		~cenPatSelView.valueAction_(~cenPatSel[~tracksValue][~seqsValue]); ~cen2PatSelView.valueAction_(~cen2PatSel[~tracksValue][~seqsValue]);
		~panPatSelView.valueAction_(~panPatSel[~tracksValue][~seqsValue]);
		~delPatSelView.valueAction_(~delPatSel[~tracksValue][~seqsValue]);
		~outLPatSelView.valueAction_(~outLPatSel[~tracksValue][~seqsValue]);
		~outRPatSelView.valueAction_(~outRPatSel[~tracksValue][~seqsValue]);
		~fxLPatSelView.valueAction_(~fxLPatSel[~tracksValue][~seqsValue]);
		~fxRPatSelView.valueAction_(~fxRPatSel[~tracksValue][~seqsValue]);


		// Données des petits sliders 6
		~rtmTypeView.valueAction_(~rtmType[~tracksValue][~seqsValue]);
		~rtmTypeView2.valueAction_(~sequenceType[~tracksValue][~seqsValue]);
		// if (~rtmTypeView2.value != ~sequenceType[~tracksValue][~seqsValue], {~rtmTypeView2.valueAction_(~sequenceType[~tracksValue][~seqsValue]) });

		// ~proBjorSpec[~tracksValue][~seqsValue] = rtmSeqSpec; // Pas nécessaire car les SeqSpec sont initiés auparavant
		/*~proBjorView.step_(rtmSeqStep).valueAction_(~proBjorSpec[~tracksValue][~seqSeq[~tracksValue]]/*[~seqsValue]*/.unmap(~proBjor[~tracksValue][~seqSeq[~tracksValue]] /*[~seqsValue]*/)).doAction; // doAction pour mise à jour du Spec & action sur le global
		~proBjor2View.step_(rtmSeqStep).valueAction_(~proBjorSpec[~tracksValue][~seqSeq[~tracksValue]]/*[~seqsValue]*/.unmap(~proBjor2[~tracksValue][~seqSeq[~tracksValue]] /*[~seqsValue]*/)).doAction; // doAction pour mise à jour du Spec & action sur le global*/
		// ~proBjorSpec[~tracksValue][~seqSeq[~tracksValue]].postln; ~proBjorSpec[~tracksValue][~seqsValue].postln;
		// Auparavant [~seqSeq[~tracksValue]] à la place de [~seqsValue] - To check ???
		~proBjorView/*.step_(rtmSeqStep)*/.value_(~proBjorSpec[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue].unmap(~proBjor[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue]) /*~proBjorGridsX[~tracksValue][~seqsValue]*/).doAction; // doAction pour mise à jour du Spec & action sur le global // Changement GUI 221
		~proBjor2View/*.step_(rtmSeqStep)*/.value_(~proBjorSpec[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue].unmap(~proBjor2[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue]) /*~proBjorGridsY[~tracksValue][~seqsValue]*/).doAction; // doAction pour mise à jour du Spec & action sur le global // Changement GUI 221
		~proSelectView.value_(~proSelect[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue]).doAction; // doAction -> necessaire pour action sur le global // Changement GUI 221

		~proBjor3View.value_(~proGridsBias[~tracksValue][~seqsValue]).doAction;
		~proBjor4View.value_(~proGridsBias2[~tracksValue][~seqsValue]).doAction;
		~proWeightView.valueAction_(~proWeight[~tracksValue][~seqsValue]);
		~proDrumTypeView.valueAction_(~proDrumType[~tracksValue][~seqsValue]);

		~proPatSelView.valueAction_(~proPatSel[~tracksValue][~seqsValue]); // était plus haut mais doit agir sur le step et l'apparition des données

		~synTypeView.valueAction_(~synType[~tracksValue][~seqsValue]);
		~offRateSecondBufView.valueAction_(~offRateSecondBufSpec.unmap(~offRateSecondBuf[~tracksValue][~seqsValue]));
		~offRateRandSecondBufView.valueAction_(~offRateRandSecondBuf[~tracksValue][~seqsValue]);

		~stereoSpatTypeView.valueAction_(~stereoSpatType[~tracksValue][~seqsValue]);
		~dbRollOffView.valueAction_(~dbRollOff[~tracksValue][~seqsValue]);
		~speakRadView.valueAction_(~speakRad[~tracksValue][~seqsValue]);
		~orientationView.valueAction_(~orientation[~tracksValue][~seqsValue]);
		~vmPointScaleView.valueAction_(~vmPointScale[~tracksValue][~seqsValue]);
		~vbPointScaleView.valueAction_(~vbPointScale[~tracksValue][~seqsValue]);
		~ambPointScaleView.valueAction_(~ambPointScale[~tracksValue][~seqsValue]);
		~trajSpatLoopView.valueAction_(~trajSpatLoop[~tracksValue][~seqsValue]);
		~trajSpatRateView.valueAction_(~trajSpatRate[~tracksValue][~seqsValue]);
		~trajSpatTimeTypeView.valueAction_(~trajSpatTimeType[~tracksValue][~seqsValue]);
		~trajSpatTypeView.valueAction_(~trajSpatType[~tracksValue][~seqsValue]);
		~spaLagTimeView.valueAction_(~spaLagTime[~tracksValue][~seqsValue]);
		~spaLagCurveView.valueAction_(~spaLagCurve[~tracksValue][~seqsValue]);
		~sdFreqRangeView.valueAction_([~sdFreqRangeMin[~tracksValue][~seqsValue],~sdFreqRangeMax[~tracksValue][~seqsValue]]);
		~sdDbRangeView.valueAction_([~sdDbRangeMin[~tracksValue][~seqsValue],~sdDbRangeMax[~tracksValue][~seqsValue]]);
		~spec2spaCurveView.valueAction_(~spec2spaCurve[~tracksValue][~seqsValue]);

		~vbapSpreadView.valueAction_(~vbapSpread[~tracksValue][~seqsValue]);
		~vbapX2OffView.valueAction_(~vbapX2Off[~tracksValue][~seqsValue]);
		~circSpreadView.valueAction_(~circSpread[~tracksValue][~seqsValue]);
		~circSpatTypeView.valueAction_(~circSpatType[~tracksValue][~seqsValue]);
		~circSpeedRangeView.valueAction_([~circSpeedRangeMin[~tracksValue][~seqsValue],~circSpeedRangeMax[~tracksValue][~seqsValue]]);
		~sdSpatTypeView.valueAction_(~sdSpatType[~tracksValue][~seqsValue]);


		~legTypeView.valueAction_(~legType[~tracksValue][~seqsValue]);
		~legLoopView.valueAction_(~legLoop[~tracksValue][~seqsValue]);

		~envNum.do { |i|
			~atkView[i].valueAction_(~atk[~tracksValue][~seqsValue][i]);
			~relView[i].valueAction_(~rel[~tracksValue][~seqsValue][i]);
			~atkCurveView[i].valueAction_(~atkCurve[~tracksValue][~seqsValue][i]);
			~relCurveView[i].valueAction_(~relCurve[~tracksValue][~seqsValue][i]);
		};
		~w1View.valueAction_(~w1[~tracksValue][~seqsValue]);
		~w2View.valueAction_(~w2[~tracksValue][~seqsValue]);
		~envTypeView.valueAction_(~envType[~tracksValue][~seqsValue]);

		~offThreshView.valueAction_(~offThreshSpec.unmap(~offThresh[~tracksValue][~seqsValue]));
		~freqRatView.valueAction_(~freqRatSpec.unmap(~freqRat[~tracksValue][~seqsValue]));
		~fAmpView.valueAction_(~fAmpSpec.unmap(~fAmp[~tracksValue][~seqsValue]));
		~ampRatView.valueAction_(~ampRatSpec.unmap(~ampRat[~tracksValue][~seqsValue]));
		~aAmpView.valueAction_(~aAmpSpec.unmap(~aAmp[~tracksValue][~seqsValue]));
		~panRatView.valueAction_(~panRatSpec.unmap(~panRat[~tracksValue][~seqsValue]));
		~pAmpView.valueAction_(~pAmpSpec.unmap(~pAmp[~tracksValue][~seqsValue]));
		~ratSynthView.valueAction_(~ratSynth[~tracksValue][~seqsValue]);

		~grainSizeView.valueAction_(~grainSize[~tracksValue][~seqsValue]);
		~grain2SizeView.valueAction_(~grain2Size[~tracksValue][~seqsValue]);

		~lehmerInit1View.valueAction_(~lehmerInit1[~tracksValue][~seqsValue]);
		~lehmerA1View.valueAction_(~lehmerA1[~tracksValue][~seqsValue]);
		~lehmerB1View.valueAction_(~lehmerB1[~tracksValue][~seqsValue]);
		~lehmerReInit1View.valueAction_(~lehmerReInit1[~tracksValue][~seqsValue]);
		~lehmerInit2View.valueAction_(~lehmerInit2[~tracksValue][~seqsValue]);
		~lehmerA2View.valueAction_(~lehmerA2[~tracksValue][~seqsValue]);
		~lehmerB2View.valueAction_(~lehmerB2[~tracksValue][~seqsValue]);
		~lehmerReInit2View.valueAction_(~lehmerReInit2[~tracksValue][~seqsValue]);


		if (~bufSequence[~tracksValue][~seqsValue] != [ 0, 0 ], { (((~tracksValue/2).floor.asInteger+1) + "/" + /*~presetSeqStart*/ (~posSeq2[~tracksValue]+1) + "- BufSequence ->" + ~bufSequence[~tracksValue][~seqsValue]).warn; });
		if (~presetNotes[~tracksValue][~seqsValue] != 0, { (((~tracksValue/2).floor.asInteger+1) + "/" + /*~presetSeqStart*/ (~posSeq2[~tracksValue]+1) + "->" + ~presetNotes[~tracksValue][~seqsValue]).postln; });


		// Multiples Miroir Chorus
		~harTrigView.valueAction_(~harTrig[~tracksValue][~seqsValue]);
		~harIndexView.valueAction_(~harNbSpec.unmap(~harIndex[~tracksValue][~seqsValue]));
		~outLHarSpatTypeView.valueAction_(~outLHarSpatType[~tracksValue][~seqsValue]);
		~outRHarSpatTypeView.valueAction_(~outRHarSpatType[~tracksValue][~seqsValue]);

		ratHarSeqSize = ~ratHar[~tracksValue][~seqsValue].size;
		ratHarSeqSpec = ControlSpec(0, ratHarSeqSize, \lin, 1, 1);
		ratHarSeqStep = 1 / ratHarSeqSize;

		~ratHarView.valueAction_(~ratHar[~tracksValue][~seqsValue]);
		~ratHarRangeView.valueAction_(~ratHarRangeSpec[~tracksValue][~seqsValue].unmap( [~ratHarMin[~tracksValue][~seqsValue], ~ratHarMax[~tracksValue][~seqsValue] ] ));
		~ratHarSeqSpec[~tracksValue][~seqsValue] = ratHarSeqSpec;
		~ratHarSeqView.step_(ratHarSeqStep).minRange_(ratHarSeqStep).valueAction_(~ratHarSeqSpec[~tracksValue][~seqsValue].unmap( [~ratHarSeqStart[~tracksValue][~seqsValue], ~ratHarSeqStop[~tracksValue][~seqsValue]+1 ] ));
		~ratHarRoundView.valueAction_(~ratHarRoundValue[~tracksValue][~seqsValue]);

		~cenHarView.valueAction_(~cenHar[~tracksValue][~seqsValue]);
		~cenHarRangeView.valueAction_(~cenHarRangeSpec[~tracksValue][~seqsValue].unmap( [~cenHarMin[~tracksValue][~seqsValue], ~cenHarMax[~tracksValue][~seqsValue] ] ));
		~cenHarSeqSpec[~tracksValue][~seqsValue] = ratHarSeqSpec;
		~cenHarSeqView.step_(ratHarSeqStep).minRange_(ratHarSeqStep).valueAction_(~cenHarSeqSpec[~tracksValue][~seqsValue].unmap( [~cenHarSeqStart[~tracksValue][~seqsValue], ~cenHarSeqStop[~tracksValue][~seqsValue]+1 ] ));
		~cenHarRoundView.valueAction_(~cenHarRoundValue[~tracksValue][~seqsValue]);

		~delHarView.valueAction_(~delHar[~tracksValue][~seqsValue]);
		~delHarRangeView.valueAction_(~delHarRangeSpec[~tracksValue][~seqsValue].unmap( [~delHarMin[~tracksValue][~seqsValue], ~delHarMax[~tracksValue][~seqsValue] ] ));
		~delHarSeqSpec[~tracksValue][~seqsValue] = ratHarSeqSpec;
		~delHarSeqView.step_(ratHarSeqStep).minRange_(ratHarSeqStep).valueAction_(~delHarSeqSpec[~tracksValue][~seqsValue].unmap( [~delHarSeqStart[~tracksValue][~seqsValue], ~delHarSeqStop[~tracksValue][~seqsValue]+1 ] ));
		~delHarRoundView.valueAction_(~delHarRoundValue[~tracksValue][~seqsValue]);

		~spaHarView.valueAction_(~spaHar[~tracksValue][~seqsValue]);
		~spaHarRangeView.valueAction_(~spaHarRangeSpec[~tracksValue][~seqsValue].unmap( [~spaHarMin[~tracksValue][~seqsValue], ~spaHarMax[~tracksValue][~seqsValue] ] ));
		~spaHarSeqSpec[~tracksValue][~seqsValue] = ControlSpec(0, ~spaHar[~tracksValue][~seqsValue].size, \lin, 1, 1); // A optimiser & ci-dessous aussi XXXXXXXXXXXXXXXXXXXXXXXX
		~spaHarSeqView.step_(1/~spaHar[~tracksValue][~seqsValue].size).minRange_(1/~spaHar[~tracksValue][~seqsValue].size).valueAction_(~spaHarSeqSpec[~tracksValue][~seqsValue].unmap( [~spaHarSeqStart[~tracksValue][~seqsValue], ~spaHarSeqStop[~tracksValue][~seqsValue]+1 ] ));

		~ampHarView.valueAction_(~ampHar[~tracksValue][~seqsValue]);
		~ampHarSeqSpec[~tracksValue][~seqsValue] = ratHarSeqSpec;
		~ampHarSeqView.step_(ratHarSeqStep).minRange_(ratHarSeqStep).valueAction_(~ampHarSeqSpec[~tracksValue][~seqsValue].unmap( [~ampHarSeqStart[~tracksValue][~seqsValue], ~ampHarSeqStop[~tracksValue][~seqsValue]+1 ] ));
		~ampHarRoundView.valueAction_(~ampHarRoundValue[~tracksValue][~seqsValue]);


		// Données du mode des SmoothRangeSliders 8 // pas de sauvegarde des données dans la GUI
		/* ~rtmRangeMode.valueAction_(~presets[index][8][0][0]);
		~proRangeMode.valueAction_(~presets[index][8][1][0]);
		~synRangeMode.valueAction_(~presets[index][8][2][0]);
		~spaRangeMode.valueAction_(~presets[index][8][3][0]);
		~legRangeMode.valueAction_(~presets[index][8][4][0]);
		~envRangeMode.valueAction_(~presets[index][8][5][0]);
		~bufRangeMode.valueAction_(~presets[index][8][6][0]);
		~offRangeMode.valueAction_(~presets[index][8][7][0]);
		~ratRangeMode.valueAction_(~presets[index][8][8][0]);
		~ampRangeMode.valueAction_(~presets[index][8][9][0]);
		~strRangeMode.valueAction_(~presets[index][8][10][0]);
		~cenRangeMode.valueAction_(~presets[index][8][11][0]);
		~panRangeMode.valueAction_(~presets[index][8][12][0]);
		~outLRangeMode.valueAction_(~presets[index][8][13][0]);
		~outRRangeMode.valueAction_(~presets[index][8][14][0]);
		~fxLRangeMode.valueAction_(~presets[index][8][15][0]);
		~fxRRangeMode.valueAction_(~presets[index][8][16][0]);

		~rtmSeqMode.valueAction_(~presets[index][8][0][1]);
		~proSeqMode.valueAction_(~presets[index][8][1][1]);
		~synSeqMode.valueAction_(~presets[index][8][2][1]);
		~spaSeqMode.valueAction_(~presets[index][8][3][1]);
		~legSeqMode.valueAction_(~presets[index][8][4][1]);
		~envSeqMode.valueAction_(~presets[index][8][5][1]);
		~bufSeqMode.valueAction_(~presets[index][8][6][1]);
		~offSeqMode.valueAction_(~presets[index][8][7][1]);
		~ratSeqMode.valueAction_(~presets[index][8][8][1]);
		~ampSeqMode.valueAction_(~presets[index][8][9][1]);
		~strSeqMode.valueAction_(~presets[index][8][10][1]);
		~cenSeqMode.valueAction_(~presets[index][8][11][1]);
		~panSeqMode.valueAction_(~presets[index][8][12][1]);
		~outLSeqMode.valueAction_(~presets[index][8][13][1]);
		~outRSeqMode.valueAction_(~presets[index][8][14][1]);
		~fxLSeqMode.valueAction_(~presets[index][8][15][1]);
		~fxRSeqMode.valueAction_(~presets[index][8][16][1]);
		*/

		// Voire si certaines des données FX doivent être mises à jour ?????????

		~fxActOnWhichView.valueAction_(previousfxActOnWhich); // Pour éviter que le fxL agisse sur le droit
		~outActOnWhichView.valueAction_(previousoutActOnWhich); // Pour éviter que le outL agisse sur le droit
		~outCompChooseView.valueAction_(previousoutCompChoose);

	});
};
);






























// GUI Pattern Parameters & triggering

// Preset Functions
// Checker impact et différence avec Zarchive ??? -> réduit la taille du fichier de 4 ou 5
/*
Zarchive -> A compressed binary safe archive format. Supports very large file sizes and is fairly fast.
Compresses strings and symbols using a string lookup table. (limit: 65536 different strings/symbols)
The text archive written by Object.writeArchive will store an object and restore all of its internal variables. However, it will break with large file sizes because it actually writes compilable code and there is a fairly small size limit to that.
*/

// ~presetspath = Document.current.dir++"/LiveForLifePresetZArchive.txt"; // ne marche plus avec l'ide
// ~presetspath = "/Users/Xon/Documents/Projets/ConsProject3_BeatCut2011/WithMathis/Live4Life/LiveForLifePresetZArchive.txt";
// ~presetspath = (PathName.new(~currentPath).pathOnly ++ ~presetsFileName);
~presetspath = if (~presetsPath.isNil, { (PathName.new(~currentPath).pathOnly ++ ~presetsFileName) }, {~presetspath = ~presetsPath});

// Création du fichier s'il n'existe pas
if (File.exists(~presetspath), { }, {File.open(~presetspath, "w")});


if (~presetsFileName2.isNil, {

	// > 21 car indication de DEvent dans le fichier quand tous les presets ont été retiré avec Del donc obligé de réinitialiser la liste des presets avec le Default
	if (File.fileSize(~presetspath) <= 21, {
		~presets = IdentityDictionary.new;
		// ~presets = ();
	} , {
		~presetsFileW = ZArchive.read(~presetspath);
		~presets = ~presetsFileW.readItem;
		~presetsFileW.close;
	});

},{

	if (File.fileSize(~presetspath) <= 21, {
		~presets1 = IdentityDictionary.new;
	} , {
		~presetsFileW = ZArchive.read(~presetspath);
		~presets1 = ~presetsFileW.readItem;
		~presetsFileW.close;
	});

	// ~presetspath2 = (PathName.new(~currentPath).pathOnly ++ ~presetsFileName2);
	~presetspath2 = if (~presetsPath2.isNil, { (PathName.new(~currentPath).pathOnly ++ ~presetsFileName2) }, {~presetspath2 = ~presetsPath2});
	if (File.exists(~presetspath2), { }, {File.open(~presetspath2, "w")});

	if (File.fileSize(~presetspath2) <= 21, {
		~presets2 = IdentityDictionary.new;
	} , {
		~presetsFileW2 = ZArchive.read(~presetspath2);
		~presets2 = ~presetsFileW2.readItem;
		~presetsFileW2.close;
	});

	~presets = ~presets1 ++ ~presets2; // vraiment necessaire ici ???

});

/*( // > 21 car indication de DEvent dans le fichier quand tous les presets ont été retiré avec Del donc obligé de réinitialiser la liste des presets avec le Default
if (File.fileSize(~presetspath) <= 21, {
(~presets = (); // garger seulement cette ligne pour n'avoir ucun preset à l'initialisation

/*~presets.put('120 BPM-4 Ev B Default 2', [ [ [ 0.5, 0.5, 0.5, 0.5 ], [ 1.0, 1.0, 1.0, 1.0 ], [ 0.0, 0.0, 0.0, 0.0 ], [ 0.0, 0.0, 0.0, 0.0 ], [ 0.5, 0.5, 0.5, 0.5 ], [ 0.642857, 0.642857, 0.642857, 0.642857 ], [ 0.0, 0.0, 0.0, 0.0 ], [ 0.0, 0.0, 0.0, 0.0 ], [ 0.5, 0.5, 0.5, 0.5 ], [ 0.8, 0.8, 0.8, 0.8 ], [ 0.5, 0.5, 0.5, 0.5 ], [ 0.234375, 0.234375, 0.234375, 0.234375 ], [ 0.5, 0.5, 0.5, 0.5 ], [ 0.0, 0.0, 0.0, 0.0 ], [ 0.142857, 0.142857, 0.142857, 0.142857 ], [ 0.0, 0.0, 0.0, 0.0 ], [ 0.0, 0.0, 0.0, 0.0 ] ], [ [ 0.0, 2.0 ], [ 0.0, 1.0 ], [ 0.0, 21.0 ], [ 0.0, 6.0 ], [ 0.0, 2.0 ], [ 0.0, 14.0 ], [ 0.0, 22 ], [ 0.0, 1.0 ], [ 0.0, 2.0 ], [ 0.0, 1.0 ], [ 0.0, 2.0 ], [ 0.0, 128.0 ], [ 1.0, -1.0 ], [ 1.0, 8.0 ], [ 1.0, 8.0 ], [ 0.0, 5.0 ], [ 0.0, 5.0 ] ], [ [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ] ], [ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], [ 0, 1, 0, 4, 0, 0, 0, 0, 7, 1 ], [ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ], [ [ 0.001, 0.1 ], [ 0.998, 0.4 ], [ 0.0, 0.0 ], [ 0.0, 0.0 ], [ 0.0, 0.0 ], 0.5 ], [ 0, 4.0, "", [ [ '  4 Ev', '4 Ev - Sum  4' ], [ '  4 Ev', '4 Ev - Sum  4' ], [ '  8 Ev', '8 Ev - Sum 32' ], [ '  8 Ev', '8 Ev - Sum 32' ], [ ' 16 Ev', '16 Ev - Sum 48' ], [ ' 16 Ev', '16 Ev - Sum 48' ] ], [ 1, 0, 0, 0, 0, 0 ], [ 4, 1, 1, 1, 1, 1 ], [ 4, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1 ] ], [ [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ] ] ]);*/

/*~presets.put( '120b| 2s| 4e| 2t| D Default', [ [ [ 0.5, 0.5, 0.5, 0.5 ], [ 1, 1, 1, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0.5, 0.5, 0.5, 0.5 ], [ 0.64285713434219, 0.64285713434219, 0.64285713434219, 0.64285713434219 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0.5, 0.5, 0.5, 0.5 ], [ 0.80000001192093, 0.80000001192093, 0.80000001192093, 0.80000001192093 ], [ 0.5, 0.5, 0.5, 0.5 ], [ 0.234375, 0.234375, 0.234375, 0.234375 ], [ 0.5, 0.5, 0.5, 0.5 ], [ 0, 0, 0, 0 ], [ 0.25, 0.25, 0.25, 0.25 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 2 ], [ 0, 1 ], [ 0, 22 ], [ 0, 6 ], [ 0, 2 ], [ 0, 14 ], [ 0, 22 ], [ 0, 1 ], [ 0, 2 ], [ 0, 1 ], [ 0, 2 ], [ 0, 128 ], [ 1, -1 ], [ 1, 5 ], [ 1, 5 ], [ 0, 5 ], [ 0, 5 ] ], [ [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ], [ 0, 3 ] ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 0, 1, 0, 4, 0, 0, 0, 0, 7, 1 ], [ [ 0, 0, 0 ], [ 0, 0, 13 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ], [ [ 0.0010000000474975, 0.10000000149012 ], [ 0.99800002574921, 0.40000000596046 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], 0.40000000596046, 4, 0, 0 ], [ 0, 4, ~rtmView.valueAction_( [ 4, [ [ 1, [ 1, 1, 1, 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ], [ 0, [ 1 ] ] ] ] .convertRhythm.linlin(0, 2 , 0, 1));, [ [ '  4 Ev', '4 Ev - Sum  4' ], [ '  4 Ev', '4 Ev - Sum  4' ], [ '  8 Ev', '8 Ev - Sum 32' ], [ '  8 Ev', '8 Ev - Sum 32' ], [ ' 16 Ev', '16 Ev - Sum 48' ], [ ' 16 Ev', '16 Ev - Sum 48' ] ], [ 1, 0, 0, 0, 0, 0 ], [ 4, 1, 1, 1, 1, 1 ], [ 4, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1 ] ], [ [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ], [ 0, 1 ] ] ] );*/

~presetsFileW = ZArchive.write(~presetspath);
~presetsFileW.writeItem(~presets);
~presetsFileW.writeClose)

});

~presetsFileW = ZArchive.read(~presetspath);
~presets = ~presetsFileW.readItem;
~presetsFileW.close;
);*/

// Code ci-dessus pour ZArchive et ci-dessous pour Object
// ~presets = Object.readArchive(~presetspath) ? ~presets = (); // ou
// ~presets = Object.readArchive(~presetspath) ? ~presets = Dictionary.new;

// Voir différence entre utilisation d'un Event, Dictionary ou Identity Dictionary pour la sauvegarde des presets ???
// Post << ~presets










// ~presets.put(~presetSetFunction.value(( /*(~nbEvents[~tracksValue][~seqsValue] / ~nbTotalBeats[~tracksValue][~seqsValue] * ~toTempo * 60 * ~rtmMul[~tracksValue][~seqsValue].reciprocal).round(0.1).asString ++ "b| " ++*/ (~nbTotalBeats[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue] / ~toTempo).round(0.1).asString ++ "s| " ++ ~nbEvents[~tracksValue][~seqsValue].asString ++ "e| " ++ /*~toTempo[~tracksValue][~seqsValue].round(0.1).asString ++ "t| "*/ ~arrayOfFolderNamesALL[~bufFolderValue[~tracksValue][~seqsValue]][0..14] ++ "| " ++ ~presetStoringName[~tracksValue][~seqsValue]).asSymbol));

// Set one Preset in Preset file with Dico

( // nécessaire de stocker les infos de ~presets dans un Object ou ZArchive

/*
~presets = IdentityDictionary.new;
~presets.keys;
~presets['test1'][\gblSeqStop];
*/

~presetSetFunction = { | preset, index |

	var sv; if (~server2.isNil or: {(~tracksValue/2).asInteger < ~serverTrackSwitch}, {sv = 0}, {sv = 1} );

	preset.put(index,
		IdentityDictionary.with(*[

			// Préférable de stocker les données mappées au cas ou les controlSpec des RangeSliders, Sliders... changent au cours du temps

			// Données du MultiSlider 0 Brutes
			// Besoin d'un FloatArray pour les dur sinon tronqué dans le fichier avec Object - mais apparemment conservé avec ZArchive - à confirmer ???
			// voire si l'ajout de ~rtmSpec[~tracksValue][~seqsValue].map(~dur[~tracksValue][~seqsValue]) ne serait pas utile ?
			\rtmView -> ~dur[~tracksValue][~seqsValue],
			\proView -> ~pro[~tracksValue][~seqsValue],
			\synView -> ~syn[~tracksValue][~seqsValue],
			\spaView -> ~spa[~tracksValue][~seqsValue],
			\legView -> ~leg[~tracksValue][~seqsValue],
			\envView -> ~env[~tracksValue][~seqsValue],
			\bufView -> ~buf[~tracksValue][~seqsValue],
			\offView -> ~off[~tracksValue][~seqsValue], \off2View -> ~off2[~tracksValue][~seqsValue], \off3View -> ~off3[~tracksValue][~seqsValue], \off4View -> ~off4[~tracksValue][~seqsValue],
			\ratView -> ~rat[~tracksValue][~seqsValue], \rat2View -> ~rat2[~tracksValue][~seqsValue],
			\ampView -> ~amp[~tracksValue][~seqsValue],
			\strView -> ~str[~tracksValue][~seqsValue], \str2View -> ~str2[~tracksValue][~seqsValue],
			\cenView -> ~cen[~tracksValue][~seqsValue], \cen2View -> ~cen2[~tracksValue][~seqsValue],
			\panView -> ~pan[~tracksValue][~seqsValue],
			\delView -> ~del[~tracksValue][~seqsValue],
			\outLView -> ~outL[~tracksValue][~seqsValue],
			\outRView -> ~outR[~tracksValue][~seqsValue],
			\fxLView -> ~fxL[~tracksValue][~seqsValue],
			\fxRView -> ~fxR[~tracksValue][~seqsValue],


			// Données du RangeSlider 1 Brutes
			/*\rtmRangeView -> ~rtmRangeView.value,
			\proRangeView -> ~proRangeView.value,
			\synRangeView -> ~synRangeView.value,
			\spaRangeView -> ~spaRangeView.value,
			\legRangeView -> ~legRangeView.value,
			\envRangeView -> ~envRangeView.value,
			\bufRangeView -> ~bufRangeView.value,
			\offRangeView -> ~offRangeView.value,
			\ratRangeView -> ~ratRangeView.value,
			\ampRangeView -> ~ampRangeView.value,
			\strRangeView -> ~strRangeView.value,
			\cenRangeView -> ~cenRangeView.value,
			\panRangeView -> ~panRangeView.value,
			\outLRangeView -> ~outLRangeView.value,
			\outRRangeView -> ~outRRangeView.value,
			\fxLRangeView -> ~fxLRangeView.value,
			\fxRRangeView -> ~fxRRangeView.value,*/

			// Données du RangeSlider 1 Mappées
			\rtmMin -> ~rtmMin[~tracksValue][~seqsValue],
			\proMin -> ~proMin[~tracksValue][~seqsValue],
			\synMin -> ~synMin[~tracksValue][~seqsValue],
			\spaMin -> ~spaMin[~tracksValue][~seqsValue],
			\legMin -> ~legMin[~tracksValue][~seqsValue],
			\envMin -> ~envMin[~tracksValue][~seqsValue],
			\bufMin -> ~bufMin[~tracksValue][~seqsValue],
			\offMin -> ~offMin[~tracksValue][~seqsValue], \off2Min -> ~off2Min[~tracksValue][~seqsValue], \off3Min -> ~off3Min[~tracksValue][~seqsValue], \off4Min -> ~off4Min[~tracksValue][~seqsValue],
			\ratMin -> ~ratMin[~tracksValue][~seqsValue], \rat2Min -> ~rat2Min[~tracksValue][~seqsValue],
			\ampMin -> ~ampMin[~tracksValue][~seqsValue],
			\strMin -> ~strMin[~tracksValue][~seqsValue], \str2Min -> ~str2Min[~tracksValue][~seqsValue],
			\cenMin -> ~cenMin[~tracksValue][~seqsValue], \cen2Min -> ~cen2Min[~tracksValue][~seqsValue],
			\panMin -> ~panMin[~tracksValue][~seqsValue],
			\delMin -> ~delMin[~tracksValue][~seqsValue],
			\outLMin -> ~outLMin[~tracksValue][~seqsValue],
			\outRMin -> ~outRMin[~tracksValue][~seqsValue],
			\fxLMin -> ~fxLMin[~tracksValue][~seqsValue],
			\fxRMin -> ~fxRMin[~tracksValue][~seqsValue],

			\rtmMax -> ~rtmMax[~tracksValue][~seqsValue],
			\proMax -> ~proMax[~tracksValue][~seqsValue],
			\synMax -> ~synMax[~tracksValue][~seqsValue],
			\spaMax -> ~spaMax[~tracksValue][~seqsValue],
			\legMax -> ~legMax[~tracksValue][~seqsValue],
			\envMax -> ~envMax[~tracksValue][~seqsValue],
			\bufMax -> ~bufMax[~tracksValue][~seqsValue],
			\offMax -> ~offMax[~tracksValue][~seqsValue], \off2Max -> ~off2Max[~tracksValue][~seqsValue], \off3Max -> ~off3Max[~tracksValue][~seqsValue], \off4Max -> ~off4Max[~tracksValue][~seqsValue],
			\ratMax -> ~ratMax[~tracksValue][~seqsValue], \rat2Max -> ~rat2Max[~tracksValue][~seqsValue],
			\ampMax -> ~ampMax[~tracksValue][~seqsValue],
			\strMax -> ~strMax[~tracksValue][~seqsValue], \str2Max -> ~str2Max[~tracksValue][~seqsValue],
			\cenMax -> ~cenMax[~tracksValue][~seqsValue], \cen2Max -> ~cen2Max[~tracksValue][~seqsValue],
			\panMax -> ~panMax[~tracksValue][~seqsValue],
			\delMax -> ~delMax[~tracksValue][~seqsValue],
			\outLMax -> ~outLMax[~tracksValue][~seqsValue],
			\outRMax -> ~outRMax[~tracksValue][~seqsValue],
			\fxLMax -> ~fxLMax[~tracksValue][~seqsValue],
			\fxRMax -> ~fxRMax[~tracksValue][~seqsValue],


			// Données du SeqRangeSlider 2 Brutes
			/*\gblSeqView -> ~gblSeqView.value, // Action sur toutes les séquences
			\gblSeqIndexView -> ~gblSeqIndexView.value, // Action sur toutes les séquences
			\rtmSeqView -> ~rtmSeqView.value,
			\proSeqView -> ~proSeqView.value,
			\synSeqView -> ~synSeqView.value,
			\spaSeqView -> ~spaSeqView.value,
			\legSeqView -> ~legSeqView.value,
			\envSeqView -> ~envSeqView.value,
			\bufSeqView -> ~bufSeqView.value,
			\offSeqView -> ~offSeqView.value,
			\ratSeqView -> ~ratSeqView.value,
			\ampSeqView -> ~ampSeqView.value,
			\strSeqView -> ~strSeqView.value,
			\cenSeqView -> ~cenSeqView.value,
			\panSeqView -> ~panSeqView.value,
			\outLSeqView -> ~outLSeqView.value,
			\outRSeqView -> ~outRSeqView.value,
			\fxLSeqView -> ~fxLSeqView.value,
			\fxRSeqView -> ~fxRSeqView.value,*/

			// Données du SeqRangeSlider 2 Mappées
			\gblSeqIndex -> ~gblSeqIndex[~tracksValue][~seqsValue],

			\gblSeqStart -> ~gblSeqStart[~tracksValue][~seqsValue],
			\rtmSeqStart -> ~rtmSeqStart[~tracksValue][~seqsValue],
			\proSeqStart -> ~proSeqStart[~tracksValue][~seqsValue],
			\synSeqStart -> ~synSeqStart[~tracksValue][~seqsValue],
			\spaSeqStart -> ~spaSeqStart[~tracksValue][~seqsValue],
			\legSeqStart -> ~legSeqStart[~tracksValue][~seqsValue],
			\envSeqStart -> ~envSeqStart[~tracksValue][~seqsValue],
			\bufSeqStart -> ~bufSeqStart[~tracksValue][~seqsValue],
			\offSeqStart -> ~offSeqStart[~tracksValue][~seqsValue], \off2SeqStart -> ~off2SeqStart[~tracksValue][~seqsValue], \off3SeqStart -> ~off3SeqStart[~tracksValue][~seqsValue], \off4SeqStart -> ~off4SeqStart[~tracksValue][~seqsValue],
			\ratSeqStart -> ~ratSeqStart[~tracksValue][~seqsValue], \rat2SeqStart -> ~rat2SeqStart[~tracksValue][~seqsValue],
			\ampSeqStart -> ~ampSeqStart[~tracksValue][~seqsValue],
			\strSeqStart -> ~strSeqStart[~tracksValue][~seqsValue], \str2SeqStart -> ~str2SeqStart[~tracksValue][~seqsValue],
			\cenSeqStart -> ~cenSeqStart[~tracksValue][~seqsValue], \cen2SeqStart -> ~cen2SeqStart[~tracksValue][~seqsValue],
			\panSeqStart -> ~panSeqStart[~tracksValue][~seqsValue],
			\delSeqStart -> ~delSeqStart[~tracksValue][~seqsValue],
			\outLSeqStart -> ~outLSeqStart[~tracksValue][~seqsValue],
			\outRSeqStart -> ~outRSeqStart[~tracksValue][~seqsValue],
			\fxLSeqStart -> ~fxLSeqStart[~tracksValue][~seqsValue],
			\fxRSeqStart -> ~fxRSeqStart[~tracksValue][~seqsValue],

			\gblSeqStop -> ~gblSeqStop[~tracksValue][~seqsValue],
			\rtmSeqStop -> ~rtmSeqStop[~tracksValue][~seqsValue],
			\proSeqStop -> ~proSeqStop[~tracksValue][~seqsValue],
			\synSeqStop -> ~synSeqStop[~tracksValue][~seqsValue],
			\spaSeqStop -> ~spaSeqStop[~tracksValue][~seqsValue],
			\legSeqStop -> ~legSeqStop[~tracksValue][~seqsValue],
			\envSeqStop -> ~envSeqStop[~tracksValue][~seqsValue],
			\bufSeqStop -> ~bufSeqStop[~tracksValue][~seqsValue],
			\offSeqStop -> ~offSeqStop[~tracksValue][~seqsValue], \off2SeqStop -> ~off2SeqStop[~tracksValue][~seqsValue], \off3SeqStop -> ~off3SeqStop[~tracksValue][~seqsValue], \off4SeqStop -> ~off4SeqStop[~tracksValue][~seqsValue],
			\ratSeqStop -> ~ratSeqStop[~tracksValue][~seqsValue], \rat2SeqStop -> ~rat2SeqStop[~tracksValue][~seqsValue],
			\ampSeqStop -> ~ampSeqStop[~tracksValue][~seqsValue],
			\strSeqStop -> ~strSeqStop[~tracksValue][~seqsValue], \str2SeqStop -> ~str2SeqStop[~tracksValue][~seqsValue],
			\cenSeqStop -> ~cenSeqStop[~tracksValue][~seqsValue], \cen2SeqStop -> ~cen2SeqStop[~tracksValue][~seqsValue],
			\panSeqStop -> ~panSeqStop[~tracksValue][~seqsValue],
			\delSeqStop -> ~delSeqStop[~tracksValue][~seqsValue],
			\outLSeqStop -> ~outLSeqStop[~tracksValue][~seqsValue],
			\outRSeqStop -> ~outRSeqStop[~tracksValue][~seqsValue],
			\fxLSeqStop -> ~fxLSeqStop[~tracksValue][~seqsValue],
			\fxRSeqStop -> ~fxRSeqStop[~tracksValue][~seqsValue],


			// Données du MulSlider 3 Brutes
			/*\rtmMulView -> ~rtmMulView.value,
			\proMulView -> ~proMulView.value,
			\synMulView -> ~synMulView.value,
			\spaMulView -> ~spaMulView.value,
			\legMulView -> ~legMulView.value,
			\envMulView -> ~envMulView.value,
			\bufMulView -> ~bufMulView.value,
			\offMulView -> ~offMulView.value,
			\ratMulView -> ~ratMulView.value,
			\ampMulView -> ~ampMulView.value,
			\strMulView -> ~strMulView.value,
			\cenMulView -> ~cenMulView.value,
			\panMulView -> ~panMulView.value,
			\outLMulView -> ~outLMulView.value,
			\outRMulView -> ~outRMulView.value,
			\fxLMulView -> ~fxLMulView.value,
			\fxRMulView -> ~fxRMulView.value,*/

			// Données du MulSlider 3 Mappées
			\rtmMul -> ~rtmMul[~tracksValue][~seqsValue],
			\proMul -> ~proMul[~tracksValue][~seqsValue],
			\synMul -> ~synMul[~tracksValue][~seqsValue],
			\spaMul -> ~spaMul[~tracksValue][~seqsValue],
			\legMul -> ~legMul[~tracksValue][~seqsValue],
			\envMul -> ~envMul[~tracksValue][~seqsValue],
			\bufMul -> ~bufMul[~tracksValue][~seqsValue],
			\offMul -> ~offMul[~tracksValue][~seqsValue], \off2Mul -> ~off2Mul[~tracksValue][~seqsValue], \off3Mul -> ~off3Mul[~tracksValue][~seqsValue], \off4Mul -> ~off4Mul[~tracksValue][~seqsValue],
			\ratMul -> ~ratMul[~tracksValue][~seqsValue], \rat2Mul -> ~rat2Mul[~tracksValue][~seqsValue],
			\ampMul -> ~ampMul[~tracksValue][~seqsValue],
			\strMul -> ~strMul[~tracksValue][~seqsValue], \str2Mul -> ~str2Mul[~tracksValue][~seqsValue],
			\cenMul -> ~cenMul[~tracksValue][~seqsValue], \cen2Mul -> ~cen2Mul[~tracksValue][~seqsValue],
			\panMul -> ~panMul[~tracksValue][~seqsValue],
			\delMul -> ~delMul[~tracksValue][~seqsValue],
			\outLMul -> ~outLMul[~tracksValue][~seqsValue],
			\outRMul -> ~outRMul[~tracksValue][~seqsValue],
			\fxLMul -> ~fxLMul[~tracksValue][~seqsValue],
			\fxRMul -> ~fxRMul[~tracksValue][~seqsValue],


			/*
			~testA = { 100.do {~rtmRoundView.value } }.bench
			~testB = { 100.do {~rtmRoundValue[~tracksValue][~seqsValue] } }.bench
			~testA / ~testB // -> B est de 2 à 3 x plus rapide que A
			*/

			// Données du Round 4 Brutes // Les données du Round ne sont pas sauvegardés - mais la position dans les PopUpMenu XXX
			\rtmRoundView -> ~rtmRoundValue[~tracksValue][~seqsValue],
			\proRoundView -> ~proRoundValue[~tracksValue][~seqsValue],
			// \synRoundView -> ~synRoundValue[~tracksValue][~seqsValue], // Voir l'intérêt de récupérer ces données ???
			// \spaRoundView -> ~spaRoundValue[~tracksValue][~seqsValue], // Voir l'intérêt de récupérer ces données ???
			\legRoundView -> ~legRoundValue[~tracksValue][~seqsValue],
			// \envRoundView -> ~envRoundValue[~tracksValue][~seqsValue], // Voir l'intérêt de récupérer ces données ???
			\bufFolderView -> ~bufFolderValue[~tracksValue][~seqsValue], // Sémantique différente // Prend en compte la position dans la structure et non pas le nom du dossier XXX
			\offRoundView -> ~offRoundValue[~tracksValue][~seqsValue], \off2RoundView -> ~off2RoundValue[~tracksValue][~seqsValue], \off3RoundView -> ~off3RoundValue[~tracksValue][~seqsValue], \off4RoundView -> ~off4RoundValue[~tracksValue][~seqsValue],
			\ratRoundView -> ~ratRoundValue[~tracksValue][~seqsValue], \rat2RoundView -> ~rat2RoundValue[~tracksValue][~seqsValue],
			\ampRoundView -> ~ampRoundValue[~tracksValue][~seqsValue],
			\strRoundView -> ~strRoundValue[~tracksValue][~seqsValue], \str2RoundView -> ~str2RoundValue[~tracksValue][~seqsValue],
			\cenRoundView -> ~cenRoundValue[~tracksValue][~seqsValue], \cen2RoundView -> ~cen2RoundValue[~tracksValue][~seqsValue],
			\panRoundView -> ~panRoundValue[~tracksValue][~seqsValue],
			\delRoundView -> ~delRoundValue[~tracksValue][~seqsValue],
			/*\outLRoundView -> ~outLRoundValue[~tracksValue][~seqsValue], // Voir l'intérêt de récupérer ces données ???
			\outRRoundView -> ~outRRoundValue[~tracksValue][~seqsValue], // Voir l'intérêt de récupérer ces données ???
			\fxLRoundView -> ~fxLRoundValue[~tracksValue][~seqsValue], // Voir l'intérêt de récupérer ces données ???
			\fxRRoundView -> ~fxRRoundValue[~tracksValue][~seqsValue], // Voir l'intérêt de récupérer ces données ??? */


			// Données du Pattern 5 Brutes de Boutons et PopUpMenus
			\rtmDirView -> ~rtmDir[~tracksValue][~seqsValue],
			\proDirView -> ~proDir[~tracksValue][~seqsValue],
			\synDirView -> ~synDir[~tracksValue][~seqsValue],
			\spaDirView -> ~spaDir[~tracksValue][~seqsValue],
			\legDirView -> ~legDir[~tracksValue][~seqsValue],
			\envDirView -> ~envDir[~tracksValue][~seqsValue],
			\bufDirView -> ~bufDir[~tracksValue][~seqsValue],
			\offDirView -> ~offDir[~tracksValue][~seqsValue], \off2DirView -> ~off2Dir[~tracksValue][~seqsValue], \off3DirView -> ~off3Dir[~tracksValue][~seqsValue], \off4DirView -> ~off4Dir[~tracksValue][~seqsValue],
			\ratDirView -> ~ratDir[~tracksValue][~seqsValue], \rat2DirView -> ~rat2Dir[~tracksValue][~seqsValue],
			\ampDirView -> ~ampDir[~tracksValue][~seqsValue],
			\strDirView -> ~strDir[~tracksValue][~seqsValue], \str2DirView -> ~str2Dir[~tracksValue][~seqsValue],
			\cenDirView -> ~cenDir[~tracksValue][~seqsValue], \cen2DirView -> ~cen2Dir[~tracksValue][~seqsValue],
			\panDirView -> ~panDir[~tracksValue][~seqsValue],
			\delDirView -> ~delDir[~tracksValue][~seqsValue],
			\outLDirView -> ~outLDir[~tracksValue][~seqsValue],
			\outRDirView -> ~outRDir[~tracksValue][~seqsValue],
			\fxLDirView -> ~fxLDir[~tracksValue][~seqsValue],
			\fxRDirView -> ~fxRDir[~tracksValue][~seqsValue],

			\rtmPatView -> ~rtmPat[~tracksValue][~seqsValue],
			\proPatView -> ~proPat[~tracksValue][~seqsValue],
			\synPatView -> ~synPat[~tracksValue][~seqsValue],
			\spaPatView -> ~spaPat[~tracksValue][~seqsValue],
			\legPatView -> ~legPat[~tracksValue][~seqsValue],
			\envPatView -> ~envPat[~tracksValue][~seqsValue],
			\bufPatView -> ~bufPat[~tracksValue][~seqsValue],
			\offPatView -> ~offPat[~tracksValue][~seqsValue], \off2PatView -> ~off2Pat[~tracksValue][~seqsValue], \off3PatView -> ~off3Pat[~tracksValue][~seqsValue], \off4PatView -> ~off4Pat[~tracksValue][~seqsValue],
			\ratPatView -> ~ratPat[~tracksValue][~seqsValue], \rat2PatView -> ~rat2Pat[~tracksValue][~seqsValue],
			\ampPatView -> ~ampPat[~tracksValue][~seqsValue],
			\strPatView -> ~strPat[~tracksValue][~seqsValue], \str2PatView -> ~str2Pat[~tracksValue][~seqsValue],
			\cenPatView -> ~cenPat[~tracksValue][~seqsValue], \cen2PatView -> ~cen2Pat[~tracksValue][~seqsValue],
			\panPatView -> ~panPat[~tracksValue][~seqsValue],
			\delPatView -> ~delPat[~tracksValue][~seqsValue],
			\outLPatView -> ~outLPat[~tracksValue][~seqsValue],
			\outRPatView -> ~outRPat[~tracksValue][~seqsValue],
			\fxLPatView -> ~fxLPat[~tracksValue][~seqsValue],
			\fxRPatView -> ~fxRPat[~tracksValue][~seqsValue],

			\rtmPatSelView -> ~rtmPatSel[~tracksValue][~seqsValue],
			\proPatSelView -> ~proPatSel[~tracksValue][~seqsValue],
			\synPatSelView -> ~synPatSel[~tracksValue][~seqsValue],
			\spaPatSelView -> ~spaPatSel[~tracksValue][~seqsValue],
			\legPatSelView -> ~legPatSel[~tracksValue][~seqsValue],
			\envPatSelView -> ~envPatSel[~tracksValue][~seqsValue],
			\bufPatSelView -> ~bufPatSel[~tracksValue][~seqsValue],
			\offPatSelView -> ~offPatSel[~tracksValue][~seqsValue], \off2PatSelView -> ~off2PatSel[~tracksValue][~seqsValue], \off3PatSelView -> ~off3PatSel[~tracksValue][~seqsValue], \off4PatSelView -> ~off4PatSel[~tracksValue][~seqsValue],
			\ratPatSelView -> ~ratPatSel[~tracksValue][~seqsValue], \rat2PatSelView -> ~rat2PatSel[~tracksValue][~seqsValue],
			\ampPatSelView -> ~ampPatSel[~tracksValue][~seqsValue],
			\strPatSelView -> ~strPatSel[~tracksValue][~seqsValue], \str2PatSelView -> ~str2PatSel[~tracksValue][~seqsValue],
			\cenPatSelView -> ~cenPatSel[~tracksValue][~seqsValue], \cen2PatSelView -> ~cen2PatSel[~tracksValue][~seqsValue],
			\panPatSelView -> ~panPatSel[~tracksValue][~seqsValue],
			\delPatSelView -> ~delPatSel[~tracksValue][~seqsValue],
			\outLPatSelView -> ~outLPatSel[~tracksValue][~seqsValue],
			\outRPatSelView -> ~outRPatSel[~tracksValue][~seqsValue],
			\fxLPatSelView -> ~fxLPatSel[~tracksValue][~seqsValue],
			\fxRPatSelView -> ~fxRPatSel[~tracksValue][~seqsValue],


			// Données des petits sliders et boutons 6 (sauf ~seg & ~end dans ENV) Brutes des Sliders
			/*\proBjorView -> ~proBjorView.value,
			\offRateSecondBufView -> ~offRateSecondBufView.value,
			\trajLevelScaleView -> ~trajLevelScaleView.value,
			\atkView -> ~atkView.value,
			\relView -> ~relView.value,
			\w1View -> ~w1View.value,
			\w2View -> ~w2View.value,
			\offThreshView -> ~offThreshView.value,
			\freqRatView -> ~freqRatView.value,
			\fAmpView -> ~fAmpView.value,
			\ampRatView -> ~ampRatView.value,
			\aAmpView -> ~aAmpView.value,
			\panRatView -> ~panRatView.value,
			\pAmpView -> ~pAmpView.value,*/

			// Données des petits sliders et boutons 6 (sauf ~seg & ~end dans ENV) Brutes quand Boutons et Mappées quand Sliders
			\rtmType -> ~rtmType[~tracksValue][~seqsValue],
			\seqType -> ~sequenceType[~tracksValue][~seqsValue],
			\proBjor -> ~proBjor[~tracksValue][~seqsValue],
			\proBjor2 -> ~proBjor2[~tracksValue][~seqsValue],

			\proBjor3 -> ~proBjor3[~tracksValue][~seqsValue],
			\proBjor4 -> ~proBjor4[~tracksValue][~seqsValue],
			\proGridsBias -> ~proGridsBias[~tracksValue][~seqsValue],
			\proGridsBias2 -> ~proGridsBias2[~tracksValue][~seqsValue],
			\proWeight -> ~proWeight[~tracksValue][~seqsValue],
			\proDrumType -> ~proDrumType[~tracksValue][~seqsValue],

			\proSelect -> ~proSelect[~tracksValue][~seqsValue],
			\synType -> ~synType[~tracksValue][~seqsValue],
			\offRateSecondBuf -> ~offRateSecondBuf[~tracksValue][~seqsValue],
			\offRateRandSecondBuf -> ~offRateRandSecondBuf[~tracksValue][~seqsValue],

			\stereoSpatType -> ~stereoSpatType[~tracksValue][~seqsValue],
			\dbRollOff -> ~dbRollOff[~tracksValue][~seqsValue],
			\speakRad -> ~speakRad[~tracksValue][~seqsValue],
			\orientation -> ~orientation[~tracksValue][~seqsValue],
			\vmPointScale -> ~vmPointScale[~tracksValue][~seqsValue],
			\vbPointScale -> ~vbPointScale[~tracksValue][~seqsValue],
			\ambPointScale -> ~ambPointScale[~tracksValue][~seqsValue],
			\trajSpatLoop -> ~trajSpatLoop[~tracksValue][~seqsValue],
			\trajSpatRate -> ~trajSpatRate[~tracksValue][~seqsValue],
			\trajSpatTimeType -> ~trajSpatTimeType[~tracksValue][~seqsValue],
			\trajSpatType -> ~trajSpatType[~tracksValue][~seqsValue],
			\spaLagTime -> ~spaLagTime[~tracksValue][~seqsValue],
			\spaLagCurve -> ~spaLagCurve[~tracksValue][~seqsValue],
			\sdFreqRangeMin -> ~sdFreqRangeMin[~tracksValue][~seqsValue],
			\sdFreqRangeMax -> ~sdFreqRangeMax[~tracksValue][~seqsValue],
			\sdDbRangeMin -> ~sdDbRangeMin[~tracksValue][~seqsValue],
			\sdDbRangeMax -> ~sdDbRangeMax[~tracksValue][~seqsValue],
			\spec2spaCurve -> ~spec2spaCurve[~tracksValue][~seqsValue],

			\vbapSpread -> ~vbapSpread[~tracksValue][~seqsValue],
			\vbapX2Off -> ~vbapX2Off[~tracksValue][~seqsValue],
			\circSpread -> ~circSpread[~tracksValue][~seqsValue],
			\circSpatType -> ~circSpatType[~tracksValue][~seqsValue],
			\circSpeedRangeMin -> ~circSpeedRangeMin[~tracksValue][~seqsValue],
			\circSpeedRangeMax -> ~circSpeedRangeMax[~tracksValue][~seqsValue],
			\sdSpatType -> ~sdSpatType[~tracksValue][~seqsValue],

			\legType -> ~legType[~tracksValue][~seqsValue],
			\legLoop -> ~legLoop[~tracksValue][~seqsValue],

			\atk1 -> ~atk[~tracksValue][~seqsValue][0],
			\rel1 -> ~rel[~tracksValue][~seqsValue][0],
			\atk2 -> ~atk[~tracksValue][~seqsValue][1],
			\rel2 -> ~rel[~tracksValue][~seqsValue][1],
			/*\atk3 -> ~atk[2][~tracksValue][~seqsValue],
			\rel3 -> ~rel[2][~tracksValue][~seqsValue],
			\atk4 -> ~atk[3][~tracksValue][~seqsValue],
			\rel4 -> ~rel[3][~tracksValue][~seqsValue],*/
			\atkCurve1 -> ~atkCurve[~tracksValue][~seqsValue][0],
			\relCurve1 -> ~relCurve[~tracksValue][~seqsValue][0],
			\atkCurve2 -> ~atkCurve[~tracksValue][~seqsValue][1],
			\relCurve2 -> ~relCurve[~tracksValue][~seqsValue][1],
			/*\atkCurve3 -> ~atkCurve[2][~tracksValue][~seqsValue],
			\relCurve3 -> ~relCurve[2][~tracksValue][~seqsValue],
			\atkCurve4 -> ~atkCurve[3][~tracksValue][~seqsValue],
			\relCurve4 -> ~relCurve[3][~tracksValue][~seqsValue],*/

			\w1 -> ~w1[~tracksValue][~seqsValue],
			\w2 -> ~w2[~tracksValue][~seqsValue],
			\envType -> ~envType[~tracksValue][~seqsValue],

			\offThresh -> ~offThresh[~tracksValue][~seqsValue],
			\freqRat -> ~freqRat[~tracksValue][~seqsValue],
			\fAmp -> ~fAmp[~tracksValue][~seqsValue],
			\ampRat -> ~ampRat[~tracksValue][~seqsValue],
			\aAmp -> ~aAmp[~tracksValue][~seqsValue],
			\panRat -> ~panRat[~tracksValue][~seqsValue],
			\pAmp -> ~pAmp[~tracksValue][~seqsValue],
			\gliss -> ~ratSynth[~tracksValue][~seqsValue],


			// Données rythmiques 7 Brutes quand Boutons et Mappées quand Sliders
			\configBeatsView -> /*~configBeatsValue[~tracksValue][~seqsValue] // car pas de valueAction déclenché */ ~configBeatsView.value, // Brutes car PopUpMenu
			\nbTotalBeats -> ~nbTotalBeats[~tracksValue][~seqsValue],
			// \nbTotalBeatsView -> ~nbTotalBeatsView.value,
			\displayRhythm -> ~displayRhythm[~tracksValue][~seqsValue], // String du ~displayRhythmView
			\selectBeatView -> 6.collect { |i| ~selectBeatValue[~tracksValue][~seqsValue][i] }, // Brutes car PopUpTreeMenu  // [ '  8 Ev', '8 Ev - Sum 32' ]
			\pBeat -> 6.collect { |i| ~pBeat[~tracksValue][~seqsValue][i] }, // Série des 6 RoundNumberBox
			\nbBeat -> 6.collect { |i| ~nbBeat[~tracksValue][~seqsValue][i] }, // Série des 6 RoundNumberBox
			\sumBeat -> 6.collect { |i| ~sumBeat[~tracksValue][~seqsValue][i] }, // Série des 6 RoundNumberBox
			\minSumBeat -> 6.collect { |i| ~minSumBeat[~tracksValue][~seqsValue][i] }, // Série des 6 RoundNumberBox

			\grainSize -> ~grainSize[~tracksValue][~seqsValue],
			\grain2Size -> ~grain2Size[~tracksValue][~seqsValue],

			\lehmerInit1 -> ~lehmerInit1[~tracksValue][~seqsValue],
			\lehmerA1 -> ~lehmerA1[~tracksValue][~seqsValue],
			\lehmerB1 -> ~lehmerB1[~tracksValue][~seqsValue],
			\lehmerReInit1 -> ~lehmerReInit1[~tracksValue][~seqsValue],
			\lehmerInit2 -> ~lehmerInit2[~tracksValue][~seqsValue],
			\lehmerA2 -> ~lehmerA2[~tracksValue][~seqsValue],
			\lehmerB2 -> ~lehmerB2[~tracksValue][~seqsValue],
			\lehmerReInit2 -> ~lehmerReInit2[~tracksValue][~seqsValue],


			// Données du mode des SmoothRangeSliders 8 Brutes - Données de boutons
			\rtmRangeMode -> ~rtmRangeMode.value,
			\proRangeMode -> ~proRangeMode.value,
			\synRangeMode -> ~synRangeMode.value,
			\spaRangeMode -> ~spaRangeMode.value,
			\legRangeMode -> ~legRangeMode.value,
			\envRangeMode -> ~envRangeMode.value,
			\bufRangeMode -> ~bufRangeMode.value,
			\offRangeMode -> ~offRangeMode.value, \off2RangeMode -> ~off2RangeMode.value, \off3RangeMode -> ~off3RangeMode.value, \off4RangeMode -> ~off4RangeMode.value,
			\ratRangeMode -> ~ratRangeMode.value, \rat2RangeMode -> ~rat2RangeMode.value,
			\ampRangeMode -> ~ampRangeMode.value,
			\strRangeMode -> ~strRangeMode.value, \str2RangeMode -> ~str2RangeMode.value,
			\cenRangeMode -> ~cenRangeMode.value, \cen2RangeMode -> ~cen2RangeMode.value,
			\panRangeMode -> ~panRangeMode.value,
			\delRangeMode -> ~delRangeMode.value,
			\outLRangeMode -> ~outLRangeMode.value,
			\outRRangeMode -> ~outRRangeMode.value,
			\fxLRangeMode -> ~fxLRangeMode.value,
			\fxRRangeMode -> ~fxRRangeMode.value,

			\rtmSeqMode -> ~rtmSeqMode.value,
			\proSeqMode -> ~proSeqMode.value,
			\synSeqMode -> ~synSeqMode.value,
			\spaSeqMode -> ~spaSeqMode.value,
			\legSeqMode -> ~legSeqMode.value,
			\envSeqMode -> ~envSeqMode.value,
			\bufSeqMode -> ~bufSeqMode.value,
			\offSeqMode -> ~offSeqMode.value, \off2SeqMode -> ~off2SeqMode.value, \off3SeqMode -> ~off3SeqMode.value, \off4SeqMode -> ~off4SeqMode.value,
			\ratSeqMode -> ~ratSeqMode.value, \rat2SeqMode -> ~rat2SeqMode.value,
			\ampSeqMode -> ~ampSeqMode.value,
			\strSeqMode -> ~strSeqMode.value, \str2SeqMode -> ~str2SeqMode.value,
			\cenSeqMode -> ~cenSeqMode.value, \cen2SeqMode -> ~cen2SeqMode.value,
			\panSeqMode -> ~panSeqMode.value,
			\delSeqMode -> ~delSeqMode.value,
			\outLSeqMode -> ~outLSeqMode.value,
			\outRSeqMode -> ~outRSeqMode.value,
			\fxLSeqMode -> ~fxLSeqMode.value,
			\fxRSeqMode -> ~fxRSeqMode.value,


			// Multiples Miroir Chorus
			\harTrig -> ~harTrig[~tracksValue][~seqsValue],
			\harIndex -> ~harIndex[~tracksValue][~seqsValue],
			\outLHarSpatType -> ~outLHarSpatType[~tracksValue][~seqsValue],
			\outRHarSpatType -> ~outRHarSpatType[~tracksValue][~seqsValue],

			\ratHar -> ~ratHar[~tracksValue][~seqsValue],
			\ratHarMin -> ~ratHarMin[~tracksValue][~seqsValue],
			\ratHarMax -> ~ratHarMax[~tracksValue][~seqsValue],
			\ratHarSeqStart -> ~ratHarSeqStart[~tracksValue][~seqsValue],
			\ratHarSeqStop -> ~ratHarSeqStop[~tracksValue][~seqsValue],
			\ratHarRoundView -> ~ratHarRoundValue[~tracksValue][~seqsValue],

			\cenHar -> ~cenHar[~tracksValue][~seqsValue],
			\cenHarMin -> ~cenHarMin[~tracksValue][~seqsValue],
			\cenHarMax -> ~cenHarMax[~tracksValue][~seqsValue],
			\cenHarSeqStart -> ~cenHarSeqStart[~tracksValue][~seqsValue],
			\cenHarSeqStop -> ~cenHarSeqStop[~tracksValue][~seqsValue],
			\cenHarRoundView -> ~cenHarRoundValue[~tracksValue][~seqsValue],

			\delHar -> ~delHar[~tracksValue][~seqsValue],
			\delHarMin -> ~delHarMin[~tracksValue][~seqsValue],
			\delHarMax -> ~delHarMax[~tracksValue][~seqsValue],
			\delHarSeqStart -> ~delHarSeqStart[~tracksValue][~seqsValue],
			\delHarSeqStop -> ~delHarSeqStop[~tracksValue][~seqsValue],
			\delHarRoundView -> ~delHarRoundValue[~tracksValue][~seqsValue],

			\spaHar -> ~spaHar[~tracksValue][~seqsValue],
			\spaHarMin -> ~spaHarMin[~tracksValue][~seqsValue],
			\spaHarMax -> ~spaHarMax[~tracksValue][~seqsValue],
			\spaHarSeqStart -> ~spaHarSeqStart[~tracksValue][~seqsValue],
			\spaHarSeqStop -> ~spaHarSeqStop[~tracksValue][~seqsValue],

			\ampHar -> ~ampHar[~tracksValue][~seqsValue],
			\ampHarSeqStart -> ~ampHarSeqStart[~tracksValue][~seqsValue],
			\ampHarSeqStop -> ~ampHarSeqStop[~tracksValue][~seqsValue],
			\ampHarRoundView -> ~ampHarRoundValue[~tracksValue][~seqsValue],

			\bufSequence -> ~bufSequence[~tracksValue][~seqsValue],
			\presetNotes -> ~presetNotes[~tracksValue][~seqsValue],

			/*
			// Collection des données d'effets EZsliders
			~fxSelect.collect { |a| var num = a-1; if (num >= 0 and: {num < ~fxSynthDef.size }, {~fxSynthDef[num].metadata['order'].size.collect { |i| ~fxSynthDefValues[(~fxSynthDef[num].name ++ ~fxSynthDef[num].metadata['order'][i]).asSymbol] } } ) }

			// Collection des données d'effets EZsliders & EQ
			~fxSelect.collect { |a| var num = a-1; case
			{num >= 0 and: {num < ~fxSynthDef.size} }
			{~fxSynthDef[num].metadata['order'].size.collect { |i| ~fxSynthDefValues[(~fxSynthDef[num].name ++ ~fxSynthDef[num].metadata['order'][i]).asSymbol] } }
			{num == ~fxSynthDef.size }
			{~eqUnitLib1.setting}
			{num == (~fxSynthDef.size+1) }
			{~eqUnitLib2.setting}
			{num < 0 or: {num > (~fxSynthDef.size+1) } }
			{0} }
			*/

			\fxSynth ->
			if (index.asString.endsWith("E")/*.postln*/ or:{index.asString.endsWith("ES")}, {1}, {0} ),

			\fxSynthNum ->
			if (index.asString.endsWith("E") or:{index.asString.endsWith("ES")}, {~fxSelect[sv].copy} ),
			// Le .copy est necessaire, sinon la donnée n'est pas rappelée - Pourquoi ??? car dans une fonction ????????? XXXXXXXXX

			\fxSynthSerPar ->
			if (index.asString.endsWith("E") or:{index.asString.endsWith("ES")}, {~fxInSerieChoose[sv].copy/*[0]*/} ),

			\fxSynthData ->
			if (index.asString.endsWith("E") or:{index.asString.endsWith("ES")}, {
				// Collection des données d'effets EZsliders & EQ
				~fxSelect[sv].collect { |a| var num = (a-1); // num.postln;
					case
					{num >= 0 and: {num < ~numFxSynthDef} }
					{ ~fxSynthDef[num].metadata['order'].size.collect { |i| ~fxSynthDefValues[sv][(~fxSynthDef[num].name ++ ~fxSynthDef[num].metadata['order'][i]).asSymbol].copy }; }
					{num == ~numFxSynthDef }
					{~eqUnitLib[sv][0].setting.copy}
					{num == (~numFxSynthDef+1) }
					{~eqUnitLib[sv][1].setting.copy}
					{num == (~numFxSynthDef+2) }
					{~eqUnitLib[sv][2].setting.copy}
					{num == (~numFxSynthDef+3) } // Spectral EQ
					{[~fftEQMagValues[sv].copy, ~fftEQSliderLag[sv].copy, ~fftEQCompChoose[sv].copy, ~fftEQBufChoose[sv].copy, ~fftEQRoutRand[sv].copy]}
					{num == (~numFxSynthDef+4) } // Spectral Delay
					{[~fftDelfbValues[sv].copy, ~fftDelSliderLag[sv].copy, ~fftDelCompChoose[sv].copy, ~fftDelBufChoose[sv].copy, ~fftDelRoutRand[sv].copy]}
					{num == (~numFxSynthDef+5) } // Spectral Diffusion
					{[~fftOutChannelValues[sv].copy, ~fftOutSliderLag[sv].copy, ~fftOutCompChoose[sv].copy, ~fftOutBufChoose[sv].copy, ~fftOutRoutRand[sv].copy]}
					{num > (~numFxSynthDef+5) }
					{ var nb = num - (~numFxSynthDef+6); // nb.postln;
						~fxSynthDefV[nb].metadata['order'].size.collect { |i| ~fxSynthDefValues[sv][(~fxSynthDefV[nb].name ++ ~fxSynthDefV[nb].metadata['order'][i]).asSymbol].copy };
					}
					{num < 0} // utilité ??? -> si pas de FX
					{0}; }
				// ~fxSynthDef[0].metadata['order'].size.collect { |i| ~fxSynthDefValues[sv][(~fxSynthDef[num].name ++ ~fxSynthDef[num].metadata['order'][i]).asSymbol] };
			}),

			\fxSynthDataM ->
			if (index.asString.endsWith("E") or:{index.asString.endsWith("ES")}, {
				// Collection des données d'effets EZsliders & EQ
				~fxSelect[sv].collect { |a| var num = a-1;
					// num.postln;
					if (num >= 0 and:{ num < ~numFxSynthDef } and:{ ~fxSynthDef[num].metadata['orderM'].notNil }, {
						~fxSynthDef[num].metadata['orderM'].size.collect { |i| ~fxSynthDefValues[sv][(~fxSynthDef[num].name ++ ~fxSynthDef[num].metadata['orderM'][i]).asSymbol].copy }
					});
					// num.postln;
				}/*.postln;*/
			}),

			// Pourquoi obligé de rajouter qqch pour \fxSynthDataM dans ~presetSetFunction pour éviter une erreur metadata dans l'enregistrement de certains presets comme D DRN_0.5_002_X2KIK5_E ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

			// Pour les effets ambisoniques
			\fxASynth ->
			if (index.asString.endsWith("S")/*.postln*/, {1}, {0} ),

			\fxASynthNum ->
			if (index.asString.endsWith("S"), {~fxASelect[sv].copy} ),

			\fxASynthData ->
			if (index.asString.endsWith("S"), {
				// Collection des données d'effets EZsliders & EQ
				~fxASelect[sv].collect { |a| var numS, num = a-1;
					// num.postln;
					case
					{ num.inclusivelyBetween(0, ~numFxSynthDef5-1) }
					{ [~fxSynthDefA[num].metadata['order'].size.collect { |i| ~fxSynthDefValues[sv][(~fxSynthDefA[num].name.asString[0..2] ++ num.asSymbol ++ ~fxSynthDefA[num].metadata['order'][i]).asSymbol].copy }, ~fxSynthDef5SwitchTyp[sv][num].copy ]
					}
					{ num.inclusivelyBetween(~numFxSynthDef5, ~numFxSynthDef6Cum-1) }
					{ numS = num-~numFxSynthDef5; [~fxSynthDefA[num].metadata['order'].size.collect { |i| ~fxSynthDefValues[sv][(~fxSynthDefA[num].name.asString[0..2] ++ numS.asSymbol ++ ~fxSynthDefA[num].metadata['order'][i]).asSymbol].copy }, ~fxSynthDef6SwitchTyp[sv][numS].copy ]
					}
					{ num.inclusivelyBetween(~numFxSynthDef6Cum, ~numFxSynthDef7Cum-1) }
					{ numS = num-~numFxSynthDef6Cum; [~fxSynthDefA[num].metadata['order'].size.collect { |i| ~fxSynthDefValues[sv][(~fxSynthDefA[num].name.asString[0..1] ++ numS.asSymbol ++ ~fxSynthDefA[num].metadata['order'][i]).asSymbol].copy }, ~fxSynthDef7SwitchTyp[sv][numS].copy, ~fxSynthDef7SwitchTypPC[sv][numS].copy ]
					}
					{ num.inclusivelyBetween(~numFxSynthDef7Cum, ~numFxSynthDefA-1) }
					{ numS = num-~numFxSynthDef7Cum; [~fxSynthDefA[num].metadata['order'].size.collect { |i| ~fxSynthDefValues[sv][(~fxSynthDefA[num].name.asString[0..4] ++ numS.asSymbol ++ ~fxSynthDefA[num].metadata['order'][i]).asSymbol].copy }, ~fxSynthDef8SwitchTyp[sv][numS].copy, ~fxSynthDef8SwitchTypPC[sv][numS].copy, ~fxSynthDef8SwitchRev[sv][numS].copy ]
					}
					{ num < 0 or: {num > ~numFxSynthDefA } } // utilité car pas de variants ???
					{0}
				}
			});

	]));
};
);

/*
~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\fxSynth]
~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\fxSynthNum]
~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\fxSynthSerPar]
~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\fxSynthData]
~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\fxSynthData][2][0]
~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\fxASynthData][0][2]
~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\fxASynthNum]
~presetSelection[~tracksValue][~seqsValue].last
~fxSynthDef[~numFxSynthDef-1]
*/










// Get one Preset in GUI with Dico

/*
- Benchmark avec les 8 types de données sauvegardées (pas de différence avec le Nouveau preset remplacant l'array par un Identity Dictionary) :
16 valeurs -> 0.03 s
96 valeurs -> 0.05 s
200 valeurs -> 0.08 s
400 valeurs -> 0.13 s
Pas beaucoup de différence si on fait un benchmark avec les 4 premiers types de données primordiales - Comment l'améliorer ?????????
voire si la suppression des spec permet de réduire de manière conséquente le CPU ?????????
{~presetGetFunction.value(~presetSelectionView.item.asSymbol)}.bench; // entre 0.10 & 0.15 avec 200 valeurs - grosse augmentation du CPU depuis le changement de format et l'ajout de nouveaux preset elements
{~presetGetFunction.value('40s| 200e| DR Dev Cwej RD| TA Cwej_PSGlis2_%_XX')}.bench;
*/

// ~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\synView]

(
~presetGetFunction = { | index |

	/*
	~presets = IdentityDictionary.new;
	~presets.keys;
	~presets.keys.asArray[0]
	~presets['test2'][\rtmView];
	~presets[~presets.keys.asArray[0]].cs
	~presets[~presets.keys.asArray[10]][\configBeatsView]

	~presets[~presetSelectionView.item.asSymbol] // à utiliser à la place d'index pour obtenir la valeur du preset en cours
	{~presetGetFunction.value(~presetSelectionView.item.asSymbol)}.bench;

	{~presetSetFunction.value('test1')}.bench
	{~presetSetFunction2.value('test2')}.bench // apparemment aucun impact par rapport au nombre de données dans le multislider contrairement au bench précédent - + rapide que le bench 1

	{~presetGetFunction.value('test1')}.bench
	{~presetGetFunction2.value('test2')}.bench // très légère meilleure performance par rapport à l'array (pratiquement imperceptible)

	~presetGetFunction.value('test1')
	~presetGetFunction2.value('test2')
	*/

	var sv;

	// Utilisation seulement du ~dur car la nb d'éléments dans toutes les séquences est le même
	var rtmSeqSize = ~presets[index][\rtmView].size;
	var rtmThumbSize = max((333 / rtmSeqSize)*~xSizeMul, ~readViewThumbSize);
	var rtmSeqStep = 1 / rtmSeqSize;
	var rtmSeqSpec = ControlSpec(0, rtmSeqSize, \lin, 1, 1);
	var rtmSeqVSpec = ControlSpec(0, rtmSeqSize-1, \lin, 1, 1);
	var ratHarSeqSize, ratHarSeqSpec, ratHarSeqStep; // Pour les Miroirs Multiples

	var previousfxActOnWhich = ~fxActOnWhich; // Pour éviter que le fxL agisse sur le droit
	var previousoutActOnWhich = ~outActOnWhich; // Pour éviter que le outL agisse sur le droit
	var previousoutCompChoose = ~outCompChoose;

	// Protection mulSlider - Mise en place d'une sécurité avec une multiplication selon le timeOnset
	// peut déclencher des lates -> peut-être multiplier par 2 encore ???
	var timeOnset = (~presets[index][\nbTotalBeats] / ~toTempo) / /*~seqDurRtm*/ rtmSeqSize/*.postln*/;
	~rtmMulSpec[~tracksValue][~seqsValue] = ControlSpec(timeOnset * (20 * ~rtmMulMinProtect / (timeOnset / 0.01).squared), 10, 4, 0.001, 1);
	// ~rtmMulSpec[~tracksValue][~seqsValue].postln;
	// Pourquoi le postln; est déclenché 2x avec changement de rythme -> fonction duration2show
	// Pourquoi le postln; est déclenché 2x avec changement de preset -> fonction getPreset
	/*
	-> 0.0025 * 0.8 -> * 320 // Quand l'un augmente de x2, l'autre est /4
	-> 0.005 * 0.4 -> * 80
	-> 0.01 * 0.2 -> * 20
	-> 0.02 * 0.1 -> * 5
	-> 0.04 * 0.05 -> * 1.25
	x = 0.5; x * (20 / (x / 0.01).squared)
	x = (~nbTotalBeats[~tracksValue][~seqsValue] / ~toTempo) / /*~seqDurRtm*/~dur[~tracksValue][~seqsValue].size; x * (20 / (x / 0.01).squared)
	*/

	if (~server2.isNil or: {(~tracksValue/2).asInteger < ~serverTrackSwitch}, {sv = 0}, {sv = 1} );

	~fxActOnWhichView.valueAction_(0); // Pour éviter que le fxL agisse sur le droit
	~outActOnWhichView.valueAction_(0); // Pour éviter que le outL agisse sur le droit


	// Données rythmiques 7
	// Changement de place en début afin que le rtyhme (\nbTotalBeats) soit respecté quand changement de preset avec des durées de Beats différents
	// Lors d'un nouveau fichier de preset garder seulement \configBeatsView (\configBeatsValue conservé pour ne pas refaire le fichier de preset
	~configBeatsView.valueAction_(~presets[index][\configBeatsView]);
	~nbTotalBeatsView.valueAction_(~nbTotalBeatsSpec.unmap(~presets[index][\nbTotalBeats]));
	~displayRhythm[~tracksValue][~seqsValue] = ~presets[index][\displayRhythm]; // nécessaire afin de ne pas changer le ~displayRhythm quand fait play sur la séquence
	~displayRhythmView.string_(~presets[index][\displayRhythm]);
	// ~displayRhythmView.string_(~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\displayRhythm])
	6.do { |i|
		// if (~presets[index][\selectBeatView][i].notNil, { ~selectBeatValue[track][seq][i] = ~presets[index][\selectBeatView][i] });
		// voir lequel est le plus justifié .notNil ou != 0 ?????? pour optimisation ??????
		if (~presets[index][\selectBeatView][i].notNil and: {~presets[index][\selectBeatView][i] != 0}, { ~selectBeatView[i].value_(~presets[index][\selectBeatView][i]) });
		~pBeatView[i].valueAction_(~presets[index][\pBeat][i]);
		~nbBeatView[i].valueAction_(~presets[index][\nbBeat][i]);
		~sumBeatView[i].valueAction_(~presets[index][\sumBeat][i]);
		~minSumBeatView[i].valueAction_(~presets[index][\minSumBeat][i])
	};


	// Données du Round 4
	// seulement une protection sur le ~bufFolderView
	// si le nb de données dans le RoundView PopUpMenu a changé par rapport au preset précédemment sauvegardé
	// et donc déclenchement d'une erreur qui empêche de lire la suite des données
	// pas de protection si le nb de données dans le RoundView PopUpMenu a changé par rapport au preset précédemment sauvegardé et donc déclenchement d'une erreur qui empêche de lire la suite des données
	~rtmRoundView.valueAction_(~presets[index][\rtmRoundView]);
	~proRoundView.valueAction_(~presets[index][\proRoundView]);
	~legRoundView.valueAction_(~presets[index][\legRoundView]);
	// ~bufFolderView.valueAction_(~presets[index][\bufFolderView]);
	if (~presets[index][\bufFolderView] < ~bufFolderSize, {~bufFolderView.valueAction_(~presets[index][\bufFolderView])}, { ~bufFolderView.valueAction_(~bufFolderSize1) }); // à optimiser
	~offRoundView.valueAction_(~presets[index][\offRoundView]);
	if (~presets[index][\off2RoundView].notNil, { ~off2RoundView.valueAction_(~presets[index][\off2RoundView]); ~off3RoundView.valueAction_(~presets[index][\off3RoundView]); ~off4RoundView.valueAction_(~presets[index][\off4RoundView]); });
	~ratRoundView.valueAction_(~presets[index][\ratRoundView]);
	~ampRoundView.valueAction_(~presets[index][\ampRoundView]);
	~strRoundView.valueAction_(~presets[index][\strRoundView]);
	~cenRoundView.valueAction_(~presets[index][\cenRoundView]);
	~panRoundView.valueAction_(~presets[index][\panRoundView]);
	~delRoundView.valueAction_(~presets[index][\delRoundView]);
	~rat2RoundView.valueAction_(~presets[index][\rat2RoundView]);
	~str2RoundView.valueAction_(~presets[index][\str2RoundView]);
	~cen2RoundView.valueAction_(~presets[index][\cen2RoundView]);

	/*
	{ 100.do {~cenRoundView.valueAction_(~presets[~presetSelectionView.item.asSymbol][\cenRoundView])}}.bench;
	// Pourquoi la ligne ci-dessous génère moins de CPU en toutes circonstances, même quand la valeur est différente ??? - A appliquer sur toutes les valeurs qui ne changent pas souvent
	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	{ 100.do {if (~cenRoundView.value != ~presets[~presetSelectionView.item.asSymbol][\cenRoundView], { ~cenRoundView.valueAction_(~presets[~presetSelectionView.item.asSymbol][\cenRoundView]) }); }}.bench;
	*/

	/* // Protection sur tous les PopUpMenus
	if (~presets[index][\rtmRoundView] < ~rtmRoundView.items.size, {~rtmRoundView.valueAction_(~presets[index][\rtmRoundView])});
	if (~presets[index][\proRoundView] < ~proRoundView.items.size, {~proRoundView.valueAction_(~presets[index][\proRoundView])});
	if (~presets[index][\legRoundView] < ~legRoundView.items.size, {~legRoundView.valueAction_(~presets[index][\legRoundView])});
	if (~presets[index][\bufFolderView] < ~bufFolderView.items.size, {~bufFolderView.valueAction_(~presets[index][\bufFolderView])});
	if (~presets[index][\offRoundView] < ~offRoundView.items.size, {~offRoundView.valueAction_(~presets[index][\offRoundView])});
	if (~presets[index][\ratRoundView] < ~ratRoundView.items.size, {~ratRoundView.valueAction_(~presets[index][\ratRoundView])});
	if (~presets[index][\ampRoundView] < ~ampRoundView.items.size, {~ampRoundView.valueAction_(~presets[index][\ampRoundView])});
	if (~presets[index][\strRoundView] < ~strRoundView.items.size, {~strRoundView.valueAction_(~presets[index][\strRoundView])});
	if (~presets[index][\cenRoundView] < ~cenRoundView.items.size, {~cenRoundView.valueAction_(~presets[index][\cenRoundView])});
	if (~presets[index][\panRoundView] < ~panRoundView.items.size, {~panRoundView.valueAction_(~presets[index][\panRoundView])});
	*/


	// Données Mappées du RangeSlider 1
	~rtmRangeView.valueAction_(~rtmRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\rtmMin], ~presets[index][\rtmMax]]));
	~proRangeView.valueAction_(~proRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\proMin], ~presets[index][\proMax]]));
	~synRangeView.valueAction_(~synRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\synMin], ~presets[index][\synMax]]));
	~spaRangeView.valueAction_(~spaRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\spaMin], ~presets[index][\spaMax]]));
	~legRangeView.valueAction_(~legRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\legMin], ~presets[index][\legMax]]));
	~envRangeView.valueAction_(~envRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\envMin], ~presets[index][\envMax]]));

	// ~bufFolderFunc.(~tracksValue, ~seqsValue, ~presets[index][\bufFolderView], /*0*/ if (~server2.isNil or: {(~tracksValue/2).asInteger < ~serverTrackSwitch}, {0}, {1}) ); déjà intégré dans BufFolderView
	// ~bufRangeView.valueAction_(ControlSpec(0, ~presets[index][\bufFolderView], 'linear', 1, 0, "").unmap([~presets[index][\bufMin], ~presets[index][\bufMax]]));
	~bufRangeView.valueAction_(~bufRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\bufMin], ~presets[index][\bufMax]])).doAction; // ???

	~offRangeView.valueAction_(~offRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\offMin], ~presets[index][\offMax]]));
	if (~presets[index][\off2Min].notNil, {
		~off2RangeView.valueAction_(~off2RangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\off2Min], ~presets[index][\off2Max]]));
		~off3RangeView.valueAction_(~off3RangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\off3Min], ~presets[index][\off3Max]]));
		~off4RangeView.valueAction_(~off4RangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\off4Min], ~presets[index][\off4Max]]));
	});

	~ratRangeView.valueAction_(~ratRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\ratMin], ~presets[index][\ratMax]]));
	~ampRangeView.valueAction_(~ampRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\ampMin], ~presets[index][\ampMax]]));
	~strRangeView.valueAction_(~strRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\strMin], ~presets[index][\strMax]]));
	~cenRangeView.valueAction_(~cenRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\cenMin], ~presets[index][\cenMax]]));
	~panRangeView.valueAction_(~panRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\panMin], ~presets[index][\panMax]]));
	~outRRangeView.valueAction_(~outRRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\outRMin], ~presets[index][\outRMax]]));
	~outLRangeView.valueAction_(~outLRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\outLMin], ~presets[index][\outLMax]]));
	~fxRRangeView.valueAction_(~fxRRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\fxRMin], ~presets[index][\fxRMax]]));
	~fxLRangeView.valueAction_(~fxLRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\fxLMin], ~presets[index][\fxLMax]]));
	~delRangeView.valueAction_(~delRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\delMin], ~presets[index][\delMax]]));
	~rat2RangeView.valueAction_(~rat2RangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\rat2Min], ~presets[index][\rat2Max]]));
	~str2RangeView.valueAction_(~str2RangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\str2Min], ~presets[index][\str2Max]]));
	~cen2RangeView.valueAction_(~cen2RangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\cen2Min], ~presets[index][\cen2Max]]));

	// Données Brutes du RangeSlider 1
	/*~rtmRangeView.valueAction_(~presets[index][\rtmRangeView]);
	~proRangeView.valueAction_(~presets[index][\proRangeView]);
	~synRangeView.valueAction_(~presets[index][\synRangeView]);
	~spaRangeView.valueAction_(~presets[index][\spaRangeView]);
	~legRangeView.valueAction_(~presets[index][\legRangeView]);
	~envRangeView.valueAction_(~presets[index][\envRangeView]);
	~bufRangeView.valueAction_(~presets[index][\bufRangeView]);
	~offRangeView.valueAction_(~presets[index][\offRangeView]);
	~ratRangeView.valueAction_(~presets[index][\ratRangeView]);
	~ampRangeView.valueAction_(~presets[index][\ampRangeView]);
	~strRangeView.valueAction_(~presets[index][\strRangeView]);
	~cenRangeView.valueAction_(~presets[index][\cenRangeView]);
	~panRangeView.valueAction_(~presets[index][\panRangeView]);
	~outLRangeView.valueAction_(~presets[index][\outLRangeView]);
	~outRRangeView.valueAction_(~presets[index][\outRRangeView]);
	~fxLRangeView.valueAction_(~presets[index][\fxLRangeView]);
	~fxRRangeView.valueAction_(~presets[index][\fxRRangeView]);*/


	/*
	To check the way of not changing the object

	{ 1000.do{~dur[~tracksValue][~seqsValue] = 0 ! 200;}}.bench
	{ 1000.do{~dur[~tracksValue][~seqsValue] = Array.new(200);}}.bench
	{ 1000.do{~dur[~tracksValue][~seqsValue] = Array.newClear(200);}}.bench
	{ 1000.do{~dur[~tracksValue][~seqsValue] = SparseArray.newClear(200);}}.bench
	{ 1000.do{~dur[~tracksValue][~seqsValue] = Array.new(200);}}.bench

	{ 1000.do{~rat[~tracksValue][~seqsValue] = Array.new(80);}}.bench
	~rat[~tracksValue][~seqsValue] = Array.new(80);
	~rat[~tracksValue][~seqsValue] = 0 ! 20;
	~rat[~tracksValue][~seqsValue].maxSize
	*/

	// Données du Multislider 0
	// ou utilisation de la méthode maxSize de l'array -> Return the maximum number of elements the ArrayedCollection can hold ???
	// Pour éviter de créer une nouvelle instance
	// requiert beaucoup de temps -> 0.005 pour chaque élément si 200 / sinon 0.001 pour 4
	~dur[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~rtmView.valueAction_(~presets[index][\rtmView]);
	~pro[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~proView.valueAction_(~presets[index][\proView]);
	~syn[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~synView.valueAction_(~presets[index][\synView]);
	~spa[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~spaView.valueAction_(~presets[index][\spaView]);
	~leg[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~legView.valueAction_(~presets[index][\legView]);
	~env[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~envView.valueAction_(~presets[index][\envView]);
	~buf[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~bufView.valueAction_(~presets[index][\bufView]);
	~off[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~offView.valueAction_(~presets[index][\offView]);

	if (~presets[index][\off2View].notNil and: {~presets[index][\off2View].size == rtmSeqSize}, {
		// obligé de rajouter "and: {~presets[index][\off2View].size == rtmSeqSize}", car pour certains presets, la taille des arrays est différente entre ~off2, ~off3 & rtmSeqSize - necessaire qu'aux presets de Paramegiani - pourrait être supprimé
		~off2[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~off2View.valueAction_(~presets[index][\off2View]);
		~off3[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~off3View.valueAction_(~presets[index][\off3View]);
		~off4[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~off4View.valueAction_(~presets[index][\off4View]);
		~off2SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec; ~off3SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec; ~off4SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~off2SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec; ~off3SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec; ~off4SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
		[~off2ReadView, ~off3ReadView, ~off4ReadView].do{ |i| i.thumbSize_(rtmThumbSize) };
	},{
		~off2[~tracksValue][~seqsValue] = (Array.fill(rtmSeqSize, {0})); ~off2View.valueAction_(~off2[~tracksValue][~seqsValue]);
		~off3[~tracksValue][~seqsValue] = (Array.fill(rtmSeqSize, {0})); ~off3View.valueAction_(~off3[~tracksValue][~seqsValue]);
		~off4[~tracksValue][~seqsValue] = (Array.fill(rtmSeqSize, {0})); ~off4View.valueAction_(~off4[~tracksValue][~seqsValue]);
		~off2SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec; ~off3SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec; ~off4SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
		~off2SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec; ~off3SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec; ~off4SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
		[~off2ReadView, ~off3ReadView, ~off4ReadView].do{ |i| i.thumbSize_(rtmThumbSize) };
	});

	~rat[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~ratView.valueAction_(~presets[index][\ratView]); // ~presets[index][\ratView].postln;
	~amp[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~ampView.valueAction_(~presets[index][\ampView]);
	~str[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~strView.valueAction_(~presets[index][\strView]);
	~cen[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~cenView.valueAction_(~presets[index][\cenView]);
	~pan[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~panView.valueAction_(~presets[index][\panView]);
	~outL[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~outLView.valueAction_(~presets[index][\outLView]);
	~outR[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~outRView.valueAction_(~presets[index][\outRView]);
	~fxL[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~fxLView.valueAction_(~presets[index][\fxLView]);
	~fxR[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~fxRView.valueAction_(~presets[index][\fxRView]);
	~del[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~delView.valueAction_(~presets[index][\delView]);
	~rat2[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~rat2View.valueAction_(~presets[index][\rat2View]);
	~str2[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~str2View.valueAction_(~presets[index][\str2View]);
	~cen2[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~cen2View.valueAction_(~presets[index][\cen2View]);


	// Changement du SeqRangeSpec - Utilité d'avoir des SeqSpec différents pour chaque module ???
	// Pourquoi garder pour ~gblSeqIndexSpec un controlSpec identique au précédent ???
	~gblSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~gblSeqIndexSpec[~tracksValue][~seqsValue] = rtmSeqSpec; // Pourquoi garder un controlSpec identique au précédent ???
	~rtmSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~proSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~synSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~spaSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~legSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~envSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~bufSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~offSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~ratSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~ampSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~strSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~cenSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~panSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~outLSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~outRSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~fxLSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~fxRSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~delSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~rat2SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~str2SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~cen2SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	// Pourquoi ligne dessous ne peut remplacer ce qu'il y a dessus ??? -> car ne prend pas l'objet mais la valeur
	/*[~gblSeqSpec[~tracksValue][~seqsValue], ~gblSeqIndexSpec[~tracksValue][~seqsValue], ~rtmSeqSpec[~tracksValue][~seqsValue], ~proSeqSpec[~tracksValue][~seqsValue], ~synSeqSpec[~tracksValue][~seqsValue], ~spaSeqSpec[~tracksValue][~seqsValue], ~legSeqSpec[~tracksValue][~seqsValue], ~envSeqSpec[~tracksValue][~seqsValue], ~bufSeqSpec[~tracksValue][~seqsValue], ~offSeqSpec[~tracksValue][~seqsValue], ~ratSeqSpec[~tracksValue][~seqsValue], ~ampSeqSpec[~tracksValue][~seqsValue], ~strSeqSpec[~tracksValue][~seqsValue], ~cenSeqSpec[~tracksValue][~seqsValue], ~panSeqSpec[~tracksValue][~seqsValue], ~outLSeqSpec[~tracksValue][~seqsValue], ~outRSeqSpec[~tracksValue][~seqsValue], ~fxLSeqSpec[~tracksValue][~seqsValue], ~fxRSeqSpec[~tracksValue][~seqsValue]].collect{ |i| i = rtmSeqSpec };*/

	~rtmSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~proSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~synSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~spaSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~legSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~envSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~bufSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~offSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~ratSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~ampSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~strSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~cenSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~panSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~outLSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~outRSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~fxLSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~fxRSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~delSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~rat2SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~str2SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	~cen2SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
	// Pourquoi ligne dessous ne peut remplacer ce qu'il y a dessus ??? -> car ne prend pas l'objet mais la valeur
	/*[~rtmSeqVSpec[~tracksValue][~seqsValue], ~proSeqVSpec[~tracksValue][~seqsValue], ~synSeqVSpec[~tracksValue][~seqsValue], ~spaSeqVSpec[~tracksValue][~seqsValue], ~legSeqVSpec[~tracksValue][~seqsValue], ~envSeqVSpec[~tracksValue][~seqsValue], ~bufSeqVSpec[~tracksValue][~seqsValue], ~offSeqVSpec[~tracksValue][~seqsValue], ~ratSeqVSpec[~tracksValue][~seqsValue], ~ampSeqVSpec[~tracksValue][~seqsValue], ~strSeqVSpec[~tracksValue][~seqsValue], ~cenSeqVSpec[~tracksValue][~seqsValue], ~panSeqVSpec[~tracksValue][~seqsValue], ~outLSeqVSpec[~tracksValue][~seqsValue], ~outRSeqVSpec[~tracksValue][~seqsValue], ~fxLSeqVSpec[~tracksValue][~seqsValue], ~fxRSeqVSpec[~tracksValue][~seqsValue]].do{ |i| i = rtmSeqVSpec };*/

	// ~bufSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurBuf[~tracksValue][~seqsValue], \lin, 1, 1); // Pour le Slider ~bufReadView

	[~rtmReadView, ~proReadView, ~synReadView, ~spaReadView, ~legReadView, ~envReadView, ~bufReadView, ~ampReadView, ~ratReadView, ~rat2ReadView, ~offReadView, ~strReadView, ~str2ReadView, ~cenReadView, ~cen2ReadView, ~panReadView, ~delReadView, ~outLReadView, ~outRReadView, ~fxLReadView, ~fxRReadView].do{ |i| i.thumbSize_(rtmThumbSize) };
	~rtmThumbSizeValue[~tracksValue][~seqsValue] = rtmThumbSize; // Pour modif du ThumbSize du ReadViewSlider dans le Tab Global XXX

	// Données du SeqRangeSlider 2 mappées
	~gblSeqIndexView.step_(rtmSeqStep).value_(~gblSeqIndexSpec[~tracksValue][~seqsValue].unmap(~presets[index][\gblSeqIndex])).doAction;
	~gblSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).value_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\gblSeqStart], ~presets[index][\gblSeqStop]+1])).doAction;
	// Le .doAction doit être changé car délenche les autres seqsView ???

	~rtmSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~rtmSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\rtmSeqStart], ~presets[index][\rtmSeqStop]+1]));
	~proSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~proSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\proSeqStart], ~presets[index][\proSeqStop]+1]));
	~synSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~synSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\synSeqStart], ~presets[index][\synSeqStop]+1]));
	~spaSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~spaSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\spaSeqStart], ~presets[index][\spaSeqStop]+1]));
	~legSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~legSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\legSeqStart], ~presets[index][\legSeqStop]+1]));
	~envSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~envSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\envSeqStart], ~presets[index][\envSeqStop]+1]));
	~bufSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~bufSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\bufSeqStart], ~presets[index][\bufSeqStop]+1]));
	~offSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~offSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\offSeqStart], ~presets[index][\offSeqStop]+1]));

	if (~presets[index][\off2SeqStart].notNil, {
		~off2SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~off2SeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\off2SeqStart], ~presets[index][\off2SeqStop]+1]));
		~off3SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~off3SeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\off3SeqStart], ~presets[index][\off3SeqStop]+1]));
		~off4SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~off4SeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\off4SeqStart], ~presets[index][\off4SeqStop]+1]));
	});

	~ratSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~ratSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\ratSeqStart], ~presets[index][\ratSeqStop]+1]));
	~ampSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~ampSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\ampSeqStart], ~presets[index][\ampSeqStop]+1]));
	~strSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~strSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\strSeqStart], ~presets[index][\strSeqStop]+1]));
	~cenSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~cenSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\cenSeqStart], ~presets[index][\cenSeqStop]+1]));
	~panSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~panSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\panSeqStart], ~presets[index][\panSeqStop]+1]));
	~outLSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~outLSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\outLSeqStart], ~presets[index][\outLSeqStop]+1]));
	~outRSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~outRSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\outRSeqStart], ~presets[index][\outRSeqStop]+1]));
	~fxLSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~fxLSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\fxLSeqStart], ~presets[index][\fxLSeqStop]+1]));
	~fxRSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~fxRSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\fxRSeqStart], ~presets[index][\fxRSeqStop]+1]));
	~delSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~delSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\delSeqStart], ~presets[index][\delSeqStop]+1]));
	~rat2SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~rat2SeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\rat2SeqStart], ~presets[index][\rat2SeqStop]+1]));
	~str2SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~str2SeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\str2SeqStart], ~presets[index][\str2SeqStop]+1]));
	~cen2SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~cen2SeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\cen2SeqStart], ~presets[index][\cen2SeqStop]+1]));

	// Données Brutes du SeqRangeSlider 2
	/*~gblSeqIndexView.step_(rtmSeqStep).value_(~presets[index][\gblSeqIndexView]).doAction;
	~gblSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).value_(~presets[index][\gblSeqView]).doAction;

	~rtmSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\rtmSeqView]);
	~proSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\proSeqView]);
	~synSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\synSeqView]);
	~spaSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\spaSeqView]);
	~legSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\legSeqView]);
	~envSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\envSeqView]);
	~bufSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\bufSeqView]);
	~offSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\offSeqView]);
	~ratSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\ratSeqView]);
	~ampSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\ampSeqView]);
	~strSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\strSeqView]);
	~cenSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\cenSeqView]);
	~panSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\panSeqView]);
	~outLSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\outLSeqView]);
	~outRSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\outRSeqView]);
	~fxLSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\fxLSeqView]);
	~fxRSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\fxRSeqView]);*/


	// Données Mappées du MulSlider 3
	~rtmMulView.value_(~rtmMulSpec[~tracksValue][~seqsValue].unmap(~presets[index][\rtmMul])).doAction;
	~proMulView.value_(~proMulSpec.unmap(~presets[index][\proMul])).doAction;
	~synMulView.valueAction_(~synMulSpec.unmap(~presets[index][\synMul]));
	~spaMulView.valueAction_(~spaMulSpec.unmap(~presets[index][\spaMul]));
	~legMulView.value_(~legMulSpec.unmap(~presets[index][\legMul])).doAction;
	~envMulView.valueAction_(~envMulSpec.unmap(~presets[index][\envMul]));
	~bufMulView.value_(~bufMulSpec.unmap(~presets[index][\bufMul])).doAction;
	~offMulView.value_(~offMulSpec.unmap(~presets[index][\offMul])).doAction;

	if (~presets[index][\off2Mul].notNil, {
		~off2MulView.valueAction_(~off2MulSpec.unmap(~presets[index][\off2Mul]));
		~off3MulView.valueAction_(~off3MulSpec.unmap(~presets[index][\off3Mul]));
		~off4MulView.valueAction_(~off4MulSpec.unmap(~presets[index][\off4Mul]));
	});

	~ratMulView.value_(~ratMulSpec.unmap(~presets[index][\ratMul])).doAction;

	/*if (~twister.notNil, {
	~ratValues[~tracksValue].value_(~ratMulSpec.unmap(~ratMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
	~rtmValues[~tracksValue].value_(~rtmMulSpec[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/.unmap(~rtmMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
	~proValues[~tracksValue].value_(~proMulSpec.unmap(~proMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
	~legValues[~tracksValue].value_(~legMulSpec.unmap(~legMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
	~strValues[~tracksValue].value_(~strMulSpec.unmap(~strMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
	~cenValues[~tracksValue].value_(~cenMulSpec.unmap(~cenMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
	~bufFolValues[~tracksValue].value_(~bufFolderValue[~tracksValue][~seqsValue]);
	~bufValues[~tracksValue].value_(~bufMulSpec.unmap(~bufMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
	~offValues[~tracksValue].value_(~offMulSpec.unmap(~offMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
	// ~offValue.value_(~offMulSpec.unmap(~offMul[~tracksValue][~seqsValue]));
	});*/

	// if (~twister.notNil, { ~ratValues[tr].value_(~ratMulSpec.unmap(~presets[index][\ratMul])/*(~ratMul[~tracksValue][~seqsValue])*/ ) }); // Pour mise à jour du Twister

	~ampMulView.valueAction_(~ampMulSpec.unmap(~presets[index][\ampMul]));
	~strMulView.value_(~strMulSpec.unmap(~presets[index][\strMul])).doAction;
	~cenMulView.value_(~cenMulSpec.unmap(~presets[index][\cenMul])).doAction;
	~panMulView.valueAction_(~panMulSpec.unmap(~presets[index][\panMul]));
	~outLMulView.valueAction_(~outLMulSpec.unmap(~presets[index][\outLMul]));
	~outRMulView.valueAction_(~outRMulSpec.unmap(~presets[index][\outRMul]));
	~fxLMulView.valueAction_(~fxLMulSpec.unmap(~presets[index][\fxLMul]));
	~fxRMulView.valueAction_(~fxRMulSpec.unmap(~presets[index][\fxRMul]));
	~delMulView.valueAction_(~delMulSpec.unmap(~presets[index][\delMul]));
	~rat2MulView.valueAction_(~rat2MulSpec.unmap(~presets[index][\rat2Mul]));
	~str2MulView.valueAction_(~str2MulSpec.unmap(~presets[index][\str2Mul]));
	~cen2MulView.valueAction_(~cen2MulSpec.unmap(~presets[index][\cen2Mul]));

	// Données Brutes du MulSlider 3
	/*~rtmMulView.valueAction_(~presets[index][\rtmMulView]);
	~proMulView.valueAction_(~presets[index][\proMulView]);
	~synMulView.valueAction_(~presets[index][\synMulView]);
	~spaMulView.valueAction_(~presets[index][\spaMulView]);
	~legMulView.valueAction_(~presets[index][\legMulView]);
	~envMulView.valueAction_(~presets[index][\envMulView]);
	~bufMulView.valueAction_(~presets[index][\bufMulView]);
	~offMulView.valueAction_(~presets[index][\offMulView]);
	~ratMulView.valueAction_(~presets[index][\ratMulView]);
	~ampMulView.valueAction_(~presets[index][\ampMulView]);
	~strMulView.valueAction_(~presets[index][\strMulView]);
	~cenMulView.valueAction_(~presets[index][\cenMulView]);
	~panMulView.valueAction_(~presets[index][\panMulView]);
	~outLMulView.valueAction_(~presets[index][\outLMulView]);
	~outRMulView.valueAction_(~presets[index][\outRMulView]);
	~fxLMulView.valueAction_(~presets[index][\fxLMulView]);
	~fxRMulView.valueAction_(~presets[index][\fxRMulView]);*/


	// Données du Pattern 5
	/*if (~allDir == 0, {*/
	~rtmDirView.valueAction_(~presets[index][\rtmDirView]);
	~proDirView.valueAction_(~presets[index][\proDirView]);
	~synDirView.valueAction_(~presets[index][\synDirView]);
	~spaDirView.valueAction_(~presets[index][\spaDirView]);
	~legDirView.valueAction_(~presets[index][\legDirView]);
	~envDirView.valueAction_(~presets[index][\envDirView]);
	~bufDirView.valueAction_(~presets[index][\bufDirView]);
	~offDirView.valueAction_(~presets[index][\offDirView]);

	if (~presets[index][\off2DirView].notNil, {
		~off2DirView.valueAction_(~presets[index][\off2DirView]); ~off3DirView.valueAction_(~presets[index][\off3DirView]); ~off4DirView.valueAction_(~presets[index][\off4DirView]);
	});

	~ratDirView.valueAction_(~presets[index][\ratDirView]);
	~ampDirView.valueAction_(~presets[index][\ampDirView]);
	~strDirView.valueAction_(~presets[index][\strDirView]);
	~cenDirView.valueAction_(~presets[index][\cenDirView]);
	~panDirView.valueAction_(~presets[index][\panDirView]);
	~outLDirView.valueAction_(~presets[index][\outLDirView]);
	~outRDirView.valueAction_(~presets[index][\outRDirView]);
	~fxLDirView.valueAction_(~presets[index][\fxLDirView]);
	~fxRDirView.valueAction_(~presets[index][\fxRDirView]);
	~delDirView.valueAction_(~presets[index][\delDirView]);
	~rat2DirView.valueAction_(~presets[index][\rat2DirView]);
	~str2DirView.valueAction_(~presets[index][\str2DirView]);
	~cen2DirView.valueAction_(~presets[index][\cen2DirView]);
	/*},{
	~rtmDirView.valueAction_(1);
	~proDirView.valueAction_(1);
	~synDirView.valueAction_(1);
	~spaDirView.valueAction_(1);
	~legDirView.valueAction_(1);
	~envDirView.valueAction_(1);
	~bufDirView.valueAction_(1);
	~offDirView.valueAction_(1);
	~ratDirView.valueAction_(1);
	~ampDirView.valueAction_(1);
	~strDirView.valueAction_(1);
	~cenDirView.valueAction_(1);
	~panDirView.valueAction_(1);
	~outLDirView.valueAction_(1);
	~outRDirView.valueAction_(1);
	~fxLDirView.valueAction_(1);
	~fxRDirView.valueAction_(1);
	~delDirView.valueAction_(1);
	~rat2DirView.valueAction_(1);
	~str2DirView.valueAction_(1);
	~cen2DirView.valueAction_(1);
	});*/

	~rtmPatView.value_(~presets[index][\rtmPatView]).doAction;
	~proPatView.value_(~presets[index][\proPatView]).doAction; // ~proPatView & ~spaPatView . doAction sont necessaires pour modifier le Global en toutes circonstances
	~synPatView.value_(~presets[index][\synPatView]).doAction;
	~spaPatView.value_(~presets[index][\spaPatView]).doAction;
	~legPatView.value_(~presets[index][\legPatView]).doAction;
	~envPatView.value_(~presets[index][\envPatView]).doAction;
	~bufPatView.value_(~presets[index][\bufPatView]).doAction;
	~offPatView.value_(~presets[index][\offPatView]).doAction;

	if (~presets[index][\off2PatView].notNil, {
		~off2PatView.value_(~presets[index][\off2PatView]).doAction;
		~off3PatView.value_(~presets[index][\off3PatView]).doAction;
		~off4PatView.value_(~presets[index][\off4PatView]).doAction;
	});

	~ratPatView.value_(~presets[index][\ratPatView]).doAction;
	~ampPatView.value_(~presets[index][\ampPatView]).doAction;
	~strPatView.value_(~presets[index][\strPatView]).doAction;
	~cenPatView.value_(~presets[index][\cenPatView]).doAction;
	~panPatView.value_(~presets[index][\panPatView]).doAction;
	~outLPatView.value_(~presets[index][\outLPatView]).doAction;
	~outRPatView.value_(~presets[index][\outRPatView]).doAction;
	~fxLPatView.value_(~presets[index][\fxLPatView]).doAction;
	~fxRPatView.value_(~presets[index][\fxRPatView]).doAction;
	~delPatView.value_(~presets[index][\delPatView]).doAction;
	~rat2PatView.value_(~presets[index][\rat2PatView]).doAction;
	~str2PatView.value_(~presets[index][\str2PatView]).doAction;
	~cen2PatView.value_(~presets[index][\cen2PatView]).doAction;

	~rtmPatSelView.valueAction_(~presets[index][\rtmPatSelView]);
	// ~proPatSelView.valueAction_(~presets[index][\proPatSelView]); // remis plus bas car agit sur le step et l'apparition des données
	~synPatSelView.valueAction_(~presets[index][\synPatSelView]);
	~spaPatSelView.valueAction_(~presets[index][\spaPatSelView]);
	~legPatSelView.valueAction_(~presets[index][\legPatSelView]);
	~envPatSelView.valueAction_(~presets[index][\envPatSelView]);
	~bufPatSelView.valueAction_(~presets[index][\bufPatSelView]);
	~offPatSelView.valueAction_(~presets[index][\offPatSelView]);

	if (~presets[index][\off2PatSelView].notNil, {
		~off2PatSelView.valueAction_(~presets[index][\off2PatSelView]);
		~off3PatSelView.valueAction_(~presets[index][\off3PatSelView]);
		~off4PatSelView.valueAction_(~presets[index][\off4PatSelView]);
	});

	~ratPatSelView.valueAction_(~presets[index][\ratPatSelView]);
	~ampPatSelView.valueAction_(~presets[index][\ampPatSelView]);
	~strPatSelView.valueAction_(~presets[index][\strPatSelView]);
	~cenPatSelView.valueAction_(~presets[index][\cenPatSelView]);
	~panPatSelView.valueAction_(~presets[index][\panPatSelView]);
	~outLPatSelView.valueAction_(~presets[index][\outLPatSelView]);
	~outRPatSelView.valueAction_(~presets[index][\outRPatSelView]);
	~fxLPatSelView.valueAction_(~presets[index][\fxLPatSelView]);
	~fxRPatSelView.valueAction_(~presets[index][\fxRPatSelView]);
	~delPatSelView.valueAction_(~presets[index][\delPatSelView]);
	~rat2PatSelView.valueAction_(~presets[index][\rat2PatSelView]);
	~str2PatSelView.valueAction_(~presets[index][\str2PatSelView]);
	~cen2PatSelView.valueAction_(~presets[index][\cen2PatSelView]);


	// Données des petits sliders 6 Mappées si possible
	~rtmTypeView.valueAction_(~presets[index][\rtmType]);
	~rtmTypeView2.valueAction_(~presets[index][\seqType]);

	~proBjorSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~proBjorView/*.step_(rtmSeqStep)*/.value_( /*~proBjorGridsX*/ ~proBjorSpec[~tracksValue][~seqsValue].unmap(~presets[index][\proBjor])).doAction; // doAction pour mise à jour du Spec & action sur le global
	~proBjor2View/*.step_(rtmSeqStep)*/.value_(/*~proBjorGridsY*/ ~proBjorSpec[~tracksValue][~seqsValue].unmap(~presets[index][\proBjor2])).doAction; // doAction pour mise à jour du Spec & action sur le global
	~proSelectView.value_(~presets[index][\proSelect]).doAction; // doAction -> necessaire pour action sur le global

	if (~presets[index][\proGridsBias].notNil, {~proBjor3View.valueAction_(~presets[index][\proGridsBias]) } );
	if (~presets[index][\proGridsBias2].notNil, {~proBjor4View.valueAction_(~presets[index][\proGridsBias2]) } );
	if (~presets[index][\proWeight].notNil, {~proWeightView.valueAction_(~presets[index][\proWeight]) } );
	if (~presets[index][\proDrumType].notNil, {~proDrumTypeView.valueAction_(~presets[index][\proDrumType]) } );

	~proPatSelView.valueAction_(~presets[index][\proPatSelView]); // était plus haut mais doit agir sur le step et l'apparition des données

	~synTypeView.valueAction_(~presets[index][\synType]);
	~offRateSecondBufView.valueAction_(~offRateSecondBufSpec.unmap(~presets[index][\offRateSecondBuf]));
	~offRateRandSecondBufView.valueAction_(~presets[index][\offRateRandSecondBuf]);

	if (~presets[index][\stereoSpatType].notNil, {~stereoSpatTypeView.valueAction_(~presets[index][\stereoSpatType]) } );
	~dbRollOffView.valueAction_(~presets[index][\dbRollOff]);
	~speakRadView.valueAction_(~presets[index][\speakRad]);
	~orientationView.valueAction_(~presets[index][\orientation]);
	if (~presets[index][\vmPointScale].notNil, {~vmPointScaleView.valueAction_(~presets[index][\vmPointScale]) } );
	if (~presets[index][\vbPointScale].notNil, {~vbPointScaleView.valueAction_(~presets[index][\vbPointScale]) } );
	~ambPointScaleView.valueAction_(~presets[index][\ambPointScale]);
	~trajSpatLoopView.valueAction_(~presets[index][\trajSpatLoop]);
	~trajSpatRateView.valueAction_(~presets[index][\trajSpatRate]);
	~trajSpatTimeTypeView.valueAction_(~presets[index][\trajSpatTimeType]);
	~trajSpatTypeView.valueAction_(~presets[index][\trajSpatType]);
	~spaLagTimeView.valueAction_(~presets[index][\spaLagTime]);
	if (~presets[index][\spaLagCurve].notNil, {~spaLagCurveView.valueAction_(~presets[index][\spaLagCurve]) } );
	if (~presets[index][\sdFreqRangeMin].notNil, {~sdFreqRangeView.valueAction_([~presets[index][\sdFreqRangeMin], ~presets[index][\sdFreqRangeMax]]) } );
	if (~presets[index][\sdDbRangeMin].notNil, {~sdDbRangeView.valueAction_([~presets[index][\sdDbRangeMin], ~presets[index][\sdDbRangeMax]]) } );
	if (~presets[index][\spec2spaCurve].notNil, {~spec2spaCurveView.valueAction_(~presets[index][\spec2spaCurve]) } );

	if (~presets[index][\vbapSpread].notNil, {~vbapSpreadView.valueAction_(~presets[index][\vbapSpread]) } );
	if (~presets[index][\vbapX2Off].notNil, {~vbapX2OffView.valueAction_(~presets[index][\vbapX2Off]) } );
	if (~presets[index][\circSpread].notNil, {~circSpreadView.valueAction_(~presets[index][\circSpread]) } );
	if (~presets[index][\circSpatType].notNil, {~circSpatTypeView.valueAction_(~presets[index][\circSpatType]) } );
	if (~presets[index][\circSpeedRangeMin].notNil, {~circSpeedRangeView.valueAction_([~presets[index][\circSpeedRangeMin], ~presets[index][\circSpeedRangeMax]]) } );
	if (~presets[index][\sdSpatType].notNil, {~sdSpatTypeView.valueAction_(~presets[index][\sdSpatType]) } );

	~legTypeView.valueAction_(~presets[index][\legType]);
	~legLoopView.valueAction_(~presets[index][\legLoop]);

	~atkView[0].valueAction_(~presets[index][\atk1]);
	~relView[0].valueAction_(~presets[index][\rel1]);
	~atkView[1].valueAction_(~presets[index][\atk2]);
	~relView[1].valueAction_(~presets[index][\rel2]);
	/*~atkView[2].valueAction_(~presets[index][\atk3]);
	~relView[2].valueAction_(~presets[index][\rel3]);
	~atkView[3].valueAction_(~presets[index][\atk4]);
	~relView[3].valueAction_(~presets[index][\rel4]);*/
	~atkCurveView[0].valueAction_(~presets[index][\atkCurve1]);
	~relCurveView[0].valueAction_(~presets[index][\relCurve1]);
	~atkCurveView[1].valueAction_(~presets[index][\atkCurve2]);
	~relCurveView[1].valueAction_(~presets[index][\relCurve2]);
	/*~atkCurveView[2].valueAction_(~presets[index][\atkCurve3]);
	~relCurveView[2].valueAction_(~presets[index][\relCurve3]);
	~atkCurveView[3].valueAction_(~presets[index][\atkCurve4]);
	~relCurveView[3].valueAction_(~presets[index][\relCurve4]);*/

	~w1View.valueAction_(~presets[index][\w1]);
	~w2View.valueAction_(~presets[index][\w2]);
	~envTypeView.valueAction_(~presets[index][\envType]);

	~offThreshView.valueAction_(~offThreshSpec.unmap(~presets[index][\offThresh]));
	~freqRatView.valueAction_(~freqRatSpec.unmap(~presets[index][\freqRat]));
	~fAmpView.valueAction_(~fAmpSpec.unmap(~presets[index][\fAmp]));
	~ampRatView.valueAction_(~ampRatSpec.unmap(~presets[index][\ampRat]));
	~aAmpView.valueAction_(~aAmpSpec.unmap(~presets[index][\aAmp]));
	~panRatView.valueAction_(~panRatSpec.unmap(~presets[index][\panRat]));
	~pAmpView.valueAction_(~pAmpSpec.unmap(~presets[index][\pAmp]));
	~ratSynthView.valueAction_(~presets[index][\gliss]);

	if (~presets[index][\grainSize].notNil, {~grainSizeView.valueAction_(~presets[index][\grainSize]) } );
	if (~presets[index][\grain2Size].notNil, {~grain2SizeView.valueAction_(~presets[index][\grain2Size]) } );

	if (~presets[index][\lehmerInit1].notNil, {~lehmerInit1View.valueAction_(~presets[index][\lehmerInit1]) } );
	if (~presets[index][\lehmerA1].notNil, {~lehmerA1View.valueAction_(~presets[index][\lehmerA1]) } );
	if (~presets[index][\lehmerB1].notNil, {~lehmerB1View.valueAction_(~presets[index][\lehmerB1]) } );
	if (~presets[index][\lehmerReInit1].notNil, {~lehmerReInit1View.valueAction_(~presets[index][\lehmerReInit1]) } );
	if (~presets[index][\lehmerInit2].notNil, {~lehmerInit2View.valueAction_(~presets[index][\lehmerInit2]) } );
	if (~presets[index][\lehmerA2].notNil, {~lehmerA2View.valueAction_(~presets[index][\lehmerA2]) } );
	if (~presets[index][\lehmerB2].notNil, {~lehmerB2View.valueAction_(~presets[index][\lehmerB2]) } );
	if (~presets[index][\lehmerReInit2].notNil, {~lehmerReInit2View.valueAction_(~presets[index][\lehmerReInit2]) } );

	// Données des petits sliders 6 Brutes si possible
	/*~rtmTypeView.valueAction_(~presets[index][\rtmType]);
	~proBjorSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
	~proBjorView.step_(rtmSeqStep)
	// ~proBjorView.doAction; // intérêt ???
	.valueAction_(~presets[index][\proBjorView]);
	~synTypeView.valueAction_(~presets[index][\synType]);
	~offRateSecondBufView.valueAction_(~presets[index][\offRateSecondBufView]);
	~offRateRandSecondBufView.valueAction_(~presets[index][\offRateRandSecondBuf]);
	~trajLevelScaleView.valueAction_(~presets[index][\trajLevelScaleView]);
	~spaTrajTimeView.valueAction_(~presets[index][\spaTrajTime]);
	~legTypeView.valueAction_(~presets[index][\legType]);
	~legLoopView.valueAction_(~presets[index][\legLoop]);
	~atkView.valueAction_(~presets[index][\atkView]);
	~relView.valueAction_(~presets[index][\relView]);
	~envTypeView.valueAction_(~presets[index][\envType]);
	~w1View.valueAction_(~presets[index][\w1View]);
	~w2View.valueAction_(~presets[index][\w2View]);
	~offThreshView.valueAction_(~presets[index][\offThreshView]);
	~freqRatView.valueAction_(~presets[index][\freqRatView]);
	~fAmpView.valueAction_(~presets[index][\fAmpView]);
	~ampRatView.valueAction_(~presets[index][\ampRatView]);
	~aAmpView.valueAction_(~presets[index][\aAmpView]);
	~panRatView.valueAction_(~presets[index][\panRatView]);
	~pAmpView.valueAction_(~presets[index][\pAmpView]);*/


	// Données du mode des SmoothRangeSliders 8
	// Les RangeMode et SeqMode prennent au global 0.00014 sec -> donc ne prend pratiquement pas de temps
	~rtmRangeMode.valueAction_(~presets[index][\rtmRangeMode]);
	~proRangeMode.valueAction_(~presets[index][\proRangeMode]);
	~synRangeMode.valueAction_(~presets[index][\synRangeMode]);
	~spaRangeMode.valueAction_(~presets[index][\spaRangeMode]);
	~legRangeMode.valueAction_(~presets[index][\legRangeMode]);
	~envRangeMode.valueAction_(~presets[index][\envRangeMode]);
	~bufRangeMode.valueAction_(~presets[index][\bufRangeMode]);
	~offRangeMode.valueAction_(~presets[index][\offRangeMode]);

	if (~presets[index][\off2RangeMode].notNil, {
		~off2RangeMode.valueAction_(~presets[index][\off2RangeMode]);
		~off3RangeMode.valueAction_(~presets[index][\off3RangeMode]);
		~off4RangeMode.valueAction_(~presets[index][\off4RangeMode]);
	});

	~ratRangeMode.valueAction_(~presets[index][\ratRangeMode]);
	~ampRangeMode.valueAction_(~presets[index][\ampRangeMode]);
	~strRangeMode.valueAction_(~presets[index][\strRangeMode]);
	~cenRangeMode.valueAction_(~presets[index][\cenRangeMode]);
	~panRangeMode.valueAction_(~presets[index][\panRangeMode]);
	~outLRangeMode.valueAction_(~presets[index][\outLRangeMode]);
	~outRRangeMode.valueAction_(~presets[index][\outRRangeMode]);
	~fxLRangeMode.valueAction_(~presets[index][\fxLRangeMode]);
	~fxRRangeMode.valueAction_(~presets[index][\fxRRangeMode]);
	~delRangeMode.valueAction_(~presets[index][\delRangeMode]);
	~rat2RangeMode.valueAction_(~presets[index][\rat2RangeMode]);
	~str2RangeMode.valueAction_(~presets[index][\str2RangeMode]);
	~cen2RangeMode.valueAction_(~presets[index][\cen2RangeMode]);

	~rtmSeqMode.valueAction_(~presets[index][\rtmSeqMode]);
	~proSeqMode.valueAction_(~presets[index][\proSeqMode]);
	~synSeqMode.valueAction_(~presets[index][\synSeqMode]);
	~spaSeqMode.valueAction_(~presets[index][\spaSeqMode]);
	~legSeqMode.valueAction_(~presets[index][\legSeqMode]);
	~envSeqMode.valueAction_(~presets[index][\envSeqMode]);
	~bufSeqMode.valueAction_(~presets[index][\bufSeqMode]);
	~offSeqMode.valueAction_(~presets[index][\offSeqMode]);

	if (~presets[index][\off2SeqMode].notNil, {
		~off2SeqMode.valueAction_(~presets[index][\off2SeqMode]);
		~off3SeqMode.valueAction_(~presets[index][\off3SeqMode]);
		~off4SeqMode.valueAction_(~presets[index][\off4SeqMode]);
	});

	~ratSeqMode.valueAction_(~presets[index][\ratSeqMode]);
	~ampSeqMode.valueAction_(~presets[index][\ampSeqMode]);
	~strSeqMode.valueAction_(~presets[index][\strSeqMode]);
	~cenSeqMode.valueAction_(~presets[index][\cenSeqMode]);
	~panSeqMode.valueAction_(~presets[index][\panSeqMode]);
	~outLSeqMode.valueAction_(~presets[index][\outLSeqMode]);
	~outRSeqMode.valueAction_(~presets[index][\outRSeqMode]);
	~fxLSeqMode.valueAction_(~presets[index][\fxLSeqMode]);
	~fxRSeqMode.valueAction_(~presets[index][\fxRSeqMode]);
	~delSeqMode.valueAction_(~presets[index][\delSeqMode]);
	~rat2SeqMode.valueAction_(~presets[index][\rat2SeqMode]);
	~str2SeqMode.valueAction_(~presets[index][\str2SeqMode]);
	~cen2SeqMode.valueAction_(~presets[index][\cen2SeqMode]);


	~harTrigView.valueAction_(~presets[index][\harTrig]);

	// Multiples Miroir Chorus
	if (~presets[index][\harTrig].notNil, {
		if (~presets[index][\harTrig] == 1, {

			// ~harTrigView.valueAction_(~presets[index][\harTrig]);
			~harIndexView.valueAction_(~harNbSpec.unmap(~presets[index][\harIndex]));
			~outLHarSpatTypeView.valueAction_(~presets[index][\outLHarSpatType]);
			~outRHarSpatTypeView.valueAction_(~presets[index][\outRHarSpatType]);

			ratHarSeqSize = ~presets[index][\ratHar].size;
			ratHarSeqSpec = ControlSpec(0, ratHarSeqSize, \lin, 1, 1);
			ratHarSeqStep = 1 / ratHarSeqSize;

			~ratHar[~tracksValue][~seqsValue] = Array.newClear(~presets[index][\harIndex] /*~presets[index][\ratHar].size*/);
			~ratHarView.valueAction_(~presets[index][\ratHar]);
			~ratHarRangeView.valueAction_(~ratHarRangeSpec[~tracksValue][~seqsValue].unmap( [~presets[index][\ratHarMin], ~presets[index][\ratHarMax]] ));
			~ratHarSeqSpec[~tracksValue][~seqsValue] = ratHarSeqSpec;
			~ratHarSeqView.step_(ratHarSeqStep).minRange_(ratHarSeqStep).valueAction_(~ratHarSeqSpec[~tracksValue][~seqsValue].unmap( [~presets[index][\ratHarSeqStart], ~presets[index][\ratHarSeqStop]+1 ] ));
			~ratHarRoundView.valueAction_(~presets[index][\ratHarRoundView]);

			~cenHar[~tracksValue][~seqsValue] = Array.newClear(~presets[index][\harIndex]);
			~cenHarView.valueAction_(~presets[index][\cenHar]);
			~cenHarRangeView.valueAction_(~cenHarRangeSpec[~tracksValue][~seqsValue].unmap( [~presets[index][\cenHarMin], ~presets[index][\cenHarMax]] ));
			~cenHarSeqSpec[~tracksValue][~seqsValue] = ratHarSeqSpec;
			~cenHarSeqView.step_(ratHarSeqStep).minRange_(ratHarSeqStep).valueAction_(~cenHarSeqSpec[~tracksValue][~seqsValue].unmap( [~presets[index][\cenHarSeqStart], ~presets[index][\cenHarSeqStop]+1 ] ));
			~cenHarRoundView.valueAction_(~presets[index][\cenHarRoundView]);

			~delHar[~tracksValue][~seqsValue] = Array.newClear(~presets[index][\harIndex]);
			~delHarView.valueAction_(~presets[index][\delHar]);
			~delHarRangeView.valueAction_(~delHarRangeSpec[~tracksValue][~seqsValue].unmap( [~presets[index][\delHarMin], ~presets[index][\delHarMax]] ));
			~delHarSeqSpec[~tracksValue][~seqsValue] = ratHarSeqSpec;
			~delHarSeqView.step_(ratHarSeqStep).minRange_(ratHarSeqStep).valueAction_(~delHarSeqSpec[~tracksValue][~seqsValue].unmap( [~presets[index][\delHarSeqStart], ~presets[index][\delHarSeqStop]+1 ] ));
			~delHarRoundView.valueAction_(~presets[index][\delHarRoundView]);

			~spaHar[~tracksValue][~seqsValue] = Array.newClear(~presets[index][\spaHar].size /*~presets[index][\harIndex]*/); // ≠ des autres car initialisation de spa à part
			~spaHarView.valueAction_(~presets[index][\spaHar]);
			~spaHarRangeView.valueAction_(~spaHarRangeSpec[~tracksValue][~seqsValue].unmap( [~presets[index][\spaHarMin], ~presets[index][\spaHarMax]] ));
			~spaHarSeqSpec[~tracksValue][~seqsValue] = ControlSpec(0, ~presets[index][\spaHar].size, \lin, 1, 1); // A optimiser & ci-dessous aussi XXXXXXXXXXXXXXXXXXXXXXXX
			~spaHarSeqView.step_(1/~presets[index][\spaHar].size).minRange_(1/~presets[index][\spaHar].size).valueAction_(~spaHarSeqSpec[~tracksValue][~seqsValue].unmap( [~presets[index][\spaHarSeqStart], ~presets[index][\spaHarSeqStop]+1 ] ));

			~ampHar[~tracksValue][~seqsValue] = Array.newClear(~presets[index][\harIndex]);
			~ampHarView.valueAction_(~presets[index][\ampHar]);
			~ampHarSeqSpec[~tracksValue][~seqsValue] = ratHarSeqSpec;
			~ampHarSeqView.step_(ratHarSeqStep).minRange_(ratHarSeqStep).valueAction_(~ampHarSeqSpec[~tracksValue][~seqsValue].unmap( [~presets[index][\ampHarSeqStart], ~presets[index][\ampHarSeqStop]+1 ] ));
			~ampHarRoundView.valueAction_(~presets[index][\ampHarRoundView]);
		}/*,{
		~harTrigView.valueAction_(0);
		}*/);
	}/*,{
	~harTrigView.valueAction_(0);
	}*/);


	// vraiment necessaire puisque déjà chargé au global -> oui au cas où les ~prestTracks ne soient pas chargés...
	if (~presets[index][\bufSequence].notNil, {
		~bufSequence[~tracksValue][~seqsValue] = ~presets[index][\bufSequence];
		// (((~tracksValue/2).floor.asInteger+1) + "/" + /*~presetSeqStart*/ (~posSeq2[~tracksValue]+1) + "- BufSequence ->" + ~presets[index][\bufSequence]).postln
	});
	if (~presets[index][\presetNotes].notNil, {
		~presetNotes[~tracksValue][~seqsValue] = ~presets[index][\presetNotes];
	});


	// Données du mode des effets si E ou ES à la fin du preset
	if (~presets[index][\fxSynth] == 1 and: {~presetsDontTriggerFX == 0},
		{/*~fxSelect[sv]*/ ~presets[index][\fxSynthNum].do { |y, yi|

			case
			{ ~presets[index][\fxSynthNum][yi] > 0 and: {~presets[index][\fxSynthNum][yi] <= ~numFxSynthDef} }
			{ ~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['order'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].name ++ ~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxSynthData][yi][a]) };

				if (~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['orderM'].notNil, {
					~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['orderM'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].name ++ ~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['orderM'][i]).asSymbol] }.do { |atem, a| try {atem.valueAction_(~presets[index][\fxSynthDataM][yi][a]) } }
				});

			}

			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+1) }
			{ ~eqUnitLib[sv][0].setting = ~presets[index][\fxSynthData][yi] }

			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+2) }
			{ ~eqUnitLib[sv][1].setting = ~presets[index][\fxSynthData][yi] }

			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+3) }
			{ ~eqUnitLib[sv][2].setting = ~presets[index][\fxSynthData][yi] }

			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+4) }
			{
				// ~fftEQMagValues = ~presets[index][\fxSynthData][yi][0]; // Pourquoi ne marche pas alos que la ligne ci-dessous marche ???
				2.do { |i| ~fftEQMagValues[sv][i] = ~presets[index][\fxSynthData][yi][0][i].copy; ~fftEQBufsGet.(i, sv) };
				~fftEQSliderLagView[sv].valueAction_(~presets[index][\fxSynthData][yi][1]);
				~fftEQCompChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][2]);
				~fftEQBufChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][3]);
				~fftEQRoutRandView[sv].valueAction_(~presets[index][\fxSynthData][yi][4])
			}
			/* Données pour Spectral EQ
			~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\fxSynthData][2][0]
			[~fftEQMagValues,~fftEQSliderLag,~fftEQCompChoose,~fftEQBufChoose,~fftEQRoutRand]
			*/
			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+5) }
			{
				4.do { |i| ~fftDelfbValues[sv][i] = ~presets[index][\fxSynthData][yi][0][i].copy; ~fftDelBufsGet.(i, sv) };
				~fftDelSliderLagView[sv].valueAction_(~presets[index][\fxSynthData][yi][1]);
				~fftDelCompChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][2]);
				~fftDelBufChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][3]);
				~fftDelRoutRandView[sv].valueAction_(~presets[index][\fxSynthData][yi][4])
			}
			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+6) }
			{
				2.do { |i|
					~fftOutChannelValues[sv][i] = ~presets[index][\fxSynthData][yi][0][i].copy;
					~getBinChannelsPan2Outs.(~fftOutChannelValues[sv][i], i, sv); // fonction n'intègre pas d'update visuel à la différence des autres ci-dessus
					~fftOutPlotterView[sv][i].setValue(~fftOutChannelValues[sv][i], false)
				};
				~fftOutSliderLagView[sv].valueAction_(~presets[index][\fxSynthData][yi][1]);
				~fftOutCompChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][2]);
				~fftOutBufChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][3]);
				~fftOutRoutRandView[sv].valueAction_(~presets[index][\fxSynthData][yi][4])
			};

			// ~fxSelect.do { |i| i.postln } // ~fxSelect.postln;
			// ~fxSelect.do { |i| ~fxSelectView[i].valueAction_(~fxSelect[i]) }
			// ~fxSelectView[yi].valueAction_(~presets[index][\fxSynthNum][yi]); // n'évite pas le redéclenchement des effets

			/*
			if (~fxSelect[yi] != ~presets[index][\fxSynthNum][yi], {
			~fxSelectView[yi].valueAction_(~presets[index][\fxSynthNum][yi]); // permet d'éviter le redéclenchement du même effet
			{ ("Try to Wait" + ( ~fadeTimeSynthFx) ++ "s - end of FX Xfade !!!").warn; ~fadeTimeSynthFx.wait; "End of FX Xfade - OK to retrigger".inform }.fork;
			} );
			*/



			if (~fxSelect[sv][yi] != ~presets[index][\fxSynthNum][yi], {

				if (~fxXfadePlaying[sv][yi] == 0 and: {~fxXfadePlayingT[sv][yi].isPlaying == false}, {
					~fxSelectView[sv][yi].valueAction_(~presets[index][\fxSynthNum][yi]);
					{
						~fxXfadePlayingF.value(yi, sv);
						("FX Xfade begins - End in" + ( ~fadeTimeSynthFx[sv] /*/ ~toTempo*/) ++ "s !!!").warn; (~fadeTimeSynthFx[sv]+0.01).wait; "End of FX Xfade - OK to retrigger".inform;
						if (~fxXfadePlayingT[sv][yi].isPlaying == false, { ~fxXfadePlaying[sv][yi] = 0 } );
						// while ( { ~fxXfadePlaying[yi] == 1 }, { loop { if (~fxXfadePlayingT[yi].isPlaying == false, { ~fxXfadePlaying[yi] = 0 } ); 0.2.wait; ~fxXfadePlayingT[yi].isPlaying.postln; } } );
					}.fork;
				},{
					("Could not send FX of Preset" + (~seqSeq[~tab]+1)).postln;
				}); /*"ok".postln;*/ // permet d'éviter le redéclenchement du même effet et d'en déclencher un nouveau si le Xfade n'est pas fini
			});



			// if (~mixFXTrigger == 1, {~mixAllFxView.valueAction_(/*~mixAllFxViewSpec.unmap(*/~mixAllFx)/*.doAction*//*)*/ }); // retiré d'en bas pour permettre d'appliquer le mix, même lorsque de multiples FX en crossfade ont été déclenchés et d'en haut pour éviter de répéter 5x l'action et retrait du wait
		};
		// ~presetSelection[~tracksValue][~seqsValue].postln;

		if (~mixFXTrigger[sv] == 1, {~mixAllFxView[sv].valueAction_(/*~mixAllFxViewSpec.unmap(*/~mixAllFx[sv])/*.doAction*//*)*/ }); // retiré d'en bas pour permettre d'appliquer le mix, même lorsque de multiples FX en crossfade ont été déclenchés et d'en haut pour éviter de répéter 5x l'action et retrait du wait

		// Ajout pour les effets en série ou en parallèle
		/*~fxInSerieChoose*/
		/*
		~presets[index][\fxSynthSerPar].do { |y, yi|
		~fxInSerieChooseButtonView[yi].valueAction_(~presets[index][\fxSynthSerPar][yi] /* préférer y ??? */ );
		};*/



		~presets[index][\fxSynthSerPar].do { |y, yi| // seulement 4 données et non pas 5 comme ~fxSelect

			if (~fxInSerieChoose[sv][yi] != ~presets[index][\fxSynthSerPar][yi], {

				if (~fxXIOfadePlaying[sv][yi] == 0 and: {~fxXIOfadePlayingT[sv][yi].isPlaying == false}, {

					~fxInSerieChooseButtonView[sv][yi].valueAction_( ~presets[index][\fxSynthSerPar][yi] /* préférer y ??? */ );
					// ~presets[~presetSelection[0][~seqSeq[0]].asSymbol][\fxSynthSerPar]
					{
						~fxXIOfadePlayingF.value(yi, sv);
						("FX INOUT Xfade begins - End in" + ( ~fadeTimeSynthFx[sv].min(6) /*/ ~toTempo*/) ++ "s !!!").warn; (~fadeTimeSynthFx[sv].min(6)+0.01).wait; "End of FX INOUT Xfade - OK to retrigger".inform;
						if (~fxXIOfadePlayingT[sv][yi].isPlaying == false, { ~fxXIOfadePlaying[sv][yi] = 0 } );
					}.fork;
				},{
					("Could not send FX INOUT of Preset" + (~seqSeq[~tab]+1)).postln;
				});
			});
		};


		if (~fxInSerieChoose[sv].sum == 4, {
			~fxInSerieChooseAllButtonView[sv].value_(1); ~fxInSerieChoose2AllButtonView[sv].value_(1)
		}, {
			~fxInSerieChooseAllButtonView[sv].value_(0); ~fxInSerieChoose2AllButtonView[sv].value_(0);
		}); // juste pour indiquer que certains effets sont en parallèle
		// Mais PROBLEME car dès qu'il y en a un, celà l'indique pour tout le monde XXX
		// [1, 0, 0, 0 ].includes(1)

		// { "".postln; "Try to Wait end of FX Synth Xfade !!!".warn; ~fadeTimeSynthFx.wait; "End of FX Synth Xfade - OK to retrigger".inform }.fork;
	});


	// ~fxSynthDef[~fxSelect[0]-1].metadata['order'].size.collect { |i| ~fxSynthDefViews[(~fxSynthDef[~fxSelect[0]-1].name ++ ~fxSynthDef[~fxSelect[0]-1].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[~presetSelectionView.item.asSymbol][\fxSynthData][0][a]) };


	// Benchmark
	/*
	bench { 100000.do { ~fxInSerieChoose != #[ 0, 0, 0, 0, 0 ] } }
	bench { 100000.do { ~fxInSerieChoose.includes(1) } }
	*/

	// Remise des effets ambisoniques à 0 à chaque nouveau preset pour éviter qu'un effet ambisonique interagisse avec la séquence
	// Vérifier si OK en termes de CPU ??? -> voire ci-dessus
	if (~fxASelect[sv] != #[ 0, 0, 0, 0, 0 ] /*.sum > 0 OK*/ /*~fxASelect[sv].includes(1) pas bon*/, {
		~fxASelect[sv].do { |y, yi| ~fxASelectView[sv][yi].valueAction_(0) };
		// ~presets[~presetSelection[0][~seqSeq[0]].asSymbol][\fxASynthNum];
	});


	// Données du mode des effets ambisoniques si S à la fin du preset
	if (~presets[index][\fxASynth] == 1 and: {~presetsDontTriggerFX == 0},
		{/*~fxASelect[sv]*/ ~presets[index][\fxASynthNum].do { |y, yi| var numS, pres = ~presets[index][\fxASynthNum][yi]-1;
			case
			{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(1, ~numFxSynthDef5) }
			{ ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDefA[pres].name.asString[0..2] ++ pres.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
				~fxSynthDef5SwitchTypView[sv][pres].valueAction_(~presets[index][\fxASynthData][yi][1])
			}
			{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(~numFxSynthDef5-1, ~numFxSynthDef6Cum) }
			{ numS = pres-~numFxSynthDef5; ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDefA[pres].name.asString[0..2] ++ numS.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
				~fxSynthDef6SwitchTypView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][1])
			}
			{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(~numFxSynthDef6Cum-1, ~numFxSynthDef7Cum) }
			{ numS = pres-~numFxSynthDef6Cum; ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDefA[pres].name.asString[0..1] ++ numS.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
				~fxSynthDef7SwitchTypView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][1]);
				~fxSynthDef7SwitchTypPCView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][2])
			}
			{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(~numFxSynthDef7Cum-1, ~numFxSynthDefA) }
			{ numS = pres-~numFxSynthDef7Cum; ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDefA[pres].name.asString[0..4] ++ numS.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
				~fxSynthDef8SwitchTypView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][1]);
				~fxSynthDef8SwitchTypPCView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][2]);
				~fxSynthDef8SwitchRevView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][3])
			};

			// ~fxASelectView[yi].valueAction_(~presets[index][\fxASynthNum][yi]);
			if (~fxASelect[sv][yi] != ~presets[index][\fxASynthNum][yi], {
				~fxASelectView[sv][yi].valueAction_(~presets[index][\fxASynthNum][yi]); // permet d'éviter le redéclenchement du même effet
				{ "Try to Wait end of Amb Xfade !!!".warn; ~fadeTimeSynthFx[sv].wait; "End of Amb Xfade - OK to retrigger".inform }.fork;
			} );
		};

	});


	~fxActOnWhichView.valueAction_(previousfxActOnWhich); // Pour éviter que le fxL agisse sur le droit
	~outActOnWhichView.valueAction_(previousoutActOnWhich); // Pour éviter que le outL agisse sur le droit
	~outCompChooseView.valueAction_(previousoutCompChoose);

	// if (~mixFXTrigger == 1, {~mixAllFxView.valueAction_(/*~mixAllFxViewSpec.unmap(*/~mixAllFx)/*.doAction*//*)*/ });

});





// Nouvelle version avec des conditions pour modifier la GUI le cas échéant - mais apparemment problème de décalage dans les boucles ??????
/*(
~presetGetFunction = { | index |

/*
~presets = IdentityDictionary.new;
~presets.class;
~presets.keys;
~presets.keys.asArray[0]
~presets['test2'][\rtmView];
~presets[~presets.keys.asArray[0]].cs
~presets[~presets.keys.asArray[10]][\configBeatsView]

~presets[~presetSelectionView.item.asSymbol] // à utiliser à la place d'index pour obtenir la valeur du preset en cours
{~presetGetFunction.value(~presetSelectionView.item.asSymbol)}.bench;
{~presetGetFunction.value('40s| 200e| DR Dev Cwej RD| TA Cwej_PSGlisA_X')}.bench;

{~presetSetFunction.value('test1')}.bench
{~presetSetFunction2.value('test2')}.bench // apparemment aucun impact par rapport au nombre de données dans le multislider contrairement au bench précédent - + rapide que le bench 1

{~presetGetFunction.value('test1')}.bench
{~presetGetFunction2.value('test2')}.bench // très légère meilleure performance par rapport à l'array (pratiquement imperceptible)

~presetGetFunction.value('test1')
~presetGetFunction2.value('test2')
*/


// Utilisation seulement du ~dur car la nb d'éléments dans toutes les séquences est le même
var rtmSeqSize = ~presets[index][\rtmView].size;
var rtmThumbSize = max(333 / rtmSeqSize, ~readViewThumbSize);
var rtmSeqStep = 1 / rtmSeqSize;
var rtmSeqSpec = ControlSpec(0, rtmSeqSize, \lin, 1, 1);
var rtmSeqVSpec = ControlSpec(0, rtmSeqSize-1, \lin, 1, 1);

var previousfxActOnWhich = ~fxActOnWhich; // Pour éviter que le fxL agisse sur le droit
var previousoutActOnWhich = ~outActOnWhich; // Pour éviter que le outL agisse sur le droit
var previousoutCompChoose = ~outCompChoose;

// Protection mulSlider - Mise en place d'une sécurité avec une multiplication selon le timeOnset
// peut déclencher des lates -> peut-être multiplier par 2 encore ???
var timeOnset = (~presets[index][\nbTotalBeats] / ~toTempo) / /*~seqDurRtm*/ rtmSeqSize/*.postln*/;
~rtmMulSpec = ControlSpec(timeOnset * (20 / (timeOnset / 0.01).squared), 10, 4, 0.001, 1);
// ~rtmMulSpec.postln;
// Pourquoi le postln; est déclenché 2x avec changement de rythme -> fonction duration2show
// Pourquoi le postln; est déclenché 2x avec changement de preset -> fonction getPreset
/*
-> 0.0025 * 0.8 -> * 320 // Quand l'un augmente de x2, l'autre est /4
-> 0.005 * 0.4 -> * 80
-> 0.01 * 0.2 -> * 20
-> 0.02 * 0.1 -> * 5
-> 0.04 * 0.05 -> * 1.25
x = 0.5; x * (20 / (x / 0.01).squared)
x = (~nbTotalBeats[~tracksValue][~seqsValue] / ~toTempo) / /*~seqDurRtm*/~dur[~tracksValue][~seqsValue].size; x * (20 / (x / 0.01).squared)
*/

~fxActOnWhichView.valueAction_(0); // Pour éviter que le fxL agisse sur le droit
~outActOnWhichView.valueAction_(0); // Pour éviter que le outL agisse sur le droit


// Données rythmiques 7
// Changement de place en début afin que le rtyhme (\nbTotalBeats) soit respecté quand changement de preset avec des durées de Beats différents
// Lors d'un nouveau fichier de preset garder seulement \configBeatsView (\configBeatsValue conservé pour ne pas refaire le fichier de preset
~configBeatsView.valueAction_(~presets[index][\configBeatsView]);
~nbTotalBeatsView.valueAction_(~nbTotalBeatsSpec.unmap(~presets[index][\nbTotalBeats]));
~displayRhythm[~tracksValue][~seqsValue] = ~presets[index][\displayRhythm]; // nécessaire afin de ne pas changer le ~displayRhythm quand fait play sur la séquence
~displayRhythmView.string_(~presets[index][\displayRhythm]);
// ~displayRhythmView.string_(~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\displayRhythm])
6.do { |i|
// if (~presets[index][\selectBeatView][i].notNil, { ~selectBeatValue[track][seq][i] = ~presets[index][\selectBeatView][i] });
// voir lequel est le plus justifié .notNil ou != 0 ?????? pour optimisation ??????
if (~presets[index][\selectBeatView][i].notNil and: {~presets[index][\selectBeatView][i] != 0}, { ~selectBeatView[i].value_(~presets[index][\selectBeatView][i]) });
~pBeatView[i].valueAction_(~presets[index][\pBeat][i]);
~nbBeatView[i].valueAction_(~presets[index][\nbBeat][i]);
~sumBeatView[i].valueAction_(~presets[index][\sumBeat][i]);
~minSumBeatView[i].valueAction_(~presets[index][\minSumBeat][i])
};


// Données du Round 4
// seulement une protection sur le ~bufFolderView
// si le nb de données dans le RoundView PopUpMenu a changé par rapport au preset précédemment sauvegardé
// et donc déclenchement d'une erreur qui empêche de lire la suite des données
// pas de protection si le nb de données dans le RoundView PopUpMenu a changé par rapport au preset précédemment sauvegardé et donc déclenchement d'une erreur qui empêche de lire la suite des données
if (~rtmRoundView.value != ~presets[index][\rtmRoundView], { ~rtmRoundView.valueAction_(~presets[index][\rtmRoundView]) });
if (~proRoundView.value != ~presets[index][\proRoundView], { ~proRoundView.valueAction_(~presets[index][\proRoundView]) });
if (~legRoundView.value != ~presets[index][\legRoundView], { ~legRoundView.valueAction_(~presets[index][\legRoundView]) });
// ~bufFolderView.valueAction_(~presets[index][\bufFolderView]);
if (~presets[index][\bufFolderView] < ~bufFolderView.items.size, {~bufFolderView.valueAction_(~presets[index][\bufFolderView])});
if (~offRoundView.value != ~presets[index][\offRoundView], { ~offRoundView.valueAction_(~presets[index][\offRoundView]) });
if (~ratRoundView.value != ~presets[index][\ratRoundView], { ~ratRoundView.valueAction_(~presets[index][\ratRoundView]) });
if (~ampRoundView.value != ~presets[index][\ampRoundView], { ~ampRoundView.valueAction_(~presets[index][\ampRoundView]) });
if (~strRoundView.value != ~presets[index][\strRoundView], { ~strRoundView.valueAction_(~presets[index][\strRoundView]) });
if (~cenRoundView.value != ~presets[index][\cenRoundView], { ~cenRoundView.valueAction_(~presets[index][\cenRoundView]) });
if (~panRoundView.value != ~presets[index][\panRoundView], { ~panRoundView.valueAction_(~presets[index][\panRoundView]) });
if (~delRoundView.value != ~presets[index][\delRoundView], { ~delRoundView.valueAction_(~presets[index][\delRoundView]) });
if (~rat2RoundView.value != ~presets[index][\rat2RoundView], { ~rat2RoundView.valueAction_(~presets[index][\rat2RoundView]) });
if (~str2RoundView.value != ~presets[index][\str2RoundView], { ~str2RoundView.valueAction_(~presets[index][\str2RoundView]) });
if (~cen2RoundView.value != ~presets[index][\cen2RoundView], { ~cen2RoundView.valueAction_(~presets[index][\cen2RoundView]) });

/*
{ 100.do {~cenRoundView.valueAction_(~presets[~presetSelectionView.item.asSymbol][\cenRoundView])}}.bench;
// Pourquoi la ligne ci-dessous génère moins de CPU en toutes circonstances, même quand la valeur est différente ??? - A appliquer sur toutes les valeurs qui ne changent pas souvent
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
{ 100.do {if (~cenRoundView.value != ~presets[~presetSelectionView.item.asSymbol][\cenRoundView], { ~cenRoundView.valueAction_(~presets[~presetSelectionView.item.asSymbol][\cenRoundView]) }); }}.bench;
*/

/* // Protection sur tous les PopUpMenus
if (~presets[index][\rtmRoundView] < ~rtmRoundView.items.size, {~rtmRoundView.valueAction_(~presets[index][\rtmRoundView])});
if (~presets[index][\proRoundView] < ~proRoundView.items.size, {~proRoundView.valueAction_(~presets[index][\proRoundView])});
if (~presets[index][\legRoundView] < ~legRoundView.items.size, {~legRoundView.valueAction_(~presets[index][\legRoundView])});
if (~presets[index][\bufFolderView] < ~bufFolderView.items.size, {~bufFolderView.valueAction_(~presets[index][\bufFolderView])});
if (~presets[index][\offRoundView] < ~offRoundView.items.size, {~offRoundView.valueAction_(~presets[index][\offRoundView])});
if (~presets[index][\ratRoundView] < ~ratRoundView.items.size, {~ratRoundView.valueAction_(~presets[index][\ratRoundView])});
if (~presets[index][\ampRoundView] < ~ampRoundView.items.size, {~ampRoundView.valueAction_(~presets[index][\ampRoundView])});
if (~presets[index][\strRoundView] < ~strRoundView.items.size, {~strRoundView.valueAction_(~presets[index][\strRoundView])});
if (~presets[index][\cenRoundView] < ~cenRoundView.items.size, {~cenRoundView.valueAction_(~presets[index][\cenRoundView])});
if (~presets[index][\panRoundView] < ~panRoundView.items.size, {~panRoundView.valueAction_(~presets[index][\panRoundView])});
*/


// Données Mappées du RangeSlider 1
~rtmRangeView.valueAction_(~rtmRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\rtmMin], ~presets[index][\rtmMax]]));
~proRangeView.valueAction_(~proRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\proMin], ~presets[index][\proMax]]));
~synRangeView.valueAction_(~synRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\synMin], ~presets[index][\synMax]]));
~spaRangeView.valueAction_(~spaRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\spaMin], ~presets[index][\spaMax]]));
~legRangeView.valueAction_(~legRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\legMin], ~presets[index][\legMax]]));
~envRangeView.valueAction_(~envRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\envMin], ~presets[index][\envMax]]));
~bufRangeView.valueAction_(~bufRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\bufMin], ~presets[index][\bufMax]]));
~offRangeView.valueAction_(~offRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\offMin], ~presets[index][\offMax]]));
~ratRangeView.valueAction_(~ratRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\ratMin], ~presets[index][\ratMax]]));
~ampRangeView.valueAction_(~ampRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\ampMin], ~presets[index][\ampMax]]));
~strRangeView.valueAction_(~strRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\strMin], ~presets[index][\strMax]]));
~cenRangeView.valueAction_(~cenRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\cenMin], ~presets[index][\cenMax]]));
~panRangeView.valueAction_(~panRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\panMin], ~presets[index][\panMax]]));
~outRRangeView.valueAction_(~outRRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\outRMin], ~presets[index][\outRMax]]));
~outLRangeView.valueAction_(~outLRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\outLMin], ~presets[index][\outLMax]]));
~fxRRangeView.valueAction_(~fxRRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\fxRMin], ~presets[index][\fxRMax]]));
~fxLRangeView.valueAction_(~fxLRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\fxLMin], ~presets[index][\fxLMax]]));
~delRangeView.valueAction_(~delRangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\delMin], ~presets[index][\delMax]]));
~rat2RangeView.valueAction_(~rat2RangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\rat2Min], ~presets[index][\rat2Max]]));
~str2RangeView.valueAction_(~str2RangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\str2Min], ~presets[index][\str2Max]]));
~cen2RangeView.valueAction_(~cen2RangeSpec[~tracksValue][~seqsValue].unmap([~presets[index][\cen2Min], ~presets[index][\cen2Max]]));

// Données Brutes du RangeSlider 1
/*~rtmRangeView.valueAction_(~presets[index][\rtmRangeView]);
~proRangeView.valueAction_(~presets[index][\proRangeView]);
~synRangeView.valueAction_(~presets[index][\synRangeView]);
~spaRangeView.valueAction_(~presets[index][\spaRangeView]);
~legRangeView.valueAction_(~presets[index][\legRangeView]);
~envRangeView.valueAction_(~presets[index][\envRangeView]);
~bufRangeView.valueAction_(~presets[index][\bufRangeView]);
~offRangeView.valueAction_(~presets[index][\offRangeView]);
~ratRangeView.valueAction_(~presets[index][\ratRangeView]);
~ampRangeView.valueAction_(~presets[index][\ampRangeView]);
~strRangeView.valueAction_(~presets[index][\strRangeView]);
~cenRangeView.valueAction_(~presets[index][\cenRangeView]);
~panRangeView.valueAction_(~presets[index][\panRangeView]);
~outLRangeView.valueAction_(~presets[index][\outLRangeView]);
~outRRangeView.valueAction_(~presets[index][\outRRangeView]);
~fxLRangeView.valueAction_(~presets[index][\fxLRangeView]);
~fxRRangeView.valueAction_(~presets[index][\fxRRangeView]);*/


/*
To check the way of not changing the object

{ 1000.do{~dur[~tracksValue][~seqsValue] = 0 ! 200;}}.bench
{ 1000.do{~dur[~tracksValue][~seqsValue] = Array.new(200);}}.bench
{ 1000.do{~dur[~tracksValue][~seqsValue] = Array.newClear(200);}}.bench
{ 1000.do{~dur[~tracksValue][~seqsValue] = SparseArray.newClear(200);}}.bench
{ 1000.do{~dur[~tracksValue][~seqsValue] = Array.new(200);}}.bench

{ 1000.do{~rat[~tracksValue][~seqsValue] = Array.new(80);}}.bench
~rat[~tracksValue][~seqsValue] = Array.new(80);
~rat[~tracksValue][~seqsValue] = 0 ! 20;
~rat[~tracksValue][~seqsValue].maxSize
*/

// Données du Multislider 0
// ou utilisation de la méthode maxSize de l'array -> Return the maximum number of elements the ArrayedCollection can hold ???
// Pour éviter de créer une nouvelle instance
// requiert beaucoup de temps -> 0.005 pour chaque élément si 200 / sinon 0.001 pour 4
/*if (~dur[~tracksValue][~seqsValue] != ~presets[index][\rtmView], { ~dur[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~rtmView.valueAction_(~presets[index][\rtmView]) });
if (~pro[~tracksValue][~seqsValue] != ~presets[index][\proView], { ~pro[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~proView.valueAction_(~presets[index][\proView]) });
if (~syn[~tracksValue][~seqsValue] != ~presets[index][\synView], { ~syn[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~synView.valueAction_(~presets[index][\synView]) });
if (~spa[~tracksValue][~seqsValue] != ~presets[index][\spaView], { ~spa[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~spaView.valueAction_(~presets[index][\spaView]) });
if (~leg[~tracksValue][~seqsValue] != ~presets[index][\legView], { ~leg[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~legView.valueAction_(~presets[index][\legView]) });
if (~env[~tracksValue][~seqsValue] != ~presets[index][\envView], { ~env[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~envView.valueAction_(~presets[index][\envView]) });
if (~buf[~tracksValue][~seqsValue] != ~presets[index][\bufView], { ~buf[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~bufView.valueAction_(~presets[index][\bufView]) });
if (~off[~tracksValue][~seqsValue] != ~presets[index][\offView], { ~off[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~offView.valueAction_(~presets[index][\offView]) });
if (~rat[~tracksValue][~seqsValue] != ~presets[index][\ratView], { ~rat[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~ratView.valueAction_(~presets[index][\ratView]) });
if (~amp[~tracksValue][~seqsValue] != ~presets[index][\ampView], { ~amp[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~ampView.valueAction_(~presets[index][\ampView]) });
if (~str[~tracksValue][~seqsValue] != ~presets[index][\strView], { ~str[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~strView.valueAction_(~presets[index][\strView]) });
if (~cen[~tracksValue][~seqsValue] != ~presets[index][\cenView], { ~cen[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~cenView.valueAction_(~presets[index][\cenView]) });
if (~pan[~tracksValue][~seqsValue] != ~presets[index][\panView], { ~pan[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~panView.valueAction_(~presets[index][\panView]) });
if (~outL[~tracksValue][~seqsValue] != ~presets[index][\outLView], { ~outL[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~outLView.valueAction_(~presets[index][\outLView]) });
if (~outR[~tracksValue][~seqsValue] != ~presets[index][\outRView], { ~outR[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~outRView.valueAction_(~presets[index][\outRView]) });
if (~fxL[~tracksValue][~seqsValue] != ~presets[index][\fxLView], { ~fxL[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~fxLView.valueAction_(~presets[index][\fxLView]) });
if (~fxR[~tracksValue][~seqsValue] != ~presets[index][\fxRView], { ~fxR[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~fxRView.valueAction_(~presets[index][\fxRView]) });
if (~del[~tracksValue][~seqsValue] != ~presets[index][\delView], { ~del[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~delView.valueAction_(~presets[index][\delView]) });
if (~rat2[~tracksValue][~seqsValue] != ~presets[index][\rat2View], { ~rat2[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~rat2View.valueAction_(~presets[index][\rat2View]) });
if (~str2[~tracksValue][~seqsValue] != ~presets[index][\str2View], { ~str2[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~str2View.valueAction_(~presets[index][\str2View]) });
if (~cen2[~tracksValue][~seqsValue] != ~presets[index][\cen2View], { ~cen2[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~cen2View.valueAction_(~presets[index][\cen2View]) });*/

// Condition ci-dessus n'est pas terrible -> doublons ~presets[index][\proView] ou ~dur[~tracksValue][~seqsValue]
~dur[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~rtmView.valueAction_(~presets[index][\rtmView]);
~pro[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~proView.valueAction_(~presets[index][\proView]);
~syn[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~synView.valueAction_(~presets[index][\synView]);
~spa[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~spaView.valueAction_(~presets[index][\spaView]);
~leg[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~legView.valueAction_(~presets[index][\legView]);
~env[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~envView.valueAction_(~presets[index][\envView]);
~buf[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~bufView.valueAction_(~presets[index][\bufView]);
~off[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~offView.valueAction_(~presets[index][\offView]);
~rat[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~ratView.valueAction_(~presets[index][\ratView]);
~amp[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~ampView.valueAction_(~presets[index][\ampView]);
~str[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~strView.valueAction_(~presets[index][\strView]);
~cen[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~cenView.valueAction_(~presets[index][\cenView]);
~pan[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~panView.valueAction_(~presets[index][\panView]);
~outL[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~outLView.valueAction_(~presets[index][\outLView]);
~outR[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~outRView.valueAction_(~presets[index][\outRView]);
~fxL[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~fxLView.valueAction_(~presets[index][\fxLView]);
~fxR[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~fxRView.valueAction_(~presets[index][\fxRView]);
~del[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~delView.valueAction_(~presets[index][\delView]);
~rat2[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~rat2View.valueAction_(~presets[index][\rat2View]);
~str2[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~str2View.valueAction_(~presets[index][\str2View]);
~cen2[~tracksValue][~seqsValue] = Array.newClear(rtmSeqSize); ~cen2View.valueAction_(~presets[index][\cen2View]);


// Changement du SeqRangeSpec - Utilité d'avoir des SeqSpec différents pour chaque module ???
// Pourquoi garder pour ~gblSeqIndexSpec un controlSpec identique au précédent ???
~gblSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~gblSeqIndexSpec[~tracksValue][~seqsValue] = rtmSeqSpec; // Pourquoi garder un controlSpec identique au précédent ???
~rtmSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~proSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~synSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~spaSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~legSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~envSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~bufSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~offSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~ratSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~ampSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~strSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~cenSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~panSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~outLSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~outRSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~fxLSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~fxRSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~delSeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~rat2SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~str2SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~cen2SeqSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
// Pourquoi ligne dessous ne peut remplacer ce qu'il y a dessus ??? -> car ne prend pas l'objet mais la valeur
/*[~gblSeqSpec[~tracksValue][~seqsValue], ~gblSeqIndexSpec[~tracksValue][~seqsValue], ~rtmSeqSpec[~tracksValue][~seqsValue], ~proSeqSpec[~tracksValue][~seqsValue], ~synSeqSpec[~tracksValue][~seqsValue], ~spaSeqSpec[~tracksValue][~seqsValue], ~legSeqSpec[~tracksValue][~seqsValue], ~envSeqSpec[~tracksValue][~seqsValue], ~bufSeqSpec[~tracksValue][~seqsValue], ~offSeqSpec[~tracksValue][~seqsValue], ~ratSeqSpec[~tracksValue][~seqsValue], ~ampSeqSpec[~tracksValue][~seqsValue], ~strSeqSpec[~tracksValue][~seqsValue], ~cenSeqSpec[~tracksValue][~seqsValue], ~panSeqSpec[~tracksValue][~seqsValue], ~outLSeqSpec[~tracksValue][~seqsValue], ~outRSeqSpec[~tracksValue][~seqsValue], ~fxLSeqSpec[~tracksValue][~seqsValue], ~fxRSeqSpec[~tracksValue][~seqsValue]].collect{ |i| i = rtmSeqSpec };*/

~rtmSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~proSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~synSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~spaSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~legSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~envSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~bufSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~offSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~ratSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~ampSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~strSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~cenSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~panSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~outLSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~outRSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~fxLSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~fxRSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~delSeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~rat2SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~str2SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
~cen2SeqVSpec[~tracksValue][~seqsValue] = rtmSeqVSpec;
// Pourquoi ligne dessous ne peut remplacer ce qu'il y a dessus ??? -> car ne prend pas l'objet mais la valeur
/*[~rtmSeqVSpec[~tracksValue][~seqsValue], ~proSeqVSpec[~tracksValue][~seqsValue], ~synSeqVSpec[~tracksValue][~seqsValue], ~spaSeqVSpec[~tracksValue][~seqsValue], ~legSeqVSpec[~tracksValue][~seqsValue], ~envSeqVSpec[~tracksValue][~seqsValue], ~bufSeqVSpec[~tracksValue][~seqsValue], ~offSeqVSpec[~tracksValue][~seqsValue], ~ratSeqVSpec[~tracksValue][~seqsValue], ~ampSeqVSpec[~tracksValue][~seqsValue], ~strSeqVSpec[~tracksValue][~seqsValue], ~cenSeqVSpec[~tracksValue][~seqsValue], ~panSeqVSpec[~tracksValue][~seqsValue], ~outLSeqVSpec[~tracksValue][~seqsValue], ~outRSeqVSpec[~tracksValue][~seqsValue], ~fxLSeqVSpec[~tracksValue][~seqsValue], ~fxRSeqVSpec[~tracksValue][~seqsValue]].do{ |i| i = rtmSeqVSpec };*/

// ~bufSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurBuf[~tracksValue][~seqsValue], \lin, 1, 1); // Pour le Slider ~bufReadView

if (rtmThumbSize != ~rtmThumbSizeValue[~tracksValue][~seqsValue], {
~rtmThumbSizeValue[~tracksValue][~seqsValue] = rtmThumbSize; // Pour modif du ThumbSize du ReadViewSlider dans le Tab Global XXX
[~rtmReadView, ~proReadView, ~synReadView, ~spaReadView, ~legReadView, ~envReadView, ~bufReadView, ~ampReadView, ~ratReadView, ~rat2ReadView, ~offReadView, ~strReadView, ~str2ReadView, ~cenReadView, ~cen2ReadView, ~panReadView, ~delReadView, ~outLReadView, ~outRReadView, ~fxLReadView, ~fxRReadView].do{ |i| i.thumbSize_(rtmThumbSize) };
});

// Données du SeqRangeSlider 2 mappées
~gblSeqIndexView.step_(rtmSeqStep).value_(~gblSeqIndexSpec[~tracksValue][~seqsValue].unmap(~presets[index][\gblSeqIndex])).doAction;
~gblSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).value_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\gblSeqStart], ~presets[index][\gblSeqStop]+1])).doAction;
// Le .doAction doit être changé car délenche les autres seqsView

~rtmSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~rtmSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\rtmSeqStart], ~presets[index][\rtmSeqStop]+1]));
~proSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~proSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\proSeqStart], ~presets[index][\proSeqStop]+1]));
~synSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~synSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\synSeqStart], ~presets[index][\synSeqStop]+1]));
~spaSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~spaSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\spaSeqStart], ~presets[index][\spaSeqStop]+1]));
~legSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~legSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\legSeqStart], ~presets[index][\legSeqStop]+1]));
~envSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~envSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\envSeqStart], ~presets[index][\envSeqStop]+1]));
~bufSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~bufSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\bufSeqStart], ~presets[index][\bufSeqStop]+1]));
~offSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~offSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\offSeqStart], ~presets[index][\offSeqStop]+1]));
~ratSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~ratSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\ratSeqStart], ~presets[index][\ratSeqStop]+1]));
~ampSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~ampSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\ampSeqStart], ~presets[index][\ampSeqStop]+1]));
~strSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~strSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\strSeqStart], ~presets[index][\strSeqStop]+1]));
~cenSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~cenSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\cenSeqStart], ~presets[index][\cenSeqStop]+1]));
~panSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~panSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\panSeqStart], ~presets[index][\panSeqStop]+1]));
~outLSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~outLSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\outLSeqStart], ~presets[index][\outLSeqStop]+1]));
~outRSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~outRSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\outRSeqStart], ~presets[index][\outRSeqStop]+1]));
~fxLSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~fxLSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\fxLSeqStart], ~presets[index][\fxLSeqStop]+1]));
~fxRSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~fxRSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\fxRSeqStart], ~presets[index][\fxRSeqStop]+1]));
~delSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~delSeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\delSeqStart], ~presets[index][\delSeqStop]+1]));
~rat2SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~rat2SeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\rat2SeqStart], ~presets[index][\rat2SeqStop]+1]));
~str2SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~str2SeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\str2SeqStart], ~presets[index][\str2SeqStop]+1]));
~cen2SeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~cen2SeqSpec[~tracksValue][~seqsValue].unmap([~presets[index][\cen2SeqStart], ~presets[index][\cen2SeqStop]+1]));

// Données Brutes du SeqRangeSlider 2
/*~gblSeqIndexView.step_(rtmSeqStep).value_(~presets[index][\gblSeqIndexView]).doAction;
~gblSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).value_(~presets[index][\gblSeqView]).doAction;

~rtmSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\rtmSeqView]);
~proSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\proSeqView]);
~synSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\synSeqView]);
~spaSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\spaSeqView]);
~legSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\legSeqView]);
~envSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\envSeqView]);
~bufSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\bufSeqView]);
~offSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\offSeqView]);
~ratSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\ratSeqView]);
~ampSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\ampSeqView]);
~strSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\strSeqView]);
~cenSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\cenSeqView]);
~panSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\panSeqView]);
~outLSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\outLSeqView]);
~outRSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\outRSeqView]);
~fxLSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\fxLSeqView]);
~fxRSeqView.step_(rtmSeqStep).minRange_(rtmSeqStep).valueAction_(~presets[index][\fxRSeqView]);*/


// Données Mappées du MulSlider 3
~rtmMulView.valueAction_(~rtmMulSpec.unmap(~presets[index][\rtmMul]));
// ~proMulView.valueAction_(~proMulSpec.unmap(~presets[index][\proMul]));
if (~proMulView.value != ~presets[index][\proMul], { ~proMulView.valueAction_(~proMulSpec.unmap(~presets[index][\proMul])) });
if (~synMulView.value != ~presets[index][\synMul], { ~synMulView.valueAction_(~synMulSpec.unmap(~presets[index][\synMul])) });
if (~spaMulView.value != ~presets[index][\spaMul], { ~spaMulView.valueAction_(~spaMulSpec.unmap(~presets[index][\spaMul])) });
~legMulView.valueAction_(~legMulSpec.unmap(~presets[index][\legMul]));
if (~envMulView.value != ~presets[index][\envMul], { ~envMulView.valueAction_(~envMulSpec.unmap(~presets[index][\envMul])) });
~bufMulView.valueAction_(~bufMulSpec.unmap(~presets[index][\bufMul]));
if (~offMulView.value != ~presets[index][\offMul], { ~offMulView.valueAction_(~offMulSpec.unmap(~presets[index][\offMul])) });
~ratMulView.valueAction_(~ratMulSpec.unmap(~presets[index][\ratMul]));
~ampMulView.valueAction_(~ampMulSpec.unmap(~presets[index][\ampMul]));
~strMulView.valueAction_(~strMulSpec.unmap(~presets[index][\strMul]));
~cenMulView.valueAction_(~cenMulSpec.unmap(~presets[index][\cenMul]));
if (~panMulView.value != ~presets[index][\panMul], { ~panMulView.valueAction_(~panMulSpec.unmap(~presets[index][\panMul])) });
if (~outLMulView.value != ~presets[index][\outLMul], { ~outLMulView.valueAction_(~outLMulSpec.unmap(~presets[index][\outLMul])) });
if (~outRMulView.value != ~presets[index][\outRMul], { ~outRMulView.valueAction_(~outRMulSpec.unmap(~presets[index][\outRMul])) });
if (~fxLMulView.value != ~presets[index][\fxLMul], { ~fxLMulView.valueAction_(~fxLMulSpec.unmap(~presets[index][\fxLMul])) });
if (~fxRMulView.value != ~presets[index][\fxRMul], { ~fxRMulView.valueAction_(~fxRMulSpec.unmap(~presets[index][\fxRMul])) });
if (~delMulView.value != ~presets[index][\delMul], { ~delMulView.valueAction_(~delMulSpec.unmap(~presets[index][\delMul])) });
~rat2MulView.valueAction_(~rat2MulSpec.unmap(~presets[index][\rat2Mul]));
~str2MulView.valueAction_(~str2MulSpec.unmap(~presets[index][\str2Mul]));
~cen2MulView.valueAction_(~cen2MulSpec.unmap(~presets[index][\cen2Mul]));

// Données Brutes du MulSlider 3
/*~rtmMulView.valueAction_(~presets[index][\rtmMulView]);
~proMulView.valueAction_(~presets[index][\proMulView]);
~synMulView.valueAction_(~presets[index][\synMulView]);
~spaMulView.valueAction_(~presets[index][\spaMulView]);
~legMulView.valueAction_(~presets[index][\legMulView]);
~envMulView.valueAction_(~presets[index][\envMulView]);
~bufMulView.valueAction_(~presets[index][\bufMulView]);
~offMulView.valueAction_(~presets[index][\offMulView]);
~ratMulView.valueAction_(~presets[index][\ratMulView]);
~ampMulView.valueAction_(~presets[index][\ampMulView]);
~strMulView.valueAction_(~presets[index][\strMulView]);
~cenMulView.valueAction_(~presets[index][\cenMulView]);
~panMulView.valueAction_(~presets[index][\panMulView]);
~outLMulView.valueAction_(~presets[index][\outLMulView]);
~outRMulView.valueAction_(~presets[index][\outRMulView]);
~fxLMulView.valueAction_(~presets[index][\fxLMulView]);
~fxRMulView.valueAction_(~presets[index][\fxRMulView]);*/


// Données du Pattern 5
if (~rtmDirView.value != ~presets[index][\rtmDirView], { ~rtmDirView.valueAction_(~presets[index][\rtmDirView]) });
if (~proDirView.value != ~presets[index][\proDirView], { ~proDirView.valueAction_(~presets[index][\proDirView]) });
if (~synDirView.value != ~presets[index][\synDirView], { ~synDirView.valueAction_(~presets[index][\synDirView]) });
if (~spaDirView.value != ~presets[index][\spaDirView], { ~spaDirView.valueAction_(~presets[index][\spaDirView]) });
if (~legDirView.value != ~presets[index][\legDirView], { ~legDirView.valueAction_(~presets[index][\legDirView]) });
if (~envDirView.value != ~presets[index][\envDirView], { ~envDirView.valueAction_(~presets[index][\envDirView]) });
if (~bufDirView.value != ~presets[index][\bufDirView], { ~bufDirView.valueAction_(~presets[index][\bufDirView]) });
if (~offDirView.value != ~presets[index][\offDirView], { ~offDirView.valueAction_(~presets[index][\offDirView]) });
if (~ratDirView.value != ~presets[index][\ratDirView], { ~ratDirView.valueAction_(~presets[index][\ratDirView]) });
if (~ampDirView.value != ~presets[index][\ampDirView], { ~ampDirView.valueAction_(~presets[index][\ampDirView]) });
if (~strDirView.value != ~presets[index][\strDirView], { ~strDirView.valueAction_(~presets[index][\strDirView]) });
if (~cenDirView.value != ~presets[index][\cenDirView], { ~cenDirView.valueAction_(~presets[index][\cenDirView]) });
if (~panDirView.value != ~presets[index][\panDirView], { ~panDirView.valueAction_(~presets[index][\panDirView]) });
if (~outLDirView.value != ~presets[index][\outLDirView], { ~outLDirView.valueAction_(~presets[index][\outLDirView]) });
if (~outRDirView.value != ~presets[index][\outRDirView], { ~outRDirView.valueAction_(~presets[index][\outRDirView]) });
if (~fxLDirView.value != ~presets[index][\fxLDirView], { ~fxLDirView.valueAction_(~presets[index][\fxLDirView]) });
if (~fxRDirView.value != ~presets[index][\fxRDirView], { ~fxRDirView.valueAction_(~presets[index][\fxRDirView]) });
if (~delDirView.value != ~presets[index][\delDirView], { ~delDirView.valueAction_(~presets[index][\delDirView]) });
if (~rat2DirView.value != ~presets[index][\rat2DirView], { ~rat2DirView.valueAction_(~presets[index][\rat2DirView]) });
if (~str2DirView.value != ~presets[index][\str2DirView], { ~str2DirView.valueAction_(~presets[index][\str2DirView]) });
if (~cen2DirView.value != ~presets[index][\cen2DirView], { ~cen2DirView.valueAction_(~presets[index][\cen2DirView]) });

if (~rtmPatView.value != ~presets[index][\rtmPatView], { ~rtmPatView.valueAction_(~presets[index][\rtmPatView]) });
if (~proPatView.value != ~presets[index][\proPatView], { ~proPatView.valueAction_(~presets[index][\proPatView]) });
if (~synPatView.value != ~presets[index][\synPatView], { ~synPatView.valueAction_(~presets[index][\synPatView]) });
if (~spaPatView.value != ~presets[index][\spaPatView], { ~spaPatView.valueAction_(~presets[index][\spaPatView]) });
if (~legPatView.value != ~presets[index][\legPatView], { ~legPatView.valueAction_(~presets[index][\legPatView]) });
if (~envPatView.value != ~presets[index][\envPatView], { ~envPatView.valueAction_(~presets[index][\envPatView]) });
if (~bufPatView.value != ~presets[index][\bufPatView], { ~bufPatView.valueAction_(~presets[index][\bufPatView]) });
if (~offPatView.value != ~presets[index][\offPatView], { ~offPatView.valueAction_(~presets[index][\offPatView]) });
if (~ratPatView.value != ~presets[index][\ratPatView], { ~ratPatView.valueAction_(~presets[index][\ratPatView]) });
if (~ampPatView.value != ~presets[index][\ampPatView], { ~ampPatView.valueAction_(~presets[index][\ampPatView]) });
if (~strPatView.value != ~presets[index][\strPatView], { ~strPatView.valueAction_(~presets[index][\strPatView]) });
if (~cenPatView.value != ~presets[index][\cenPatView], { ~cenPatView.valueAction_(~presets[index][\cenPatView]) });
if (~panPatView.value != ~presets[index][\panPatView], { ~panPatView.valueAction_(~presets[index][\panPatView]) });
if (~outLPatView.value != ~presets[index][\outLPatView], { ~outLPatView.valueAction_(~presets[index][\outLPatView]) });
if (~outRPatView.value != ~presets[index][\outRPatView], { ~outRPatView.valueAction_(~presets[index][\outRPatView]) });
if (~fxLPatView.value != ~presets[index][\fxLPatView], { ~fxLPatView.valueAction_(~presets[index][\fxLPatView]) });
if (~fxRPatView.value != ~presets[index][\fxRPatView], { ~fxRPatView.valueAction_(~presets[index][\fxRPatView]) });
if (~delPatView.value != ~presets[index][\delPatView], { ~delPatView.valueAction_(~presets[index][\delPatView]) });
if (~rat2PatView.value != ~presets[index][\rat2PatView], { ~rat2PatView.valueAction_(~presets[index][\rat2PatView]) });
if (~str2PatView.value != ~presets[index][\str2PatView], { ~str2PatView.valueAction_(~presets[index][\str2PatView]) });
if (~cen2PatView.value != ~presets[index][\cen2PatView], { ~cen2PatView.valueAction_(~presets[index][\cen2PatView]) });

if (~rtmPatSelView.value != ~presets[index][\rtmPatSelView], { ~rtmPatSelView.valueAction_(~presets[index][\rtmPatSelView]) });
if (~proPatSelView.value != ~presets[index][\proPatSelView], { ~proPatSelView.valueAction_(~presets[index][\proPatSelView]) });
if (~synPatSelView.value != ~presets[index][\synPatSelView], { ~synPatSelView.valueAction_(~presets[index][\synPatSelView]) });
if (~spaPatSelView.value != ~presets[index][\spaPatSelView], { ~spaPatSelView.valueAction_(~presets[index][\spaPatSelView]) });
if (~legPatSelView.value != ~presets[index][\legPatSelView], { ~legPatSelView.valueAction_(~presets[index][\legPatSelView]) });
if (~envPatSelView.value != ~presets[index][\envPatSelView], { ~envPatSelView.valueAction_(~presets[index][\envPatSelView]) });
if (~bufPatSelView.value != ~presets[index][\bufPatSelView], { ~bufPatSelView.valueAction_(~presets[index][\bufPatSelView]) });
if (~offPatSelView.value != ~presets[index][\offPatSelView], { ~offPatSelView.valueAction_(~presets[index][\offPatSelView]) });
if (~ratPatSelView.value != ~presets[index][\ratPatSelView], { ~ratPatSelView.valueAction_(~presets[index][\ratPatSelView]) });
if (~ampPatSelView.value != ~presets[index][\ampPatSelView], { ~ampPatSelView.valueAction_(~presets[index][\ampPatSelView]) });
if (~strPatSelView.value != ~presets[index][\strPatSelView], { ~strPatSelView.valueAction_(~presets[index][\strPatSelView]) });
if (~cenPatSelView.value != ~presets[index][\cenPatSelView], { ~cenPatSelView.valueAction_(~presets[index][\cenPatSelView]) });
if (~panPatSelView.value != ~presets[index][\panPatSelView], { ~panPatSelView.valueAction_(~presets[index][\panPatSelView]) });
if (~outLPatSelView.value != ~presets[index][\outLPatSelView], { ~outLPatSelView.valueAction_(~presets[index][\outLPatSelView]) });
if (~outRPatSelView.value != ~presets[index][\outRPatSelView], { ~outRPatSelView.valueAction_(~presets[index][\outRPatSelView]) });
if (~fxLPatSelView.value != ~presets[index][\fxLPatSelView], { ~fxLPatSelView.valueAction_(~presets[index][\fxLPatSelView]) });
if (~fxRPatSelView.value != ~presets[index][\fxRPatSelView], { ~fxRPatSelView.valueAction_(~presets[index][\fxRPatSelView]) });
if (~delPatSelView.value != ~presets[index][\delPatSelView], { ~delPatSelView.valueAction_(~presets[index][\delPatSelView]) });
if (~rat2PatSelView.value != ~presets[index][\rat2PatSelView], { ~rat2PatSelView.valueAction_(~presets[index][\rat2PatSelView]) });
if (~str2PatSelView.value != ~presets[index][\str2PatSelView], { ~str2PatSelView.valueAction_(~presets[index][\str2PatSelView]) });
if (~cen2PatSelView.value != ~presets[index][\cen2PatSelView], { ~cen2PatSelView.valueAction_(~presets[index][\cen2PatSelView]) });


// Données des petits sliders 6 Mappées si possible
if (~rtmTypeView.value != ~presets[index][\rtmType], { ~rtmTypeView.valueAction_(~presets[index][\rtmType]) });
if (~rtmTypeView2.value != ~presets[index][\seqType], { ~rtmTypeView2.valueAction_(~presets[index][\seqType]) });

~proBjorSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~proBjorView.step_(rtmSeqStep).valueAction_(~proBjorSpec[~tracksValue][~seqsValue].unmap(~presets[index][\proBjor])).doAction; // doAction pour mise à jour du Spec
~proBjor2View.step_(rtmSeqStep).valueAction_(~proBjorSpec[~tracksValue][~seqsValue].unmap(~presets[index][\proBjor2])).doAction; // doAction pour mise à jour du Spec

if (~synTypeView.value != ~presets[index][\synType], { ~synTypeView.valueAction_(~presets[index][\synType]) });
~offRateSecondBufView.valueAction_(~offRateSecondBufSpec.unmap(~presets[index][\offRateSecondBuf]));
if (~offRateRandSecondBufView.value != ~presets[index][\offRateRandSecondBuf], { ~offRateRandSecondBufView.valueAction_(~presets[index][\offRateRandSecondBuf]) });

if (~dbRollOffView.value != ~presets[index][\dbRollOff], { ~dbRollOffView.valueAction_(~presets[index][\dbRollOff]) });
if (~speakRadView.value != ~presets[index][\speakRad], { ~speakRadView.valueAction_(~presets[index][\speakRad]) });
if (~orientationView.value != ~presets[index][\orientation], { ~orientationView.valueAction_(~presets[index][\orientation]) });
if (~pointScaleView.value != ~presets[index][\pointScale], { ~pointScaleView.valueAction_(~presets[index][\pointScale]) });
if (~ambPointScaleView.value != ~presets[index][\ambPointScale], { ~ambPointScaleView.valueAction_(~presets[index][\ambPointScale]) });
if (~trajSpatLoopView.value != ~presets[index][\trajSpatLoop], { ~trajSpatLoopView.valueAction_(~presets[index][\trajSpatLoop]) });
if (~trajSpatRateView.value != ~presets[index][\trajSpatRate], { ~trajSpatRateView.valueAction_(~presets[index][\trajSpatRate]) });
if (~trajSpatTimeTypeView.value != ~presets[index][\trajSpatTimeType], { ~trajSpatTimeTypeView.valueAction_(~presets[index][\trajSpatTimeType]) });
if (~trajSpatTypeView.value != ~presets[index][\trajSpatType], { ~trajSpatTypeView.valueAction_(~presets[index][\trajSpatType]) });
if (~spaLagTimeView.value != ~presets[index][\spaLagTime], { ~spaLagTimeView.valueAction_(~presets[index][\spaLagTime]) });

if (~legTypeView.value != ~presets[index][\legType], { ~legTypeView.valueAction_(~presets[index][\legType]) });
if (~legLoopView.value != ~presets[index][\legLoop], { ~legLoopView.valueAction_(~presets[index][\legLoop]) });

if (~atkView[0].value != ~presets[index][\atk1], { ~atkView[0].valueAction_(~presets[index][\atk1]) });
if (~relView[0].value != ~presets[index][\rel1], { ~relView[0].valueAction_(~presets[index][\rel1]) });
if (~atkView[1].value != ~presets[index][\atk2], { ~atkView[1].valueAction_(~presets[index][\atk2]) });
if (~relView[1].value != ~presets[index][\rel2], { ~relView[1].valueAction_(~presets[index][\rel2]) });
/*~atkView[2].valueAction_(~presets[index][\atk3]);
~relView[2].valueAction_(~presets[index][\rel3]);
~atkView[3].valueAction_(~presets[index][\atk4]);
~relView[3].valueAction_(~presets[index][\rel4]);*/
if (~atkCurveView[0].value != ~presets[index][\atkCurve1], { ~atkCurveView[0].valueAction_(~presets[index][\atkCurve1]) });
if (~relCurveView[0].value != ~presets[index][\relCurve1], { ~relCurveView[0].valueAction_(~presets[index][\relCurve1]) });
if (~atkCurveView[1].value != ~presets[index][\atkCurve2], { ~atkCurveView[1].valueAction_(~presets[index][\atkCurve2]) });
if (~relCurveView[1].value != ~presets[index][\relCurve2], { ~relCurveView[1].valueAction_(~presets[index][\relCurve2]) });
/*~atkCurveView[2].valueAction_(~presets[index][\atkCurve3]);
~relCurveView[2].valueAction_(~presets[index][\relCurve3]);
~atkCurveView[3].valueAction_(~presets[index][\atkCurve4]);
~relCurveView[3].valueAction_(~presets[index][\relCurve4]);*/

if (~w1View.value != ~presets[index][\w1], { ~w1View.valueAction_(~presets[index][\w1]) });
if (~w2View.value != ~presets[index][\w2], { ~w2View.valueAction_(~presets[index][\w2]) });
if (~envTypeView.value != ~presets[index][\envType], { ~envTypeView.valueAction_(~presets[index][\envType]) });

~offThreshView.valueAction_(~offThreshSpec.unmap(~presets[index][\offThresh]));
~freqRatView.valueAction_(~freqRatSpec.unmap(~presets[index][\freqRat]));
~fAmpView.valueAction_(~fAmpSpec.unmap(~presets[index][\fAmp]));
~ampRatView.valueAction_(~ampRatSpec.unmap(~presets[index][\ampRat]));
~aAmpView.valueAction_(~aAmpSpec.unmap(~presets[index][\aAmp]));
~panRatView.valueAction_(~panRatSpec.unmap(~presets[index][\panRat]));
~pAmpView.valueAction_(~pAmpSpec.unmap(~presets[index][\pAmp]));
~ratSynthView.valueAction_(~presets[index][\gliss]);
~proSelectView.valueAction_(~presets[index][\proSelect]);

// Données des petits sliders 6 Brutes si possible
/*~rtmTypeView.valueAction_(~presets[index][\rtmType]);
~proBjorSpec[~tracksValue][~seqsValue] = rtmSeqSpec;
~proBjorView.step_(rtmSeqStep)
// ~proBjorView.doAction; // intérêt ???
.valueAction_(~presets[index][\proBjorView]);
~synTypeView.valueAction_(~presets[index][\synType]);
~offRateSecondBufView.valueAction_(~presets[index][\offRateSecondBufView]);
~offRateRandSecondBufView.valueAction_(~presets[index][\offRateRandSecondBuf]);
~trajLevelScaleView.valueAction_(~presets[index][\trajLevelScaleView]);
~spaTrajTimeView.valueAction_(~presets[index][\spaTrajTime]);
~legTypeView.valueAction_(~presets[index][\legType]);
~legLoopView.valueAction_(~presets[index][\legLoop]);
~atkView.valueAction_(~presets[index][\atkView]);
~relView.valueAction_(~presets[index][\relView]);
~envTypeView.valueAction_(~presets[index][\envType]);
~w1View.valueAction_(~presets[index][\w1View]);
~w2View.valueAction_(~presets[index][\w2View]);
~offThreshView.valueAction_(~presets[index][\offThreshView]);
~freqRatView.valueAction_(~presets[index][\freqRatView]);
~fAmpView.valueAction_(~presets[index][\fAmpView]);
~ampRatView.valueAction_(~presets[index][\ampRatView]);
~aAmpView.valueAction_(~presets[index][\aAmpView]);
~panRatView.valueAction_(~presets[index][\panRatView]);
~pAmpView.valueAction_(~presets[index][\pAmpView]);*/


// Données du mode des SmoothRangeSliders 8
// Les RangeMode et SeqMode prennent au global 0.00014 sec -> donc ne prend pratiquement pas de temps
~rtmRangeMode.valueAction_(~presets[index][\rtmRangeMode]);
~proRangeMode.valueAction_(~presets[index][\proRangeMode]);
~synRangeMode.valueAction_(~presets[index][\synRangeMode]);
~spaRangeMode.valueAction_(~presets[index][\spaRangeMode]);
~legRangeMode.valueAction_(~presets[index][\legRangeMode]);
~envRangeMode.valueAction_(~presets[index][\envRangeMode]);
~bufRangeMode.valueAction_(~presets[index][\bufRangeMode]);
~offRangeMode.valueAction_(~presets[index][\offRangeMode]);
~ratRangeMode.valueAction_(~presets[index][\ratRangeMode]);
~ampRangeMode.valueAction_(~presets[index][\ampRangeMode]);
~strRangeMode.valueAction_(~presets[index][\strRangeMode]);
~cenRangeMode.valueAction_(~presets[index][\cenRangeMode]);
~panRangeMode.valueAction_(~presets[index][\panRangeMode]);
~outLRangeMode.valueAction_(~presets[index][\outLRangeMode]);
~outRRangeMode.valueAction_(~presets[index][\outRRangeMode]);
~fxLRangeMode.valueAction_(~presets[index][\fxLRangeMode]);
~fxRRangeMode.valueAction_(~presets[index][\fxRRangeMode]);
~delRangeMode.valueAction_(~presets[index][\delRangeMode]);
~rat2RangeMode.valueAction_(~presets[index][\rat2RangeMode]);
~str2RangeMode.valueAction_(~presets[index][\str2RangeMode]);
~cen2RangeMode.valueAction_(~presets[index][\cen2RangeMode]);

~rtmSeqMode.valueAction_(~presets[index][\rtmSeqMode]);
~proSeqMode.valueAction_(~presets[index][\proSeqMode]);
~synSeqMode.valueAction_(~presets[index][\synSeqMode]);
~spaSeqMode.valueAction_(~presets[index][\spaSeqMode]);
~legSeqMode.valueAction_(~presets[index][\legSeqMode]);
~envSeqMode.valueAction_(~presets[index][\envSeqMode]);
~bufSeqMode.valueAction_(~presets[index][\bufSeqMode]);
~offSeqMode.valueAction_(~presets[index][\offSeqMode]);
~ratSeqMode.valueAction_(~presets[index][\ratSeqMode]);
~ampSeqMode.valueAction_(~presets[index][\ampSeqMode]);
~strSeqMode.valueAction_(~presets[index][\strSeqMode]);
~cenSeqMode.valueAction_(~presets[index][\cenSeqMode]);
~panSeqMode.valueAction_(~presets[index][\panSeqMode]);
~outLSeqMode.valueAction_(~presets[index][\outLSeqMode]);
~outRSeqMode.valueAction_(~presets[index][\outRSeqMode]);
~fxLSeqMode.valueAction_(~presets[index][\fxLSeqMode]);
~fxRSeqMode.valueAction_(~presets[index][\fxRSeqMode]);
~delSeqMode.valueAction_(~presets[index][\delSeqMode]);
~rat2SeqMode.valueAction_(~presets[index][\rat2SeqMode]);
~str2SeqMode.valueAction_(~presets[index][\str2SeqMode]);
~cen2SeqMode.valueAction_(~presets[index][\cen2SeqMode]);


// Données du mode des effets si E ou ES à la fin du preset
if (~presets[index][\fxSynth] == 1,
{~fxSelect.do { |y, yi|
case
{ ~presets[index][\fxSynthNum][yi] > 0 and: {~presets[index][\fxSynthNum][yi] <= ~numFxSynthDef} }
{ ~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['order'].size.collect { |i| ~fxSynthDefViews[(~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].name ++ ~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxSynthData][yi][a]) } }

{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+1) }
{ ~eqUnitLib[0].setting = ~presets[index][\fxSynthData][yi] }

{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+2) }
{ ~eqUnitLib[1].setting = ~presets[index][\fxSynthData][yi] }

{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+3) }
{ ~eqUnitLib[2].setting = ~presets[index][\fxSynthData][yi] }

{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+4) }
{
// ~fftEQMagValues = ~presets[index][\fxSynthData][yi][0]; // Pourquoi ne marche pas alos que la ligne ci-dessous marche ???
2.do { |i| ~fftEQMagValues[i] = ~presets[index][\fxSynthData][yi][0][i]; ~fftEQBufsGet.(i) };
~fftEQSliderLagView.valueAction_(~presets[index][\fxSynthData][yi][1]);
~fftEQCompChooseView.valueAction_(~presets[index][\fxSynthData][yi][2]);
~fftEQBufChooseView.valueAction_(~presets[index][\fxSynthData][yi][3]);
~fftEQRoutRandView.valueAction_(~presets[index][\fxSynthData][yi][4])
}
/* Données pour Spectral EQ
~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\fxSynthData][2][0]
[~fftEQMagValues,~fftEQSliderLag,~fftEQCompChoose,~fftEQBufChoose,~fftEQRoutRand]
*/
{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+5) }
{
4.do { |i| ~fftDelfbValues[i] = ~presets[index][\fxSynthData][yi][0][i]; ~fftDelBufsGet.(i) };
~fftDelSliderLagView.valueAction_(~presets[index][\fxSynthData][yi][1]);
~fftDelCompChooseView.valueAction_(~presets[index][\fxSynthData][yi][2]);
~fftDelBufChooseView.valueAction_(~presets[index][\fxSynthData][yi][3]);
~fftDelRoutRandView.valueAction_(~presets[index][\fxSynthData][yi][4])
}
{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+6) }
{
2.do { |i|
~fftOutChannelValues[i] = ~presets[index][\fxSynthData][yi][0][i];
~getBinChannelsPan2Outs.(~fftOutChannelValues[i], i); // fonction n'intègre pas d'update visuel à la différence des autres ci-dessus
~fftOutPlotterView[i].setValue(~fftOutChannelValues[i], false)
};
~fftOutSliderLagView.valueAction_(~presets[index][\fxSynthData][yi][1]);
~fftOutCompChooseView.valueAction_(~presets[index][\fxSynthData][yi][2]);
~fftOutBufChooseView.valueAction_(~presets[index][\fxSynthData][yi][3]);
~fftOutRoutRandView.valueAction_(~presets[index][\fxSynthData][yi][4])
};

// ~fxSelect.do { |i| i.postln } // ~fxSelect.postln;
// ~fxSelect.do { |i| ~fxSelectView[i].valueAction_(~fxSelect[i]) }
~fxSelectView[yi].valueAction_(~presets[index][\fxSynthNum][yi]);
};

// Ajout pour les effets en série ou en parallèle - avec protection pour les anciens presets ?
/*~fxInSerieChoose*/~presets[index][\fxSynthSerPar].do { |y, yi|
~fxInSerieChooseButtonView[yi].valueAction_(~presets[index][\fxSynthSerPar][yi]);
};
if (~fxInSerieChoose.includes(1), {~fxInSerieChooseAllButtonView.value_(1); ~fxInSerieChoose2AllButtonView.value_(1); }) // juste pour indiquer que certains effets sont en parallèle

});

// ~fxSynthDef[~fxSelect[0]-1].metadata['order'].size.collect { |i| ~fxSynthDefViews[(~fxSynthDef[~fxSelect[0]-1].name ++ ~fxSynthDef[~fxSelect[0]-1].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[~presetSelectionView.item.asSymbol][\fxSynthData][0][a]) };


// Données du mode des effets ambisoniques si S à la fin du preset
if (~presets[index][\fxASynth] == 1,
{~fxASelect.do { |y, yi| var numS, pres = ~presets[index][\fxASynthNum][yi]-1;
case
{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(1, ~numFxSynthDef5) }
{ ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[(~fxSynthDefA[pres].name.asString[0..2] ++ pres.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
~fxSynthDef5SwitchTypView[pres].valueAction_(~presets[index][\fxASynthData][yi][1])
}
{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(~numFxSynthDef5-1, ~numFxSynthDef6Cum) }
{ numS = pres-~numFxSynthDef5; ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[(~fxSynthDefA[pres].name.asString[0..2] ++ numS.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
~fxSynthDef6SwitchTypView[numS].valueAction_(~presets[index][\fxASynthData][yi][1])
}
{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(~numFxSynthDef6Cum-1, ~numFxSynthDef7Cum) }
{ numS = pres-~numFxSynthDef6Cum; ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[(~fxSynthDefA[pres].name.asString[0..1] ++ numS.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
~fxSynthDef7SwitchTypView[numS].valueAction_(~presets[index][\fxASynthData][yi][1]);
~fxSynthDef7SwitchTypPCView[numS].valueAction_(~presets[index][\fxASynthData][yi][2])
}
{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(~numFxSynthDef7Cum-1, ~numFxSynthDefA) }
{ numS = pres-~numFxSynthDef7Cum; ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[(~fxSynthDefA[pres].name.asString[0..4] ++ numS.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
~fxSynthDef8SwitchTypView[numS].valueAction_(~presets[index][\fxASynthData][yi][1]);
~fxSynthDef8SwitchTypPCView[numS].valueAction_(~presets[index][\fxASynthData][yi][2]);
~fxSynthDef8SwitchRevView[numS].valueAction_(~presets[index][\fxASynthData][yi][3])
};

~fxASelectView[yi].valueAction_(~presets[index][\fxASynthNum][yi]);
};

});



~fxActOnWhichView.valueAction_(previousfxActOnWhich); // Pour éviter que le fxL agisse sur le droit
~outActOnWhichView.valueAction_(previousoutActOnWhich); // Pour éviter que le outL agisse sur le droit
~outCompChooseView.valueAction_(previousoutCompChoose);

});*/










// Version sans update visuel pour changement plus rapide et directe des données - à améliorer XXX
// et pas la possibilité de changer les données du multiSlider -> car pas le même nombre de valeurs XXX
// de tout façon un peu hasardeux de changer les valeurs sans update visuel
// fonction seulement destinée à changer super rapidement de presets ou à modifier rapidement certains paramètres de tous les presets comme la configuration spatiale
// problème si un buffer folder a été rajouté ou enlevé alors que ce n'en n'est pas un avec le ~presetGetFunction normal -> à régler XXX

~presetsDontTriggerFX = 0; // Protection pour ne pas déclencher les effets des presets lors du chargement de tous les presets dans les pistes

(
~presetGetFunctionQuick = { | index, track, seq |

	/*
	{~presetSetFunction.value('test1')}.bench
	{~presetGetFunction.value('test1')}.bench
	{~presetGetFunctionQuick.value('test2')}.bench
	*/

	var sv;

	// Utilisation seulement du ~dur car le nb d'éléments dans toutes les séquences est le même
	// Les 5 lignes ci-dessous pas vraiment nécessaire si l'on n'a pas besoin d'update visuel par la suite car mise en place d'un preset sur 1 seq ≠ que celle visualisée
	var rtmSeqSize = ~presets[index][\rtmView].size;
	// var rtmSeqStep = 1 / rtmSeqSize;
	var rtmSeqSpec = ControlSpec(0, rtmSeqSize, \lin, 1, 1);

	var rtmThumbSize = max((333 / rtmSeqSize)*~xSizeMul, ~readViewThumbSize); // Pour modif du ThumbSize du ReadViewSlider dans le Tab Global XXX
	var rtmSeqVSpec = ControlSpec(0, rtmSeqSize-1, \lin, 1, 1);
	var ratHarSeqSize, ratHarSeqSpec; // Pour les Miroirs Multiples

	// Protection mulSlider - Mise en place d'une sécurité avec une multiplication selon le timeOnset
	// peut déclencher des lates -> peut-être multiplier par 2 encore ???
	var timeOnset = (~presets[index][\nbTotalBeats] / ~toTempo) / /*~seqDurRtm*/ rtmSeqSize /*.postln*/;
	~rtmMulSpec[track][seq] = ControlSpec(timeOnset * (20 * ~rtmMulMinProtect / (timeOnset / 0.01).squared), 10, 4, 0.001, 1);
	// ~rtmMulSpec[track][seq].postln;
	// Pourquoi le postln; est déclenché 2x avec changement de rythme -> fonction duration2show
	// Pourquoi le postln; est déclenché 2x avec changement de preset -> fonction getPreset
	/*
	-> 0.0025 * 0.8 -> * 320 // Quand l'un augmente de x2, l'autre est /4
	-> 0.005 * 0.4 -> * 80
	-> 0.01 * 0.2 -> * 20
	-> 0.02 * 0.1 -> * 5
	-> 0.04 * 0.05 -> * 1.25
	x = 0.5; x * (20 / (x / 0.01).squared)
	x = (~nbTotalBeats[track][seq] / ~toTempo) / /*~seqDurRtm*/~dur[track][seq].size; x * (20 / (x / 0.01).squared)
	*/

	if (~server2.isNil or: {(track/2).asInteger < ~serverTrackSwitch}, {sv = 0}, {sv = 1} );

	~rtmThumbSizeValue[track][seq] = rtmThumbSize; // Pour modif du ThumbSize du ReadViewSlider dans le Tab Global XXX


	// Données rythmiques 7 -> pas nécessaire car déjà dans le rythme
	// pas vraiment nécessaire si l'on n'a pas besoin d'update visuel par la suite car mise en place d'un preset sur 1 seq ≠ que celle visualisée
	// Changement de place en début afin que le rtyhme (\nbTotalBeats) soit respecté quand changement de preset avec des durées de Beats différents
	// Lors d'un nouveau fichier de preset garder seulement \configBeatsView (\configBeatsValue conservé pour ne pas refaire le fichier de preset
	~configBeatsValue[track][seq] = ~presets[index][\configBeatsView];
	~nbTotalBeats[track][seq] = ~presets[index][\nbTotalBeats];
	~displayRhythm[track][seq] = ~presets[index][\displayRhythm];
	6.do { |i|
		// if (~presets[index][\selectBeatView][i].notNil, { ~selectBeatValue[track][seq][i] = ~presets[index][\selectBeatView][i] });
		// voir lequel est le plus justifié .notNil ou != 0 ?????? pour optimisation ??????
		if (~presets[index][\selectBeatView][i].notNil and: {~presets[index][\selectBeatView][i] != 0}, { ~selectBeatValue[track][seq][i] = ~presets[index][\selectBeatView][i] });
		~pBeat[track][seq][i] = ~presets[index][\pBeat][i];
		~nbBeat[track][seq][i] = ~presets[index][\nbBeat][i];
		~sumBeat[track][seq][i] = ~presets[index][\sumBeat][i];
		~minSumBeat[track][seq][i] = ~presets[index][\minSumBeat][i]
	};


	// Données du Round 4
	~rtmRoundValue[track][seq] = ~presets[index][\rtmRoundView];
	~proRoundValue[track][seq] = ~presets[index][\proRoundView];
	~legRoundValue[track][seq] = ~presets[index][\legRoundView];
	// Données du BufFolder - Sémantique différente // Prend en compte la position dans la structure et non pas le nom du dossier XXX
	// Les données propre du BufFolder ne sont pas sauvegardées mais seulement la valeur du PopUpMenu
	// ~bufFolderValue[track][seq] = ~presets[index][\bufFolderView];
	if (~presets[index][\bufFolderView] < ~bufFolderSize, {~bufFolderValue[track][seq] = ~presets[index][\bufFolderView]}, {~bufFolderValue[track][seq] = ~bufFolderSize1}); // à optimiser

	if (~presets[index][\bufFolderView] < ~bufFolderSize, {~bufFolderFunc.value(track, seq, ~presets[index][\bufFolderView], /*0*/ sv ) }, {~bufFolderFunc.value(track, seq, ~bufFolderSize1, /*0*/ sv ) }); // à optimiser
	// ~bufRangeSpec[track][seq] = ControlSpec(0, ~bufFolderM[0][track][seq].size-1, \lin, 1);


	~offRoundValue[track][seq] = ~presets[index][\offRoundView];
	if (~presets[index][\off2RoundView].notNil, {
		~off2RoundValue[track][seq] = ~presets[index][\off2RoundView];
		~off3RoundValue[track][seq] = ~presets[index][\off3RoundView];
		~off4RoundValue[track][seq] = ~presets[index][\off4RoundView];
	});
	~ratRoundValue[track][seq] = ~presets[index][\ratRoundView];
	~ampRoundValue[track][seq] = ~presets[index][\ampRoundView];
	~strRoundValue[track][seq] = ~presets[index][\strRoundView];
	~cenRoundValue[track][seq] = ~presets[index][\cenRoundView];
	~panRoundValue[track][seq] = ~presets[index][\panRoundView];
	~delRoundValue[track][seq] = ~presets[index][\delRoundView];
	~rat2RoundValue[track][seq] = ~presets[index][\rat2RoundView];
	~str2RoundValue[track][seq] = ~presets[index][\str2RoundView];
	~cen2RoundValue[track][seq] = ~presets[index][\cen2RoundView];


	// Données du RangeSlider 1
	~rtmMin[track][seq] = ~presets[index][\rtmMin]; ~rtmMax[track][seq] = ~presets[index][\rtmMax];
	~proMin[track][seq] = ~presets[index][\proMin]; ~proMax[track][seq] = ~presets[index][\proMax];
	~synMin[track][seq] = ~presets[index][\synMin]; ~synMax[track][seq] = ~presets[index][\synMax];
	~spaMin[track][seq] = ~presets[index][\spaMin]; ~spaMax[track][seq] = ~presets[index][\spaMax];
	~legMin[track][seq] = ~presets[index][\legMin]; ~legMax[track][seq] = ~presets[index][\legMax];
	~envMin[track][seq] = ~presets[index][\envMin]; ~envMax[track][seq] = ~presets[index][\envMax];
	~bufMin[track][seq] = ~presets[index][\bufMin]; ~bufMax[track][seq] = ~presets[index][\bufMax];
	~offMin[track][seq] = ~presets[index][\offMin]; ~offMax[track][seq] = ~presets[index][\offMax];

	if (~presets[index][\off2Min].notNil, {
		~off2Min[track][seq] = ~presets[index][\off2Min]; ~off2Max[track][seq] = ~presets[index][\off2Max];
		~off3Min[track][seq] = ~presets[index][\off3Min]; ~off3Max[track][seq] = ~presets[index][\off3Max];
		~off4Min[track][seq] = ~presets[index][\off4Min]; ~off4Max[track][seq] = ~presets[index][\off4Max];
	});

	~ratMin[track][seq] = ~presets[index][\ratMin]; ~ratMax[track][seq] = ~presets[index][\ratMax];
	~ampMin[track][seq] = ~presets[index][\ampMin]; ~ampMax[track][seq] = ~presets[index][\ampMax];
	~strMin[track][seq] = ~presets[index][\strMin]; ~strMax[track][seq] = ~presets[index][\strMax];
	~cenMin[track][seq] = ~presets[index][\cenMin]; ~cenMax[track][seq] = ~presets[index][\cenMax];
	~panMin[track][seq] = ~presets[index][\panMin]; ~panMax[track][seq] = ~presets[index][\panMax];
	~outLMin[track][seq] = ~presets[index][\outLMin]; ~outLMax[track][seq] = ~presets[index][\outLMax];
	~outRMin[track][seq] = ~presets[index][\outRMin]; ~outRMax[track][seq] = ~presets[index][\outRMax];
	~fxLMin[track][seq] = ~presets[index][\fxLMin]; ~fxLMax[track][seq] = ~presets[index][\fxLMax];
	~fxRMin[track][seq] = ~presets[index][\fxRMin]; ~fxRMax[track][seq] = ~presets[index][\fxRMax];
	~delMin[track][seq] = ~presets[index][\delMin]; ~delMax[track][seq] = ~presets[index][\delMax];
	~rat2Min[track][seq] = ~presets[index][\rat2Min]; ~rat2Max[track][seq] = ~presets[index][\rat2Max];
	~str2Min[track][seq] = ~presets[index][\str2Min]; ~str2Max[track][seq] = ~presets[index][\str2Max];
	~cen2Min[track][seq] = ~presets[index][\cen2Min]; ~cen2Max[track][seq] = ~presets[index][\cen2Max];


	// Les données du Round ne sont pas sauvegardées et prendront donc les valeurs du Round affichée
	// si on suppime cette section les Spec du pattern prennent les valeurs du Spec affichée et changent complètement le pattern sauvegardé
	// Intéressant pour changer complètement un preset sauvegardé XXX (Attention quand même au rythme)
	~rtmSpec[track][seq] = ControlSpec(~rtmMin[track][seq], ~rtmMax[track][seq], \lin, ~rtmRound[track][seq]);
	~proSpec[track][seq] = ControlSpec(~proMin[track][seq], ~proMax[track][seq], \lin, ~proRound[track][seq]);
	~synSpec[track][seq] = ControlSpec(~synMin[track][seq], ~synMax[track][seq], \lin, 1);
	~spaSpec[track][seq] = ControlSpec(~spaMin[track][seq], ~spaMax[track][seq], \lin, 1);
	~legSpec[track][seq] = ControlSpec(~legMin[track][seq], ~legMax[track][seq], \lin, ~legRound[track][seq]);
	~envSpec[track][seq] = ControlSpec(~envMin[track][seq], ~envMax[track][seq], \lin, 1);
	~bufSpec[track][seq] = ControlSpec(~bufMin[track][seq], ~bufMax[track][seq], \lin, 1);

	// if (~presets[index][\bufFolderView] < /*~bufFolderView.items.size*/ ~arrayOfFolderNamesALL.size, {~bufFolderFunc.value(track, seq, ~presets[index][\bufFolderView], /*0*/if (~server2.isNil or: {(~tracksValue/2).asInteger < ~serverTrackSwitch}, {0}, {1})) }, {~bufFolderFunc.value(track, seq, ~arrayOfFolderNamesALL.size-1, /*0*/ if (~server2.isNil or: {(~tracksValue/2).asInteger < ~serverTrackSwitch}, {0}, {1})) }); // à optimiser
	// ~bufRangeSpec[track][seq] = ControlSpec(0, ~bufFolderM[0][track][seq].size-1, \lin, 1);

	~offSpec[track][seq] = ControlSpec(~offMin[track][seq], ~offMax[track][seq], \lin, ~offRound[track][seq]);
	~ratSpec[track][seq] = ControlSpec(~ratMin[track][seq], ~ratMax[track][seq], \lin, ~ratRound[track][seq]);
	~ampSpec[track][seq] = ControlSpec(~ampMin[track][seq], ~ampMax[track][seq], \lin, ~ampRound[track][seq]);
	~strSpec[track][seq] = ControlSpec(~strMin[track][seq], ~strMax[track][seq], \lin, ~strRound[track][seq]);
	~cenSpec[track][seq] = ControlSpec(~cenMin[track][seq], ~cenMax[track][seq], \lin, ~cenRound[track][seq]);
	~panSpec[track][seq] = ControlSpec(~panMin[track][seq], ~panMax[track][seq], \lin, ~panRound[track][seq]);
	~outLSpec[track][seq] = ControlSpec(~outLMin[track][seq], ~outLMax[track][seq], \lin, 1);
	~outRSpec[track][seq] = ControlSpec(~outRMin[track][seq], ~outRMax[track][seq], \lin, 1);
	~fxLSpec[track][seq] = ControlSpec(~fxLMin[track][seq], ~fxLMax[track][seq], \lin, 1);
	~fxRSpec[track][seq] = ControlSpec(~fxRMin[track][seq], ~fxRMax[track][seq], \lin, 1);
	~delSpec[track][seq] = ControlSpec(~delMin[track][seq], ~delMax[track][seq], \lin, 1);
	~rat2Spec[track][seq] = ControlSpec(~rat2Min[track][seq], ~rat2Max[track][seq], \lin, 1);
	~str2Spec[track][seq] = ControlSpec(~str2Min[track][seq], ~str2Max[track][seq], \lin, 1);
	~cen2Spec[track][seq] = ControlSpec(~cen2Min[track][seq], ~cen2Max[track][seq], \lin, 1);


	// Données du Multislider 0
	~dur[track][seq] = ~presets[index][\rtmView].copy;
	~pro[track][seq] = ~presets[index][\proView].copy;
	~syn[track][seq] = ~presets[index][\synView].copy;
	~spa[track][seq] = ~presets[index][\spaView].copy;
	~leg[track][seq] = ~presets[index][\legView].copy;
	~env[track][seq] = ~presets[index][\envView].copy;
	~buf[track][seq] = ~presets[index][\bufView].copy;
	~off[track][seq] = ~presets[index][\offView].copy;

	if (~presets[index][\off2View].notNil, {
		~off2Spec[track][seq] = ControlSpec(~off2Min[track][seq], ~off2Max[track][seq], \lin, ~off2Round[track][seq]);
		~off3Spec[track][seq] = ControlSpec(~off3Min[track][seq], ~off3Max[track][seq], \lin, ~off3Round[track][seq]);
		~off4Spec[track][seq] = ControlSpec(~off4Min[track][seq], ~off4Max[track][seq], \lin, ~off4Round[track][seq]);
		~off2[track][seq] = ~presets[index][\off2View].copy;
		~off3[track][seq] = ~presets[index][\off3View].copy;
		~off4[track][seq] = ~presets[index][\off4View].copy;
	},{
		~off2Spec[track][seq] = ControlSpec(~off2Min[track][seq], ~off2Max[track][seq], \lin, ~off2Round[track][seq]);
		~off3Spec[track][seq] = ControlSpec(~off3Min[track][seq], ~off3Max[track][seq], \lin, ~off3Round[track][seq]);
		~off4Spec[track][seq] = ControlSpec(~off4Min[track][seq], ~off4Max[track][seq], \lin, ~off4Round[track][seq]);
		~off2[track][seq] = (Array.fill(rtmSeqSize, {0}));
		~off3[track][seq] = (Array.fill(rtmSeqSize, {0}));
		~off4[track][seq] = (Array.fill(rtmSeqSize, {0}));
	});

	~rat[track][seq] = ~presets[index][\ratView].copy;
	~amp[track][seq] = ~presets[index][\ampView].copy;
	~str[track][seq] = ~presets[index][\strView].copy;
	~cen[track][seq] = ~presets[index][\cenView].copy;
	~pan[track][seq] = ~presets[index][\panView].copy;
	~outL[track][seq] = ~presets[index][\outLView].copy;
	~outR[track][seq] = ~presets[index][\outRView].copy;
	~fxL[track][seq] = ~presets[index][\fxLView].copy;
	~fxR[track][seq] = ~presets[index][\fxRView].copy;
	~del[track][seq] = ~presets[index][\delView].copy;
	~rat2[track][seq] = ~presets[index][\rat2View].copy;
	~str2[track][seq] = ~presets[index][\str2View].copy;
	~cen2[track][seq] = ~presets[index][\cen2View].copy;


	// Données du MulSlider 3
	~rtmMul[track][seq] = ~presets[index][\rtmMul];
	~proMul[track][seq] = ~presets[index][\proMul];
	~synMul[track][seq] = ~presets[index][\synMul];
	~spaMul[track][seq] = ~presets[index][\spaMul];
	~legMul[track][seq] = ~presets[index][\legMul];
	~envMul[track][seq] = ~presets[index][\envMul];
	~bufMul[track][seq] = ~presets[index][\bufMul];
	~offMul[track][seq] = ~presets[index][\offMul];

	if (~presets[index][\off2Mul].notNil, {
		~off2Mul[track][seq] = ~presets[index][\off2Mul];
		~off3Mul[track][seq] = ~presets[index][\off3Mul];
		~off4Mul[track][seq] = ~presets[index][\off4Mul];
	});

	~ratMul[track][seq] = ~presets[index][\ratMul];

	// if (~twister.notNil, { ~ratValues[tr].value_(~ratMulSpec.unmap(~presets[index][\ratMul])/*(~ratMul[~tracksValue][~seqsValue])*/ ) }); // Pour mise à jour du Twister

	~ampMul[track][seq] = ~presets[index][\ampMul];
	~strMul[track][seq] = ~presets[index][\strMul];
	~cenMul[track][seq] = ~presets[index][\cenMul];
	~panMul[track][seq] = ~presets[index][\panMul];
	~outLMul[track][seq] = ~presets[index][\outLMul];
	~outRMul[track][seq] = ~presets[index][\outRMul];
	~fxLMul[track][seq] = ~presets[index][\fxLMul];
	~fxRMul[track][seq] = ~presets[index][\fxRMul];
	~delMul[track][seq] = ~presets[index][\delMul];
	~rat2Mul[track][seq] = ~presets[index][\rat2Mul];
	~str2Mul[track][seq] = ~presets[index][\str2Mul];
	~cen2Mul[track][seq] = ~presets[index][\cen2Mul];

	// Changement du SeqRangeSpec - Utilité d'avoir des SeqSpec différents pour chaque module ???
	// pas vraiment nécessaire si l'on n'a pas besoin d'update visuel par la suite car mise en place d'un preset sur 1 seq ≠ que celle visualisée
	~gblSeqIndexSpec[track][seq] = rtmSeqSpec;
	~gblSeqSpec[track][seq] = rtmSeqSpec;
	~rtmSeqSpec[track][seq] = rtmSeqSpec;
	~proSeqSpec[track][seq] = rtmSeqSpec;
	~synSeqSpec[track][seq] = rtmSeqSpec;
	~spaSeqSpec[track][seq] = rtmSeqSpec;
	~legSeqSpec[track][seq] = rtmSeqSpec;
	~envSeqSpec[track][seq] = rtmSeqSpec;
	~bufSeqSpec[track][seq] = rtmSeqSpec;
	~offSeqSpec[track][seq] = rtmSeqSpec;
	~ratSeqSpec[track][seq] = rtmSeqSpec;
	~ampSeqSpec[track][seq] = rtmSeqSpec;
	~strSeqSpec[track][seq] = rtmSeqSpec;
	~cenSeqSpec[track][seq] = rtmSeqSpec;
	~panSeqSpec[track][seq] = rtmSeqSpec;
	~outLSeqSpec[track][seq] = rtmSeqSpec;
	~outRSeqSpec[track][seq] = rtmSeqSpec;
	~fxLSeqSpec[track][seq] = rtmSeqSpec;
	~fxRSeqSpec[track][seq] = rtmSeqSpec;
	~delSeqSpec[track][seq] = rtmSeqSpec;
	~rat2SeqSpec[track][seq] = rtmSeqSpec;
	~str2SeqSpec[track][seq] = rtmSeqSpec;
	~cen2SeqSpec[track][seq] = rtmSeqSpec;

	~rtmSeqVSpec[track][seq] = rtmSeqVSpec;
	~proSeqVSpec[track][seq] = rtmSeqVSpec;
	~synSeqVSpec[track][seq] = rtmSeqVSpec;
	~spaSeqVSpec[track][seq] = rtmSeqVSpec;
	~legSeqVSpec[track][seq] = rtmSeqVSpec;
	~envSeqVSpec[track][seq] = rtmSeqVSpec;
	~bufSeqVSpec[track][seq] = rtmSeqVSpec;
	~offSeqVSpec[track][seq] = rtmSeqVSpec;
	~ratSeqVSpec[track][seq] = rtmSeqVSpec;
	~ampSeqVSpec[track][seq] = rtmSeqVSpec;
	~strSeqVSpec[track][seq] = rtmSeqVSpec;
	~cenSeqVSpec[track][seq] = rtmSeqVSpec;
	~panSeqVSpec[track][seq] = rtmSeqVSpec;
	~outLSeqVSpec[track][seq] = rtmSeqVSpec;
	~outRSeqVSpec[track][seq] = rtmSeqVSpec;
	~fxLSeqVSpec[track][seq] = rtmSeqVSpec;
	~fxRSeqVSpec[track][seq] = rtmSeqVSpec;
	~delSeqVSpec[track][seq] = rtmSeqVSpec;
	~rat2SeqVSpec[track][seq] = rtmSeqVSpec;
	~str2SeqVSpec[track][seq] = rtmSeqVSpec;
	~cen2SeqVSpec[track][seq] = rtmSeqVSpec;


	// Données du SeqRangeSlider 2
	~gblSeqIndex[track][seq] = ~presets[index][\gblSeqIndex]; // pas vraiment nécessaire
	~gblSeqStart[track][seq] = ~presets[index][\gblSeqStart]; ~gblSeqStop[track][seq] = ~presets[index][\gblSeqStop]; // pas vraiment nécessaire
	~rtmSeqStart[track][seq] = ~presets[index][\rtmSeqStart]; ~rtmSeqStop[track][seq] = ~presets[index][\rtmSeqStop];
	~proSeqStart[track][seq] = ~presets[index][\proSeqStart]; ~proSeqStop[track][seq] = ~presets[index][\proSeqStop];
	~synSeqStart[track][seq] = ~presets[index][\synSeqStart]; ~synSeqStop[track][seq] = ~presets[index][\synSeqStop];
	~spaSeqStart[track][seq] = ~presets[index][\spaSeqStart]; ~spaSeqStop[track][seq] = ~presets[index][\spaSeqStop];
	~legSeqStart[track][seq] = ~presets[index][\legSeqStart]; ~legSeqStop[track][seq] = ~presets[index][\legSeqStop];
	~envSeqStart[track][seq] = ~presets[index][\envSeqStart]; ~envSeqStop[track][seq] = ~presets[index][\envSeqStop];
	~bufSeqStart[track][seq] = ~presets[index][\bufSeqStart]; ~bufSeqStop[track][seq] = ~presets[index][\bufSeqStop];
	~offSeqStart[track][seq] = ~presets[index][\offSeqStart]; ~offSeqStop[track][seq] = ~presets[index][\offSeqStop];

	if (~presets[index][\off2SeqStart].notNil, {
		~off2SeqSpec[track][seq] = rtmSeqSpec; ~off3SeqSpec[track][seq] = rtmSeqSpec; ~off4SeqSpec[track][seq] = rtmSeqSpec;
		~off2SeqVSpec[track][seq] = rtmSeqVSpec; ~off3SeqVSpec[track][seq] = rtmSeqVSpec; ~off4SeqVSpec[track][seq] = rtmSeqVSpec;
		~off2SeqStart[track][seq] = ~presets[index][\off2SeqStart]; ~off2SeqStop[track][seq] = ~presets[index][\off2SeqStop];
		~off3SeqStart[track][seq] = ~presets[index][\off3SeqStart]; ~off3SeqStop[track][seq] = ~presets[index][\off3SeqStop];
		~off4SeqStart[track][seq] = ~presets[index][\off4SeqStart]; ~off4SeqStop[track][seq] = ~presets[index][\off4SeqStop];
		~seqDurOff2[track][seq] = ~off2SeqStop[track][seq] - ~off2SeqStart[track][seq] + 1;
		~seqDurOff3[track][seq] = ~off3SeqStop[track][seq] - ~off3SeqStart[track][seq] + 1;
		~seqDurOff4[track][seq] = ~off4SeqStop[track][seq] - ~off4SeqStart[track][seq] + 1;
	},{
		~off2SeqSpec[track][seq] = rtmSeqSpec; ~off3SeqSpec[track][seq] = rtmSeqSpec; ~off4SeqSpec[track][seq] = rtmSeqSpec;
		~off2SeqVSpec[track][seq] = rtmSeqVSpec; ~off3SeqVSpec[track][seq] = rtmSeqVSpec; ~off4SeqVSpec[track][seq] = rtmSeqVSpec;
		~off2SeqStart[track][seq] = 0; ~off2SeqStop[track][seq] = rtmSeqSize;
		~off3SeqStart[track][seq] = 0; ~off3SeqStop[track][seq] = rtmSeqSize;
		~off4SeqStart[track][seq] = 0; ~off4SeqStop[track][seq] = rtmSeqSize;
		~seqDurOff2[track][seq] = ~off2SeqStop[track][seq] - ~off2SeqStart[track][seq] + 1;
		~seqDurOff3[track][seq] = ~off3SeqStop[track][seq] - ~off3SeqStart[track][seq] + 1;
		~seqDurOff4[track][seq] = ~off4SeqStop[track][seq] - ~off4SeqStart[track][seq] + 1;
	});

	~ratSeqStart[track][seq] = ~presets[index][\ratSeqStart]; ~ratSeqStop[track][seq] = ~presets[index][\ratSeqStop];
	~ampSeqStart[track][seq] = ~presets[index][\ampSeqStart]; ~ampSeqStop[track][seq] = ~presets[index][\ampSeqStop];
	~strSeqStart[track][seq] = ~presets[index][\strSeqStart]; ~strSeqStop[track][seq] = ~presets[index][\strSeqStop];
	~cenSeqStart[track][seq] = ~presets[index][\cenSeqStart]; ~cenSeqStop[track][seq] = ~presets[index][\cenSeqStop];
	~panSeqStart[track][seq] = ~presets[index][\panSeqStart]; ~panSeqStop[track][seq] = ~presets[index][\panSeqStop];
	~outLSeqStart[track][seq] = ~presets[index][\outLSeqStart]; ~outLSeqStop[track][seq] = ~presets[index][\outLSeqStop];
	~outRSeqStart[track][seq] = ~presets[index][\outRSeqStart]; ~outRSeqStop[track][seq] = ~presets[index][\outRSeqStop];
	~fxLSeqStart[track][seq] = ~presets[index][\fxLSeqStart]; ~fxLSeqStop[track][seq] = ~presets[index][\fxLSeqStop];
	~fxRSeqStart[track][seq] = ~presets[index][\fxRSeqStart]; ~fxRSeqStop[track][seq] = ~presets[index][\fxRSeqStop];
	~delSeqStart[track][seq] = ~presets[index][\delSeqStart]; ~delSeqStop[track][seq] = ~presets[index][\delSeqStop];
	~rat2SeqStart[track][seq] = ~presets[index][\rat2SeqStart]; ~rat2SeqStop[track][seq] = ~presets[index][\rat2SeqStop];
	~str2SeqStart[track][seq] = ~presets[index][\str2SeqStart]; ~str2SeqStop[track][seq] = ~presets[index][\str2SeqStop];
	~cen2SeqStart[track][seq] = ~presets[index][\cen2SeqStart]; ~cen2SeqStop[track][seq] = ~presets[index][\cen2SeqStop];

	// pas vraiment nécessaire si l'on n'a pas besoin d'update visuel par la suite car mise en place d'un preset sur 1 seq ≠ que celle visualisée
	~seqDurRtm[track][seq] = ~rtmSeqStop[track][seq] - ~rtmSeqStart[track][seq] + 1;
	~seqDurPro[track][seq] = ~proSeqStop[track][seq] - ~proSeqStart[track][seq] + 1;
	~seqDurSyn[track][seq] = ~synSeqStop[track][seq] - ~synSeqStart[track][seq] + 1;
	~seqDurSpa[track][seq] = ~spaSeqStop[track][seq] - ~spaSeqStart[track][seq] + 1;
	~seqDurLeg[track][seq] = ~legSeqStop[track][seq] - ~legSeqStart[track][seq] + 1;
	~seqDurEnv[track][seq] = ~envSeqStop[track][seq] - ~envSeqStart[track][seq] + 1;
	~seqDurBuf[track][seq] = ~bufSeqStop[track][seq] - ~bufSeqStart[track][seq] + 1;
	~seqDurOff[track][seq] = ~offSeqStop[track][seq] - ~offSeqStart[track][seq] + 1;
	~seqDurRat[track][seq] = ~ratSeqStop[track][seq] - ~ratSeqStart[track][seq] + 1;
	~seqDurAmp[track][seq] = ~ampSeqStop[track][seq] - ~ampSeqStart[track][seq] + 1;
	~seqDurStr[track][seq] = ~strSeqStop[track][seq] - ~strSeqStart[track][seq] + 1;
	~seqDurCen[track][seq] = ~cenSeqStop[track][seq] - ~cenSeqStart[track][seq] + 1;
	~seqDurPan[track][seq] = ~panSeqStop[track][seq] - ~panSeqStart[track][seq] + 1;
	~seqDurOutL[track][seq] = ~outLSeqStop[track][seq] - ~outLSeqStart[track][seq] + 1;
	~seqDurOutR[track][seq] = ~outRSeqStop[track][seq] - ~outRSeqStart[track][seq] + 1;
	~seqDurFxL[track][seq] = ~fxLSeqStop[track][seq] - ~fxLSeqStart[track][seq] + 1;
	~seqDurFxR[track][seq] = ~fxRSeqStop[track][seq] - ~fxRSeqStart[track][seq] + 1;
	~seqDurDel[track][seq] = ~delSeqStop[track][seq] - ~delSeqStart[track][seq] + 1;
	~seqDurRat2[track][seq] = ~rat2SeqStop[track][seq] - ~rat2SeqStart[track][seq] + 1;
	~seqDurStr2[track][seq] = ~str2SeqStop[track][seq] - ~str2SeqStart[track][seq] + 1;
	~seqDurCen2[track][seq] = ~cen2SeqStop[track][seq] - ~cen2SeqStart[track][seq] + 1;


	// Données du Pattern 5
	~rtmDir[track][seq] = ~presets[index][\rtmDirView];
	~proDir[track][seq] = ~presets[index][\proDirView];
	~synDir[track][seq] = ~presets[index][\synDirView];
	~spaDir[track][seq] = ~presets[index][\spaDirView];
	~legDir[track][seq] = ~presets[index][\legDirView];
	~envDir[track][seq] = ~presets[index][\envDirView];
	~bufDir[track][seq] = ~presets[index][\bufDirView];
	~offDir[track][seq] = ~presets[index][\offDirView];

	if (~presets[index][\off2DirView].notNil, {
		~off2Dir[track][seq] = ~presets[index][\off2DirView];
		~off3Dir[track][seq] = ~presets[index][\off3DirView];
		~off4Dir[track][seq] = ~presets[index][\off4DirView];
		~off2Pat[track][seq] = ~presets[index][\off2PatView];
		~off3Pat[track][seq] = ~presets[index][\off3PatView];
		~off4Pat[track][seq] = ~presets[index][\off4PatView];
		~off2PatSel[track][seq] = ~presets[index][\off2PatSelView];
		~off3PatSel[track][seq] = ~presets[index][\off3PatSelView];
		~off4PatSel[track][seq] = ~presets[index][\off4PatSelView];
	});

	~ratDir[track][seq] = ~presets[index][\ratDirView];
	~ampDir[track][seq] = ~presets[index][\ampDirView];
	~strDir[track][seq] = ~presets[index][\strDirView];
	~cenDir[track][seq] = ~presets[index][\cenDirView];
	~panDir[track][seq] = ~presets[index][\panDirView];
	~outLDir[track][seq] = ~presets[index][\outLDirView];
	~outRDir[track][seq] = ~presets[index][\outRDirView];
	~fxLDir[track][seq] = ~presets[index][\fxLDirView];
	~fxRDir[track][seq] = ~presets[index][\fxRDirView];
	~delDir[track][seq] = ~presets[index][\delDirView];
	~rat2Dir[track][seq] = ~presets[index][\rat2DirView];
	~str2Dir[track][seq] = ~presets[index][\str2DirView];
	~cen2Dir[track][seq] = ~presets[index][\cen2DirView];

	~rtmPat[track][seq] = ~presets[index][\rtmPatView];
	~proPat[track][seq] = ~presets[index][\proPatView];
	~synPat[track][seq] = ~presets[index][\synPatView];
	~spaPat[track][seq] = ~presets[index][\spaPatView];
	~legPat[track][seq] = ~presets[index][\legPatView];
	~envPat[track][seq] = ~presets[index][\envPatView];
	~bufPat[track][seq] = ~presets[index][\bufPatView];
	~offPat[track][seq] = ~presets[index][\offPatView];
	~ratPat[track][seq] = ~presets[index][\ratPatView];
	~ampPat[track][seq] = ~presets[index][\ampPatView];
	~strPat[track][seq] = ~presets[index][\strPatView];
	~cenPat[track][seq] = ~presets[index][\cenPatView];
	~panPat[track][seq] = ~presets[index][\panPatView];
	~outLPat[track][seq] = ~presets[index][\outLPatView];
	~outRPat[track][seq] = ~presets[index][\outRPatView];
	~fxLPat[track][seq] = ~presets[index][\fxLPatView];
	~fxRPat[track][seq] = ~presets[index][\fxRPatView];
	~delPat[track][seq] = ~presets[index][\delPatView];
	~rat2Pat[track][seq] = ~presets[index][\rat2PatView];
	~str2Pat[track][seq] = ~presets[index][\str2PatView];
	~cen2Pat[track][seq] = ~presets[index][\cen2PatView];

	~rtmPatSel[track][seq] = ~presets[index][\rtmPatSelView];
	~proPatSel[track][seq] = ~presets[index][\proPatSelView];
	~synPatSel[track][seq] = ~presets[index][\synPatSelView];
	~spaPatSel[track][seq] = ~presets[index][\spaPatSelView];
	~legPatSel[track][seq] = ~presets[index][\legPatSelView];
	~envPatSel[track][seq] = ~presets[index][\envPatSelView];
	~bufPatSel[track][seq] = ~presets[index][\bufPatSelView];
	~offPatSel[track][seq] = ~presets[index][\offPatSelView];
	~ratPatSel[track][seq] = ~presets[index][\ratPatSelView];
	~ampPatSel[track][seq] = ~presets[index][\ampPatSelView];
	~strPatSel[track][seq] = ~presets[index][\strPatSelView];
	~cenPatSel[track][seq] = ~presets[index][\cenPatSelView];
	~panPatSel[track][seq] = ~presets[index][\panPatSelView];
	~outLPatSel[track][seq] = ~presets[index][\outLPatSelView];
	~outRPatSel[track][seq] = ~presets[index][\outRPatSelView];
	~fxLPatSel[track][seq] = ~presets[index][\fxLPatSelView];
	~fxRPatSel[track][seq] = ~presets[index][\fxRPatSelView];
	~delPatSel[track][seq] = ~presets[index][\delPatSelView];
	~rat2PatSel[track][seq] = ~presets[index][\rat2PatSelView];
	~str2PatSel[track][seq] = ~presets[index][\str2PatSelView];
	~cen2PatSel[track][seq] = ~presets[index][\cen2PatSelView];


	// Données des petits sliders 6
	~rtmType[track][seq] = ~presets[index][\rtmType];
	if (~presets[index][\seqType].notNil, { ~sequenceType[track][seq] = ~presets[index][\seqType] }, { ~sequenceType[track][seq] = 0 });

	~proBjor[track][seq] = ~presets[index][\proBjor];
	~proBjor2[track][seq] = ~presets[index][\proBjor2];

	if (~presets[index][\proBjor3].notNil, {~proBjor3[track][seq] = ~presets[index][\proBjor3]});
	if (~presets[index][\proBjor4].notNil, {~proBjor4[track][seq] = ~presets[index][\proBjor4]});
	if (~presets[index][\proGridsBias].notNil, {~proGridsBias[track][seq] = ~presets[index][\proGridsBias]});
	if (~presets[index][\proGridsBias2].notNil, {~proGridsBias2[track][seq] = ~presets[index][\proGridsBias2]});
	if (~presets[index][\proWeight].notNil, {~proWeight[track][seq] = ~presets[index][\proWeight]});
	if (~presets[index][\proDrumType].notNil, {~proDrumType[track][seq] = ~presets[index][\proDrumType]});

	~synType[track][seq] = ~presets[index][\synType];
	~offRateSecondBuf[track][seq] = ~presets[index][\offRateSecondBuf];
	~offRateRandSecondBuf[track][seq] = ~presets[index][\offRateRandSecondBuf];

	if (~presets[index][\stereoSpatType].notNil, {~stereoSpatType[track][seq] = ~presets[index][\stereoSpatType] } );
	~dbRollOff[track][seq] = ~presets[index][\dbRollOff];
	~speakRad[track][seq] = ~presets[index][\speakRad];
	~orientation[track][seq] = ~presets[index][\orientation];
	if (~presets[index][\vmPointScale].notNil, {~vmPointScale[track][seq] = ~presets[index][\vmPointScale] } );
	if (~presets[index][\vbPointScale].notNil, {~vbPointScale[track][seq] = ~presets[index][\vbPointScale] } );
	~ambPointScale[track][seq] = ~presets[index][\ambPointScale];
	~trajSpatLoop[track][seq] = ~presets[index][\trajSpatLoop];
	~trajSpatRate[track][seq] = ~presets[index][\trajSpatRate];
	~trajSpatTimeType[track][seq] = ~presets[index][\trajSpatTimeType];
	~trajSpatType[track][seq] = ~presets[index][\trajSpatType];
	~spaLagTime[track][seq] = ~presets[index][\spaLagTime];
	if (~presets[index][\spaLagCurve].notNil, {~spaLagCurve[track][seq] = ~presets[index][\spaLagCurve] } );
	if (~presets[index][\sdFreqRangeMin].notNil, {~sdFreqRangeMin[track][seq] = ~presets[index][\sdFreqRangeMin]; ~sdFreqRangeMax[track][seq] = ~presets[index][\sdFreqRangeMax] } );
	if (~presets[index][\sdDbRangeMin].notNil, {~sdDbRangeMin[track][seq] = ~presets[index][\sdDbRangeMin]; ~sdDbRangeMax[track][seq] = ~presets[index][\sdDbRangeMax] } );
	if (~presets[index][\spec2spaCurve].notNil, {~spec2spaCurve[track][seq] = ~presets[index][\spec2spaCurve] } );

	if (~presets[index][\vbapSpread].notNil, {~vbapSpread[track][seq] = ~presets[index][\vbapSpread] } );
	if (~presets[index][\vbapX2Off].notNil, {~vbapX2Off[track][seq] = ~presets[index][\vbapX2Off] } );
	if (~presets[index][\circSpread].notNil, {~circSpread[track][seq] = ~presets[index][\circSpread] } );
	if (~presets[index][\circSpatType].notNil, {~circSpatType[track][seq] = ~presets[index][\circSpatType] } );
	if (~presets[index][\circSpeedRangeMin].notNil, {~circSpeedRangeMin[track][seq] = ~presets[index][\circSpeedRangeMin]; ~circSpeedRangeMax[track][seq] = ~presets[index][\circSpeedRangeMax] } );
	if (~presets[index][\sdSpatType].notNil, {~sdSpatType[track][seq] = ~presets[index][\sdSpatType] } );

	~legType[track][seq] = ~presets[index][\legType];
	~legLoop[track][seq] = ~presets[index][\legLoop];

	~atk[track][seq][0] = ~presets[index][\atk1];
	~rel[track][seq][0] = ~presets[index][\rel1];
	~atk[track][seq][1] = ~presets[index][\atk2];
	~rel[track][seq][1] = ~presets[index][\rel2];
	/*~atk[2][track][seq] = ~presets[index][\atk3];
	~rel[2][track][seq] = ~presets[index][\rel3];
	~atk[3][track][seq] = ~presets[index][\atk4];
	~rel[3][track][seq] = ~presets[index][\rel4];*/
	~atkCurve[track][seq][0] = ~presets[index][\atkCurve1];
	~relCurve[track][seq][0] = ~presets[index][\relCurve1];
	~atkCurve[track][seq][1] = ~presets[index][\atkCurve2];
	~relCurve[track][seq][1] = ~presets[index][\relCurve2];
	/*~atkCurve[2][track][seq] = ~presets[index][\atkCurve3];
	~relCurve[2][track][seq] = ~presets[index][\relCurve3];
	~atkCurve[3][track][seq] = ~presets[index][\atkCurve4];
	~relCurve[3][track][seq] = ~presets[index][\relCurve4];*/

	~w1[track][seq] = ~presets[index][\w1];
	~w2[track][seq] = ~presets[index][\w2];
	~envType[track][seq] = ~presets[index][\envType];

	~offThresh[track][seq] = ~presets[index][\offThresh];
	~freqRat[track][seq] = ~presets[index][\freqRat];
	~fAmp[track][seq] = ~presets[index][\fAmp];
	~ampRat[track][seq] = ~presets[index][\ampRat];
	~aAmp[track][seq] = ~presets[index][\aAmp];
	~panRat[track][seq] = ~presets[index][\panRat];
	~pAmp[track][seq] = ~presets[index][\pAmp];
	~ratSynth[track][seq] = ~presets[index][\gliss];
	~proSelect[track][seq] = ~presets[index][\proSelect];

	if (~presets[index][\grainSize].notNil, {~grainSize[track][seq] = ~presets[index][\grainSize] } );
	if (~presets[index][\grain2Size].notNil, {~grain2Size[track][seq] = ~presets[index][\grain2Size] } );

	if (~presets[index][\lehmerInit1].notNil, {~lehmerInit1[track][seq] = ~presets[index][\lehmerInit1] } );
	if (~presets[index][\lehmerA1].notNil, {~lehmerA1[track][seq] = ~presets[index][\lehmerA1] } );
	if (~presets[index][\lehmerB1].notNil, {~lehmerB1[track][seq] = ~presets[index][\lehmerB1] } );
	if (~presets[index][\lehmerReInit1].notNil, {~lehmerReInit1[track][seq] = ~presets[index][\lehmerReInit1] } );
	if (~presets[index][\lehmerInit2].notNil, {~lehmerInit2[track][seq] = ~presets[index][\lehmerInit2] } );
	if (~presets[index][\lehmerA2].notNil, {~lehmerA2[track][seq] = ~presets[index][\lehmerA2] } );
	if (~presets[index][\lehmerB2].notNil, {~lehmerB2[track][seq] = ~presets[index][\lehmerB2] } );
	if (~presets[index][\lehmerReInit2].notNil, {~lehmerReInit2[track][seq] = ~presets[index][\lehmerReInit2] } );


	~harTrig[track][seq] = ~presets[index][\harTrig];

	// Multiples Miroir Chorus
	if (~presets[index][\harTrig].notNil, {
		if (~presets[index][\harTrig] == 1, {

			// ~harTrig[track][seq] = ~presets[index][\harTrig];
			~harIndex[track][seq] = ~presets[index][\harIndex];
			~outLHarSpatType[track][seq] = ~presets[index][\outLHarSpatType];
			~outRHarSpatType[track][seq] = ~presets[index][\outRHarSpatType];

			ratHarSeqSize = ~presets[index][\ratHar].size;
			ratHarSeqSpec = ControlSpec(0, ratHarSeqSize, \lin, 1, 1);

			~ratHar[track][seq] = ~presets[index][\ratHar];
			~ratHarMin[track][seq] = ~presets[index][\ratHarMin];
			~ratHarMax[track][seq] = ~presets[index][\ratHarMax];
			~ratHarRoundValue[track][seq] = ~presets[index][\ratHarRoundView];
			~ratHarSpec[track][seq] = ControlSpec(~ratHarMin[track][seq], ~ratHarMax[track][seq], \lin, ~ratHarRoundValue[track][seq]);
			~ratHarSeqStart[track][seq] = ~presets[index][\ratHarSeqStart];
			~ratHarSeqStop[track][seq] = ~presets[index][\ratHarSeqStop];
			// Ligne ci-dessous évaluée par la GUI - sinon pb de DC et clic
			~ratHarSeq[track][seq] = ([1] ++ ~ratHarSpec[track][seq].map(~ratHar[track][seq][~ratHarSeqStart[track][seq]..~ratHarSeqStop[track][seq]])).midiratio;
			~ratHarSeqSpec[track][seq] = ratHarSeqSpec;

			~cenHar[track][seq] = ~presets[index][\cenHar];
			~cenHarMin[track][seq] = ~presets[index][\cenHarMin];
			~cenHarMax[track][seq] = ~presets[index][\cenHarMax];
			~cenHarRoundValue[track][seq] = ~presets[index][\cenHarRoundView];
			~cenHarSpec[track][seq] = ControlSpec(~cenHarMin[track][seq], ~cenHarMax[track][seq], \lin, ~cenHarRoundValue[track][seq]);
			~cenHarSeqStart[track][seq] = ~presets[index][\cenHarSeqStart];
			~cenHarSeqStop[track][seq] = ~presets[index][\cenHarSeqStop];
			// Ligne ci-dessous évaluée par la GUI - sinon pb de DC et clic
			~cenHarSeq[track][seq] = [0] ++ ~cenHarSpec[track][seq].map(~cenHar[track][seq][~cenHarSeqStart[track][seq]..~cenHarSeqStop[track][seq]]);
			~cenHarSeqSpec[track][seq] = ratHarSeqSpec;

			~delHar[track][seq] = ~presets[index][\delHar];
			~delHarMin[track][seq] = ~presets[index][\delHarMin];
			~delHarMax[track][seq] = ~presets[index][\delHarMax];
			~delHarRoundValue[track][seq] = ~presets[index][\delHarRoundView];
			~delHarSpec[track][seq] = ControlSpec(~delHarMin[track][seq], ~delHarMax[track][seq], \lin, ~delHarRoundValue[track][seq]);
			~delHarSeqStart[track][seq] = ~presets[index][\delHarSeqStart];
			~delHarSeqStop[track][seq] = ~presets[index][\delHarSeqStop];
			// Ligne ci-dessous évaluée par la GUI - sinon pb de DC et clic
			~delHarSeq[track][seq] = [0] ++ ~delHarSpec[track][seq].map(~delHar[track][seq][~delHarSeqStart[track][seq]..~delHarSeqStop[track][seq]]);
			~delHarSeqSpec[track][seq] = ratHarSeqSpec;

			~spaHar[track][seq] = ~presets[index][\spaHar];
			~spaHarMin[track][seq] = ~presets[index][\spaHarMin];
			~spaHarMax[track][seq] = ~presets[index][\spaHarMax];
			~spaHarSpec[track][seq] = ControlSpec(~spaHarMin[track][seq], ~spaHarMax[track][seq], \lin, 1);
			~spaHarSpecStereo[track][seq] = ControlSpec(0, ~spaHarMax[track][seq].min(5), \lin, 1);
			~spaHarSeq[track][seq] = /*~spaHarSpec[track][seq].map(*/ ~spaHar[track][seq][~spaHarSeqStart[track][seq]..~spaHarSeqStop[track][seq]] /*).asInteger*/;
			~spaHarSeqSpec[track][seq] = ControlSpec(0, ~presets[index][\spaHar].size, \lin, 1, 1);
			~spaHarSeqStart[track][seq] = ~presets[index][\spaHarSeqStart];
			~spaHarSeqStop[track][seq] = ~presets[index][\spaHarSeqStop];

			~ampHar[track][seq] = ~presets[index][\ampHar];
			// Ligne ci-dessous évaluée par la GUI - sinon pb de DC et clic
			~ampHarSeqStart[track][seq] = ~presets[index][\ampHarSeqStart];
			~ampHarSeqStop[track][seq] = ~presets[index][\ampHarSeqStop];
			~ampHarSeq[track][seq] = [0.5] ++ ~ampHar[track][seq][~ampHarSeqStart[track][seq]..~ampHarSeqStop[track][seq]];
			~ampHarSeqSpec[track][seq] = ratHarSeqSpec;
			~ampHarRoundValue[track][seq] = ~presets[index][\ampHarRoundView];
		});
	}/*,{
	~harTrig[track][seq] = 0;
	}*/);


	// pas vraiment nécessaire si l'on n'a pas besoin d'update visuel par la suite car mise en place d'un preset sur 1 seq ≠ que celle visualisée
	~proBjorSpec[track][seq] = rtmSeqSpec;


	// Visualisation du preset
	~presetSelection[track][seq] = index.asString;

	// Pour charger les séquences de Buffers ou PresetNotes
	if (~presets[index][\bufSequence].notNil, { ~bufSequence[track][seq] = ~presets[index][\bufSequence] });
	if (~presets[index][\presetNotes].notNil, { ~presetNotes[track][seq] = ~presets[index][\presetNotes] });

	// Données du mode des effets si E à la fin du preset
	if (~presets[index][\fxSynth] == 1 and: {~presetsDontTriggerFX == 0},
		{/*~fxSelect[sv]*/ ~presets[index][\fxSynthNum].do { |y, yi|
			case
			{ ~presets[index][\fxSynthNum][yi] > 0 and: {~presets[index][\fxSynthNum][yi] <= ~numFxSynthDef} }
			{~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['order'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].name ++ ~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxSynthData][yi][a]) };

				if (~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['orderM'].notNil, {
					~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['orderM'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].name ++ ~fxSynthDef[~presets[index][\fxSynthNum][yi]-1].metadata['orderM'][i]).asSymbol] }.do { |atem, a| try { atem.valueAction_(~presets[index][\fxSynthDataM][yi][a]) } }
				});
			}

			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+1) }
			{~eqUnitLib[sv][0].setting = ~presets[index][\fxSynthData][yi] }

			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+2) }
			{~eqUnitLib[sv][1].setting = ~presets[index][\fxSynthData][yi] }

			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+3) }
			{~eqUnitLib[sv][2].setting = ~presets[index][\fxSynthData][yi] }

			// Mettre en place une version non visuelle pour les effets spectraux ?????????
			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+4) }
			{
				// ~fftEQMagValues = ~presets[index][\fxSynthData][yi][0]; // Pourquoi ne marche pas alos que la ligne ci-dessous marche ???
				2.do { |i| ~fftEQMagValues[sv][i] = ~presets[index][\fxSynthData][yi][0][i]; ~fftEQBufsGet.(i, sv) };
				~fftEQSliderLagView[sv].valueAction_(~presets[index][\fxSynthData][yi][1]);
				~fftEQCompChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][2]);
				~fftEQBufChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][3]);
				~fftEQRoutRandView[sv].valueAction_(~presets[index][\fxSynthData][yi][4])
			}
			/* Données pour Spectral EQ
			~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\fxSynthData][2][0]
			[~fftEQMagValues,~fftEQSliderLag,~fftEQCompChoose,~fftEQBufChoose,~fftEQRoutRand]
			*/
			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+5) }
			{
				4.do { |i| ~fftDelfbValues[sv][i] = ~presets[index][\fxSynthData][yi][0][i]; ~fftDelBufsGet.(i, sv) };
				~fftDelSliderLagView[sv].valueAction_(~presets[index][\fxSynthData][yi][1]);
				~fftDelCompChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][2]);
				~fftDelBufChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][3]);
				~fftDelRoutRandView[sv].valueAction_(~presets[index][\fxSynthData][yi][4])
			}
			{ ~presets[index][\fxSynthNum][yi] == (~numFxSynthDef+6) }
			{
				2.do { |i|
					~fftOutChannelValues[sv][i] = ~presets[index][\fxSynthData][yi][0][i];
					~getBinChannelsPan2Outs.(~fftOutChannelValues[sv][i], i, sv); // fonction n'intègre pas d'update visuel à la différence des autres ci-dessus
					~fftOutPlotterView[sv][i].setValue(~fftOutChannelValues[sv][i], false)
				};
				~fftOutSliderLagView[sv].valueAction_(~presets[index][\fxSynthData][yi][1]);
				~fftOutCompChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][2]);
				~fftOutBufChooseView[sv].valueAction_(~presets[index][\fxSynthData][yi][3]);
				~fftOutRoutRandView[sv].valueAction_(~presets[index][\fxSynthData][yi][4])
			};

			// if (~mixFXTrigger == 1, {~mixAllFxView.valueAction_(/*~mixAllFxViewSpec.unmap(*/~mixAllFx)/*.doAction*//*)*/ }); // retiré d'en bas pour permettre d'appliquer le mix, même lorsque de multiples FX en crossfade ont été déclenchés

			// ~fxSelect.do { |i| i.postln }
			// ~fxSelect.do { |i| ~fxSelectView[i].valueAction_(~fxSelect[i]) }
			// ~fxSelectView[yi].valueAction_(~presets[index][\fxSynthNum][yi]);
			// if (~fxSelect[yi] != ~presets[index][\fxSynthNum][yi], {~fxSelectView[yi].valueAction_(~presets[index][\fxSynthNum][yi])} ); // permet d'éviter le redéclenchement du même effet
			if (~fxSelect[sv][yi] != ~presets[index][\fxSynthNum][yi], {

				if (~fxXfadePlaying[sv][yi] == 0 and: {~fxXfadePlayingT[sv][yi].isPlaying == false}, {
					~fxSelectView[sv][yi].valueAction_(~presets[index][\fxSynthNum][yi]);
					{
						~fxXfadePlayingF.value(yi, sv);
						("FX Xfade begins - End in" + ( ~fadeTimeSynthFx[sv] /*/ ~toTempo*/) ++ "s !!!").warn; (~fadeTimeSynthFx[sv]+0.01).wait; "End of FX Xfade - OK to retrigger".inform;
						if (~fxXfadePlayingT[sv][yi].isPlaying == false, { ~fxXfadePlaying[sv][yi] = 0 } );
						// while ( { ~fxXfadePlaying[yi] == 1 }, { loop { if (~fxXfadePlayingT[yi].isPlaying == false, { ~fxXfadePlaying[yi] = 0 } ); 0.2.wait; ~fxXfadePlayingT[yi].isPlaying.postln; } } );
					}.fork;
				},{
					("Could not send FX of Preset" + (~seqSeq[~tracksValue]+1)).postln;
				}); /*"ok".postln;*/ // permet d'éviter le redéclenchement du même effet et d'en déclencher un nouveau si le Xfade n'est pas fini
			});

		};

		if (~mixFXTrigger[sv] == 1, {~mixAllFxView[sv].valueAction_(/*~mixAllFxViewSpec.unmap(*/~mixAllFx[sv])/*.doAction*//*)*/ }); // retiré d'en bas pour permettre d'appliquer le mix, même lorsque de multiples FX en crossfade ont été déclenchés et d'en haut pour éviter de répéter 5x l'action et retrait du wait

		// Ajout pour les effets en série ou en parallèle
		/*~fxInSerieChoose*/
		/*~presets[index][\fxSynthSerPar].do { |y, yi|
		~fxInSerieChooseButtonView[yi].valueAction_(~presets[index][\fxSynthSerPar][yi]);
		};*/

		~presets[index][\fxSynthSerPar].do { |y, yi| // seulement 4 données et non pas 5 comme ~fxSelect

			if (~fxInSerieChoose[sv][yi] != ~presets[index][\fxSynthSerPar][yi], {

				if (~fxXIOfadePlaying[sv][yi] == 0 and: {~fxXIOfadePlayingT[sv][yi].isPlaying == false}, {

					~fxInSerieChooseButtonView[sv][yi].valueAction_( ~presets[index][\fxSynthSerPar][yi] /* préférer y ??? */ );
					// ~presets[~presetSelection[0][~seqSeq[0]].asSymbol][\fxSynthSerPar]
					{
						~fxXIOfadePlayingF.value(yi, sv);
						("FX INOUT Xfade begins - End in" + ( ~fadeTimeSynthFx[sv].min(6) /*/ ~toTempo*/) ++ "s !!!").warn; (~fadeTimeSynthFx[sv].min(6)+0.01).wait; "End of FX INOUT Xfade - OK to retrigger".inform;
						if (~fxXIOfadePlayingT[sv][yi].isPlaying == false, { ~fxXIOfadePlaying[sv][yi] = 0 } );
					}.fork;
				},{
					("Could not send FX INOUT of Preset" + (~seqSeq[~tracksValue]+1)).postln;
				});
			});
		};

		if (~fxInSerieChoose[sv].sum == 4, {
			~fxInSerieChooseAllButtonView[sv].value_(1); ~fxInSerieChoose2AllButtonView[sv].value_(1)
		}, {
			~fxInSerieChooseAllButtonView[sv].value_(0); ~fxInSerieChoose2AllButtonView[sv].value_(0);
		}); // juste pour indiquer que certains effets sont en parallèle
		// Mais PROBLEME car dès qu'il y en a un, celà l'indique pour tout le monde XXX
		// [1, 0, 0, 0 ].includes(1)

	});


	// Benchmark
	/*
	bench { 100000.do { ~fxInSerieChoose != #[ 0, 0, 0, 0, 0 ] } }
	bench { 100000.do { ~fxInSerieChoose.includes(1) } }
	*/

	// Remise des effets ambisoniques à 0 à chaque nouveau preset pour éviter qu'un effet ambisonique interagisse avec la séquence
	// Vérifier si OK en termes de CPU ??? -> voire ci-dessus
	if (~fxASelect[sv] != #[ 0, 0, 0, 0, 0 ] /*.sum > 0 OK*/ /*~fxASelect[sv].includes(1) pas bon*/, {
		~fxASelect[sv].do { |y, yi| ~fxASelectView[sv][yi].valueAction_(0) };
		// ~presets[~presetSelection[0][~seqSeq[0]].asSymbol][\fxASynthNum];
	});


	// Données du mode des effets ambisoniques si S à la fin du preset
	if (~presets[index][\fxASynth] == 1 and: {~presetsDontTriggerFX == 0},
		{/*~fxASelect[sv]*/ ~presets[index][\fxASynthNum].do { |y, yi| var numS, pres = ~presets[index][\fxASynthNum][yi]-1;
			case
			{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(1, ~numFxSynthDef5) }
			{ ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDefA[pres].name.asString[0..2] ++ pres.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
				~fxSynthDef5SwitchTypView[sv][pres].valueAction_(~presets[index][\fxASynthData][yi][1])
			}
			{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(~numFxSynthDef5-1, ~numFxSynthDef6Cum) }
			{ numS = pres-~numFxSynthDef5; ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDefA[pres].name.asString[0..2] ++ numS.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
				~fxSynthDef6SwitchTypView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][1])
			}
			{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(~numFxSynthDef6Cum-1, ~numFxSynthDef7Cum) }
			{ numS = pres-~numFxSynthDef6Cum; ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDefA[pres].name.asString[0..1] ++ numS.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
				~fxSynthDef7SwitchTypView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][1]);
				~fxSynthDef7SwitchTypPCView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][2])
			}
			{ ~presets[index][\fxASynthNum][yi].inclusivelyBetween(~numFxSynthDef7Cum-1, ~numFxSynthDefA) }
			{ numS = pres-~numFxSynthDef7Cum; ~fxSynthDefA[pres].metadata['order'].size.collect { |i| ~fxSynthDefViews[sv][(~fxSynthDefA[pres].name.asString[0..4] ++ numS.asSymbol ++ ~fxSynthDefA[pres].metadata['order'][i]).asSymbol] }.do { |atem, a| atem.valueAction_(~presets[index][\fxASynthData][yi][0][a]) };
				~fxSynthDef8SwitchTypView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][1]);
				~fxSynthDef8SwitchTypPCView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][2]);
				~fxSynthDef8SwitchRevView[sv][numS].valueAction_(~presets[index][\fxASynthData][yi][3])
			};

			// ~fxASelectView[yi].valueAction_(~presets[index][\fxASynthNum][yi]);
			if (~fxASelect[sv][yi] != ~presets[index][\fxASynthNum][yi], {~fxASelectView[sv][yi].valueAction_(~presets[index][\fxASynthNum][yi])} ); // permet d'éviter le redéclenchement du même effet
		};

	});

	// if (~mixFXTrigger == 1, {~mixAllFxView.valueAction_(/*~mixAllFxViewSpec.unmap(*/~mixAllFx)/*.doAction*//*)*/ });

};
);




















{

	// Preset Sort Functions

	~presetSortFunctions = [

		/* Seul moyen pour obtenir une String au lieu d'un Symbole ???
		~presets.keys.asArray.select({ |i| i.asString.split($ )[4].includesAny(~presetSelectionType2[~tracksValue][~seqsValue].flatten) })[0].class
		~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString }.select({ |i| i.asString.split($ )[4].includesAny(~presetSelectionType2[~tracksValue][~seqsValue].flatten) })[0].class

		{~presets.keys.asArray.select({ |i| i.asString.split($ )[4].includesAny(~presetSelectionType2[~tracksValue][~seqsValue].flatten) })}.bench
		{~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString }.select({ |i| i.asString.split($ )[4].includesAny(~presetSelectionType2[~tracksValue][~seqsValue].flatten) })}.bench
		*/

		/*{var list = ~presetList.sort({ |a, b| a.split($|)[3].split($ )[1] < b.split($|)[3].split($ )[1]}); // Type
		list = list.sort({ |a, b| a.split($|)[3].split($ )[2] > b.split($|)[3].split($ )[2]}); // Name
		// list = list.sort({ |a, b| a.split($ )[3] < b.split($ )[3]}); // Buf Folder
		// list = list.sort({ |a, b| a.split($ )[0].asFloat < b.split($ )[0].asFloat}); // BPM
		},*/ // preset Sort BPM Function

		{ |presList| var list = presList.sort({ |a, b| a.split($|)[3] < b.split($|)[3]}); // Type
			// list = list.sort({ |a, b| a.split($ ).last < b.split($ ).last}); // Name
			list = list.sort({ |a, b| a.split($|)[0].asFloat < b.split($|)[0].asFloat}) }, // preset Sort timing (sec) Function

		{ |presList| var list = presList.sort({ |a, b| a.split($|)[3] < b.split($|)[3]}); // Type
			// list = list.sort({ |a, b| a.split($ ).last < b.split($ ).last}); // Name
			list = list.sort({ |a, b| a.split($|)[1].asInteger < b.split($|)[1].asInteger}) }, // preset Sort Ev Function

		{ // var list = ~presetList.sort({ |a, b| a.split($ ).last < b.split($ ).last}); // Name
			|presList| var list = presList.sort({ |a, b| a.split($|)[3] < b.split($|)[3]}); // Type
			list = list.sort({ |a, b| a.split($|)[2] < b.split($|)[2]}) }, // preset Sort Buf Folder Function

		{ // var list = ~presetList.sort({ |a, b| a.split($ )[2] < b.split($ )[2]}); // Buf Folder
			|presList| var list = presList.sort({ |a, b| a.split($ ).last < b.split($ ).last}); // Name
			list = list.sort({ |a, b| a.split($|)[3] < b.split($|)[3]}) }, // preset Sort Type Function

		/*
		~presetList.sort({ |a, b| a.split($ )[2] < b.split($ )[2]}); // preset Sort Buf Folder Function
		~presetList[70].split($|)[2]
		*/

		{ |presList| var list = presList.sort({ |a, b| a.split($ ).last < b.split($ ).last}); // Name
			// list = list.sort({ |a, b| a.split($ )[0].asFloat < b.split($ )[0].asFloat}); // BPM
			list = list.sort({ |a, b| a.split($|)[0].asFloat < b.split($|)[0].asFloat}); // SEC
			list = list.sort({ |a, b| a.split($|)[3] < b.split($|)[3]}) }, // preset Sort Type Function 2

		// Besoin de rien faire pour le nom car normalement unique ??? par précaution tri au préalable sur le type
		{ |presList| var list = presList.sort({ |a, b| a.split($|)[3] < b.split($|)[3]}); // Type
			list = list.sort({ |a, b| a.split($ ).last < b.split($ ).last}) }, // preset Sort Name Function

		/*
		~presetSortFunctions = [
		{ ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString }.sort({ |a, b| a.split($ )[0].asFloat < b.split($ )[0].asFloat}) }, // preset Sort BPM Function
		{ ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString }.sort({ |a, b| a.split($|)[0].split($ )[1].asFloat < b.split($|)[0].split($ )[1].asFloat}) }, // preset Sort timing (sec) Function
		{ ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString }.sort({ |a, b| a.split($e)[0].split($ )[2].asInteger < b.split($e)[0].split($ )[2].asInteger}) }, // preset Sort Ev Function
		{ ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString }.sort({ |a, b| a.split($ )[4] < b.split($ )[4]}) }, // preset Sort Type Function
		{ ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString }.sort({ |a, b| a.split($ )[5] < b.split($ )[5]}) }, // preset Sort Name Function
		*/

		/*
		Pas de fonction pour réarranger un Set comme rand - Autre manière plus simple de faire
		~presets.keys.rand
		~presets.keys.asArray.class.perfectShuffle
		*/
		// { Array.fill(~presets.keys.size, Pshuf(~presets.keys.asArray, inf).iter) } // preset Rand Function
		// Pourquoi la fonction ci-dessus ne marche pas ??? pb de classe ??? Car les éléments à l'intérieur de l'Array sont des symboles
		{ |presList| var list = Pshuf(presList, inf).asStream; presList.size.collect({list.next.asString})}
	];


	/*
	~presets.keys.asArray[0].asString
	~presets.keys.asArray[0].asString.split($ )[0].asFloat // -> BPM
	~presets.keys.asArray[0].asString.split($|)[0].split($ )[1].asFloat // -> Nb de sec (à / 2 pour obtenir le nb de secondes) OU
	~presets.keys.asArray[0].asString.split($e)[0].split($ )[2].asInteger // -> Nb d'évènements
	~presets.keys.asArray[0].asString.split($t)[0].split($ )[3].asFloat	// TEMPO
	~presets.keys.asArray[0].asString.split($ )[4] // -> Type / catégorie de son (T / B...)
	~presets.keys.asArray[0].asString.split($ )[5] // -> Type de son
	*/


	~presetStoringName = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~presetSelection = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~presetSelectionPrevent = 0;
	~tabPresetSelectionDetached = 0;


	~presetSelectionTabbedView = TabbedView2(~patComp, Rect(2*~xSizeMul, 2*~ySizeMul, 362*~xSizeMul, 207*~ySizeMul))
	.lockPosition_(true)
	.lockEdges_(true)
	.backgrounds_([Color(0.8, 0.8, 0.8)])
	.unfocusedColors_([Color.white])
	.labelColors_([Color.blue])
	.font_(Font("Verdana",11*~fontSizeMul))
	.tabHeight_(22*~ySizeMul).tabWidth_(if (~presetsFileName2.isNil, {60*~xSizeMul}, {30*~xSizeMul}) )/*.tabCurve_(10)*/.resize_(5);

	~tabPresetSelection = ~presetSelectionTabbedView.add( if (~presetsFileName2.isNil, {"Preset"}, {"Pre"} ) /*, scroll:true*/).useDetachIcon_(false)
	.onChangeParent_({ |i|
		if (~tabPresetSelectionDetached == 0, {
			~tabPresetSelectionDetached = 1; ~presetSelectionPrevent = 1;
			// ~tabPresetSelection.view.resizeTo(394,300); // ou
			// ~presetSelectionTabbedView.view.bounds_(Rect(2, 2, 394, 300)); // ne marche pas ?????????
			// ~presetSelectionTabbedView.refresh;
		}, {
			~tabPresetSelectionDetached = 0; ~presetSelectionPrevent = 0;
			// ~presetSelectionTabbedView.view.resizeTo(394,207); // ou
			// ~presetSelectionTabbedView.view.bounds_(Rect(2, 2, 394, 207));
			// ~presetSelectionTabbedView.refresh;
		});

		if (~presetSelectionPrevent == 0, { "Impact on ListView Activated".postln /*even with Cmd Key*/}, { "Impact on ListView Desactivated".postln} )
	});
	// .onAfterChangeParent_({ |view| }); ~tabPresetSelectionDetached.postln});

	// Comment mettre le ~presetSelectionPrevent à 1 lorsque la touche Cmd est enfoncée dans la nouvelle window de la tab créée et empêcher l'action sur la ListView ????????????
	// Actuellement le fait de cliquer sur le DetachIcon permet de basculer entre un ~presetSelectionPrevent à 1 ou 0
	/*
	~tabPresetSelection.view.keyDownAction_({ |view, char, mod, uni, key, key2| if (key2 == 16777249, {~presetSelectionPrevent = 1; "ok".postln} ); });
	~presetSelectionTabbedView.view.keyDownAction_({ |view, char, mod, uni, key, key2| if (key2 == 16777249, {~presetSelectionPrevent = 1; "ok".postln} ); });
	*/

	/*
	Pour déclencher ~presetSelectionPrevent, mais désormais OK avec onAfterChangeParent
	~presetSelectionPreventView = RoundButton(~patComp, Rect(110, 3, 70, 16))
	.states_([["Prev Sel", Color.white, Color.red], ["Prev Sel", Color.black, Color.green]])
	.font_(Font("Verdana",11))
	.action_({ |i| ~presetSelectionPrevent = i.value;
	});
	*/


	~monoSpaceFont = "Monaco";
	/*
	Andale Mono
	Courier New // pour avoir un peu plus d'espace vs Courier
	Menlo
	Monaco
	PT Mono
	*/
	// /*"Osaka"*/ /*"Lantinghei TC"*/ // Pas MS


	if (~presetsFileName2.isNil, {

		~presetList = ~presets.keys.asArray.collect{ |i| i.asString };

	},{
		~presetList1 = ~presets1.keys.asArray.collect{ |i| i.asString };
		~presetList2 = ~presets2.keys.asArray.collect{ |i| i.asString };
		~presetList = ~presetList1 ++ ~presetList2;

		~tabPresetSelection2 = ~presetSelectionTabbedView.add("Set").useDetachIcon_(false)
		.onChangeParent_({ |i|
			if (~tabPresetSelection2Detached == 0, {
				~tabPresetSelection2Detached = 1; ~presetSelectionPrevent = 1;
			}, {
				~tabPresetSelection2Detached = 0; ~presetSelectionPrevent = 0;
			});
			if (~presetSelectionPrevent == 0, { "Impact on ListView Activated".postln}, { "Impact on ListView Desactivated".postln} )
		});

		~tabPresetSelection.focusAction = { // ~presetSelectionView.doAction; // Décommenter pour charger un preset quand changement de tab de presets
			~currentTabPresetSelection = 0;
			/*var pres = ~presetSelectionView.item.asSymbol; ~currentTabPresetSelection = 0; ~presetGetFunction.(pres);
			~presetStoringNameView.value_(~presetSelectionView.item.split($|)[3][1..30]);*/ // Prise en compte du nouveau format des fichiers avec les espaces
			// [1..30] pour éviter le 1er espace - A optimiser ??????????????????????????????????????????????????????????????? ~nbTotalBeatsView.doAction; };

			// Ci-dessous -> rappel non pas du preset en entier, mais seulement du ~presetStoringNameView & du ~nbTotalBeatsView pour enregistrer les fichiers
			/*
			if (~updateVisualPreset == 0, {
			~nbEvents[~tracksValue][~seqsValue] = (6.collect({|i| (~presets[pres][\pBeat]/*~pBeat[~tracksValue][~seqsValue]*/[i] > 0).if ({~presets[pres][\nbBeat]/*~nbBeat[~tracksValue][~seqsValue]*/[i]}, {0}) })).sum;
			~nbTotalBeats[~tracksValue][~seqsValue] = ~presets[pres][\nbTotalBeats] /*~nbTotalBeatsSpec.map(view.value)*/;
			~nbTotalBeatsView.value_(~nbTotalBeatsSpec.unmap(~presets[pres][\nbTotalBeats]));
			~nbTotalBeatsView.string = ("% Beats - % Ev in %s - ABPM: %").format(~nbTotalBeats[~tracksValue][~seqsValue] * ~presets[pres][\rtmMul] /*~rtmMul[~tracksValue][~seqsValue]*/, ~nbEvents[~tracksValue][~seqsValue], (~nbTotalBeats[~tracksValue][~seqsValue] / ~toTempo * ~presets[pres][\rtmMul] /*~rtmMul[~tracksValue][~seqsValue]*/).round(0.01), ( ~nbEvents[~tracksValue][~seqsValue] / ~nbTotalBeats[~tracksValue][~seqsValue] * ~toTempo * 60 * ~presets[pres][\rtmMul] /*~rtmMul[~tracksValue][~seqsValue]*/.reciprocal).round(0.01));
			});*/
		};
		~tabPresetSelection2.focusAction = { // ~presetSelection2View.doAction; // Décommenter pour charger un preset quand changement de tab de presets
			~currentTabPresetSelection = 1;
			/*var pres = ~presetSelection2View.item.asSymbol; ~currentTabPresetSelection = 1; ~presetGetFunction.(pres);
			~presetStoringNameView.value_(~presetSelection2View.item.split($|)[3][1..30]);*/
			/*
			if (~updateVisualPreset == 0, {
			~nbEvents[~tracksValue][~seqsValue] = (6.collect({|i| (~presets[~presetSelection2View.item.asSymbol][\pBeat]/*~pBeat[~tracksValue][~seqsValue]*/[i] > 0).if ({~presets[pres][\nbBeat]/*~nbBeat[~tracksValue][~seqsValue]*/[i]}, {0}) })).sum;
			~nbTotalBeats[~tracksValue][~seqsValue] = ~presets[pres][\nbTotalBeats] /*~nbTotalBeatsSpec.map(view.value)*/;
			~nbTotalBeatsView.value_(~nbTotalBeatsSpec.unmap(~presets[pres][\nbTotalBeats]));
			~nbTotalBeatsView.string = ("% Beats - % Ev in %s - ABPM: %").format(~nbTotalBeats[~tracksValue][~seqsValue] * ~presets[pres][\rtmMul] /*~rtmMul[~tracksValue][~seqsValue]*/, ~nbEvents[~tracksValue][~seqsValue], (~nbTotalBeats[~tracksValue][~seqsValue] / ~toTempo * ~presets[pres][\rtmMul] /*~rtmMul[~tracksValue][~seqsValue]*/).round(0.01), ( ~nbEvents[~tracksValue][~seqsValue] / ~nbTotalBeats[~tracksValue][~seqsValue] * ~toTempo * 60 * ~presets[pres][\rtmMul] /*~rtmMul[~tracksValue][~seqsValue]*/.reciprocal).round(0.01));
			});*/
		};

		~presetSelection2View = ListView(~tabPresetSelection2, Rect(0, 0, 362*~xSizeMul, 187*~ySizeMul))
		.background_(Color./*clear*/red(0.4, alpha: 0.8))
		.hiliteColor_(Color.yellow(alpha: 1))
		.selectedStringColor_(Color.black)
		.stringColor_(Color.white)
		.font_(Font(/*"Verdana"*/ ~monoSpaceFont /*"Courier New"*/, (11*~fontSizeMul).asInteger /*, bold: true*/))
		.resize_(5) // Pour ajuster la taille du ListView selon le TabView
		.beginDragAction_({ arg listView; listView.items[ listView.value ].postln; }) // pour faire le drag and drop
		.action_({ |menu| var presetSym;
			if (~presetSelectionPrevent == 0, { // ~presetSelectionView./*dragLabel*/keyModifiersChanged.postln; // Comment arrêter la sélection si on fait un drag n drop -> OK

				if (~followPreset == 1, {
					~seqsView.valueAction_(~seqsValue+1); ~presetSeqRangeView.valueAction_(~presetSeqRangeSpec.unmap([~seqsValue, ~seqsValue+1]));
					if (~currentTab == 0, {
						~seqComp5.visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-4)*20*~ySizeMul).max(0).min(~seqComp5MaxVisibleOrigin)
					},{
						~seqCompG1[~tracksValue].visibleOrigin = 0@( (~presetSeqStart[~tracksValue]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin)
					});
				});

				// ~presetGetFunction.value(menu.item.asSymbol, ~tracksValue, ~seqsValue);
				~presetSelection[~tracksValue][~seqsValue] = menu.item;
				presetSym = ~presetSelection[~tracksValue][~seqsValue].asSymbol;
				if (~updateVisualPreset == 0, {~presetGetFunction.value(presetSym)}, {~presetGetFunctionQuick.value(presetSym, ~tracksValue, ~seqsValue)});
				~nbTotalBeatsView.doAction; // pour mettre à jour le BPM si le ~rtmMul a changé ???
				// ~presetStoringNameView.value_(menu.item.split($|)[3].split($ )[1] ++ " " ++ menu.item.split($|)[3].split($ )[2] );
				~presetStoringNameView.value_(~presetSelection[~tracksValue][~seqsValue].split($|)[3][1..30]); // Prise en compte du nouveau format des fichiers avec les espaces
				// [1..30] pour éviter le 1er espace - A optimiser ???????????????????????????????????????????????????????????????
				~presetsEventSource.fire(presetSym);

				// ~presets[~presetSelection2View.item.asSymbol][\fxSynth].postln; // juste pour des test enregistrements FX

				// seulement quand la 2ème séquence est visualisée ?
				~presetSeqTextView[~seqsValue].string = ~presetSelection[~tracksValue][~seqsValue];
				// Action sur le tab Global
				~presetSeqTextViewG[~tracksValue][~seqsValue].string = ~presetSelection[~tracksValue][~seqsValue];
			});
		});
	});


	// si hauteur > de 20 pixels, la barre verticale de navigation devient utile
	~presetSelectionView = ListView(~tabPresetSelection, Rect(0, 0, 362*~xSizeMul, 187*~ySizeMul))
	.background_(Color./*clear*/red(0.4, alpha: 0.8))
	.hiliteColor_(Color.yellow(alpha: 1))
	.selectedStringColor_(Color.black)
	.stringColor_(Color.white)
	.font_(Font(/*"Verdana"*/ ~monoSpaceFont /*"Courier New"*/, (11*~fontSizeMul).asInteger /*, bold: true*/))
	.resize_(5) // Pour ajuster la taille du ListView selon le TabView
	.beginDragAction_({ arg listView; listView.items[ listView.value ].postln; }) // pour faire le drag and drop
	.action_({ |menu| var presetSym;
		if (~presetSelectionPrevent == 0, { // ~presetSelectionView./*dragLabel*/keyModifiersChanged.postln; // Comment arrêter la sélection si on fait un drag n drop -> OK
			// ~presetGetFunction.value(menu.item.asSymbol, ~tracksValue, ~seqsValue);
			~presetSelection[~tracksValue][~seqsValue] = menu.item;
			presetSym = ~presetSelection[~tracksValue][~seqsValue].asSymbol;
			if (~updateVisualPreset == 0, {~presetGetFunction.value(presetSym)}, {~presetGetFunctionQuick.value(presetSym, ~tracksValue, ~seqsValue)});
			~nbTotalBeatsView.doAction; // pour mettre à jour le BPM si le ~rtmMul a changé ???
			// ~presetStoringNameView.value_(menu.item.split($|)[3].split($ )[1] ++ " " ++ menu.item.split($|)[3].split($ )[2] );
			~presetStoringNameView.value_(~presetSelection[~tracksValue][~seqsValue].split($|)[3][1..30]); // Prise en compte du nouveau format des fichiers avec les espaces
			// [1..30] pour éviter le 1er espace - A optimiser ???????????????????????????????????????????????????????????????

			if (~presetsFileName2.isNil, {~presetsEventSource.fire(presetSym)});

			// seulement quand la 2ème séquence est visualisée ?
			~presetSeqTextView[~seqsValue].string = ~presetSelection[~tracksValue][~seqsValue];
			// Action sur le tab Global
			~presetSeqTextViewG[~tracksValue][~seqsValue].string = ~presetSelection[~tracksValue][~seqsValue];

			// [\rtmBlock, \proBlock, \synBlock, \spaBlock, \legBlock, \envBlock, \bufBlock, \ampBlock, \ratBlock, \rat2Block, \offBlock, \strBlock, \str2Block, \cenBlock, \cen2Block, \panBlock, \delBlock, \outLBlock, \outRBlock, \fxLBlock, \fxRBlock].do {|i| currentEnvironment[i][~tracksValue] = 1}; // ~ampBlock // intégré directement dans les boutons

			// ~seqBlock[~tracksValue] = 1; // Pour remettre la séquence à 0 quand le preset change (pour le pattern)

			// juste pour vérifier que le format de preset de [\fxSynthSerPar] est bien [ 1, 1, 1, 1 ]
			// if (~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol].notNil, {~presets[~presetSelection[~tracksValue][~seqsValue].asSymbol][\fxSynthSerPar].postln});
		});
	});


	~presetStoringNameView = TextField(~patComp, Rect(68*~xSizeMul, 2*~ySizeMul, 212*~xSizeMul, 20*~ySizeMul)/*(197, 214, 116, 20)*/)
	.string_("T PresetName")
	.action_({|field| ~presetStoringName[~tracksValue][~seqsValue] = field.value.asSymbol })
	.font_(Font("Verdana",10*~fontSizeMul))
	.background_(Color.grey(0.3))
	.stringColor_(Color.white);

	// ~presetSelectionButton = 0; // obligé de l'initialiser car le .valueAction ne le fait pas ??? -> à supprimer
	~presetSelectionButtonView = RoundButton(~patComp, Rect(367*~xSizeMul, 2*~ySizeMul, 22*~xSizeMul, 20*~ySizeMul)/*(377, 214, 20, 20)*/)
	.states_([["NS", Color.black, Color.green],["OS", Color.white, Color.red]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({|i| ~presetSelectionButton = i.value })
	.value_(0).doAction;


	if (~presetsFileName2.isNil, {

		// Un faux BPM est enregistré si la touche Random n'a pas été déclenché car c'est cette fonction qui actualise le nb de valeurs dans le multislider
		~presetStoringButtonView = RoundButton(~patComp, Rect(325*~xSizeMul, 2*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul)/*(345, 214, 30, 20)*/)
		.states_([["Store", Color.black, Color.green]])
		.font_(Font("Verdana",10*~fontSizeMul))
		.action_({ var presetList, currentItem, currentItemIndex, newItem;
			~presetStoringNameView.doAction;
			// ligne ci-dessous nécessaire pour pouvoir enregistrer un preset dès le début et qui n'a pas un nb d'Ev de 0 ???
			~nbTotalBeatsView.doAction;
			/* Version brute sans indication du BPM, du nb d'Ev ...
			~presetSetFunction.value((~presetStoringName[~tracksValue][~seqsValue]).asSymbol, ~tracksValue, ~seqsValue).writeArchive(~presetspath);
			*/
			// ~presetsFile.writeItem(a)

			newItem =
			( // Nouvelle version des noms de Presets formatés avec des espaces 1 mais en gardant les separateurs | et format Approprié de la durée
				// A Optimiser ou créer une liste à partir de la quelle le nom est retrouvé ?????????
				if ( (~nbTotalBeats[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue] / ~toTempo).round(0.1).asString.contains("."), {
					(~nbTotalBeats[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue] / ~toTempo).round(0.1).asString.padLeft(4, " ")
				},{
					(~nbTotalBeats[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue] / ~toTempo).round(0.1).asString.padLeft(2, " ") ++ ".0"
				})
				++ "| " ++
				~nbEvents[~tracksValue][~seqsValue].asString.padLeft(3, " ")
				++ "| " ++
				if (~arrayOfFolderNamesALL[~bufFolderValue[~tracksValue][~seqsValue]].isNil, {
					~arrayOfFolderNamesALL.last /*[69]*/
				},{
					~arrayOfFolderNamesALL[~bufFolderValue[~tracksValue][~seqsValue]][0..9] // Protection pour nil pour ~presets[item][\bufFolderView] dans le cas de synthèses
				}).padRight(10, " ")
				++ "| " ++
				~presetStoringName[~tracksValue][~seqsValue]
				/* item.asString.split($|).last.split($ )[1].padRight(3, " ") + item.asString.split($ ).last */ // Ancienne façon de récupérer le nom - A supprimer XXXXXXXXX
			);

			if (~savePresetFile == 0, { // Pour éviter de sauvegarder le fichier de preset à chaque fois
				// L'enregistrement rajoute environ 8 secondes

				// ~presetspath = (PathName.new(~currentPath).pathOnly ++ ~presetsFileName);
				~presetspath = if (~presetsPath.isNil, { (PathName.new(~currentPath).pathOnly ++ ~presetsFileName) }, {~presetspath = ~presetsPath});
				~presetsFile = ZArchive.write(~presetspath);
				~presetsFile.writeItem(~presetSetFunction.(~presets, newItem.asSymbol));
				~presetsFile.writeClose;
				/*~presetsFileW = ZArchive.read(~presetspath);
				~presets = ~presetsFileW.readItem;
				~presetsFileW.close;*/

				// Code ci-dessus pour ZArchive et ci-dessous pour Object
				// ~presetSetFunction.value(( (~nbEvents[~tracksValue][~seqsValue] / ~nbTotalBeats[~tracksValue][~seqsValue] * ~toTempo * 60 * ~rtmMul[~tracksValue][~seqsValue].reciprocal).round(0.1).asString ++ " BPM-" ++ ~nbEvents[~tracksValue][~seqsValue].asString ++ " Ev " ++ ~presetStoringName[~tracksValue][~seqsValue] ++ " " ++ ~toTempo[~tracksValue][~seqsValue].asString ++ "").asSymbol, ~tracksValue, ~seqsValue).writeArchive(~presetspath);
				// ~presets = Object.readArchive(~presetspath);

			},{
				~presetSetFunction.(~presets, newItem.asSymbol);
			});

			// Le tri rajoute environ 2 secondes avec + de 1000 refs
			// ~presetList = ~presets./*keys.*/size.collect{ |i| ~presets.keys.asArray[i].asString };
			/*{ var presetList; ~presetList = ~presets./*keys.*/size.collect{ |i| ~presets.keys.asArray[i].asString };
			presetList = ~presetSortFunctions[~presetSortView.value].value; }.bench*/
			~presetList = ~presets.keys.asArray.collect{ |i| i.asString };
			presetList = ~presetSortFunctions[~presetSortView.value].value(~presetList);

			~presetSelectionView.items_(presetList);

			if (presetList.size > 1, {
				if (~presetSelectionButton == 1, {
					// renvoie l'ancien preset
					currentItem = ~presetSelectionView.item;
					currentItemIndex = /*~presetSelectionView.items*/ presetList.find([currentItem]);
					~presetSelectionView.valueAction_(currentItemIndex);
				},{
					// renvoie le nouveau preset
					currentItemIndex = /*~presetSelectionView.items*/ presetList.find([ newItem
						// ( /*(~nbEvents[~tracksValue][~seqsValue] / ~nbTotalBeats[~tracksValue][~seqsValue] * ~toTempo * 60 * ~rtmMul[~tracksValue][~seqsValue].reciprocal).round(0.1).asString ++ "b| " ++*/ (~nbTotalBeats[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue] / ~toTempo).round(0.1).asString ++ "s| " ++ ~nbEvents[~tracksValue][~seqsValue].asString ++ "e| " ++ /*~toTempo[~tracksValue][~seqsValue].round(0.1).asString ++ "t| "*/ ~arrayOfFolderNamesALL[~bufFolderValue[~tracksValue][~seqsValue]][0..14] ++ "| " ++ ~presetStoringName[~tracksValue][~seqsValue])
					]);
					~presetSelectionView.value_(currentItemIndex); // ~presetSelectionView.valueAction_(currentItemIndex) -> à supprimer
			}) });

			"Preset stored ->".postln;
			newItem.postln;

		});

		~presetRemoveButtonView = RoundButton(~patComp, Rect(284*~xSizeMul, 2*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul) /*(314, 214, 30, 20)*/)
		.states_([["Delete", Color.white, Color.red]])
		.font_(Font("Verdana",10*~fontSizeMul))
		.action_({ var presetList, presetListValue, presetListName; // + nécessaire
			if (~presetList.size > 0 /*~presetSelectionView.value.notNil*/, {
				presetListValue = ~presetSelectionView.value;
				presetListName = ~presetSelectionView.item;
				~presets.removeAt(presetListName.asSymbol);

				if (~savePresetFile == 0, {
					~presetsFile = ZArchive.write(~presetspath);
					~presetsFile.writeItem(~presets);
					~presetsFile.writeClose;
					~presetsFileW = ZArchive.read(~presetspath);
					~presets = ~presetsFileW.readItem;
					~presetsFileW.close;
					// Code ci-dessus pour ZArchive et ci-dessous pour Object
					// ~presets.writeArchive(~presetspath);

				});

				// presetList = ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString }.sort({ |a, b| a.split($ )[0].asFloat < b.split($ )[0].asFloat});
				~presetList = ~presets.keys.asArray.collect{ |i| i.asString };
				presetList = ~presetSortFunctions[~presetSortView.value].value(~presetList);
				~presetSelectionView.items_(presetList);
				if (presetListValue > 0, {~presetSelectionView.value_(presetListValue-1) });

				"Preset deleted ->".postln;
				presetListName.postln;

			})
		});

		~presetSortViewView = View(~patComp, Rect(2*~xSizeMul, 214*~ySizeMul, 52*~xSizeMul, 20*~ySizeMul));

		~presetSortView = PopUpMenu.new(~presetSortViewView, Rect(0, 0, 80*~xSizeMul, 20*~ySizeMul))
		.action_({ |menu|
			var currentItem, currentItemIndex, presetList;
			currentItem = ~presetSelectionView.item;
			presetList = ~presetSortFunctions[menu.value].value(~presetList);
			~presetSelectionView.items_(presetList);
			currentItemIndex = /*~presetSelectionView.items*/ ~presetList.find([currentItem]);
			~presetSelectionView.value_(currentItemIndex);
			/*
			~presetSelectionView.item
			// Recherche du preset dans une liste en donnant l'index
			~presetSelectionView.items.find([~presetSelectionView.item])
			*/
		})
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(Color.black)
		.font_(Font("Verdana",9*~fontSizeMul));

		~retriggerPreset = RoundButton(~patComp, Rect(116*~xSizeMul, 214*~ySizeMul, 60*~xSizeMul, 20*~ySizeMul) /*(64, 214, 40, 20)*/)
		.states_([["Cur P", Color.white, Color.red]])
		.font_(Font("Verdana",10*~fontSizeMul, bold: true))
		.action_({ |i| ~presetSelectionView.valueAction_(~presetSelectionView.selection[0]);
		});


	},{


		~presetStoringButtonView = RoundButton(~patComp, Rect(325*~xSizeMul, 2*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul) /*(345, 214, 30, 20)*/)
		.states_([["Store", Color.black, Color.green]])
		.font_(Font("Verdana",10*~fontSizeMul))
		.action_({ var presetList, currentItem, currentItemIndex, newItem;
			~presetStoringNameView.doAction;
			~nbTotalBeatsView.doAction;

			newItem =
			( // Nouvelle version des noms de Presets formatés avec des espaces 1 mais en gardant les separateurs | et format Approprié de la durée
				// A Optimiser ou créer une liste à partir de la quelle le nom est retrouvé ?????????
				if ( (~nbTotalBeats[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue] / ~toTempo).round(0.1).asString.contains("."), {
					(~nbTotalBeats[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue] / ~toTempo).round(0.1).asString.padLeft(4, " ")
				},{
					(~nbTotalBeats[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue] / ~toTempo).round(0.1).asString.padLeft(2, " ") ++ ".0"
				})
				++ "| " ++
				~nbEvents[~tracksValue][~seqsValue].asString.padLeft(3, " ")
				++ "| " ++
				if (~arrayOfFolderNamesALL[~bufFolderValue[~tracksValue][~seqsValue]].isNil, {
					~arrayOfFolderNamesALL.last /*[69]*/
				},{
					~arrayOfFolderNamesALL[~bufFolderValue[~tracksValue][~seqsValue]][0..9] // Protection pour nil pour ~presets[item][\bufFolderView] dans le cas de synthèses
				}).padRight(10, " ")
				++ "| " ++
				~presetStoringName[~tracksValue][~seqsValue]
				/* item.asString.split($|).last.split($ )[1].padRight(3, " ") + item.asString.split($ ).last */ // Ancienne façon de récupérer le nom - A supprimer XXXXXXXXX
			);

			if (~savePresetFile == 0, { // Pour éviter de sauvegarder le fichier de preset à chaque fois
				// L'enregistrement rajoute environ 8 secondes

				// ~presetspath2 = (PathName.new(~currentPath).pathOnly ++ ~presetsFileName2);
				~presetspath2 = if (~presetsPath2.isNil, { (PathName.new(~currentPath).pathOnly ++ ~presetsFileName2) }, {~presetspath2 = ~presetsPath2});
				~presetsFile2 = ZArchive.write(~presetspath2);
				~presetsFile2.writeItem(~presetSetFunction.(~presets2, newItem.asSymbol));
				~presetsFile2.writeClose;

			},{
				~presetSetFunction.(~presets2, newItem.asSymbol);
			});

			~presetList2 = ~presets2.keys.asArray.collect{ |i| i.asString };
			presetList = ~presetSortFunctions[~presetSortView.value].value(~presetList2);

			~presetSelection2View.items_(presetList);

			if (presetList.size > 1, {
				if (~presetSelectionButton == 1, {
					// renvoie l'ancien preset
					currentItem = ~presetSelection2View.item;
					currentItemIndex = /*~presetSelectionView.items*/ presetList.find([currentItem]);
					~presetSelection2View.valueAction_(currentItemIndex);
				},{
					// renvoie le nouveau preset
					currentItemIndex = /*~presetSelectionView.items*/ presetList.find([ newItem]);
					~presetSelection2View.value_(currentItemIndex);
				})
			});

			~presets = ~presets ++ ~presets2;
			// ~presets[~presetSelection2View.item.asSymbol][\fxSynthNum].postln;

			"New Preset stored ->".postln;
			newItem.postln;

		});

		~presetRemoveButtonView = RoundButton(~patComp, Rect(284*~xSizeMul, 2*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul) /*(314, 214, 30, 20)*/)
		.states_([["Delete", Color.white, Color.red]])
		.font_(Font("Verdana",10*~fontSizeMul))
		.action_({ var presetList, presetListValue, presetListName; // + nécessaire
			if (~presetList.size > 0 and: { ~currentTabPresetSelection == 1 } /*~presetSelectionView.value.notNil*/, {
				presetListValue = ~presetSelection2View.value;
				presetListName = ~presetSelection2View.item;
				~presets2.removeAt(presetListName.asSymbol);

				if (~savePresetFile == 0, {
					~presetsFile2 = ZArchive.write(~presetspath2);
					~presetsFile2.writeItem(~presets2);
					~presetsFile2.writeClose;
					~presetsFileW2 = ZArchive.read(~presetspath2);
					~presets2 = ~presetsFileW2.readItem;
					~presetsFileW2.close;
					// Code ci-dessus pour ZArchive et ci-dessous pour Object
					// ~presets.writeArchive(~presetspath);

				});

				// presetList = ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString }.sort({ |a, b| a.split($ )[0].asFloat < b.split($ )[0].asFloat});
				~presetList2 = ~presets2.keys.asArray.collect{ |i| i.asString };
				presetList = ~presetSortFunctions[~presetSortView.value].value(~presetList2);
				~presetSelection2View.items_(presetList);
				if (presetListValue > 0, {~presetSelection2View.value_(presetListValue-1) });

				"Preset deleted ->".postln;
				presetListName.postln;

			})
		});

		~presetSortViewView = View(~patComp, Rect(2*~xSizeMul, 214*~ySizeMul, 52*~xSizeMul, 20*~ySizeMul));

		~presetSortView = PopUpMenu.new(~presetSortViewView, Rect(0, 0, 80*~xSizeMul, 20*~ySizeMul))
		.action_({ |menu|
			var currentItem, currentItemIndex, presetList, view, list;
			if ( ~currentTabPresetSelection == 0, { view = \presetSelectionView.envirGet; list = \presetList1.envirGet },{ view = \presetSelection2View.envirGet; list = \presetList2.envirGet });
			currentItem = view.item;
			presetList = ~presetSortFunctions[menu.value].value(list);
			view.items_(presetList);
			currentItemIndex = view.items.find([currentItem]);
			view.value_(currentItemIndex);
		})
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(Color.black)
		.font_(Font("Verdana",9*~fontSizeMul));

		~retriggerPreset = RoundButton(~patComp, Rect(150*~xSizeMul, 214*~ySizeMul, 26*~xSizeMul, 20*~ySizeMul) /*(64, 214, 40, 20)*/)
		.states_([["Cur", Color.white, Color.red]])
		.font_(Font("Verdana",10*~fontSizeMul, bold: true))
		.action_({ |i| var view; if ( ~currentTabPresetSelection == 0, { view = \presetSelectionView.envirGet; },{ view = \presetSelection2View.envirGet; });
			view.valueAction_(view.selection[0]);
		});

	});


	~presetsDontTriggerFXView = RoundButton(~patComp, Rect(262*~xSizeMul, 214*~ySizeMul, 60*~xSizeMul, 20*~ySizeMul) /*(64, 214, 40, 20)*/)
	.states_([["Trig FX", Color.black, Color.green], ["NTrigFX", Color.white, Color.red]])
	.font_(Font("Verdana",10*~fontSizeMul/*, bold: true*/))
	.action_({ |i| ~presetsDontTriggerFX = i.value });

	~allDirView = RoundButton(~patComp, Rect(324*~xSizeMul, 214*~ySizeMul, 20*~xSizeMul, 20*~ySizeMul))
	.states_([["\>", Color.black, ~popUpMenuBackgroundColor], ["\<", Color.white, Color.red]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({ |i| ~allDir = i.value;

		[ ~rtmDirView, ~proDirView, ~synDirView, ~spaDirView, ~legDirView, ~envDirView, ~bufDirView, ~ampDirView, ~ratDirView, ~rat2DirView, ~offDirView, ~off2DirView, ~off3DirView, ~off4DirView, ~strDirView, ~cenDirView, ~str2DirView, ~cen2DirView, ~panDirView, ~delDirView, ~outLDirView, ~outRDirView, ~fxLDirView, ~fxRDirView ].do { |i| i.valueAction_(~allDir) };

		/*envir[dir][~tracksValue][~seqsValue] = i.value;
		envir[block][~tracksValue] = 1;
		if (~patFlag == 1, {~seqs.do {|sequence| envir[dir][~tracksValue][sequence] = i.value} });*/

	});





	~presetsEventSource = EventSource();
	~presetsListMemoryNb = 40;
	~presetsCollection = 0 ! 40;
	// Keep the last 3/4 values
	/*
	~presetsEventInjection = ~presetsEventSource.inject([0.0,0.0,0.0],{ |state,v| [state[1],state[2], v] });
	~presetsEventInjection = ~presetsEventSource.inject(0!4,{ |state,v| [state[1],state[2], state[3], v] });
	*/
	// Keep the last x values
	~eventSourceFomula = (~presetsListMemoryNb-1).collect{|i| "state[" ++ (i+1) ++ "]"}; // .cs -> nécessaire lorsque la String est trop longue (au delà de 40) -> mais la transformation en string génère une erreur ????????????????????????????????????????????????????????????????????????????????????????????????????????????
	~eventSourceFomula = "{ |state,v|" + ~eventSourceFomula.asString[0..~eventSourceFomula.asString.size-2] + ",v] }";
	~presetsEventInjection = ~presetsEventSource.inject(0!~presetsListMemoryNb, ~eventSourceFomula.interpret );
	~positionInPreset = ~presetsListMemoryNb-1;
	// You can assign a key to the function:
	~presetsEventInjection.doDef(\action1, { |v| ~presetsCollection = v/*.postln*/ }); // juste pour l'affichage
	// Disable the function d'injection:
	// ~presetsEventInjection.doDef(\action1);

	~lastPresetView = RoundButton(~patComp, Rect(178*~xSizeMul, 214*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul) /*(106, 214, 20, 20)*/)
	.states_([["\<", Color.black, Color.green]])
	.font_(Font("Verdana", 9*~fontSizeMul, bold: true))
	.action_({|i| var curPresetItem;
		// [\rtmBlock, \proBlock, \synBlock, \spaBlock, \legBlock, \envBlock, \bufBlock, \ampBlock, \ratBlock, \rat2Block, \offBlock, \strBlock, \str2Block, \cenBlock, \cen2Block, \panBlock, \delBlock, \outLBlock, \outRBlock, \fxLBlock, \fxRBlock].do {|i| currentEnvironment[i][~tracksValue] = 1}; // ~ampBlock // intégré directement dans les boutons
		// ~positionInPreset.postln;
		~positionInPreset = max(0, ~positionInPreset - 1);
		// ~positionInPreset.postln;
		curPresetItem = ~presetsCollection[~positionInPreset];
		if (curPresetItem == 0 or: {~positionInPreset == 0}, {
			~positionInPreset = ~positionInPreset + 1; "No previous Preset".postln; // pour annuler la dernière action
		},{
			if ( ~presetsFileName2.isNil, {
				~presetSelectionView.value_(~presetList.find([curPresetItem.asString]));
			},{
				~presetSelection2View.value_(~presetList2.find([curPresetItem.asString]));
			});

			if (~updateVisualPreset == 0, {~presetGetFunction.value(curPresetItem)}, {~presetGetFunctionQuick.value(curPresetItem, ~tracksValue, ~seqsValue)});
			~nbTotalBeatsView.doAction; // pour mettre à jour le BPM si le ~rtmMul a changé ???
			~presetStoringNameView.value_(curPresetItem.asString.split($|)[3].split($ )[1] ++ " " ++ curPresetItem.asString.split($|)[3].split($ )[2]);

			~presetSelection[~tracksValue][~seqsValue] = curPresetItem.asString;

			// Action sur la séquence
			~presetSeqTextView[~seqsValue].string = curPresetItem.asString; /*~presetSelection[~tracksValue][~seqsValue];*/
			// Action sur le tab Global
			~presetSeqTextViewG[~tracksValue][~seqsValue].string = curPresetItem.asString; /*~presetSelection[~tracksValue][~seqsValue];*/

			("Preset Memory Nb : " + (~positionInPreset+1-~presetsListMemoryNb)).postln;
		});
	});

	~nextPresetView = RoundButton(~patComp, Rect(220*~xSizeMul, 214*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul) /*(128, 214, 20, 20)*/)
	.states_([["\>", Color.black, Color.green]])
	.font_(Font("Verdana", 9*~fontSizeMul, bold: true))
	.action_({|i| var curPresetItem;
		~positionInPreset = min(~presetsListMemoryNb, ~positionInPreset + 1);
		curPresetItem = ~presetsCollection[~positionInPreset];

		if (~positionInPreset == ~presetsListMemoryNb, {
			// if (curPresetItem == 0, {
			~positionInPreset = ~positionInPreset - 1; "No next Preset".postln;// pour annuller la dernière action
		},{
			if ( ~presetsFileName2.isNil, {
				~presetSelectionView.value_(~presetList.find([curPresetItem.asString]));
			},{
				~presetSelection2View.value_(~presetList2.find([curPresetItem.asString]));
			});

			if (~updateVisualPreset == 0, {~presetGetFunction.value(curPresetItem)}, {~presetGetFunctionQuick.value(curPresetItem, ~tracksValue, ~seqsValue)});
			~nbTotalBeatsView.doAction; // pour mettre à jour le BPM si le ~rtmMul a changé ???
			~presetStoringNameView.value_(curPresetItem.asString.split($|)[3].split($ )[1] ++ " " ++ curPresetItem.asString.split($|)[3].split($ )[2]);

			~presetSelection[~tracksValue][~seqsValue] = curPresetItem.asString;

			// Action sur le smoothSlider de la séquence
			~presetSeqTextView[~seqsValue].string = curPresetItem.asString; /*~presetSelection[~tracksValue][~seqsValue];*/
			// Action sur le tab Global
			~presetSeqTextViewG[~tracksValue][~seqsValue].string = curPresetItem.asString; /*~presetSelection[~tracksValue][~seqsValue];*/

			("Preset Memory Nb : " + (~positionInPreset+1-~presetsListMemoryNb)).postln;
		});
	});


	if (~presetsFileName2.isNil, {

		if (~presetList.size > 0, {
			~presetSelectionView.items_(
				// ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString }.sort({ |a, b| a.split($ )[0].asFloat < b.split($ )[0].asFloat});
				~presetSortFunctions[3].value(~presetList);
			);
		});


		// Initialisation des données au départ et update à chaque fois que l'on store un preset (~savePresetFileView)
		~presetsTypeList = ~presetList.collect({ |i| i.split($|)[3].split($ )[1] }).addAll(["ALL", "AsD", "AsF"]).as(Set).as(Array).sort; // removeDups -> extension de la librairie wslib requiert un symbole et donc pas pratique pour le mettre dans un PopUp menu qui demande une liste
		// Création de plusieurs listes de presets selon les types
		~presetListAcType = 0 ! (~presetsTypeList.size -1 +2);
		~presetsTypeList.do { |item, s| ~presetListAcType[s] = ~presetList.select({ |i| i.split($|)[3].split($ )[1] == ~presetsTypeList[s] }) };
		~presetListAcType[0] = ~presetList;
		~presetListAcType[1] = ~presetList.reject({ |i| i.split($|)[3].split($ )[1].beginsWith("D") });
		// ~presetListAcType[2] = ~presetList.reject({ |i| var type = i.split($|)[3]; type.endsWith("E") or: {type.endsWith("S")} or: {type.beginsWith("D")} });
		~presetListAcType[2] = ~presetListAcType[1].reject({ |i| var type = i.split($|)[3]; type.endsWith("E") or: {type.endsWith("S")} });

		~presetRandomTypeViewView = View(~patComp, Rect(60*~xSizeMul, 214*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul));

		~presetRandomTypeView = PopUpMenu.new(~presetRandomTypeViewView, Rect(0, 0, 80*~xSizeMul, 20*~ySizeMul) /*(150, 214, 45, 20)*/)
		.action_({ |menu| ~presetRandomTypeValue = menu.value;
		})
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(Color.black)
		.font_(Font("Verdana",9*~fontSizeMul));
		~presetRandomTypeView.items_(~presetsTypeList).valueAction_(1);

	},{

		if (~presetList1.size > 0, { ~presetSelectionView.items_(~presetSortFunctions[3].value(~presetList1)) });
		if (~presetList2.size > 0, { ~presetSelection2View.items_(~presetSortFunctions[3].value(~presetList2)) });


		// Initialisation des données au départ et update à chaque fois que l'on store un preset (~savePresetFileView)
		~presetsTypeList1 = ~presetList1.collect({ |i| i.split($|)[3].split($ )[1] }).addAll(["ALL", "AsD", "AsF"]).as(Set).as(Array).sort; // removeDups -> extension de la librairie wslib requiert un symbole et donc pas pratique pour le mettre dans un PopUp menu qui demande une liste
		// Création de plusieurs listes de presets selon les types
		~presetListAcType1 = 0 ! (~presetsTypeList1.size -1 +2);
		~presetsTypeList1.do { |item, s| ~presetListAcType1[s] = ~presetList1.select({ |i| i.split($|)[3].split($ )[1] == ~presetsTypeList1[s] }) };
		~presetListAcType1[0] = ~presetList1;
		~presetListAcType1[1] = ~presetList1.reject({ |i| i.split($|)[3].split($ )[1].beginsWith("D") });
		// ~presetListAcType[2] = ~presetList.reject({ |i| var type = i.split($|)[3]; type.endsWith("E") or: {type.endsWith("S")} or: {type.beginsWith("D")} });
		~presetListAcType1[2] = ~presetListAcType1[1].reject({ |i| var type = i.split($|)[3]; type.endsWith("E") or: {type.endsWith("S")} });

		~presetsTypeList2 = ~presetList2.collect({ |i| i.split($|)[3].split($ )[1] }).addAll(["ALL", "AsD", "AsF"]).as(Set).as(Array).sort;
		~presetListAcType2 = 0 ! (~presetsTypeList2.size -1 +2);
		~presetsTypeList2.do { |item, s| ~presetListAcType2[s] = ~presetList2.select({ |i| i.split($|)[3].split($ )[1] == ~presetsTypeList2[s] }) };
		~presetListAcType2[0] = ~presetList2;
		~presetListAcType2[1] = ~presetList2.reject({ |i| i.split($|)[3].split($ )[1].beginsWith("D") });
		~presetListAcType2[2] = ~presetListAcType2[1].reject({ |i| var type = i.split($|)[3]; type.endsWith("E") or: {type.endsWith("S")} });

		~presetRandomTypeViewView = View(~patComp, Rect(56*~xSizeMul, 214*~ySizeMul, 45*~xSizeMul, 20*~ySizeMul));

		~presetRandomTypeView = PopUpMenu.new(~presetRandomTypeViewView, Rect(0, 0, 80*~xSizeMul, 20*~ySizeMul) /*(150, 214, 45, 20)*/)
		.action_({ |menu| ~presetRandomTypeValue = menu.value;
		})
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(Color.black)
		.font_(Font("Verdana",9*~fontSizeMul));
		~presetRandomTypeView.items_(~presetsTypeList1).valueAction_(1);

		~presetRandomType2ViewView = View(~patComp, Rect(102*~xSizeMul, 214*~ySizeMul, 45*~xSizeMul, 20*~ySizeMul));

		~presetRandomType2View = PopUpMenu.new(~presetRandomType2ViewView, Rect(0, 0, 80*~xSizeMul, 20*~ySizeMul) /*(150, 214, 45, 20)*/)
		.action_({ |menu| ~presetRandomType2Value = menu.value;
		})
		.allowsReselection_(true)
		.background_(~popUpMenuBackgroundColor)
		.stringColor_(Color.black)
		.font_(Font("Verdana",9*~fontSizeMul));
		~presetRandomType2View.items_(~presetsTypeList2).valueAction_(1);

	});

	~presetSortView.items_([ /*"BPM",*/ "Sec", "Ev", "BUF", "Type", "Typ2", "Name", "Rand" ]).value_(3);

	// Déclenchement seulement s'il y a des presets
	// if (~presetList.size > 0, {~presetSortView.valueAction_(3)});

	// ~presets.keys.asArray.select({ |i| i.asString.split($ )[4].includesAny(~presetSelectionType[~tracksValue][~seqsValue].flat) })[0].class

	/* Post Unique array elements -> to return the unique elements of an array more efficient than this:
	a = [2, 3, 4, 4, 5];
	b = [];
	a do: { |n| if (b includes: n) { } { b = b add: n } };

	Dan's solution :
	a.as(Set).as(Array);

	Just to note: Dan's solution is slower (creates and fills an intermediate object) and doesn't preserve the order of (first occurrences of) elements in original array.
	see Collection:removeDups method in ddwCommon quark (which does almost exactly the same your code do)
	btw imho it is one of these methods which should go to main distro.
	a = Array.fill(200, { rrand(0,100) });
	{1000.do{  a.as(Set).as(Array) }}.bench // => 0.41048772900103
	{1000.do{ a.removeDups	}}.bench // => 0.11006214399822

	Mais benchmark équivalent dans mon cas :
	{10.do{ ~test = ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString.split($ )[4].asSymbol }.removeDups }}.bench
	{10.do{ ~test = ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString.split($ )[4] }.as(Set).as(Array) }}.bench
	{ ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString.split($ )[4].asSymbol }}.bench
	{ ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString.split($ )[4] }.as(Set).as(Array) }.bench
	{ ~presetList.size.collect{ |i| ~presetSelectionView.items.asArray[i].asString.split($ )[4].asSymbol }}.bench // 10 x plus rapide
	{ ~presetList.size.collect{ |i| ~presetSelectionView.items.asArray[i].asString.split($ )[4] }.as(Set).as(Array) }.bench // 10 x plus rapide
	*/

	// Initialisation du preset sélectionné par défaut - voire différence de timing à l'initialisation de la GUI
	// ~presetSelectionView.valueAction_(/*~presetSelectionView.items*/~presetList.find(["120 BPM-4 Ev B Default 2"]));

	// Benchmark équivalent
	// {Post << ~presets.keys.size.collect{ |i| ~presets.asSortedArray[i][0].asString }}.bench
	// {Post << ~presets.keys.size.collect{ |i| ~presets.keys.asArray[i].asString }.sort }.bench

	// Post << ~presets;
	// Post << ~presets.getPairs;
	// Post << ~presets.getPairs.asArray;
	// Post << ~presets.keys.asArray





	// Montage
	~nbEventsTrigComp = CompositeView(~globalWindow, Rect(274*~xSizeMul, 2*~ySizeMul, 93*~xSizeMul, 41*~ySizeMul)).background = Color.black /*~sliderHilightNoColor*/ /*Color.magenta*/;

	~nbEventsTrigSpec = ControlSpec(1, 100, 'lin', 1, 3);
	~nbEventsTrig = ~nbEventsTrigSpec.default /*! ~nbOfSeqs */ ! ~nbOfTracksX2;
	~nbEventView = EZNumber.new(/*~patComp*/ ~nbEventsTrigComp, Rect(2*~xSizeMul, 1*~ySizeMul, 22*~xSizeMul, 20*~ySizeMul), nil, ~nbEventsTrigSpec,
		{ |ez| ~nbOfTracksX2.do { |i| ~nbEventsTrig[/*~tracksValue*/ i ] = ez.value }}, unitWidth:0, initVal:~nbEventsTrigSpec.default, numberWidth:24*~xSizeMul, labelWidth:0, layout: \horz)
	.setColors(/*Color.grey*/~sliderBackgroundColor,Color.white/*,numBackground:~sliderBackgroundColor,numNormalColor:Color.white*/)
	.font_(Font("Verdana",10*~fontSizeMul));


	// ~lastTrigEvent = {0 ! 1} ! 1 /*! ~nbOfTracks*/; déjà initialisé plus haut
	if (~recordMontage == 1, {
		~lastTrigEvents = List.new;
		~lastTrigTime = List.new;
	});
	~lastTime = 0;

	~curEventTrigFunction = { |mul = 0|

		var onset, server;

		if (~server2.isNil or: {(~tracksValue/2).asInteger < ~serverTrackSwitch}, {server=0}, {server=1});

		if (Pdef(~patterns2[~tracksValue]).isPlaying == false and: {~cpuServer[server] == 0}, {

			fork {

				var track = (~tracksValue/2).floor;
				var nbEvents = if ( mul == 0, { nbEvents = 1 }, { nbEvents = ~nbEventsTrig[~tracksValue] });
				var seq = ~presetSeqStart[~tracksValue]; /*~seqsValue*/

				onset = (~gblTempo.seconds - ~lastTime);
				("Time since last event ->" + onset.round(0.001) + "sec.").postln;

				if (~harTrig[~tracksValue][seq] == 1, {
					~lastTrigEvent/*[track]*/ = {0 ! (~spaHarSeq[~tracksValue][seq].size +1)} ! nbEvents;
					nbEvents.do { |a|
						(~spaHarSeq[~tracksValue][seq].size +1).do { |item, i|

							// if (~cpuServer == 1, { ~aliveThreadPeriod.wait; /*"Wait".postln*/ } , {0.005.wait} );
							/*block {|break|
							400.do {|i| if (~cpuServer == 1, { 0.005.wait } , { break.value } ) }; // boucle d'au moins 2 secondes pour empêcher de lancer des évènements si surcharge du CPU
							};*/
							~lastTrigEvent/*[track]*/[a][i] = ~oneEvent[track].next(());
							if (~cpuServer[server] == 0, { ~lastTrigEvent/*[track]*/[a][i].play; });
							// ~lastTrigEvent/*[track]*/[a][i].removeAt(\msgFunc);
						};
						(/*"Tr:" +*/ ~tracksViewItemsB[~tracksValue] + "- Pos:" + ~posRtm[~tracksValue][seq] + "dure" + ~lastTrigEvent/*[track]*/[a][0][\durenv0].round(0.01) + "->" + nbEvents + "Ev" + "x" + ~lastTrigEvent/*[track]*/[a].size ).postln;
					}
					// ~lastTrigEvent[0] = {0 ! 4} ! 2
					// ~lastTrigEvent[0] = {[0]} ! 2
					// Prise en compte des multiples chorus
				},{
					~lastTrigEvent/*[track]*/ = {[0]} ! nbEvents;
					nbEvents.do { |a|

						// if (~cpuServer == 1, { ~aliveThreadPeriod.wait; /*"Wait".postln*/ } , {0.005.wait} );
						/*block {|break|
						400.do {|i| if (~cpuServer == 1, { 0.005.wait } , { break.value } ) }; // boucle d'au moins 2 secondes pour empêcher de lancer des évènements si surcharge du CPU
						};*/
						~lastTrigEvent/*[track]*/[a][0] = ~oneEvent[track].next(()); ~lastTrigEvent/*[track]*/[a][0].play;
						// ~lastTrigEvent/*[track]*/[a][0].removeAt(\msgFunc);

						(/*"Tr:" +*/ ~tracksViewItemsB[~tracksValue] + "- Pos:" + ~posRtm[~tracksValue][seq] + "dure" + ~lastTrigEvent/*[track]*/[a][0][\durenv0].round(0.01) + "->" + nbEvents + "Ev" + "x" + ~lastTrigEvent/*[track]*/[a].size ).postln;
					};
				});

				~lastTime = ~gblTempo.seconds;

				if (~recordMontage == 1, {~lastTrigEvents.add(~lastTrigEvent); ~lastTrigTime.add(onset) });

				/*0.1*/ ~updateTime.wait;

				// ~lastEvent[~tracksValue][\durenv0].round(0.01).postln; // Pourquoi affichage dans la post window avec un tel délai > à 1 ou plusieurs secondes ????????????????????????????????????
				// ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
				// ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
				// ~lastEvent[~tracksValue].cs
				// ~synReadView.value_(~rtmSeqSpec[~tracksValue][~seqsValue].unmap(~posRtm[~tracksValue][~seqsValue]));

				// voire si ne génère pas trop de charge CPU ?????????

				{

					if ( ~currentTab == 3, {

						~seqReadViewG[~tracksValue].value_(~seqSeqSpec3.unmap(~posSeq2[~tracksValue]));
						// Pour modif de la valeur & du ThumbSize du ReadViewSlider dans le Tab Global XXX
						~rtmReadViewG[~tracksValue].thumbSize_(~rtmThumbSizeValue[~tracksValue][seq]).value_(~rtmSeqVSpec[~tracksValue][seq].unmap(~posRtm[~tracksValue][seq]));

						// (/*"Tr:" +*/ ~tracksViewItemsB[~tracksValue] + "- Pos:" + ~posRtm[~tracksValue][seq] + "dure" + ~lastEvent[~tracksValue][\durenv0].round(0.01) + "x" + nbEvents + "Ev" + "x" + ~lastTrigEvent[track].size ).postln;

					},{

						if (~visuelSlider == 1, {
							~updateModuleSliderFunction.();
						},{
							~updateModuleMultiSliderFunction.();
						});

						~updateModuleTextFunction.();

						// ~lastEvent[~tracksValue][\durenv0].round(0.01).postln;
						// (/*"Tr:" +*/ ~tracksViewItemsB[~tracksValue] + "- Pos:" + ~posRtm[~tracksValue][seq] + "dure" + ~lastEvent[~tracksValue][\durenv0].round(0.01) + "x" + nbEvents + "Ev" + "x" + ~lastTrigEvent[track].size ).postln;

					})

				}.defer;

			};

		},{
			"Too much CPU or Pattern is already playing".postln;
		});

	};

	~curEventTrigView = RoundButton(~nbEventsTrigComp, Rect(28*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
	.states_([["Trig", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul/*, bold: true*/))
	.action_({ |i| ~curEventTrigFunction.(1) });

	~lastEventTrigView = RoundButton(~nbEventsTrigComp, Rect(60*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
	.states_([["Last", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul/*, bold: true*/))
	// .action_({ |i| ~lastTrigEvent[(~tracksValue/2).floor].size.do { |item, i| ~lastTrigEvent[(~tracksValue/2).floor][i].play; };
	.action_({ |i|
		/*fork {
		~lastTrigEvent.do { |item, i|
		item.do { |atem, a|
		if (~cpuServer[0] == 1, { ~aliveThreadPeriod.wait; /*"Wait".postln*/ } , {0.005.wait} );
		~lastTrigEvent[i][a].play;
		if (~cpuServer[0] == 1, { ~aliveThreadPeriod.wait; /*"Wait".postln*/ } , {0.005.wait} );
		}
		}
		}*/
		fork {
			~lastTrigEvent.do { |item, i|
				item.do { |atem, a|
					// 	if (~cpuServer[0] == 1, { ~aliveThreadPeriod.wait; /*"Wait".postln*/ } , {0.005.wait} );
					if ( atem[\cpuServer] == 1, { ~aliveThreadPeriod.wait; /*"Wait".postln*/ } , {0.005.wait} );
					~lastTrigEvent[i][a].play;
					if (atem[\cpuServer] == 1, { ~aliveThreadPeriod.wait; /*"Wait".postln*/ } , {0.005.wait} );
				}
			}
		}
	});


	~curSeqTrig = 0;
	~curSeqTrigView = RoundButton(~nbEventsTrigComp, Rect(2*~xSizeMul, 22*~ySizeMul, 28*~xSizeMul, 18*~ySizeMul))
	.states_([["Arm", Color.white, Color.red, bold:true], ["Arm", Color.white, Color.blue]])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({ |i|

		~curSeqTrig = i.value;

		// ~presetSeqRangeView.doAction;
		~presetSeqRangeViewG[~tracksValue].doAction;

		if (~curSeqTrig == 1, {
			~nbOfTracksX2.do { |i| ~pFadeViewG[i].valueAction_(~pFadeSpec.unmap( 0 /*~pFade[~tracksValue])*/)); }; ~pFadeView.valueAction_(~pFadeSpec.unmap( 0 ));
			// ~keyControlView.valueAction_(0);
		},{
			~nbOfTracksX2.do { |i| ~pFadeViewG[i].valueAction_(~pFadeSpec.unmap( ~trackXFadeDefault /*~pFade[~tracksValue])*/)); }; ~pFadeView.valueAction_(~pFadeSpec.unmap( ~trackXFadeDefault ));
			//~keyControlView.valueAction_(2);
		});

		// transféré dans ~presetSeqRangeView
		/*
		if (Pdef(~patterns2[~tracksValue]).isPlaying == false, {
		if (~seqChange == 0, {~seqChangeViewG[0].valueAction_(1)});
		~seqsView.valueAction_(~presetSeqStart[~tracksValue]);
		/*if (~seqChange == 1, {
		try { ~presetGetFunction.value(~presetSelection[~tracksValue][ ~presetSeqStart[~tracksValue] /*~seqsValue*/].asSymbol); };
		});*/
		});
		*/

	});

	~updatePresetSelectionView = RoundButton(~nbEventsTrigComp, Rect(32*~xSizeMul, 22*~ySizeMul, 28*~xSizeMul, 18*~ySizeMul) /*~seqComp, Rect(367, 204, 30, 20)*/)
	.states_([["\Up", Color.black, Color.yellow], ["\Nup", Color.red, Color.yellow]])
	.font_(Font("Verdana",8*~fontSizeMul, bold:true))
	.action_({|i| ~updatePresetSelection = i.value })
	.valueAction_(1);

	~readType = 0;
	~readTypeView = RoundButton(~nbEventsTrigComp, Rect(62*~xSizeMul, 22*~ySizeMul, 28*~xSizeMul, 18*~ySizeMul))
	.states_([["End" /*"End\nLess"*/, Color.white, Color.magenta],["Blok" /*"Block\nRead"*/, Color.white, Color.magenta]])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({ |i| ~readType = i.value });


}.value;






























// SEQUENCE

// Possibilité d' "overload" si action sur plusieurs paramètres en même temps puisque chaque paramètre peut avoir des actions sur les autres ???
// Comment faire pour avoir un update toutes les 0.1 s ???
// Recap des améliorations à faire et des "bugs" :
// 1. Le changement inapproprié des valeurs du View lorque changement des steps du View (pour "palier" le manque d'une grille / échelle sur le MultiSlider)
// 2. Si changement du Mul, pas de changement du step & du round du Multislider -> donc round et step décalés, multipliés
// 3. Léger pb de rounding de la valeur de l'indexView en correspondance avec le Display



// Déclaration variables SEQ

~seq = 0 ! ~nbOfTracksX2;

~seqSeqView = 0 ! ~nbOfTracksX2;
~seqSeqStart = 0 ! ~nbOfTracksX2;
~seqSeqStop = 0 ! ~nbOfTracksX2;
~presetSeqStart = 0 ! ~nbOfTracksX2;
~presetSeqStop = 0 ! ~nbOfTracksX2;
~seqIndex = 0 ! ~nbOfTracksX2;

// Déclaration variables Patterns
// ~seqSeq = 0 ! ~nbOfTracksX2; // nécessaire de le déclarer avant ~bufFolderView
~seqDurSeq = 0 ! ~nbOfTracksX2;
~posSeq = 0 ! ~nbOfTracksX2;
~seqSeq2 = 0 ! ~nbOfTracksX2;
~posSeq2 = 0 ! ~nbOfTracksX2;

// ~nFadeView = 0 ! ~nbOfTracksX2; // pas utilisé car pas de fade-in/out sur les patterns
// ~pFadeView = 0 ! ~nbOfTracksX2;
// ~quantView = 0 ! ~nbOfTracksX2;
~nFade = 0 ! ~nbOfTracksX2; // pas utilisé car pas de fade-in/out sur les patterns
~pFade = 0 ! ~nbOfTracksX2;
~quant = 0 ! ~nbOfTracksX2;



~seqComp = CompositeView(~tabGUI, Rect(2*~xSizeMul, 0, 399*~xSizeMul, 227*~ySizeMul))/*.focus(false)*/.background = ~seqCompColor;
~seqComp2 = ScrollView(~seqComp, Rect(2*~xSizeMul, 22*~ySizeMul, 362*~xSizeMul, 132*~ySizeMul)).hasHorizontalScroller_(false).hasVerticalScroller_(false).background = ~seqCompColor; // MultiSlider
~seqComp3 = ScrollView(~seqComp, Rect(2*~xSizeMul, 156*~ySizeMul, 362*~xSizeMul, 24*~ySizeMul)).hasHorizontalScroller_(false).hasVerticalScroller_(false).background = ~seqCompColor; // RangeSlider
~seqComp4 = ScrollView(~seqComp, Rect(2*~xSizeMul, 2*~ySizeMul, 362*~xSizeMul, 18*~ySizeMul)).hasHorizontalScroller_(false).hasVerticalScroller_(false).background = ~seqCompColor; // Slider
~seqComp5 = ScrollView(~seqComp, Rect(2*~xSizeMul, 2*~ySizeMul, 362*~xSizeMul, 199*~ySizeMul)).hasHorizontalScroller_(false).hasVerticalScroller_(false).focus(false).background = ~seqCompColor; // StaticText des presets - vertical
// .focus(false) ne marche pas ??????

~seqMin = 1;
~seqMax = ~nbOfSeqs;
~seqSpec = ControlSpec(~seqMin, ~seqMax, \lin, 1);
~seqSeqSpec = ControlSpec(0, 50, \lin, 1);
~seqSeqSpec2 = ControlSpec(0, 49, \lin, 1); // juste pour la visualisation

~pFadeSpec = ControlSpec(0, 120, \lin, 1, 20);
~quantSpec = ControlSpec(0, 120, \lin, 1, 4);

~switchSeqValue = 0 ! ~nbOfTracksX2;

~tracks.do { |tr|

	// ~seq[tr] = 0 ! 50; // Necessary to give values before triggering the function
	// Pourquoi obligé de recalculer l'Array.fill et l'affectation à une variable ne marche pas
	// ~buildSeqTrack = Array.fill(50, { |i=0| min(i+1, 24)});
	// ~buildSeqTrack = ~seqSpec.unmap(~buildSeqTrack);

	~seq[tr] = ~buildSeqTrack; // utilité ???
	~seq[tr] = ~seqSpec.unmap(Array.fill(50, { |i=0| min(i+1, ~nbOfSeqs)})); // Necessary to give values before triggering the function - i++ ne marche pas ???
	~seqSeqStart[tr] = 0;
	~seqSeqStop[tr] = 0;
	~presetSeqStart[tr] = 0;
	~presetSeqStop[tr] = 0;

	~pFade[tr] = 60;
	~quant[tr] = 4;

	~playViewValue[tr] = 0;

};


~visibleSeqValue = 1;
~visibleSeqValue2 = 0;
~visibleSeqView = RoundButton(~seqComp, Rect(363*~xSizeMul, 2*~ySizeMul, 18*~xSizeMul, 20*~ySizeMul))
.states_([["V1", Color.white, Color.blue], ["V2", Color.black, Color.green]])
.font_(Font("Verdana", 8*~fontSizeMul))
.action_({|i| ~visibleSeqValue = i.value;
	if (~visibleSeqValue == 0, {~visibleSeqValue2 = 1});
	if (~visibleSeqValue == 1, {~visibleSeqValue2 = 0});

	~seqReadView.visible_(~visibleSeqValue);
	~seqPosView.visible_(~visibleSeqValue);
	~seqComp4.visible_(~visibleSeqValue);
	~seqView.visible_(~visibleSeqValue);
	~seqComp2.visible_(~visibleSeqValue);
	~seqSeqView.visible_(~visibleSeqValue);
	~seqComp3.visible_(~visibleSeqValue);

	~seqUserView.visible_(~visibleSeqValue);

	~seqDisplay.visible_(~visibleSeqValue);
	~seqSeqViewStaticText.visible_(~visibleSeqValue);
	~seqIndexView.visible_(~visibleSeqValue);
	// ~seqSeqAllView.visible_(~visibleSeqValue);
	// ~seqSeqMode.visible_(~visibleSeqValue);
	~seqShowView.visible_(~visibleSeqValue);

	/*80*/~nbOfSeqs.do { |i| ~presetSeqTextView[i].visible_(~visibleSeqValue2) };
	~seqComp5.visible_(~visibleSeqValue2);
	// ~presetSeqRangeView.visible_(~visibleSeqValue2);
	~positionSeqView.visible_(~visibleSeqValue2);
	~position2SeqView.visible_(~visibleSeqValue2);
	~positionRandSeqView.visible_(~visibleSeqValue2);

});


~seqDisplay = TextView(~seqComp, Rect(2*~xSizeMul, (166+12)*~ySizeMul, 362*~xSizeMul, 20*~ySizeMul))
// .hasVerticalScroller_(true) // supprimé car hauteur trop petite pour être visible
// .autohidesScrollers_(true)
.hasVerticalScroller_(false)
.hasHorizontalScroller_(false)
.enterInterpretsSelection_(1)
.font_(Font("arial",10*~fontSizeMul));

~seqView = MultiSliderView.new(~seqComp2, Rect(-2*~xSizeMul, -2*~ySizeMul, 998*~xSizeMul, 130*~ySizeMul));
~seqView.value_(~seq[~tracksValue])
.background_(~sliderBackgroundColor/*~seqCompColor*/)
.strokeColor_(Color.white)
.fillColor_(Color.black)
.elasticMode_(1)
.isFilled_(false)
.drawLines_(true)
.valueThumbSize_(max(8, (138 / (~seqMax - ~seqMin +1))))
.thumbSize_(~seqView.bounds.width / (~seq[~tracksValue].size))
.showIndex_(true)
.step_(1/(~seqMax - ~seqMin))
.action_({ | view |
	view.value.do({|x, i|
		~seq[~tracksValue][i] = x});
	~seqDisplay.string_(("~seqView.valueAction_(~seqSpec.unmap( "+(~seqSpec.map(~seq[~tracksValue])).round(1).asInteger.asCompileString+"));").asString); ~seqDisplay.setFont((Font("arial",1)), 4, 33);
	~seqSeqViewStaticText.string_(~seqSeqStart[~tracksValue].asString + " to " + ~seqSeqStop[~tracksValue].asString + " (Dur : " + ~seqDurSeq[~tracksValue].asString + " / Seq : " + ~seqSpec.map(~seq[~tracksValue])[~seqSeqStart[~tracksValue]] + " ->)");
});

// Pourquoi nécessaire de rajouter cette car pas pris en compte dans le multislider du dessus
~seqView.valueThumbSize_(max(8, (138 / (~seqMax - ~seqMin +1)))*~xSizeMul);


~seqSeqViewStaticText = StaticText(~seqComp, Rect(100*~xSizeMul, 158*~ySizeMul, 210*~xSizeMul, 20*~ySizeMul))
.font_(Font("Verdana", 10*~fontSizeMul))
.acceptsMouse_(0)
.align_(\left)
.stringColor_(Color.white)
.string_("SEL");


~seqSeqView = SmoothRangeSlider(~seqComp3, Rect(-2*~xSizeMul, 0, 998*~xSizeMul, 20*~ySizeMul))
.action_({ |view| // var presetName;
	~seqSeqStart[~tracksValue] = ~seqSeqSpec.map(view.lo).asInteger; ~seqSeqStop[~tracksValue] = ~seqSeqSpec.map(view.hi).asInteger-1;
	~seqDurSeq[~tracksValue] = ~seqSeqStop[~tracksValue] - ~seqSeqStart[~tracksValue]+1;
	// view.string = ("% to % (Dur : %)").format(~seqSeqStart[~tracksValue], ~seqSeqStop[~tracksValue], ~seqDurSeq[~tracksValue]);

	// Essai pour afficher le nom du preset de la 1ere séquence sélectionnée
	// presetName = if (~presetSelection[~tracksValue][~seqSeqStart[~tracksValue]] != 0, {~presetSelection[~tracksValue][~seqSeqStart[~tracksValue]].split($ )[4] ++ " " ++ ~presetSelection[~tracksValue][~seqSeqStart[~tracksValue]].split($ )[5]}, {"No Preset"});
	if (~switchSeqValue[~tracksValue] == 1, {
		("Seq" + ~seqSpec.map(~seq[~tracksValue])[~seqSeqStart[~tracksValue]] + "Pos" + (~seqSeqStart[~tracksValue]+1) + ":" + ~presetSelection[~tracksValue][~seqSeqStart[~tracksValue]]).postln }); // pour afficher le preset en cours de la séquence // ~seqSeqStart[~tracksValue].postln;

	~seqSeqViewStaticText.string_(~seqSeqStart[~tracksValue].asString + " to " + ~seqSeqStop[~tracksValue].asString + " (Dur : " + ~seqDurSeq[~tracksValue].asString + " / Seq : " + ~seqSpec.map(~seq[~tracksValue])[~seqSeqStart[~tracksValue]] + "-> )");
	// Ligne ci-dessous pour pouvoir adapter la position dans le Multislider selon la 1ère valeur du SmoothRangeSlider sélectionnée
	// ~seqComp2.visibleOrigin = (~seqSeqStart[~tracksValue] * 20 - 2)@78;

})
.font_(Font("Verdana", 10*~fontSizeMul))
.background_(~sliderBackgroundColor)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor)
.value_([0, 1])
.minRange_(1/(~seq[~tracksValue].size))
.step_(1/(~seq[~tracksValue].size))
.doAction;

// ~seqSeqView.align_(\left);
// ~seqSeqView.stringAlignToKnob = true;

// Comment faire pour que les autres ~seqComp 3 & 4 puissent avoir aussi une action sur le ~seqComp 2 sans générer une boucle sans fin ???
~seqComp2.action = { var origin;
	origin = ~seqComp2.visibleOrigin;
	~seqComp3.visibleOrigin = (origin.x*~xSizeMul)@0/*(origin.y)*/;
	~seqComp4.visibleOrigin = (origin.x*~xSizeMul)@0/*(origin.y)*/;
};



// ne marche que lorsque la GUI est complètement affichée ??? -> à mettre dans le pattern
// ~seqComp2.visibleOrigin_(657@78);
// ~seqComp2.visibleOrigin_(0@78);

// Comment savoir si l'on survolle une View ???
// ~seqSeqView.mouseOverAction = { | a, b, c| a.postln; b.postln; c.postln; };

~seqUserView = UserView(~seqComp2, Rect(-2*~xSizeMul, -2*~ySizeMul, 998*~xSizeMul, 130*~ySizeMul)).acceptsMouse_(0);

// Comment mettre en place une grille ???
~seqUserViewXGrid = ControlSpec(0, 50, \lin, 0.1).grid/*.looseRange(10, 50, 10)*/;
~seqUserViewYGrid = ControlSpec(0, ~nbOfSeqs, \lin, 0.1).grid/*.asGrid.looseRange(ntick: 24)*/;
~seqUserViewGrid = DrawGrid(Rect(0, 0, 1000*~xSizeMul, 130*~ySizeMul), ~seqUserViewXGrid, ~seqUserViewYGrid).font_(Font("Verdana", 10*~fontSizeMul, bold: true)).fontColor_(Color.green).gridColors_(Color.yellow !2).opacity_(1);

~seqUserView.drawFunc = { ~seqUserViewGrid.draw };


/*(
w = Window("win", Rect(20,20,350,350)).front;
u = UserView(w, Rect(0,0,330,330));
y = GridLines([1,14].asSpec);
x = GridLines([1,8].asSpec);
d = DrawGrid(u.bounds,x,y);
d.gridColors = [Color.black,Color.black];
u.drawFunc = { d.draw }
)*/





~seqIndexView = SmoothSlider(~seqComp, Rect(367*~xSizeMul, (2+22)*~ySizeMul, 30*~xSizeMul, 130*~ySizeMul))
.action_({ |view| ~seqIndex[~tracksValue] = ~seqSpec.map(view.value);
	view.string = "%".format((~seqIndex[~tracksValue]).round(1).asInteger);
	// ~seqView.valueAction_(~seqIndex.curvelin(~seqMin, ~seqMax, 0, 1, 2) ! ~seq.size)
	// Modif pour action sur multislider seulement sur la sélection de la séquence au lieu de toute la séquence
	~seqView.valueAction_(~seq[~tracksValue].putEach([(~seqSeqStart[~tracksValue]..~seqSeqStop[~tracksValue])], [~seqSpec.unmap(~seqIndex[~tracksValue])] ));
})
.valueAction_(~seqSpec.unmap(0)) // pour initialiser les valeurs du View au chargement
.font_(Font("Verdana", 10*~fontSizeMul))
.background_(~sliderBackgroundColor)
.hilightColor_(~sliderHilightColor)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor)
.step_(1/~seqMax)
.doAction;

~seqSeqView.valueAction_([0, ~seqSeqSpec2.unmap(1)]); // Sélection initiale de la première séquence
~seqView.valueAction_(~seqSpec.unmap(Array.fill(50, { |i=0| min(i+1, ~nbOfSeqs)}))); // Réaffectation des valeurs de la séquence du multislider





// Name OF Module SEQ

~seqShowView = StaticText(~seqComp, Rect(170*~xSizeMul, 25*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
.font_(Font("Verdana",14*~fontSizeMul, bold: true))
.align_(\center)
.acceptsMouse_(0)
.stringColor_(/*Color.gray*/ Color.white)
.string_("SEQ");






























// 2ème type de visualisation des séquences avec le nom des séquences (plus pratique)

~presetSeqRangeRand = 0 ! ~nbOfTracksX2;

~seqUserView2 = UserView(~seqComp5, Rect(0, 0, 340*~xSizeMul, 1290*~ySizeMul)).acceptsMouse_(0); // si 350 au lieu de 340 , léger vacillement horizontal

~presetSeqRangeSpec = ControlSpec(~nbOfSeqs, 0, \lin, 1, 0);
~presetSeqRangeView = SmoothRangeSlider(~seqComp5, Rect(2*~xSizeMul, 0, 26*~xSizeMul, ((20*~nbOfSeqs)+6)*~ySizeMul))
.action_({ |view| // var presetName;
	var a, b, c, p;
	~presetSeqStart[~tracksValue] = ~presetSeqRangeSpec.map(view.hi).asInteger; ~presetSeqStop[~tracksValue] = ~presetSeqRangeSpec.map(view.lo).asInteger - 1;

	// Impact sur le global
	~presetSeqRangeViewG[~tracksValue].value_([view.hi, view.lo]);


	if (~lemurNewSeqs[~tracksValue].size == 0, {
		~seq2[~tracksValue] = (1..~nbOfSeqs).copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])[~presetSeqNb2Value[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]).order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])[~presetSeqNb2Value[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]).order][id] }.flat;
	},{
		~presetSeqNb2LemurValue[~tracksValue]  = ~lemurNewSeqs[~tracksValue].collect { |a1, ad| ~presetSeqNb2Value[~tracksValue][a1-1] };
		~lemurPresetSeqLength[~tracksValue] = ~lemurNewSeqs[~tracksValue][~presetSeqNb2LemurValue[~tracksValue].order].collect { |a1, ad| a1 ! ~presetSeqNbSelectDurValue[~tracksValue][a1-1] }.flat;
	});

	/*~seq2[~tracksValue] = (1..~nbOfSeqs).copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])[~presetSeqNb2Value[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]).order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])[~presetSeqNb2Value[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]).order][id] }.flat;*/

	// Pour la fabrication de la séquence aléatoire à chaque fois que le RangeSlider est modifié
	~presetSeqRangeRand[~tracksValue] = Pxrand(~seq2[~tracksValue]/*.copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])*/, inf).asStream;

	/*	("Pos" + ~seqSpec.map(~seq[~tracksValue])[~seqSeqStart[~tracksValue]] + "Seq" + (~seqSeqStart[~tracksValue]+1) + ":" + ~presetSelection[~tracksValue][~seqSeqStart[~tracksValue]]).postln;

	~seqSeqViewStaticText.string_(~seqSeqStart[~tracksValue].asString + " to " + ~seqSeqStop[~tracksValue].asString + " (Dur : " + ~seqDurSeq[~tracksValue].asString + " / Seq : " + ~seqSpec.map(~seq[~tracksValue])[~seqSeqStart[~tracksValue]] + "-> )");*/

	// Changement de séquence dès que le RangeSlider est modifié sans attendre la fin de la séquence
	if (~seqChange[~tracksValue] == 1, {
		~seqBlock[~tracksValue] = 1;
		[\rtmBlock, \proBlock, \synBlock, \spaBlock, \legBlock, \envBlock, \bufBlock, \ampBlock, \ratBlock, \rat2Block, \offBlock, \strBlock, \str2Block, \cenBlock, \cen2Block, \panBlock, \delBlock, \outLBlock, \outRBlock, \fxLBlock, \fxRBlock].do {|i| currentEnvironment[i][~tracksValue] = 1};
	});

	p = ~presetSeqStart[~tracksValue]; // p.postln;

	// Armer la séquence si changement du rangeslider
	if (~curSeqTrig == 1, {

		if (Pdef(~patterns2[~tracksValue]).isPlaying == false, {

			if (~seqChange[~tracksValue] == 0, {~seqChangeViewG[~tracksValue].valueAction_(1)});
			~seqsView.valueAction_(p);

			// ~oneEvent[(~tracksValue/2).floor] = Pdef(~patterns[(~tracksValue/2).floor]).asStream;
			/*if (~seqChange == 1, {
			try { ~presetGetFunction.value(~presetSelection[~tracksValue][ ~presetSeqStart[~tracksValue] /*~seqsValue*/].asSymbol); };
			});*/
		});

		// if ( ~presetSelection[~tracksValue][~presetSeqStart[~tracksValue]] != 0, { ~retriggerPreset.valueAction_(1) });
		// Obligé de le rajouter sinon quand on change le presetRangeSlider de la séquence et que l'on modifie un multislider ou plusieurs le ~retriggerPreset ne marche plus ???
		// Puis finalement retiré, car apparemment dû à ma grossière erreur sur le rappel des presets pour les multislider,
		// & avec l'introduction de ~presetsFileName2.isNil, cela réaffectait les pesets de la piste selon le mauvais ~presetSelectionView
	});

	// if (~tracksValue == 0, {~presetsSelEventSource.fire(~presetSeqStart[~tracksValue]) });
	case
	{ ~tracksValue == 0 } { ~presetsSelEventSource[0].fire(~presetSeqStart[0]);
		if (~positionInPresetSel[0] != (~presetsSelListMemoryNb-1), {~positionInPresetSel[0] = (~presetsSelListMemoryNb-1) }); // Afin de remettre à 0 la position du preset si modif du ~presetSeqRangeView
	}
	{ ~tracksValue == 2 } { ~presetsSelEventSource[1].fire(~presetSeqStart[2]);
		if (~positionInPresetSel[1] != (~presetsSelListMemoryNb-1), {~positionInPresetSel[1] = (~presetsSelListMemoryNb-1) });
	}
	{ ~tracksValue == 4 } { ~presetsSelEventSource[2].fire(~presetSeqStart[4]);
		if (~positionInPresetSel[2] != (~presetsSelListMemoryNb-1), {~positionInPresetSel[2] = (~presetsSelListMemoryNb-1) });
	};

	if (~lemurConnected1 == 1, {

		// ~lemurNewSeqs[~tracksValue] = 0; // Erreur si répété vs ~presetSeqRangeViewG
		// ~lemurNewSeqs[~tracksValue] = ~presetSeqRangeSpec.map(view.lo).asInteger; // ~presetSeqStop[tr] = ~presetSeqRangeSpec.map(view.lo).asInteger - 1;

		if ((p+1) != ~lemurNewSeqs[~tracksValue], {
			// "hey".postln;

			if (p - ~presetSeqStop[~tracksValue] == 0, {
				a = ~lemurSwitchesMapsPatch3[p];
				~lemurAdress1.sendMsg( *[[~lemurSwitchesValues[~tracksValue]] ++ ((0 ! a) ++ 1 ++ (0 ! (240-a)))].flatten(1) );

				~lemurAdress1.sendMsg( "/CurSeq2/value", p+1 /*1.0.rand*/);
				~lemurAdress1.sendMsg( *["/CurSeqText2", "@content", ~presetSelection[~tracksValue][p] ]);
			},{
				b = (p..~presetSeqStop[~tracksValue]).collect { |i| ~lemurSwitchesMapsPatch3[i] };
				c = 0 ! ~nbOfSeqs; b.do { |i| c[i] = 1; };
				~lemurAdress1.sendMsg( *[[~lemurSwitchesValues[~tracksValue]] ++ c].flatten(1) );

				~lemurAdress1.sendMsg( *[ ["/CurSeq2/value"], [((p+1)..~presetSeqStop[~tracksValue]+1).asString] ].flatten(1) );
				~lemurAdress1.sendMsg( *["/CurSeqText2", "@content", "" /*~presetSelection[tr][p]*/ ]);
			});

			case
			{ p.inclusivelyBetween(0,19) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 1); ~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-6, -7, 2748, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(20,39) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 0.91); ~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-919, -7, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(40,59) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 0.82); ~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-1833, -7, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(60,79) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 0.72); ~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-6, -223, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(80,99) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 0.63); ~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-919, -223, 2758 ,890]].flatten(1) );  }
			{ p.inclusivelyBetween(100,119) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 0.54);~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-1833, -223, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(120,139) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 0.45); ~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-6, -440, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(140,159) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 0.36); ~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-919, -440, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(160,179) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 0.27); ~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-1833, -440, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(180,199) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 0.18); ~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-6, -656, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(200,219) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 0.09); ~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-919, -656, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(220,239) }
			{ ~lemurAdress1.sendMsg( ~lemurFaderValues[~tracksValue], 0); ~lemurAdress1.sendMsg( *[[~lemurSwitchesContainerNames[~tracksValue]], ["@rect"], [-1833, -656, 2758, 890]].flatten(1) );  };

		});

		{
			if (~lemurNewSeqs[~tracksValue].isInteger, {
				~presetSeqRangeView.background_(~sliderBackgroundColor2).hilightColor_(Color.red); // ~presetSeqRangeViewG[(t*2)+1].background_(~sliderBackgroundColor).hilightColor_(Color.red);
			},{
				~presetSeqRangeView.background_(Color.magenta).hilightColor_(Color.blue); // ~presetSeqRangeViewG[(t*2)+1].background_(Color.magenta).hilightColor_(Color.blue)
			})
		}.defer;
	});

})
.font_(Font("Verdana", 8*~fontSizeMul))
.background_(~sliderBackgroundColor2/*Color.red*/)
.hilightColor_(Color.red)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor)
// .value_([1,  ~presetSeqRangeSpec.unmap(1)])
.minRange_(1/(~nbOfSeqs))
.step_(1/(~nbOfSeqs));
// .doAction;

~presetSeqTextView = 0 ! ~nbOfSeqs;
~presetSeqNbView = 0 ! ~nbOfSeqs;
~presetSeqNbSelectDurValue = {1 ! ~nbOfSeqs} ! ~nbOfTracksX2;
~presetSeqNbTextView = 0 ! ~nbOfSeqs;

~presetSeqNb2Value = {0 ! ~nbOfSeqs} ! ~nbOfTracksX2; // necessaire de le déclarer ici pour l'initialisation

~positionRandSeq = 0 ! ~nbOfTracksX2;

~seq2 = {(1..~nbOfSeqs).dup.flat} ! ~nbOfTracksX2;
~seqSeqSpec3 = ControlSpec((~nbOfSeqs -1), 0, \lin, 1); // juste pour la visualisation


~nbOfSeqs.do { |i|

	~presetSeqNbView[i] = StaticText(~seqComp5, Rect(4*~xSizeMul, (2+(20*i))*~ySizeMul, 20*~xSizeMul, 15*~ySizeMul))
	.acceptsMouse_(0)
	.font_(Font("Verdana", 11*~fontSizeMul /*, bold: true*/))
	.stringColor_(Color.white)
	.string_((i+1).asString);

	~presetSeqTextView[i] = StaticText(~seqComp5, Rect(55*~xSizeMul, (2+(20*i))*~ySizeMul, 304*~xSizeMul, 18*~ySizeMul))
	.background_(Color.grey(0.4))
	.font_(Font(~monoSpaceFont, (10*~fontSizeMul).asInteger) /*("Arial", 10) ("Verdana", 9)*/)
	.stringColor_(Color.white)
	.canReceiveDragHandler_({ // Protection pour ne pas changer le preset qui est en train d'être lu
		// if (/*(~presetSeqStart[~tracksValue]..~presetSeqStop[~tracksValue]).includes(~seqSeq[~tracksValue]) == false*/
		if (i != ~posSeq2[~tracksValue], {View.currentDrag.isString; }, { if (Pdef(~patterns2[~tracksValue]).isPlaying == false, {View.currentDrag.isString}); } );
	})
	.receiveDragHandler_({
		// var toPutInSeq;
		// Sélectionner une séquence vide la plus petite pour mettre un preset
		// toPutInSeq = ~seqs.collect{ |i| if (~presetSelection[~tracksValue][i] == 0, { i } ) }.reject{ |x| x.isNil }.minItem;
		~presetSelection[~tracksValue][i] = View.currentDrag;
		~presetSeqTextView[i].string = ~presetSelection[~tracksValue][i];
		~presetGetFunctionQuick.value(/*~presetList.choose.asSymbol.postln*/ ~presetSelection[~tracksValue][i].asSymbol, ~tracksValue, /*toPutInSeq*/ i);
		// ~presetSeqNbText[i].string_(toPutInSeq);

		// Action sur le tab Global
		~presetSeqTextViewG[~tracksValue][i].string = ~presetSelection[~tracksValue][i];

	})
	.action_({ /*~presetSeqText.string.postln*/ })
	.string_(0);
	// .visible_(0);


	~presetSeqNbTextView[i] = StaticText(~seqComp5, Rect(32*~xSizeMul, (2+(20*i))*~ySizeMul, 18*~xSizeMul, 15*~ySizeMul))
	.acceptsMouse_(0)
	.font_(Font("Verdana", 10*~fontSizeMul /*, bold: true*/))
	.stringColor_(Color./*black*/white)
	.align_(\right)
	// .background_(Color.yellow)
	.string_((i+1).asString);

};


// Basculement entre le MultiSlider et les TextView pour les séquences
~switchSeqView = RoundButton(~seqComp, Rect(381*~xSizeMul, 2*~ySizeMul, 18*~xSizeMul, 20*~ySizeMul))
.states_([["V1", Color.white, Color.blue], ["V2", Color.black, Color.green]])
.font_(Font("Verdana", 8*~fontSizeMul))
.action_({|i| ~switchSeqValue[~tracksValue] = i.value });

~positionSeqView = RoundButton(~seqComp, Rect(367*~xSizeMul, 30*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
.states_([["^", Color.black, ~popUpMenuBackgroundColor]])
.font_(Font("Verdana", 12*~fontSizeMul))
.action_({|i| ~seqComp5.visibleOrigin = 0@0 });

~position2SeqView = RoundButton(~seqComp, Rect(367*~xSizeMul, 55*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
.states_([[">", Color.black, ~popUpMenuBackgroundColor]])
.font_(Font("Verdana", 12*~fontSizeMul))
.action_({|i| ~seqComp5.visibleOrigin = 0@~seqComp5MaxVisibleOrigin/*((20*~nbOfSeqs)+2)*/ });

~positionRandSeqView = RoundButton(~seqComp, Rect(367*~xSizeMul, 80*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
.states_([["Seq", Color.white, Color.blue], ["RSeq", Color.white, Color.red]])
.font_(Font("Verdana", 9*~fontSizeMul))
.action_({|i| ~positionRandSeq[~tracksValue] = i.value;  ~positionRandSeqViewG[~tracksValue].value_(~positionRandSeq[~tracksValue]) });

~seqSeqAllView = RoundButton(~seqComp, Rect(367*~xSizeMul, 156*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
.states_([["All S", Color.black, ~popUpMenuBackgroundColor]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({~seqSeqView.valueAction_([0, 1]); ~presetSeqRangeView.valueAction_([0, 1]);
});

/*~seqRangeMode[tr] = RoundButton(~seqComp, ~rangeModePos5)
.states_([["\Jump", Color.white, Color.blue], ["\Drag", Color.black, Color.green]])
.font_(Font("Verdana",8))
.action_({|i| ~seqRangeView.mode_(~modes[i.value])});*/

~seqSeqMode = RoundButton(~seqComp, Rect(367*~xSizeMul, 180*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
.states_([["\Drag", Color.black, ~popUpMenuBackgroundColor], ["\Jump", Color.black, ~popUpMenuBackgroundColor]])
.font_(Font("Verdana",8*~fontSizeMul))
.action_({|i| ~seqSeqView.mode_(~modes[i.value]); ~presetSeqRangeView.mode_(~modes[i.value]) })
.valueAction_(1);


/*~seqCopyAView = RoundButton(~seqComp, ~copyAViewPos5)
.states_([["CA", Color.red, Color.white]])
.font_(Font("Verdana",8))
.action_({~seqCopyA.value(~tracksValue, ~seqsValue);
});

~seqPasteAView = RoundButton(~seqComp, ~pasteAViewPos5)
.states_([["PA", Color.red, Color.white]])
.font_(Font("Verdana",8))
.action_({~seqPasteA.value(~tracksValue, ~seqsValue);
});

~seqPasteMView = RoundButton(~seqComp, ~pasteMViewPos5)
.states_([["PM", Color.black, Color.white]])
.font_(Font("Verdana",8))
.action_({~seqPasteM.value(~tracksValue, ~seqsValue);
});

~seqDefaultView = RoundButton(~seqComp, ~defaultViewPos5)
.states_([["Def", Color.white, Color.blue]])
.font_(Font("Verdana",8))
.action_({~seqDefault.value(~tracksValue, ~seqsValue);
});*/





// Visuels Suivi du Pattern des Sliders & Text pour les modules séquences

~seqReadView = Slider(~seqComp4, Rect(-2*~xSizeMul, -2*~ySizeMul, 998*~xSizeMul, 18*~ySizeMul)).background_(Color.grey(0.6)).knobColor_(Color.black).acceptsMouse_(0).thumbSize_(22);
~seqRead2View = Slider(~seqComp5, Rect(27*~xSizeMul, 1*~ySizeMul, 28*~xSizeMul, (20*~nbOfSeqs)*~ySizeMul)).background_(Color.grey(0.6).alpha_(0)).knobColor_(/*Color.black*/Color.clear).acceptsMouse_(0).thumbSize_(18*~xSizeMul).valueAction_(1).canFocus_(false);

~seqReadView.palette = ~seqReadView.palette.button_(Color.yellow);
~seqRead2View.palette = ~seqReadView.palette.button_(Color.blue.alpha_(0.5));

~seqPosView = StaticText(~seqComp, Rect(2*~xSizeMul, 2*~ySizeMul, 363*~xSizeMul, 18*~ySizeMul))
.font_(Font("Verdana", 12*~fontSizeMul, bold: true))
.align_(\left)
.acceptsMouse_(0)
.stringColor_(Color.black);










// Sliders XFade & Quantisation

// voir la possibilité de faire un fade-in et fade-out sur le pattern -> possible seulement en stéréo ???
/*~nFadeView[t][s] = EZSmoothSlider(~patComp[t][s], Rect(2, 2, 30, 185), "N X", ControlSpec(0, 60, 4, 1, 16),
{|ez| ~nFade[t][s] = ez.value.postln}, layout:\vert, numberWidth:40, margin: 2@2, initAction: true)
.setColors(Color.grey(0.9),Color.black, Color.red(0.7),Color.grey, Color.white, Color.yellow,nil, Color.blue, Color.grey(0.7))
.font_(Font("Verdana",8));*/

~pFadeView = SmoothSlider(~seqComp, Rect(2*~xSizeMul, 202*~ySizeMul, 178*~xSizeMul, 24*~ySizeMul))
.action_({ |view| ~pFade[~tracksValue] = ~pFadeSpec.map(view.value);
	view.string = ("XFade : % Beats - % sec").format(~pFade[~tracksValue], (~pFade[~tracksValue] / ~toTempo).round(0.01));
	// Action sur le Global
	~pFadeViewG[~tracksValue].valueAction = view.value;
})
.font_(Font("Verdana", 10*~fontSizeMul))
.background_(~sliderBackgroundColor)
.hilightColor_(~sliderHilightColor)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor);
// .doAction // utilité ???
// obligé de le mettre en dessous quand ~pFadeViewG est déclaré
// ~pFadeView.valueAction_(~pFadeSpec.unmap(60));

~quantView = SmoothSlider(~seqComp, Rect(184*~xSizeMul, 202*~ySizeMul, 178*~xSizeMul, 24*~ySizeMul))
.action_({ |view| ~quant[~tracksValue] = ~quantSpec.map(view.value);
	view.string = ("Quant : % Beats - % sec").format(~quant[~tracksValue], (~quant[~tracksValue] / ~toTempo).round(0.01));
	// Action sur le Global
	~quantViewG[~tracksValue].valueAction = view.value;
})
.font_(Font("Verdana", 10*~fontSizeMul))
.background_(~sliderBackgroundColor)
.hilightColor_(~sliderHilightColor)
.stringColor_(Color.white)
.border_(~border)
.borderColor_(~borderColor);
// .doAction // utilité ???
// obligé de le mettre en dessous quand ~quantViewG est déclaré
// ~quantView.valueAction_(~quantSpec.unmap(4));






























// VUE GLOBALE pour les presets de chaque piste

~seqCompG = 0 ! ~nbOfTracksX2;
~seqCompGABIndex = 0 ! ~nbOfTracks /*X2*/; // initialisé aussi auparavant dans Init Midi Twister
~seqCompG1 = 0 ! ~nbOfTracksX2;
~seqCompG1VisibleOrigin = 0 ! ~nbOfTracksX2;
~seqUserView2 = 0 ! ~nbOfTracksX2;
~presetSeqRangeViewG = 0 ! ~nbOfTracksX2;

~switchSeqViewG = 0 ! ~nbOfTracksX2;
~position1SeqViewG = 0 ! ~nbOfTracksX2;
~position2SeqViewG = 0 ! ~nbOfTracksX2;
~position3SeqViewG = 0 ! ~nbOfTracksX2;
~position4SeqViewG = 0 ! ~nbOfTracksX2;
~presetSeqVisuViewG = 0 ! ~nbOfTracksX2;
~seqSeqModeG = 0 ! ~nbOfTracksX2;
~seqReadViewG = 0 ! ~nbOfTracksX2;
~rtmReadViewG = 0 ! ~nbOfTracksX2;
~positiontoSeqTrViewG = 0 ! ~nbOfTracksX2;
~pFadeViewG = 0 ! ~nbOfTracksX2;
~quantViewG = 0 ! ~nbOfTracksX2;
~spaRangePresetViewG = 0 ! ~nbOfTracksX2;
~spaRangePresetViewViewG = 0 ! ~nbOfTracksX2;
~spaPatSelViewG = 0 ! ~nbOfTracksX2;
~spaPatSelViewViewG = 0 ! ~nbOfTracksX2;
~spaPatViewG = 0 ! ~nbOfTracksX2;
~panRangePresetViewViewG = 0 ! ~nbOfTracksX2;
~panRangePresetViewG = 0 ! ~nbOfTracksX2;
~bufFolderViewViewG = 0 ! ~nbOfTracksX2;
~bufFolderViewG = 0 ! ~nbOfTracksX2;
~rtmMulViewG = 0 ! ~nbOfTracksX2;
~proPatViewG = 0 ! ~nbOfTracksX2;
~proBjorViewG = 0 ! ~nbOfTracksX2;
~proBjor2ViewG = 0 ! ~nbOfTracksX2;
~proSelectViewG = 0 ! ~nbOfTracksX2;
~rtmMulPresetViewViewG = 0 ! ~nbOfTracksX2;
~rtmMulPresetViewG = 0 ! ~nbOfTracksX2;
~proMulViewG = 0 ! ~nbOfTracksX2;
~ratMulViewG = 0 ! ~nbOfTracksX2;
~legMulViewG = 0 ! ~nbOfTracksX2;
~legMulPresetViewViewG = 0 ! ~nbOfTracksX2;
~legMulPresetViewG = 0 ! ~nbOfTracksX2;
~strMulViewG = 0 ! ~nbOfTracksX2;
~cenMulViewG = 0 ! ~nbOfTracksX2;
~bufMulViewG = 0 ! ~nbOfTracksX2;
~offMulViewG = 0 ! ~nbOfTracksX2;
~xqViewG = 0 ! ~nbOfTracksX2;
~playViewG = 0 ! ~nbOfTracksX2;
~play2ViewG = 0 ! ~nbOfTracksX2;
~retriggerPresetViewG = 0 ! ~nbOfTracksX2;
~retriggerPreset1ViewG = 0 ! ~nbOfTracksX2;
~retriggerPresetPreViewG = 0 ! ~nbOfTracksX2;
~triggerAllSeqsViewG = 0 ! ~nbOfTracksX2;
~triggerAllSeqs = 0 ! ~nbOfTracksX2; // initialisé aussi auparavant dans Init Midi Twister
~folRandViewG = 0 ! ~nbOfTracksX2;
~ratRandViewG = 0 ! ~nbOfTracksX2;
~strRandViewG = 0 ! ~nbOfTracksX2;
~bufRandViewG = 0 ! ~nbOfTracksX2;
~offRandViewG = 0 ! ~nbOfTracksX2;
~spaRandViewG = 0 ! ~nbOfTracksX2;
~outRandViewG = 0 ! ~nbOfTracksX2;
~positionRandSeqViewG = 0 ! ~nbOfTracksX2;
~seqABVisibleViewG = 0 ! ~nbOfTracksX2;
~seqABPlayingViewG = 0 ! ~nbOfTracksX2;

// ~tabGlobal.decorator = FlowLayout(~tabGlobal.view.bounds);

~presetSeqTextViewG = {0 ! ~nbOfSeqs} ! ~nbOfTracksX2;
~presetSeqNbViewG = {0 ! ~nbOfSeqs} ! ~nbOfTracksX2;
~presetSeqNbSelectDurViewG = {0 ! ~nbOfSeqs} ! ~nbOfTracksX2;
~presetSeqNbTextViewG = {0 ! ~nbOfSeqs} ! ~nbOfTracksX2;

~presetSeqNb2ViewG = {0 ! ~nbOfSeqs} ! ~nbOfTracksX2;
// ~presetSeqNb2Value = {0 ! ~nbOfSeqs} ! ~nbOfTracksX2; // necessaire de le déclarer avant pour l'initialisation

~seqChangeViewG = 0 ! ~nbOfTracksX2; // Pour Modification de la séquence dès que le RangeSlider change - nécessaire de le déclarer au préalable -> OK à cette position
~seqChange =  0 ! ~nbOfTracksX2;


~lemurNewSeqs = 0 ! ~nbOfTracksX2; // nécessaire de le déclarer au préalable avant le Lemur
~lemurPresetSeqLength = 0 ! ~nbOfTracksX2; // nécessaire de le déclarer au préalable avant le Lemur
~presetSeqNb2LemurValue = 0 ! ~nbOfTracksX2;
~lemurTracksRadioSwitches = 0 ! ~nbOfTracksX2; // nécessaire de le déclarer au préalable avant le Lemur


~updateLemurTrackSeq = { |lemurAdress, tr, p, flag| var a, b, c;

	/*if (flag == 1, {
	case
	{lemurAdress == ~lemurAdress1}
	{lemurAdress.sendMsg( *[["/TrackSwitch1/x"] ++ (0 ! (tr/2).asInteger ++ 1 ++ (0 ! (~nbOfTracksX2-tr/2-1).asInteger)  ++ 0) ].flatten(1) );}
	{lemurAdress == ~lemurAdress2}
	{lemurAdress.sendMsg( *[["/TrackSwitch1Lemur2/x"] ++ (0 ! (tr/2).asInteger ++ 1 ++ (0 ! (~nbOfTracksX2-tr/2-1).asInteger)  ++ 0) ].flatten(1) );};

	if (~seqCompGABIndex[(tr/2).asInteger] == 1, { lemurAdress.sendMsg( ~lemurABSwitchesValues[(tr/2).asInteger],  1); }, { lemurAdress.sendMsg( ~lemurABSwitchesValues[(tr/2).asInteger],  0); });
	});*/

	if ((p/*+1*/) != ~lemurNewSeqs[tr] or: {(p+1) != ~lemurNewSeqs[tr]}, { // ou à chaque fois que c'est une sélection - pas très économique

		//  "hey".postln;

		if ( ~lemurNewSeqs[tr].size == 0, {

			if (p - ~presetSeqStop[tr] == 0, {
				a = ~lemurSwitchesMapsPatch3[p];
				lemurAdress.sendMsg( *[[~lemurSwitchesValues[tr]] ++ ((0 ! a) ++ 1 ++ (0 ! (240-a)))].flatten(1) );

				if (flag == 1, {
					lemurAdress.sendMsg( "/CurSeq2/value", p+1 /*1.0.rand*/);
					lemurAdress.sendMsg( *["/CurSeqText2", "@content", ~presetSelection[tr][p] ]);
				});
			},{
				// Avant, mais erreur lorsque de grandes sélections de séquences qui débordent
				/*a = ~lemurSwitchesMapsPatch3[p].postcs;
				b = ~presetSeqStop[tr];
				b = ~lemurSwitchesMapsPatch3[b].postcs;
				lemurAdress.sendMsg( *[[~lemurSwitchesValues[tr]] ++ ((0 ! a) ++ (1 ! (b-a+1))  ++ (0 ! (240-a-(b-a-1))))].flatten(1) );*/

				b = (p..~presetSeqStop[tr]).collect { |i| ~lemurSwitchesMapsPatch3[i] };
				c = 0 ! ~nbOfSeqs; b.do { |i| c[i] = 1; };
				lemurAdress.sendMsg( *[[~lemurSwitchesValues[tr]] ++ c].flatten(1) );

				if (flag == 1, {
					lemurAdress.sendMsg( *[ ["/CurSeq2/value"], [((p+1)..~presetSeqStop[tr]+1).asString] ].flatten(1) );
					lemurAdress.sendMsg( *["/CurSeqText2", "@content", "" /*~presetSelection[tr][p]*/ ]);
				});
			});

			// ~lemurAdress1.sendMsg( "/Tracks/FTr1SelSeq/x", 1-((20/200)*10/9) /*1.0.rand*/);
			// 1-((19/200)*10/9)
			// (1/11) * (1..11)
			case
			{ p.inclusivelyBetween(0,19) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 1); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-6, -7, 2748, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(20,39) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.91); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-919, -7, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(40,59) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.82); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-1833, -7, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(60,79) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.72); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-6, -223, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(80,99) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.63); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-919, -223, 2758 ,890]].flatten(1) );  }
			{ p.inclusivelyBetween(100,119) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.54);lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-1833, -223, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(120,139) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.45); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-6, -440, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(140,159) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.36); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-919, -440, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(160,179) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.27); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-1833, -440, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(180,199) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.18); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-6, -656, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(200,219) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.09); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-919, -656, 2758, 890]].flatten(1) );  }
			{ p.inclusivelyBetween(220,239) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-1833, -656, 2758, 890]].flatten(1) );  };
			// { ~presetSeqStart[tr] > 200 } {};

		},{

			// Avant
			// ~lemurPresetSeqLength[tr] = ~lemurNewSeqs[tr].collect { |i, id| i ! ~presetSeqNbSelectDurValue[tr][i-1] }.flat;
			// Après
			// ~presetSeqNb2LemurValue[tr]  = ~lemurNewSeqs[tr].collect { |i, id| ~presetSeqNb2Value[tr][i-1] };
			// ~lemurPresetSeqLength[tr] = ~lemurNewSeqs[tr][~presetSeqNb2LemurValue[tr].order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[tr][i-1] }.flat;
			// Plus necessaire - déjà dans ~presetSeqRangeViewG et d'autres

			/*
			~lemurNewSeqs[~tracksValue] = [3,6,9,15]
			{~presetSeqNb2LemurValue = ~lemurNewSeqs[~tracksValue].collect { |i, id| ~presetSeqNb2Value[~tracksValue][i-1] }; ~lemurPresetSeqLength[~tracksValue] = ~lemurNewSeqs[~tracksValue].collect { |i, id| i ! ~presetSeqNbSelectDurValue[~tracksValue][i-1] }.flat;}.bench
			{~presetSeqNb2LemurValue = ~lemurNewSeqs[~tracksValue].collect { |i, id| ~presetSeqNb2Value[~tracksValue][i-1] }; ~lemurPresetSeqLength[~tracksValue] = ~lemurNewSeqs[~tracksValue][~presetSeqNb2LemurValue.order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[~tracksValue][~presetSeqNb2LemurValue.order][id] }.flat;}.bench
			*/

			/*~lemurSwitchesMapsPatch4 = [ 0, 1, 2, 3, 4, 5, 16, 17, 18, 19, 20, 31, 32, 33, 34, 35, 46, 47, 48, 49, 50, 6, 7, 8, 9, 10, 21, 21, 23, 24, 25, 36, 37, 38, 39, 40, 51, 52, 53, 54, 55, 11, 12, 13, 14, 15, 26, 27, 28, 29, 30, 41, 42, 43, 44, 45, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 76, 77, 78, 79, 80, 91, 92, 93, 94, 95, 106, 107, 108, 109, 110, 66, 67, 68, 69, 70, 81, 82, 83, 84, 85, 96, 97, 98, 99, 100, 111, 112, 113, 114, 115, 71, 72, 73, 74, 75, 86, 87, 88, 89, 90, 101, 102, 103, 104, 105, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 136, 137, 138, 139, 140, 151, 152, 153, 154, 155, 166, 167, 168, 169, 170, 126, 127, 128, 129, 130, 141, 142, 143, 144, 145, 156, 157, 158, 159, 160, 171, 172, 173, 174, 175, 131, 132, 133, 134, 135, 146, 147, 148, 149, 150, 161, 162, 163, 164, 165, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 196, 197, 198, 199, 200, 211, 212, 213, 214, 215, 226, 227, 228, 229, 230 ];*/
			~lemurNewSeqsPatch = ~lemurNewSeqs[tr].collect { |i| ~lemurSwitchesMapsPatch4[i] }.sort;
			~lemurSeqDif = ~lemurNewSeqsPatch.differentiate;

			lemurAdress.sendMsg( *[[~lemurSwitchesValues[tr]] ++ ~lemurSeqDif.collect { |i| [0 ! (i-1), 1] }.flat ++ (0 ! (240 - ~lemurSeqDif.sum)) ].flatten(1) );
			case
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(0,19) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 1); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-6, -7, 2748, 890]].flatten(1) );  }
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(20,39) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.91); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-919, -7, 2758, 890]].flatten(1) );  }
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(40,59) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.82); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-1833, -7, 2758, 890]].flatten(1) );  }
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(60,79) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.72); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-6, -223, 2758, 890]].flatten(1) );  }
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(80,99) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.63); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-919, -223, 2758 ,890]].flatten(1) );  }
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(100,119) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.54);lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-1833, -223, 2758, 890]].flatten(1) );  }
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(120,139) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.45); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-6, -440, 2758, 890]].flatten(1) );  }
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(140,159) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.36); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-919, -440, 2758, 890]].flatten(1) );  }
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(160,179) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.27); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-1833, -440, 2758, 890]].flatten(1) );  }
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(180,199) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.18); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-6, -656, 2758, 890]].flatten(1) );  }
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(200,219) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0.09); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-919, -646, 2758, 890]].flatten(1) );  }
			{ ~lemurNewSeqs[tr].minItem.inclusivelyBetween(220,239) }
			{ lemurAdress.sendMsg( ~lemurFaderValues[tr], 0); lemurAdress.sendMsg( *[[~lemurSwitchesContainerNames[tr]], ["@rect"], [-1833, -656, 2758, 890]].flatten(1) );  };

			if (flag == 1, {
				// lemurAdress.sendMsg( "/CurSeq2/value", ~lemurNewSeqs[tr] /*1.0.rand*/);
				lemurAdress.sendMsg( *[ ["/CurSeq2/value"], [~lemurNewSeqs[tr].asString] ].flatten(1) );
				// ~lemurAdress1.sendMsg( *[ ["/CurSeq2/value"], [~lemurNewSeqs[~tracksValue].asString] ].flatten(1) );
				lemurAdress.sendMsg( *["/CurSeqText2", "@content", ""/*~presetSelection[tr][~lemurNewSeqs[tr][0]+1]*/ ]);

			});

		});

	});

};


~tracks.do { |tr|

	var width, height;

	case
	/*{ tr.inclusivelyBetween(0, 7)} { width = (tr / 2).asInteger * 399+2; if (tr.even, {height = 0}, {height = 270})  }
	{ tr.inclusivelyBetween(8, 15)} { width = (tr / 2).asInteger % 4 * 399+2; if (tr.even, {height = 270*2}, {height = 270*3})  };*/

	{ tr.inclusivelyBetween(0, 7)} { width = ((tr / 2).asInteger * 399+2)*~xSizeMul; height = 0 }
	{ tr.inclusivelyBetween(8, 15)} { width = ((tr / 2).asInteger % 4 * 399+2)*~xSizeMul; height = (270*2)*~ySizeMul };


	// ~seqsGlobalColors = ([~seqCompColor, Color.yellow, ~seqCompColor, Color.yellow, Color.yellow, ~seqCompColor, Color.yellow, ~seqCompColor] ! /*~nbOfTracksX2*/ 2).flat;
	// ~seqsGlobalColors = ([Color.grey(0.9), Color.grey(0.8), Color.grey(0.7), Color.grey(0.6), Color.grey(0.5), Color.grey(0.4), Color.grey(0.3), Color.grey(0.2)] ! 2).flop.flat;
	~seqsGlobalColors = ([Color.grey(0.2)!2, Color.grey(0.1)!2] !2).flat ++ ([Color.grey(0.1)!2, Color.grey(0.2)!2] !2).flat;
	// ~seqsGlobalColors = Color.grey(0.7) ! ~nbOfTracksX2;

	~seqCompG[tr] = CompositeView(~tabGlobal, Rect(width, height, 399*~xSizeMul, (270*2)*~ySizeMul))/*.focus(false)*/.background = ~seqsGlobalColors[tr] /*Color.grey(0.7)*/;
	/*~seqCompG[tr].decorator = FlowLayout(~tabGlobal.view.bounds);
	~seqCompG[tr].decorator.nextLine;
	~tabGlobal.decorator.nextLine;*/

	~seqCompG1[tr] = ScrollView(~seqCompG[tr], Rect(34*~xSizeMul, 20*~ySizeMul, 363*~xSizeMul, 422*~ySizeMul /*198*2*/)).hasHorizontalScroller_(false).hasVerticalScroller_(true/*false*/).focus(false).background_( /*~seqsGlobalColors[tr]*/ Color.grey(0.7)); // StaticText des presets - vertical

	~seqUserView2[tr] = UserView(~seqCompG[tr], Rect(0, 0, 340*~xSizeMul, 1290*~ySizeMul)).acceptsMouse_(0); // si 350 au lieu de 340, léger vacillement horizontal

	~presetSeqRangeSpec = ControlSpec(~nbOfSeqs, 0, \lin, 1, 0);
	~presetSeqRangeViewG[tr] = SmoothRangeSlider(~seqCompG1[tr], Rect(1*~xSizeMul, 0, 26*~xSizeMul, ((20*~nbOfSeqs)+6)*~ySizeMul))
	.action_({ |view| // var presetName;
		var a, b, p;

		// if (~sequenceType[tr][~seqSeq[tr]/*~seqsValue*/] == 1, { ~tracksView.valueAction_(tr) } ); // Nécessaire quand on est en loop d'être sur la piste, pour casser la boucle
		// n'est valable que lorsqu'on change de piste // necessaire de le faire lors du changement de séquence si plusieurs sont sélectionnées / sinon effet étrange
		// Comment y remédier si plusieurs séquences sont en looping sur une même piste ???????????????????????????????????????????????????????????????????????????????????
		// -> Plus necessaire car changement du Relancement des routines quand Mode Looping change dans le pattern, réalisé dans  Init Pattern 163.scd

		~presetSeqStart[tr] = ~presetSeqRangeSpec.map(view.hi).asInteger; ~presetSeqStop[tr] = ~presetSeqRangeSpec.map(view.lo).asInteger - 1;

		// Sortie de la condition ~lemurConnected1 afin de pouvoir lire des séquences d'une piste d'une manière discontinue sans le Lemur
		if ( ~lemurTracksRadioSwitches[tr] == 0 or: {/*~presetSeqLength[tr].size == 1*/ (~presetSeqStop[tr] - ~presetSeqStart[tr]) == 0}, {
			~lemurNewSeqs[tr] = 0;
			~lemurNewSeqs[tr] = ~presetSeqStart[tr]/*+1*/; // le +1 empêche l'affichage de la multiple sélection sur le Lemur du RangeSlider
		});

		if (~lemurNewSeqs[tr].size == 0, {
			~seq2[tr] = (1..~nbOfSeqs).copyRange(~presetSeqStart[tr], ~presetSeqStop[tr])[~presetSeqNb2Value[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr]).order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr])[~presetSeqNb2Value[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr]).order][id] }.flat;
		},{
			~presetSeqNb2LemurValue[tr]  = ~lemurNewSeqs[tr].collect { |a, ad| ~presetSeqNb2Value[tr][a-1] };
			~lemurPresetSeqLength[tr] = ~lemurNewSeqs[tr][~presetSeqNb2LemurValue[tr].order].collect { |a, ad| a ! ~presetSeqNbSelectDurValue[tr][a-1] }.flat;
		});

		// ~seq2[tr] = (1..~nbOfSeqs).copyRange(~presetSeqStart[tr], ~presetSeqStop[tr])[~presetSeqNb2Value[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr]).order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr])[~presetSeqNb2Value[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr]).order][id] }.flat;

		// Pour la fabrication de la séquence aléatoire à chaque fois que le RangeSlider est modifié - à ne mettre en place que si la durée de la séquence est > à 1 -> à faire XXX
		~presetSeqRangeRand[tr] = Pxrand(~seq2[tr]/*.copyRange(~presetSeqStart[tr], ~presetSeqStop[tr])*/, inf).asStream;

		// Changement de séquence dès que le RangeSlider est modifié sans attendre la fin de la séquence
		if (~seqChange[tr] == 1, {
			~seqBlock[tr] = 1;
			[\rtmBlock, \proBlock, \synBlock, \spaBlock, \legBlock, \envBlock, \bufBlock, \ampBlock, \ratBlock, \rat2Block, \offBlock, \strBlock, \str2Block, \cenBlock, \cen2Block, \panBlock, \delBlock, \outLBlock, \outRBlock, \fxLBlock, \fxRBlock].do {|i| currentEnvironment[i][tr] = 1};
		} );

		// ~presetsEventSource.fire( ~presetSelection[tr][~presetSeqStart[tr]].value.asSymbol /*~presetSelectionView.item.asSymbol*/ ); // test pour intégrer la mémoire de preset de la ListView avec celle de sélection des séquences du SmoothSlider

		p = ~presetSeqStart[tr];

		// Armer la séquence si changement du rangeslider en mode Montage Pas à Pas
		if (~curSeqTrig == 1, {

			if (Pdef(~patterns2[tr]).isPlaying == false, {

				if (~seqChange[tr] == 0, {~seqChangeViewG[tr].valueAction_(1)});

				if (~tracksValue != tr, {~tracksView.valueAction_(tr)});
				~seqsView.valueAction_(p);

				// ~oneEvent[(tr/2).floor] = Pdef(~patterns[(tr/2).floor]).asStream;
				/*if (~seqChange == 1, {
				try { ~presetGetFunction.value(~presetSelection[tr][ ~presetSeqStart[tr] /*~seqsValue*/].asSymbol); };
				});*/
			});
		});

		// if (~tracksValue == 0, {~presetsSelEventSource.fire(~presetSeqStart[~tracksValue]) });
		case
		{ tr == 0 } { ~presetsSelEventSource[0].fire(~presetSeqStart[0]);
			if (~positionInPresetSel[0] != (~presetsSelListMemoryNb-1), {~positionInPresetSel[0] = (~presetsSelListMemoryNb-1) }); // Afin de remettre à 0 la position du preset si modif du ~presetSeqRangeView
		}
		{ tr == 2 } { ~presetsSelEventSource[1].fire(~presetSeqStart[2]);
			if (~positionInPresetSel[1] != (~presetsSelListMemoryNb-1), {~positionInPresetSel[1] = (~presetsSelListMemoryNb-1) });
		}
		{ tr == 4 } { ~presetsSelEventSource[2].fire(~presetSeqStart[4]);
			if (~positionInPresetSel[2] != (~presetsSelListMemoryNb-1), {~positionInPresetSel[2] = (~presetsSelListMemoryNb-1) });
		};


		if (~lemurConnected2 == 1, { // "test".postln;

			if (tr == ~secondLemurX2Track, {
				~updateLemurTrackSeq.(~lemurAdress2, tr, p, 1);
			}, {
				~updateLemurTrackSeq.(~lemurAdress2, tr, p)
			});
		});


		if (~lemurConnected1 == 1, {
			if (tr == ~tracksValue, {
				~updateLemurTrackSeq.(~lemurAdress1, tr, p, 1);
			}, {
				~updateLemurTrackSeq.(~lemurAdress1, tr, p);
			});

		});


		/*// Sortie de la condition ~lemurConnected1 afin de pouvoir lire des séquences d'une piste d'une manière discontinue sans le Lemur
		if ( ~lemurTracksRadioSwitches[tr] == 0 or: {/*~presetSeqLength[tr].size == 1*/ (~presetSeqStop[tr] - ~presetSeqStart[tr]) == 0}, {
		~lemurNewSeqs[tr] = 0;
		~lemurNewSeqs[tr] = ~presetSeqStart[tr]/*+1*/; // le +1 empêche l'affichage de la multiple sélection sur le Lemur du RangeSlider
		});*/

		{
			if (~lemurNewSeqs[tr].isInteger, {
				~presetSeqRangeViewG[tr].background_(~sliderBackgroundColor2).hilightColor_(Color.red); // ~presetSeqRangeViewG[(t*2)+1].background_(~sliderBackgroundColor).hilightColor_(Color.red);
			},{
				~presetSeqRangeViewG[tr].background_(Color.magenta).hilightColor_(Color.blue); // ~presetSeqRangeViewG[(t*2)+1].background_(Color.magenta).hilightColor_(Color.blue)
			})
		}.defer;

	})
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor2/*Color.red*/)
	.hilightColor_(Color.red)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	// .value_([1,  ~presetSeqRangeSpec.unmap(1)])
	.minRange_(1/(~nbOfSeqs))
	.step_(1/(~nbOfSeqs));
	// .doAction;



	~nbOfSeqs.do { |i|

		~presetSeqTextViewG[tr][i] = StaticText(~seqCompG1[tr], Rect(53*~xSizeMul, (2+(20*i))*~ySizeMul, 308*~xSizeMul, 18*~ySizeMul))
		.background_(Color.grey(0.3))
		.font_(Font(~monoSpaceFont, (10*~fontSizeMul).asInteger) /*("Arial", 10) ("Verdana", 9)*/)
		.stringColor_(Color.white)
		// .canReceiveDragHandler_({ View.currentDrag.isString })
		.canReceiveDragHandler_({ // Protection pour ne pas changer le preset qui est en train d'être lu
			// if (/*(~presetSeqStart[~tracksValue]..~presetSeqStop[~tracksValue]).includes(~seqSeq[~tracksValue]) == false*/
			if (i != ~posSeq2[tr], {View.currentDrag.isString}, { if (Pdef(~patterns2[tr]).isPlaying == false, {View.currentDrag.isString}); } );
		})
		.receiveDragHandler_({
			// var toPutInSeq;
			// Sélectionner une séquence vide la plus petite pour mettre un preset
			// toPutInSeq = ~seqs.collect{ |i| if (~presetSelection[~tracksValue][i] == 0, { i } ) }.reject{ |x| x.isNil }.minItem;
			~presetSelection/*[~tracksValue]*/[tr][i] = View.currentDrag;
			~presetSeqTextViewG[tr][i].string = ~presetSelection[tr][i];
			~presetGetFunctionQuick.value(/*~presetList.choose.asSymbol.postln*/ ~presetSelection[tr][i].asSymbol, tr, /*toPutInSeq*/ i);
			// ~presetSeqNbText[i].string_(toPutInSeq);
		})
		.action_({ /*~presetSeqText.string.postln*/ })
		.string_(0);
		// .visible_(0);

		~presetSeqNbViewG[tr][i] = StaticText(~seqCompG1[tr], Rect(3*~xSizeMul, (3+(20*i))*~ySizeMul, 20*~xSizeMul, 15*~ySizeMul))
		.acceptsMouse_(0)
		.font_(Font("Verdana", (11*~fontSizeMul).asInteger /*, bold: true*/))
		.stringColor_(Color.white)
		.string_((i+1).asString);

		~presetSeqNb2ViewG[tr][i] = /*Round*/NumberBox(~seqCompG1[tr], Rect(28*~xSizeMul, (4+(20*i))*~ySizeMul, 24*~xSizeMul, 15*~ySizeMul))
		.clipLo_(1).clipHi_(~nbOfSeqs).align_( \right )
		.font_(Font("Verdana", 10*~fontSizeMul /*, bold: true*/))
		.background_(Color.clear.alpha_(0)/*~sliderBackgroundColor*//*Color.blue*/)
		.stringColor_(Color.white)
		.typingColor_(Color.white)
		.normalColor_(/*Color.white*/Color.clear.alpha_(0))
		.step_(1.0)
		.scroll_step_(0.0)
		// .alt_scale_(1.0)
		.action_({|view|

			~presetSeqNb2Value[tr][i] = view.value.asInteger;

			if (~lemurNewSeqs[tr].size == 0, {
				~seq2[tr] = (1..~nbOfSeqs).copyRange(~presetSeqStart[tr], ~presetSeqStop[tr])[~presetSeqNb2Value[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr]).order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr])[~presetSeqNb2Value[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr]).order][id] }.flat;
			},{
				~presetSeqNb2LemurValue[tr]  = ~lemurNewSeqs[tr].collect { |a, ad| ~presetSeqNb2Value[tr][a-1] };
				~lemurPresetSeqLength[tr] = ~lemurNewSeqs[tr][~presetSeqNb2LemurValue[tr].order].collect { |a, ad| a ! ~presetSeqNbSelectDurValue[tr][a-1] }.flat;
			});

			/*
			{ ~seq2[~tracksValue] = (~nbOfSeqs.collect { |i| (i+1).dup(~presetSeqNbSelectDurValue[~tracksValue][i]) } ++ ~nbOfSeqs.collect { |i| ~presetSeqNbSelectValue[~tracksValue][i].dup(~presetSeqNbSelectDurValue[~tracksValue][i+~nbOfSeqs]) }).flat; }.bench; // Originel
			{ ~seq2[~tracksValue] = ((1..~nbOfSeqs)[~presetSeqNb2Value[~tracksValue].order].collect { |i, id| i.dup(~presetSeqNbSelectDurValue[~tracksValue][~presetSeqNb2Value[~tracksValue].order][id]) } ++ ~nbOfSeqs.collect { |i| ~presetSeqNbSelectValue[~tracksValue][i].dup(~presetSeqNbSelectDurValue[~tracksValue][i+~nbOfSeqs]) }).flat; }.bench; // 100 x plus lent
			{ ~seq2[~tracksValue] = ((1..~nbOfSeqs)[~presetSeqNb2Value[~tracksValue].order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[~tracksValue][~presetSeqNb2Value[~tracksValue].order][id] } ++ ~nbOfSeqs.collect { |i| ~presetSeqNbSelectValue[~tracksValue][i].dup(~presetSeqNbSelectDurValue[~tracksValue][i+~nbOfSeqs]) }).flat; }.bench; // 100 x plus lent

			{ ~seq2[~tracksValue] = (1..~nbOfSeqs).copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])[~presetSeqNb2Value[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]).order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue])[~presetSeqNb2Value[~tracksValue].copyRange(~presetSeqStart[~tracksValue], ~presetSeqStop[~tracksValue]).order][id] }.flat; }.bench // 10 à 20 x plus rapide en réduisant la taille de la base

			{ 1000.do { ~seq2[~tracksValue] =  (1..~nbOfSeqs)[~presetSeqNb2Value[~tracksValue].copy.sort.collect(~presetSeqNb2Value[~tracksValue].indexOf(_))] } }.bench // a l'air un peu plus rapide
			{ 1000.do { (1..~nbOfSeqs)[~presetSeqNb2Value[~tracksValue].order] } }.bench

			~seq2[~tracksValue]
			*/

			if (~presetSeqNb2Value[tr][i] != ~presetSeqNbViewG[tr][i].string.asInteger, { ~presetSeqNb2ViewG[tr][i].background_(Color.red).normalColor_(Color.white); ~presetSeqNbTextViewG[tr][i].stringColor_(Color.clear.alpha_(0)) }, { ~presetSeqNb2ViewG[tr][i].background_(Color.clear.alpha_(0)/*~sliderBackgroundColor*//*Color.blue*/).normalColor_(Color.clear.alpha_(0)); ~presetSeqNbTextViewG[tr][i].stringColor_(Color.black) } );

		});


		~presetSeqNbSelectDurViewG[tr][i] = /*Round*/NumberBox(~seqCompG1[tr], Rect(335*~xSizeMul, (1+(i*20))*~ySizeMul, 26*~xSizeMul, 20*~ySizeMul))
		.clipLo_(1).clipHi_(~nbOfSeqs).align_( \right )
		.font_(Font("Verdana", 10*~fontSizeMul /*, bold: true*/))
		.background_(Color.clear.alpha_(0)/*~sliderBackgroundColor*//*Color.blue*/)
		.stringColor_(Color.white)
		.typingColor_(Color.white)
		.normalColor_(/*Color.white*/Color.clear.alpha_(0))
		.step_(1)
		.scroll_step_(0.0)
		// .alt_scale_(1.0)
		.action_({|view|

			~presetSeqNbSelectDurValue[tr][i] = view.value.asInteger;

			if (~presetSeqNbSelectDurValue[tr][i] > 1, { ~presetSeqNbSelectDurViewG[tr][i].background_(Color.red).normalColor_(Color.white) }, { ~presetSeqNbSelectDurViewG[tr][i].background_(Color.clear.alpha_(0)/*~sliderBackgroundColor*//*Color.blue*/).normalColor_(Color.clear.alpha_(0)) } );

			// Prise en compte des ~presetSeqNbSelectDurValue
			/*~seq2[tr] = (~nbOfSeqs.collect { |i| (i+1).dup(~presetSeqNbSelectDurValue[tr][i]) } ++ ~nbOfSeqs.collect { |i| ~presetSeqNbSelectValue[tr][i].dup(~presetSeqNbSelectDurValue[tr][i+~nbOfSeqs]) }).flat;*/


			if (~lemurNewSeqs[tr].size == 0, {
				~seq2[tr] = (1..~nbOfSeqs).copyRange(~presetSeqStart[tr], ~presetSeqStop[tr])[~presetSeqNb2Value[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr]).order].collect { |i, id| i ! ~presetSeqNbSelectDurValue[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr])[~presetSeqNb2Value[tr].copyRange(~presetSeqStart[tr], ~presetSeqStop[tr]).order][id] }.flat;
			},{
				~presetSeqNb2LemurValue[tr]  = ~lemurNewSeqs[tr].collect { |a, ad| ~presetSeqNb2Value[tr][a-1] };
				~lemurPresetSeqLength[tr] = ~lemurNewSeqs[tr][~presetSeqNb2LemurValue[tr].order].collect { |a, ad| a ! ~presetSeqNbSelectDurValue[tr][a-1] }.flat;
			});

		});

		// }}}.bench

		// /*~tracks.collect { |t| */~presetSeqNbSelectDurValue[tr][i] = 1 /*}*/;
		~presetSeqNbSelectDurViewG[tr][i].valueAction = 1;


		~presetSeqNbTextViewG[tr][i] = StaticText(~seqCompG1[tr], Rect(32*~xSizeMul, (4+(20*i))*~ySizeMul, 18*~xSizeMul, 15*~ySizeMul))
		.acceptsMouse_(0)
		.font_(Font("Verdana", 10*~fontSizeMul /*, bold: true*/))
		.stringColor_(Color.black)
		.align_(\right)
		// .background_(Color.yellow)
		.string_((i+1).asString);


		~presetSeqNb2ViewG[tr][i].valueAction_(i+1);


	};


	~presetSeqRangeViewG[tr].valueAction_([1, ~presetSeqRangeSpec.unmap(1)]);


	~positiontoSeqTrViewGStringColors = ([Color.white, Color.magenta] ! ~nbOfTracks).flat;
	~positiontoSeqTrViewGBackgroundColors = ([Color.magenta, Color.white] ! ~nbOfTracks).flat;
	~positiontoSeqTrViewG[tr] = RoundButton(~seqCompG[tr], Rect(34*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 16*~ySizeMul))
	.states_([[~tracksViewItemsB[tr], ~positiontoSeqTrViewGStringColors[tr], ~positiontoSeqTrViewGBackgroundColors[tr]]])
	.font_(Font("Verdana", 12*~fontSizeMul))
	.action_({|i| ~tracksView.valueAction_(tr); /*~tabbedView.focus(0)*/ });

	~seqABVisibleViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["A", Color.white, Color.magenta], ["B", Color.magenta, Color.white]])
	.font_(Font("Verdana", 10*~fontSizeMul /*, bold: true*/))
	.action_({ |i| ~seqCompGABIndex[(tr/2).asInteger] = i.value;
		if (tr.even,
			{ /*~seqCompGABIndex[(tr/2).asInteger] = 1;*/ ~seqCompG[tr].visible_(0); ~seqCompG[tr+1].visible_(1); ~seqABVisibleViewG[tr+1].value_(1); /*if (~lemurConnected1 == 1 or: { ~aControllerConnected == 1 }, {*/ {~tracksView.valueAction_(tr+1)}.defer; /*} )*/ },
			{ /*~seqCompGABIndex[(tr/2).asInteger] = 0;*/ ~seqCompG[tr].visible_(0); ~seqCompG[tr-1].visible_(1); ~seqABVisibleViewG[tr-1].value_(0); /*if (~lemurConnected1 == 1 or: { ~aControllerConnected == 1 }, {*/ {~tracksView.valueAction_(tr-1)}.defer; /*} )*/ };
		);
		~rhythmTracksX2 = ~rhythmTracks.collect { |i| (i*2) + ~seqCompGABIndex[i] }; // Mise à jour de pistes rythmiques
	});

	~seqABPlayingViewG[tr] = StaticText(~seqCompG[tr], Rect(2*~xSizeMul, 24*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.background_(Color.grey)
	.font_(Font("Verdana", 10*~fontSizeMul, bold: true))
	.stringColor_(Color.yellow);

	~positionRandSeqViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 262*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["Seq", Color.white, Color.blue], ["RSeq", Color.white, Color.red]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i| ~positionRandSeq[tr] = i.value; ~positionRandSeqView.value_(~positionRandSeq[tr]) });

	/*~seqSeqAllViewG[tr] = RoundButton(~seqCompG[tr], /*Rect(367, 175, 30, 16)*/ Rect(38, 220, 32, 20))
	.states_([["All S", Color.white, Color.blue]])
	.font_(Font("Verdana",8))
	.action_({~seqSeqView.valueAction_([0, 1]); ~presetSeqRangeViewG[tr].valueAction_([0, 1]);
	});*/

	~seqSeqModeG[tr] = RoundButton(~seqCompG[tr], /*Rect(367, 195, 30, 16)*/ Rect(2*~xSizeMul, 469*~ySizeMul, 32*~xSizeMul, 20*~ySizeMul))
	.states_([["\Drag", Color.black, ~popUpMenuBackgroundColor], ["\Jump", Color.black, ~popUpMenuBackgroundColor]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| ~seqSeqView.mode_(~modes[i.value]); ~presetSeqRangeViewG[tr].mode_(~modes[i.value]) })
	.valueAction_(1);


	// Visu Rouge
	/*
	~seqReadViewG[tr] = Slider(~seqCompG1[tr], Rect(290, 1, 18, (3200/200*~nbOfSeqs))).background_(Color.red/*.alpha_(0.3)*/).knobColor_(Color.blue).acceptsMouse_(0).thumbSize_(17).valueAction_(1);

	~rtmReadViewG[tr] = Slider(~seqCompG[tr], /*~readViewPos5*/ Rect(2, 2, 310, 16)).background_(Color.red /*Color.magenta*/).knobColor_(Color.blue).acceptsMouse_(0).thumbSize = 15;
	*/

	// Nouvelle Visu - plus douce sans rouge
	~readViewSliderButtonColor = /*Color.grey(0.3)*/ Color.yellow; // en double - répété plus tard dans visu des sliders de séquences
	~readViewSliderButtonColor2 = Color.black; // en double - répété plus tard dans visu des sliders de séquences
	~readViewSliderBackgroundColor = Color.grey(0.6); // en double - répété plus tard dans visu des sliders de séquences

	/*~seqReadViewG[tr] = Slider(~seqCompG1[tr], Rect(292, 1, 18, (6400/200*~nbOfSeqs))).background_(~readViewSliderBackgroundColor).knobColor_(/*~readViewSliderButtonColor2*/Color.yellow).acceptsMouse_(0).thumbSize_(28).valueAction_(1);
	~seqReadViewG[tr].palette = ~seqReadViewG[tr].palette.button_(/*~readViewSliderButtonColor*/Color.blue);*/

	~seqReadViewG[tr] = Slider(~seqCompG1[tr], Rect(26*~xSizeMul, 1*~ySizeMul, 28*~xSizeMul, (20*~nbOfSeqs)*~ySizeMul)).background_(/*~readViewSliderBackgroundColor*/ Color(0.7, 0.7, 0.7, 0)).knobColor_(/*~readViewSliderButtonColor2*//*Color.yellow.alpha_(0.4)*//*Color.blue.alpha_(0.4)*/Color.clear).acceptsMouse_(0).thumbSize_(18*~xSizeMul).valueAction_(1).canFocus_(false);
	// ~seqReadViewG[0].palette.hasColor = (Color(0.6, 0.6, 0.6, 0));
	~seqReadViewG[tr].palette = ~seqReadViewG[tr].palette.button_(/*~readViewSliderButtonColor*/Color.blue.alpha_(0.5));

	~rtmReadViewG[tr] = Slider(~seqCompG[tr], /*~readViewPos5*/ Rect(84*~xSizeMul, 2*~ySizeMul, 314*~xSizeMul, 16*~ySizeMul)).background_(~readViewSliderBackgroundColor).knobColor_(~readViewSliderButtonColor2).acceptsMouse_(0).thumbSize = ~rtmThumbSizeValue[0][0] /*15*/;
	~rtmReadViewG[tr].palette = ~rtmReadViewG[tr].palette.button_(~readViewSliderButtonColor);















	~xqViewG[tr] = RoundButton(/*~seqComp, Rect(5, 217, 65, 25)*/ ~seqCompG[tr], Rect(2*~xSizeMul, 284*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["wiXQ", Color.black, Color.yellow /*Color.new255(255, 165, 0)*/ /*Color.green*/], ["NoXQ", Color.white, Color.red]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({|i| ~xqViewValue[tr] = i.value;
		~xqControlView[tr].value_(~xqViewValue[tr]);
	});

	/*
	~playMono[0] = 1
	~playM.value(npdef: ~patterns2[0], track: ~tracks[0], nfade: ~nFade[0], pfade: ~pFade[0], quant: ~quant[0], stretchdur: 1/1)
	Function
	~playM.def
	~patterns2M = [ \a_oneM, \a_oneM, \b_twoM, \b_twoM, \c_threeM, \c_threeM, \d_fourM, \d_fourM, \e_fiveM, \e_fiveM, \f_sixM, \f_sixM, \g_sevenM, \g_sevenM, \h_heightM, \h_heightM ]
	Pdef(~patterns2[0]).pause
	*/

	~playViewG[tr] = RoundButton(/*~seqComp, Rect(75, 217, 75, 25)*/ ~seqCompG[tr], Rect(2*~xSizeMul, 306*~ySizeMul, 30*~xSizeMul, 24*~ySizeMul))
	// .states_([["Play", Color.black, Color.green], ["ying", Color.white, Color.red]])
	.states_([["Play", Color.black, Color.white], ["ying", Color.black, Color.green]])
	.font_(Font("Verdana", 9*~fontSizeMul, bold: true))
	.action_({|i| var playMSwitch; if (~playMono[tr] == 0, { playMSwitch =  \play.envirGet }, { playMSwitch =  \playM.envirGet} );

		~playViewValue[tr] = i.value;

		// ~tracksView.valueAction_(tr); // Pourquoi obligé de le rajouter sinon erreur du pattern ???????????????????????????????????????????????????????????????????????????????

		if (~playViewValue[tr].value == 1 /*and: {Pdef(~patterns2[tr]).isPlaying == false}*/, {
			if (~xqViewValue[tr] == 0, {
				playMSwitch.value(npdef: ~patterns2[tr], track: ~tracks[tr], nfade: ~nFade[tr], pfade: ~pFade[tr], quant: ~quant[tr], stretchdur: 1/1)
			},{
				playMSwitch.value(npdef: ~patterns2[tr], track: ~tracks[tr], nfade: ~nFade[tr], pfade: 0, quant: 0, stretchdur: 1/1); // ~playControlView[tr].value = 1 - A supprimer
			});
			~playControlView[tr].value = 1;

			// Pour mettre à jour le controlleur AKAI
			if (~aControllerConnected == 1, {
				if ( ~aController.padInternalState[2,(tr/2).asInteger] == 0, { ~aController.setState(2,(tr/2).asInteger,1); ~aController.incrementState(2,(tr/2).asInteger); ~aController.incrementState(2,(tr/2).asInteger); });
				if ( ~aController.padInternalState[3,(tr/2).asInteger] == 0, { ~aController.setState(3,(tr/2).asInteger,1); ~aController.incrementState(3,(tr/2).asInteger); ~aController.incrementState(3,(tr/2).asInteger); }); // Pour activer l'affichage du rythme
			});

		},{

			if (~xqViewValue[tr] == 0, {

				// Pour mettre à jour le visuel - meilleur manière d'updater le visuel ??????
				// x 4 car x2 puisque 0.5.wait; et encore x par 2 du fait de la quantisation
				fork({ block { |break| // pour stopper la boucle quand arrêt du pattern
					((~quant[tr] / ~toTempo).round(0.01) * 4).do {
						if (Pdef(~patterns2[tr]).isPlaying == true,

							// Pour mettre à jour le controlleur AKAI
							if (~aControllerConnected == 1, {
								~aController.setState(2,(tr/2).asInteger,2);
								~aController.setState(3,(tr/2).asInteger,2);
							});

							{
								~playControlView[tr].states_([["Stopping", Color.red, Color.yellow], [("Ying"+~tracksViewItemsB[tr]).asString, Color.black, Color.green]]); {~playControlView[tr].acceptsMouse_(false)}.defer;
								~playViewG[tr].states_([["ping", Color.red, Color.yellow], ["ying", Color.black, Color.green]]); {~playViewG[tr].acceptsMouse_(false)}.defer
							},{
								break.value;
						});
						0.5.wait; // lié au tempo ??? -> NON à chaque demi-seconde
						// "ok".postln; // juste pour tester
				}};
				~playControlView[tr].states_([[("Play"+~tracksViewItemsB[tr]).asString, Color.black, Color.white], [("Ying"+~tracksViewItemsB[tr]).asString, Color.black, Color.green]]);
				{~playControlView[tr].acceptsMouse_(true)}.defer;
				~playViewG[tr].states_([["Play", Color.black, Color.white], ["ying", Color.black, Color.green]]);
				{~playViewG[tr].acceptsMouse_(true)}.defer;

				// Pour mettre à jour le controlleur AKAI
				if (~aControllerConnected == 1, {
					~aController.setState(2,(tr/2).asInteger,0);
					~aController.setState(3,(tr/2).asInteger,0);
					~aController.setState(0,(tr/2).asInteger,0); // Pour désactiver l'affichage du rythme
				});

				});

				Pdef(~patterns2[tr]).quant_(~quant[tr]); Pdef(~patterns2[tr]).pause

			},{

				// Pour mettre à jour le controlleur AKAI
				if (~aControllerConnected == 1, {
					~aController.setState(2,(tr/2).asInteger,0);
					~aController.setState(3,(tr/2).asInteger,0);
					~aController.setState(0,(tr/2).asInteger,0); // Pour désactiver l'affichage du rythme
				});

				Pdef(~patterns2[tr]).quant_(0); Pdef(~patterns2[tr]).pause
			});
			// voir utilisation de mute -> différence vs CPU ???
			~playControlView[tr].value = 0;
		});

		~playViewFunction.(tr, ~playViewValue[tr]);

	});

	~play2ViewG[tr] = RoundButton(/*~seqComp, Rect(150, 217, 75, 25)*/ ~seqCompG[tr], Rect(2*~xSizeMul, 332*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["Res", Color.black, ~popUpMenuBackgroundColor/*Color.grey*/]])
	.font_(Font("Verdana", 9*~fontSizeMul))
	.action_({
		if (Pdef(~patterns2[tr]).isPlaying == false, {
			// La ligne ci-dessous n'est pas forcément nécessaire par rapport à la quantisation qui est quand même pris en compte ??? - voire ~play2ControlView[tr]
			// Pdef(~patterns2[tr]).resume; // Est ce que celà suffirait ???
			if (~xqViewValue[tr] == 0, {Pdef(~patterns2[tr]).quant_(~quant[tr]); Pdef(~patterns2[tr]).resume}, {Pdef(~patterns2[tr]).quant_(0); Pdef(~patterns2[tr]).resume});

			if ((tr.even && ~playViewValue[tr +1] == 1) || (tr.odd && ~playViewValue[tr -1] == 1), {~playControlView[tr].value = 0}, {~playControlView[tr].value = 1; ~playViewValue[tr] = 1; ~playViewG[tr].value_(1)});
			~playViewFunction.(tr, ~playViewValue[tr]);

			// Pour mettre à jour le controlleur AKAI
			if (~aControllerConnected == 1, {
				if ( ~aController.padInternalState[2,(tr/2).asInteger] == 0, { ~aController.setState(2,(tr/2).asInteger,1); ~aController.incrementState(2,(tr/2).asInteger); ~aController.incrementState(2,(tr/2).asInteger); });
				if ( ~aController.padInternalState[3,(tr/2).asInteger] == 0, { ~aController.setState(3,(tr/2).asInteger,1); ~aController.incrementState(3,(tr/2).asInteger); ~aController.incrementState(3,(tr/2).asInteger); }); // Pour activer l'affichage du rythme
			});

		},{
			~playViewG[tr].valueAction_(0)
		});
	});

	~triggerAllSeqsViewG[tr] = RoundButton(~seqCompG[tr], Rect(368*~xSizeMul, 494*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["1", Color.white, Color.blue], ["Sel", Color.white, Color.magenta] /*, ["Pre", Color.black, Color.yellow]*/ ])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({ |i| ~triggerAllSeqs[tr] = i.value;
		// [ /RyWinC/Sel4/x, /RyWinC/Sel5/x, /RyWinC/Sel6/x, /RyWinC/Sel7/x, /RyWinC/Sel8/x ] // autre ordre que ~lemurSelRyValues
		if (~lemurConnected1 == 1 and: {~rhythmTracksX2.includes(tr)}, { ~lemurAdress1.sendMsg( [ "/RyWinC/Sel4/x", "/RyWinC/Sel5/x", "/RyWinC/Sel6/x", "/RyWinC/Sel7/x", "/RyWinC/Sel8/x" ][(tr/2).asInteger-3], ~triggerAllSeqs[tr]) });
		if (~lemurConnected2 == 1 and: {~rhythmTracksX2.includes(tr)}, { ~lemurAdress2.sendMsg( [ "/RyWinC/Sel4/x", "/RyWinC/Sel5/x", "/RyWinC/Sel6/x", "/RyWinC/Sel7/x", "/RyWinC/Sel8/x" ][(tr/2).asInteger-3], ~triggerAllSeqs[tr]) });
	})
	.valueAction_(0);


	// Initialisation des couleurs des pistes
	~tracksPresetColorModel1 = [16] /*(0..15)*/ /*[0, 2, 4]*/; // Pistes concernées par les couleurs des séquences de trame ci-dessous // initialisé dans la GUI à toutes les pistes
	// Initialisation à 16 pour ne pas avoire de colorisation par défaut s'il n'y a rien
	~trameSequencesColors = 0 ! ~nbOfSeqs;
	~nbOfSeqs.do { |i| ~trameSequencesColors[i] = Color.grey(0.3) };

	~tracksColorizeFunction = { |t| if (~tracksPresetColorModel1.includes(t), {
		(0..(~nbOfSeqs-1)).do { |i| ~presetSeqTextViewG[t][i].background_(~trameSequencesColors[i]) } },{
		(0..(~nbOfSeqs-1)).do { |i| ~presetSeqTextViewG[t][i].background_(Color.grey(0.3)) } })
	};

	~seqsColorizeFunction = { |t, s| if (~tracksPresetColorModel1.includes(t), {
		~presetSeqTextViewG[t][s].background_(~trameSequencesColors[s]) },{
		~presetSeqTextViewG[t][s].background_(Color.grey(0.3)) })
	};


	if ( ~presetsFileName2.isNil, {

		~retriggerPresetPreViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 354*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
		.states_([["Pre", Color.black, Color.yellow]])
		.font_(Font("Verdana",10*~fontSizeMul, bold: true))
		.action_({ var pres, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); pres = ~presetSelection[tr][seq];
			~presetsDontTriggerFX = 1; // Pour ne pas déclencher les effets
			// var sequenceSelected = ~nbOfSeqs.collect { |i| if (~presetSeqTextViewG[tr][i].string != "0", {i}) }.reject({ arg item, i; item.isNil }); // préférable de prendre les presets identifiés dans les pistes pour faire de l'aléatoire

			if (pres != 0 and: {tr == ~tracksValue} and: {~updateVisualPreset == 0}, {
				// ~presetSelectionView.valueAction_(~presetList.indexOfEqual(~presetSelection[tr][~seqSeq[tr]]) );
				~presetGetFunction.value(pres.asSymbol);
			});

			/*sequenceSelected*/ ~presetSeqRandList[tr].do {|i|
				~presetGetFunctionQuick.value(~presetSelection[tr][i].asSymbol, tr, i ) /*},{ ~defaultA.(tr, sequenceSelected[i]) */;
				~seqsColorizeFunction.(tr, i); // voir si ~tracksColorizeFunction.(~tracksValue); n'est pas préférable en dehors de la boucle
			};
			~changeSeqMetaControlsG.(tr, seq); // necessaire quand on est pas sur la piste puisqu'aucun update

			if (~twister.notNil, {
				~ratValues[tr].value_(~ratMulSpec.unmap(~ratMul[tr][seq]));
				~bufFolValues[tr].value_(~bufFolderValue[tr][seq]);
				~rtmValues[tr].value_(~rtmMulSpec[tr][seq].unmap(~rtmMul[tr][seq]));
				~proValues[tr].value_(~proMulSpec.unmap(~proMul[tr][seq]));
				~legValues[tr].value_(~legMulSpec.unmap(~legMul[tr][seq]));
				~strValues[tr].value_(~strMulSpec.unmap(~strMul[tr][seq]));
				~cenValues[tr].value_(~cenMulSpec.unmap(~cenMul[tr][seq]));
				~bufValues[tr].value_(~bufMulSpec.unmap(~bufMul[tr][seq]));
				~offValues[tr].value_(~offMulSpec.unmap(~offMul[tr][seq]));
			}); // Pour mise à jour du Twister // Mauvaise donnée rappelée si avant ~changeSeqMetaControlsG.(tr, seq);
			~presetsDontTriggerFX = 0;
		});

		~retriggerPreset1ViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 400*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
		.states_([["C1", Color.white, Color.blue]])
		.font_(Font("Verdana",10*~fontSizeMul /*, bold: true*/))
		.action_({ var pres, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); pres = ~presetSelection[tr][seq];
			~presetsDontTriggerFX = 1; // Pour ne pas déclencher les effets

			if (pres != 0, { // rajouter ~defaultA.(tr, seq) si 0 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

				if (tr == ~tracksValue and: {~updateVisualPreset == 0}, {
					// ~tracksView.valueAction_(tr);
					// ~seqsView.valueAction_(~seqSeq[tr]); // Sélection de la séquence de la piste -> nécessaire si la piste ne joue pas
					// Ci-dessous manière d'éviter de déclencher la fonction ~updateAllView déclenchée avec ~tracksView et ~seqsView

					// ~tracksView.value_(tr); ~tracksValue = tr;
					// ~seqsView.value_(~seqSeq[tr]); ~seqsValue = ~seqSeq[tr];
					// ~changeSeqMetaControls.(tr, ~seqSeq[tr]); // dans quelles circonstances, utile ???
					// Plus d'update de la vue Séquence, ce qui peut parfois poser problème pour l'update du Lemur ???
					// Pour l'interface graphique ce n'est pas grave, car l'update est inclus dans le changement de TAB (~tabGUI vers la séquence)

					// ~presetSelectionView.valueAction_(/*~presetSelectionView.selection[0]*/ ~presetList.indexOfEqual(~presetSelection[tr][~seqSeq[tr]]) );// Avant
					~presetGetFunction.value(pres.asSymbol);
				},{~presetGetFunctionQuick.(~presetSelection[tr][seq].asSymbol, tr, seq) });
			});
			~seqsColorizeFunction.(tr, seq); // ~presetSeqTextViewG[tr][seq].background_(Color.grey(0.3)); // Colorisation par défaut automatique
			~changeSeqMetaControlsG.(tr, seq);

			if (~twister.notNil, {
				~ratValues[tr].value_(~ratMulSpec.unmap(~ratMul[tr][seq]));
				~bufFolValues[tr].value_(~bufFolderValue[tr][seq]);
				~rtmValues[tr].value_(~rtmMulSpec[tr][seq].unmap(~rtmMul[tr][seq]));
				~proValues[tr].value_(~proMulSpec.unmap(~proMul[tr][seq]));
				~legValues[tr].value_(~legMulSpec.unmap(~legMul[tr][seq]));
				~strValues[tr].value_(~strMulSpec.unmap(~strMul[tr][seq]));
				~cenValues[tr].value_(~cenMulSpec.unmap(~cenMul[tr][seq]));
				~bufValues[tr].value_(~bufMulSpec.unmap(~bufMul[tr][seq]));
				~offValues[tr].value_(~offMulSpec.unmap(~offMul[tr][seq]));
			}); // Pour mise à jour du Twister // Mauvaise donnée rappelée si avant ~changeSeqMetaControlsG.(tr, seq);
			~presetsDontTriggerFX = 0;
		});

		~retriggerPresetViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 376*~ySizeMul, 30*~xSizeMul, 22*~ySizeMul))
		.states_([["Sel", Color.black, Color.new255(255, 165, 0) ]])
		.font_(Font("Verdana",10*~fontSizeMul, bold: true))
		.action_({ var pres, seq, sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i /*if (~presetSeqNbTextViewG[tr][i].isNil, {~presetSeqNbSelectViewG[tr][i-~nbOfSeqs].value-1}, {~presetSeqNbTextViewG[tr][i].string.asInteger-1})*/ }; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); pres = ~presetSelection[tr][seq];
			~presetsDontTriggerFX = 1; // Pour ne pas déclencher les effets

			if (pres != 0 and: {tr == ~tracksValue} and: {~updateVisualPreset == 0}, {
				// ~presetSelectionView.valueAction_(~presetList.indexOfEqual(~presetSelection[tr][~seqSeq[tr]]) ); // Avant
				~presetGetFunction.value(pres.asSymbol);
			});

			sequenceSelected.do {|i|
				if (~presetSelection[tr][i] != 0, {
					~presetGetFunctionQuick.value(~presetSelection[tr][i].asSymbol, tr, i /*sequenceSelected[i]*/)
				}/*,{ ~defaultA.(tr, sequenceSelected[i]) }*/ ); // peut provoquer une erreur d'affichage (texte qui reste en rouge ou autres) ?????????
				~seqsColorizeFunction.(tr, i);
			};
			~changeSeqMetaControlsG.(tr, seq);

			if (~twister.notNil, {
				~ratValues[tr].value_(~ratMulSpec.unmap(~ratMul[tr][seq]));
				~bufFolValues[tr].value_(~bufFolderValue[tr][seq]);
				~rtmValues[tr].value_(~rtmMulSpec[tr][seq].unmap(~rtmMul[tr][seq]));
				~proValues[tr].value_(~proMulSpec.unmap(~proMul[tr][seq]));
				~legValues[tr].value_(~legMulSpec.unmap(~legMul[tr][seq]));
				~strValues[tr].value_(~strMulSpec.unmap(~strMul[tr][seq]));
				~cenValues[tr].value_(~cenMulSpec.unmap(~cenMul[tr][seq]));
				~bufValues[tr].value_(~bufMulSpec.unmap(~bufMul[tr][seq]));
				~offValues[tr].value_(~offMulSpec.unmap(~offMul[tr][seq]));
			}); // Pour mise à jour du Twister // Mauvaise donnée rappelée si avant ~changeSeqMetaControlsG.(tr, seq);
			~presetsDontTriggerFX = 0;

			if (~rhythmTracksX2.includes(tr), {
				if (~lemurConnected1 == 1, {
					~lemurAdress1.sendMsg(~lemurRatGTextValues[tr], ~ratMul[tr][seq]);
					~lemurAdress1.sendMsg(~lemurRatGLedValues[tr], ~ratMulSpec.unmap(~ratMul[tr][seq]));
					~lemurAdress1.sendMsg(~lemurLegGTextValues[tr], ~legMul[tr][seq]);
					~lemurAdress1.sendMsg(~lemurLegGLedValues[tr], ~legMulSpec.unmap(~legMul[tr][seq]));
				});
				if (~lemurConnected2 == 1, {
					~lemurAdress2.sendMsg(~lemurRatGTextValues[tr], ~ratMul[tr][seq]);
					~lemurAdress2.sendMsg(~lemurRatGLedValues[tr], ~ratMulSpec.unmap(~ratMul[tr][seq]));
					~lemurAdress2.sendMsg(~lemurLegGTextValues[tr], ~legMul[tr][seq]);
					~lemurAdress2.sendMsg(~lemurLegGLedValues[tr], ~legMulSpec.unmap(~legMul[tr][seq]));
				});
			});
		});


	},{


		~retriggerPresetPreViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 354*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
		.states_([["Pre", Color.black, Color.yellow]])
		.font_(Font("Verdana",10*~fontSizeMul, bold: true))
		.action_({ var pres, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); pres = ~presetSelection[tr][seq];
			~presetsDontTriggerFX = 1;

			if (pres != 0 and: {tr == ~tracksValue} and: {~updateVisualPreset == 0}, {
				// ~presetSelectionView.valueAction_(~presetSelectionView.items.indexOfEqual(~presetSelection[tr][~seqSeq[tr]]) ); // Avant
				~presetGetFunction.value(pres.asSymbol);
			}/*,{ ~changeSeqMetaControlsG.(tr, seq) } */);

			~presetSeqRandList[tr].do { |i|
				~presetGetFunctionQuick.value(~presetSelection[tr][i].asSymbol, tr, i ); ~seqsColorizeFunction.(tr, i);
			};
			~changeSeqMetaControlsG.(tr, seq); // necessaire quand on est pas sur la piste puisqu'aucun update

			if (~twister.notNil, {
				~ratValues[tr].value_(~ratMulSpec.unmap(~ratMul[tr][seq]));
				~bufFolValues[tr].value_(~bufFolderValue[tr][seq]);
				~rtmValues[tr].value_(~rtmMulSpec[tr][seq].unmap(~rtmMul[tr][seq]));
				~proValues[tr].value_(~proMulSpec.unmap(~proMul[tr][seq]));
				~legValues[tr].value_(~legMulSpec.unmap(~legMul[tr][seq]));
				~strValues[tr].value_(~strMulSpec.unmap(~strMul[tr][seq]));
				~cenValues[tr].value_(~cenMulSpec.unmap(~cenMul[tr][seq]));
				~bufValues[tr].value_(~bufMulSpec.unmap(~bufMul[tr][seq]));
				~offValues[tr].value_(~offMulSpec.unmap(~offMul[tr][seq]));
			}); // Pour mise à jour du Twister // Mauvaise donnée rappelée si avant ~changeSeqMetaControlsG.(tr, seq);
			~presetsDontTriggerFX = 0;
		});

		~retriggerPreset1ViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 400*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
		.states_([["C1", Color.white, Color.blue]])
		.font_(Font("Verdana",10*~fontSizeMul /*, bold: true*/))
		.action_({ var pres, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); pres = ~presetSelection[tr][seq];
			~presetsDontTriggerFX = 1;

			if (pres != 0, {
				// ~presetSelectionView.valueAction_(~presetSelectionView.items.indexOfEqual(~presetSelection[tr][~seqSeq[tr]]) ); // Avant
				if (tr == ~tracksValue and: {~updateVisualPreset == 0}, {~presetGetFunction.value(pres.asSymbol);
				},{ ~presetGetFunctionQuick.value(pres.asSymbol, tr, seq) });
			});
			~seqsColorizeFunction.(tr, seq); ~changeSeqMetaControlsG.(tr, seq);

			if (~twister.notNil, {
				~ratValues[tr].value_(~ratMulSpec.unmap(~ratMul[tr][seq]));
				~bufFolValues[tr].value_(~bufFolderValue[tr][seq]);
				~rtmValues[tr].value_(~rtmMulSpec[tr][seq].unmap(~rtmMul[tr][seq]));
				~proValues[tr].value_(~proMulSpec.unmap(~proMul[tr][seq]));
				~legValues[tr].value_(~legMulSpec.unmap(~legMul[tr][seq]));
				~strValues[tr].value_(~strMulSpec.unmap(~strMul[tr][seq]));
				~cenValues[tr].value_(~cenMulSpec.unmap(~cenMul[tr][seq]));
				~bufValues[tr].value_(~bufMulSpec.unmap(~bufMul[tr][seq]));
				~offValues[tr].value_(~offMulSpec.unmap(~offMul[tr][seq]));
			}); // Pour mise à jour du Twister // Mauvaise donnée rappelée si avant ~changeSeqMetaControlsG.(tr, seq);
			~presetsDontTriggerFX = 0;
		});

		~retriggerPresetViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 376*~ySizeMul, 30*~xSizeMul, 22*~ySizeMul))
		.states_([["Sel", Color.black, Color.new255(255, 165, 0) ]])
		.font_(Font("Verdana",10*~fontSizeMul, bold: true))
		.action_({ var pres, seq, sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); pres = ~presetSelection[tr][seq];
			~presetsDontTriggerFX = 1;

			if (pres != 0 and: {tr == ~tracksValue} and: {~updateVisualPreset == 0}, {
				// ~presetSelectionView.valueAction_(~presetSelectionView.items.indexOfEqual(~presetSelection[tr][~seqSeq[tr]]) ); // Avant
				~presetGetFunction.value(pres.asSymbol);
			}/*,{ ~changeSeqMetaControlsG.(tr, seq) }*/ );
			sequenceSelected.do { |i|
				if (~presetSelection[tr][i] != 0, {
					~presetGetFunctionQuick.value(~presetSelection[tr][i].asSymbol, tr, i)
				});
				~seqsColorizeFunction.(tr, i);
			};
			~changeSeqMetaControlsG.(tr, seq);

			if (~twister.notNil, {
				~ratValues[tr].value_(~ratMulSpec.unmap(~ratMul[tr][seq]));
				~bufFolValues[tr].value_(~bufFolderValue[tr][seq]);
				~rtmValues[tr].value_(~rtmMulSpec[tr][seq].unmap(~rtmMul[tr][seq]));
				~proValues[tr].value_(~proMulSpec.unmap(~proMul[tr][seq]));
				~legValues[tr].value_(~legMulSpec.unmap(~legMul[tr][seq]));
				~strValues[tr].value_(~strMulSpec.unmap(~strMul[tr][seq]));
				~cenValues[tr].value_(~cenMulSpec.unmap(~cenMul[tr][seq]));
				~bufValues[tr].value_(~bufMulSpec.unmap(~bufMul[tr][seq]));
				~offValues[tr].value_(~offMulSpec.unmap(~offMul[tr][seq]));
			}); // Pour mise à jour du Twister // Mauvaise donnée rappelée si avant ~changeSeqMetaControlsG.(tr, seq);
			~presetsDontTriggerFX = 0;

			if (~rhythmTracksX2.includes(tr), {
				if (~lemurConnected1 == 1, {
					~lemurAdress1.sendMsg(~lemurRatGTextValues[tr], ~ratMul[tr][seq]);
					~lemurAdress1.sendMsg(~lemurRatGLedValues[tr], ~ratMulSpec.unmap(~ratMul[tr][seq]));
					~lemurAdress1.sendMsg(~lemurLegGTextValues[tr], ~legMul[tr][seq]);
					~lemurAdress1.sendMsg(~lemurLegGLedValues[tr], ~legMulSpec.unmap(~legMul[tr][seq]));
				});
				if (~lemurConnected2 == 1, {
					~lemurAdress2.sendMsg(~lemurRatGTextValues[tr], ~ratMul[tr][seq]);
					~lemurAdress2.sendMsg(~lemurRatGLedValues[tr], ~ratMulSpec.unmap(~ratMul[tr][seq]));
					~lemurAdress2.sendMsg(~lemurLegGTextValues[tr], ~legMul[tr][seq]);
					~lemurAdress2.sendMsg(~lemurLegGLedValues[tr], ~legMulSpec.unmap(~legMul[tr][seq]));
				});
			});
		});

	});


	~position1SeqViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 46*~ySizeMul, 30*~xSizeMul, 12*~ySizeMul))
	.states_([["^", Color.black, ~popUpMenuBackgroundColor]])
	.font_(Font("Verdana", 12*~fontSizeMul))
	.action_({|i| ~seqCompG1[tr].visibleOrigin = 0@0 });

	~position2SeqViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 60*~ySizeMul, 30*~xSizeMul, 12*~ySizeMul))
	.states_([["-", Color.black, ~popUpMenuBackgroundColor]])
	.font_(Font("Verdana", 12*~fontSizeMul))
	.action_({|i| ~seqCompG1[tr].visibleOrigin = 0@(~seqCompG1[tr].visibleOrigin.y - (400*~ySizeMul)) });

	~position3SeqViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 74*~ySizeMul, 30*~xSizeMul, 12*~ySizeMul))
	.states_([["+", Color.black, ~popUpMenuBackgroundColor]])
	.font_(Font("Verdana", 12*~fontSizeMul))
	.action_({|i| if (~seqCompG1[tr].visibleOrigin.y == 0, { ~seqCompG1[tr].visibleOrigin = 0@(~seqCompG1[tr].visibleOrigin.y + (380*~ySizeMul)).min(~seqCompG1MaxVisibleOrigin) }, { ~seqCompG1[tr].visibleOrigin = 0@(~seqCompG1[tr].visibleOrigin.y + (400*~ySizeMul)).min(~seqCompG1MaxVisibleOrigin) }) }); // (4380) = (400 * 11) - 20 ou (20 ° 20 * 11) - 20

	~position4SeqViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 88*~ySizeMul, 30*~xSizeMul, 12*~ySizeMul))
	.states_([[">", Color.black, ~popUpMenuBackgroundColor]])
	.font_(Font("Verdana", 12*~fontSizeMul))
	.action_({|i| ~seqCompG1[tr].visibleOrigin = 0@(4380*~ySizeMul) });

	~presetSeqVisuViewG[tr] = ListView(~seqCompG[tr], Rect(2*~xSizeMul, 102*~ySizeMul, 30*~xSizeMul, 158*~ySizeMul)).stringColor_(Color.white).hiliteColor_(Color.grey(0.8)/*black*/).font_(Font("Verdana",(10*~fontSizeMul).asInteger)).background = Color.grey(0.3);
	~presetSeqVisuViewG[tr].items = [1, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200, 220]; /*(1..12);*/
	~presetSeqVisuViewG[tr].action_({|i| ~seqCompG1[tr].visibleOrigin = 0@( ((i.value)*400)-20).max(0)*~ySizeMul });


	// Regroupement Free parties will survive - Avant Parme
	// Faire un regroupement aléatoire IP/IT/PZ/RC en favorisant certains types comme PZ ou IP avec .wchoose - ~folRandViewG ~folderRyRand
	// P+ ~folderStructureRValues // [ 54, 55, 56, 57, 67, 58, 59, 60, 68 ] + de 0 à 11 sauf scratch + 43 piano Bosen ou 33 ou 47 pour gong -> à améliorer

	/*~folRandViewG[tr] = RoundButton(~seqCompG[tr], Rect(2, 423, 30, 20))
	.states_([["FOL", Color.red, Color.white]])
	.font_(Font("Verdana",9, bold: true))
	.action_({ var seq, serv; if (~server2.isNil or: {(tr/2).asInteger < ~serverTrackSwitch}, {serv = 0}, {serv = 1}); if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });

	case
	{ ~triggerAllSeqs[tr] == 0 } // Séquence de le piste en cours de sélection
	{
	case
	{ ~folderRyRand == 0 } // dossier du même type
	{ ~bufFolderValue[tr][seq] = (~folderStructureValues[~kindOfFoldersSymbol.indexOf(~kindOfFoldersStructure[~bufFolderView.value].asSymbol)].choose) }
	// { ~bufFolderValue[tr][seq] = ~bufFolderView.value }
	{ ~folderRyRand == 1 } // (AR/AS)
	{ ~bufFolderValue[tr][seq] = (~folderStructureAValues.choose) }
	{ ~folderRyRand == 2 } // (DR/IP)
	{ ~bufFolderValue[tr][seq] = (~folderStructureDValues.choose) }
	{ ~folderRyRand == 3 } // (PN/IT)
	{ ~bufFolderValue[tr][seq] = (~folderStructureIValues.choose) }
	{ ~folderRyRand == 4 } // (PZ/RC)
	{ ~bufFolderValue[tr][seq] = (~folderStructureRValues.choose) }
	{ ~folderRyRand == 5 } // Sélection (PZ/RC) + de 0 à 11 sauf scratch + 43 piano Bosen _ [ 0,1,2,3,4,5,6,7,9,10,11, 43, 54, 55, 56, 57, 67, 58, 59, 60, 68 ]
	{ ~bufFolderValue[tr][seq] = ( (~folderStructureValues[8]++ ~folderStructureValues[9]) /*(~folderStructureDValues++~folderStructureIValues)*/ /*[ 0,1,2,3,4,5,6,7,9,10,11, 43, 54, 55, 56, 57, 67, 58, 59, 60, 68 ]*/ .choose) }
	{ ~folderRyRand == 6 } // ALL
	{ ~bufFolderValue[tr][seq] = (rand(~bufFolderSize1)) };

	~bufFolderFunc.value(tr, seq, ~bufFolderValue[tr][seq] , serv /*~bufFolderValue[~tracksValue][~seqsValue]*/);
	~presetSeqTextViewG[tr][seq].background_(Color.red);
	// ~bufFolderValue[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size;
	}
	{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
	{
	var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i }; // A intégrer seulement si plusieurs séquences sélectionnées
	sequenceSelected.do {|i|
	case
	{ ~folderRyRand == 0 } // dossier du même type ou même dossier
	{ ~bufFolderValue[tr][i] = (~folderStructureValues[~kindOfFoldersSymbol.indexOf(~kindOfFoldersStructure[~bufFolderView.value].asSymbol)].choose) }
	// { ~bufFolderValue[tr][i] = ~bufFolderView.value }
	{ ~folderRyRand == 1 } // (AR/AS)
	{ ~bufFolderValue[tr][i] = (~folderStructureAValues.choose) }
	{ ~folderRyRand == 2 } // (DR/IP)
	{ ~bufFolderValue[tr][i] = (~folderStructureDValues.choose) }
	{ ~folderRyRand == 3 } // (PN/IT)
	{ ~bufFolderValue[tr][i] = (~folderStructureIValues.choose) }
	{ ~folderRyRand == 4 } // (PZ/RC)
	{ ~bufFolderValue[tr][i] = (~folderStructureRValues.choose) }
	{ ~folderRyRand == 5 } // Sélection (PZ/RC) + de 0 à 11 sauf scratch + 43 piano Bosen
	{ ~bufFolderValue[tr][i] = ( (~folderStructureValues[8]++ ~folderStructureValues[9]) /*(~folderStructureDValues++~folderStructureIValues)*/ /*[ 0,1,2,3,4,5,6,7,9,10,11, 43, 54, 55, 56, 57, 67, 58, 59, 60, 68 ]*/ .choose) }
	{ ~folderRyRand == 6 } // ALL
	{ ~bufFolderValue[tr][i] = (rand(~bufFolderSize1)) };

	~bufFolderFunc.value(tr, i, ~bufFolderValue[tr][i] , serv /*~bufFolderValue[~tracksValue][~seqsValue]*/);
	~presetSeqTextViewG[tr][i].background_(Color.red);
	};
	}
	{ ~triggerAllSeqs[tr] == 2} // tous les presets
	{
	~presetSeqRandList[tr].do {|i|
	case
	{ ~folderRyRand == 0 } // dossier du même type
	{ ~bufFolderValue[tr][i] = (~folderStructureValues[~kindOfFoldersSymbol.indexOf(~kindOfFoldersStructure[~bufFolderView.value].asSymbol)].choose) }
	// { ~bufFolderValue[tr][i] = ~bufFolderView.value }
	{ ~folderRyRand == 1 } // (AR/AS)
	{ ~bufFolderValue[tr][i] = (~folderStructureAValues.choose) }
	{ ~folderRyRand == 2 } // (DR/IP)
	{ ~bufFolderValue[tr][i] = (~folderStructureDValues.choose) }
	{ ~folderRyRand == 3 } // (PN/IT)
	{ ~bufFolderValue[tr][i] = (~folderStructureIValues.choose) }
	{ ~folderRyRand == 4 } // (PZ/RC)
	{ ~bufFolderValue[tr][i] = (~folderStructureRValues.choose) }
	{ ~folderRyRand == 5 } // Sélection (PZ/RC) + de 0 à 11 sauf scratch + 43 piano Bosen
	{ ~bufFolderValue[tr][i] = ( (~folderStructureValues[8]++ ~folderStructureValues[9]) /*(~folderStructureDValues++~folderStructureIValues)*/ /*[ 0,1,2,3,4,5,6,7,9,10,11, 43, 54, 55, 56, 57, 67, 58, 59, 60, 68 ]*/ .choose) }
	{ ~folderRyRand == 6 } // ALL
	{ ~bufFolderValue[tr][i] = (rand(~bufFolderSize1)) };

	~bufFolderFunc.value(tr, i, ~bufFolderValue[tr][i] , serv /*~bufFolderValue[~tracksValue][~seqsValue]*/);
	~presetSeqTextViewG[tr][i].background_(Color.red);
	};
	}
	});*/

	~folderRyRand = 1; // initialisation obligatoire sinon erreur
	~folRandFunction = { |tr|
		var seq, serv; if (~server2.isNil or: {(tr/2).asInteger < ~serverTrackSwitch}, {serv = 0}, {serv = 1}); if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
		//~folderRyGroupItems
		case
		{ ~triggerAllSeqs[tr] == 0 } // Séquence de le piste en cours de sélection
		{
			case
			{ ~folderRyRand == 0 } // ALL
			{ ~bufFolderValue[tr][seq] = (rand(~bufFolderSize1)) }
			{ ~folderRyRand == 1 } // dossier du même type
			{ ~bufFolderValue[tr][seq] = (~folderStructureValues[~kindOfFoldersSymbol.indexOf(~kindOfFoldersStructure[~bufFolderView.value].asSymbol)].choose) }
			// { ~bufFolderValue[tr][seq] = ~bufFolderView.value }
			{ ~folderRyRand == 2 } // (AR/AS)
			{ ~bufFolderValue[tr][seq] = (~folderStructureAValues.choose) }
			{ ~folderRyRand == 3 } // (DR/IP)
			{ ~bufFolderValue[tr][seq] = (~folderStructureDValues.choose) }
			{ ~folderRyRand == 4 } // (PN/IT)
			{ ~bufFolderValue[tr][seq] = (~folderStructureIValues.choose) }
			{ ~folderRyRand == 5 } // (PZ/RC)
			{ ~bufFolderValue[tr][seq] = (~folderStructureRValues.choose) }
			{ ~folderRyRand == 6 } // Sélection (PZ/RC) + de 0 à 11 sauf scratch + 43 piano Bosen _ [ 0,1,2,3,4,5,6,7,9,10,11, 43, 54, 55, 56, 57, 67, 58, 59, 60, 68 ]
			{ ~bufFolderValue[tr][seq] = ((~folderStructureValues[8]++ ~folderStructureValues[9]) /*(~folderStructureDValues++~folderStructureIValues)*/ /*[ 0,1,2,3,4,5,6,7,9,10,11, 43, 54, 55, 56, 57, 67, 58, 59, 60, 68 ]*/ .choose) }
			{ ~folderRyRand > 6 } // ALL
			{ ~bufFolderValue[tr][seq] = (~folderStructureValues[~folderRyRand-7].choose) };

			~bufFolderFunc.value(tr, seq, ~bufFolderValue[tr][seq] , serv /*~bufFolderValue[~tracksValue][~seqsValue]*/);
			~presetSeqTextViewG[tr][seq].background_(Color.red);
			// ~bufFolderValue[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size;
		}
		{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i }; // A intégrer seulement si plusieurs séquences sélectionnées
			sequenceSelected.do {|i|
				case
				{ ~folderRyRand == 0 } // ALL
				{ ~bufFolderValue[tr][i] = (rand(~bufFolderSize1)) }
				{ ~folderRyRand == 1 } // dossier du même type ou même dossier
				{ ~bufFolderValue[tr][i] = (~folderStructureValues[~kindOfFoldersSymbol.indexOf(~kindOfFoldersStructure[~bufFolderView.value].asSymbol)].choose) }
				// { ~bufFolderValue[tr][i] = ~bufFolderView.value }
				{ ~folderRyRand == 2 } // (AR/AS)
				{ ~bufFolderValue[tr][i] = (~folderStructureAValues.choose) }
				{ ~folderRyRand == 3 } // (DR/IP)
				{ ~bufFolderValue[tr][i] = (~folderStructureDValues.choose) }
				{ ~folderRyRand == 4 } // (PN/IT)
				{ ~bufFolderValue[tr][i] = (~folderStructureIValues.choose) }
				{ ~folderRyRand == 5 } // (PZ/RC)
				{ ~bufFolderValue[tr][i] = (~folderStructureRValues.choose) }
				{ ~folderRyRand == 6 } // Sélection (PZ/RC) + de 0 à 11 sauf scratch + 43 piano Bosen
				{ ~bufFolderValue[tr][i] = ((~folderStructureValues[8]++ ~folderStructureValues[9]) /*(~folderStructureDValues++~folderStructureIValues)*/ /*[ 0,1,2,3,4,5,6,7,9,10,11, 43, 54, 55, 56, 57, 67, 58, 59, 60, 68 ]*/ .choose) }
				{ ~folderRyRand > 6 } // ALL
				{ ~bufFolderValue[tr][i] = (~folderStructureValues[~folderRyRand-7].choose) };

				~bufFolderFunc.value(tr, i, ~bufFolderValue[tr][i] , serv /*~bufFolderValue[~tracksValue][~seqsValue]*/);
				~presetSeqTextViewG[tr][i].background_(Color.red);
			};
		}
		{ ~triggerAllSeqs[tr] == 2} // tous les presets
		{
			~presetSeqRandList[tr].do {|i|
				case
				{ ~folderRyRand == 0 } // ALL
				{ ~bufFolderValue[tr][i] = (rand(~bufFolderSize1)) }
				{ ~folderRyRand == 1 } // dossier du même type
				{ ~bufFolderValue[tr][i] = (~folderStructureValues[~kindOfFoldersSymbol.indexOf(~kindOfFoldersStructure[~bufFolderView.value].asSymbol)].choose) }
				// { ~bufFolderValue[tr][i] = ~bufFolderView.value }
				{ ~folderRyRand == 2 } // (AR/AS)
				{ ~bufFolderValue[tr][i] = (~folderStructureAValues.choose) }
				{ ~folderRyRand == 3 } // (DR/IP)
				{ ~bufFolderValue[tr][i] = (~folderStructureDValues.choose) }
				{ ~folderRyRand == 4 } // (PN/IT)
				{ ~bufFolderValue[tr][i] = (~folderStructureIValues.choose) }
				{ ~folderRyRand == 5 } // (PZ/RC)
				{ ~bufFolderValue[tr][i] = (~folderStructureRValues.choose) }
				{ ~folderRyRand == 6 } // Sélection (PZ/RC) + de 0 à 11 sauf scratch + 43 piano Bosen
				{ ~bufFolderValue[tr][i] = ((~folderStructureValues[8]++ ~folderStructureValues[9]) /*(~folderStructureDValues++~folderStructureIValues)*/ /*[ 0,1,2,3,4,5,6,7,9,10,11, 43, 54, 55, 56, 57, 67, 58, 59, 60, 68 ]*/ .choose) }
				{ ~folderRyRand > 6 } // ALL
				{ ~bufFolderValue[tr][i] = (~folderStructureValues[~folderRyRand-7].choose) };

				~bufFolderFunc.value(tr, i, ~bufFolderValue[tr][i] , serv /*~bufFolderValue[~tracksValue][~seqsValue]*/);
				~presetSeqTextViewG[tr][i].background_(Color.red);
			};
		}
	};


	~folRandViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 423*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["FOL", Color.red, Color.white]])
	.font_(Font("Verdana",9*~fontSizeMul, bold: true))
	.action_({~folRandFunction.(tr); ~bufFolderViewG[tr].value_(~bufFolderValue[tr][~seqSeq[tr]]) });

	~ratRandViewG[tr] = RoundButton(~seqCompG[tr], Rect(64*~xSizeMul, 445*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["RAT", Color.red, Color.white]])
	.font_(Font("Verdana",9*~fontSizeMul, bold: true))
	.action_({ var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
		case
		{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
		{
			~rat[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size; // ne sert à rien avec ~rate.value après...
			if (tr == ~tracksValue, {~rate.value(~tracksValue, seq) }); // Pas terrible - meilleur de juste updater le multislider XXX
			~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i|
				~rat[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~presetSeqTextViewG[tr][i].background_(Color.red)
			};
			if (tr == ~tracksValue, {~rate.value(~tracksValue, seq) }); // Pas terrible - meilleur de juste updater le multislider XXX
		}
		{ ~triggerAllSeqs[tr] == 2} // tous les presets
		{
			~presetSeqRandList[tr].do {|i|
				~rat[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~presetSeqTextViewG[tr][i].background_(Color.red)
			};
			if (tr == ~tracksValue, {~rate.value(~tracksValue, seq) }); // Pas terrible - meilleur de juste updater le multislider XXX
		}
	});

	~strRandViewG[tr] = RoundButton(~seqCompG[tr], Rect(95*~xSizeMul, 445*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["RST", Color.red, Color.white]])
	.font_(Font("Verdana",9*~fontSizeMul /*, bold: true*/))
	.action_({ var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
		case
		{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
		{
			~str[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size;
			~cen[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size;
			if (tr == ~tracksValue, {~stretching.value(~tracksValue, seq); ~center.value(~tracksValue, seq) });
			~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i|
				~str[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~cen[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~presetSeqTextViewG[tr][i].background_(Color.red)
			};
			if (tr == ~tracksValue, {~stretching.value(~tracksValue, seq); ~center.value(~tracksValue, seq) });
		}
		{ ~triggerAllSeqs[tr] == 2} // toutes les séquences sélectionnées
		{
			~presetSeqRandList[tr].do {|i|
				~str[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~cen[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~presetSeqTextViewG[tr][i].background_(Color.red)
			};
			if (tr == ~tracksValue, {~stretching.value(~tracksValue, seq); ~center.value(~tracksValue, seq) });
		}
	});

	~bufRandViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 445*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["RBU", Color.red, Color.white]])
	.font_(Font("Verdana",9*~fontSizeMul /*, bold: true*/))
	.action_({ var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
		case
		{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
		{
			~buf[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size;
			if (tr == ~tracksValue, {~buffer.value(~tracksValue, seq) });
			~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i|
				~buf[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~presetSeqTextViewG[tr][i].background_(Color.red)
			};
			if (tr == ~tracksValue, {~buffer.value(~tracksValue, seq) });
		}
		{ ~triggerAllSeqs[tr] == 2} // toutes les séquences sélectionnées
		{
			~presetSeqRandList[tr].do {|i|
				~buf[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~presetSeqTextViewG[tr][i].background_(Color.red)
			};
			if (tr == ~tracksValue, {~buffer.value(~tracksValue, seq) });
		}
	});

	~offRandViewG[tr] = RoundButton(~seqCompG[tr], Rect(33*~xSizeMul, 445*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["ROF", Color.red, Color.white]])
	.font_(Font("Verdana",9*~fontSizeMul /*, bold: true*/))
	.action_({ var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
		case
		{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
		{
			~off[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size;
			if (tr == ~tracksValue, {~offset.value(~tracksValue, seq) });
			~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i|
				~off[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~presetSeqTextViewG[tr][i].background_(Color.red)
			};
			if (tr == ~tracksValue, {~offset.value(~tracksValue, seq) });
		}
		{ ~triggerAllSeqs[tr] == 2} // toutes les séquences sélectionnées
		{
			~presetSeqRandList[tr].do {|i|
				~off[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~presetSeqTextViewG[tr][i].background_(Color.red)
			};
			if (tr == ~tracksValue, {~offset.value(~tracksValue, seq) });
		}
	});

	~spaRandViewG[tr] = RoundButton(~seqCompG[tr], Rect(126*~xSizeMul, 445*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["RSP", Color.red, Color.white]])
	.font_(Font("Verdana",9*~fontSizeMul /*, bold: true*/))
	.action_({ var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
		case
		{ ~triggerSpaSeqs == 0} // Séquence de le piste en cours de sélection
		{
			~spa[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size;
			~pan[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size;
			~del[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size;
			if (tr == ~tracksValue, {~spatialisation.value(~tracksValue, seq); ~panning.value(~tracksValue, seq); ~delay.value(~tracksValue, seq) });
			// ~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerSpaSeqs == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i|
				~spa[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~pan[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~del[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				// ~presetSeqTextViewG[tr][i].background_(Color.red)
			};
			if (tr == ~tracksValue, {~spatialisation.value(~tracksValue, seq); ~panning.value(~tracksValue, seq); ~delay.value(~tracksValue, seq) });
		}
		/*{ ~triggerAllSeqs[tr] == 2} // toutes les séquences sélectionnées
		{
		~presetSeqRandList[tr].do {|i|
		~spa[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
		~pan[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
		~del[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
		~presetSeqTextViewG[tr][i].background_(Color.red)
		};
		if (tr == ~tracksValue, {~spatialisation.value(~tracksValue, seq); ~panning.value(~tracksValue, seq); ~delay.value(~tracksValue, seq) });
		}*/
	});

	~outRandViewG[tr] = RoundButton(~seqCompG[tr], Rect(157*~xSizeMul, 445*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["ROU", Color.red, Color.white]])
	.font_(Font("Verdana",9*~fontSizeMul /*, bold: true*/))
	.action_({ var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
		case
		{ ~triggerSpaSeqs == 0} // Séquence de le piste en cours de sélection
		{
			~outL[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size;
			~outR[tr][seq] = {rrand(0.0,1.0)} ! ~dur[tr][seq].size;
			if (tr == ~tracksValue, {~outingL.value(~tracksValue, seq); ~outingR.value(~tracksValue, seq) });
			// ~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerSpaSeqs == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i|
				~outL[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				~outR[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
				// ~presetSeqTextViewG[tr][i].background_(Color.red)
			};
			if (tr == ~tracksValue, {~outingL.value(~tracksValue, seq); ~outingR.value(~tracksValue, seq) });
		}
		/*{ ~triggerAllSeqs[tr] == 2} // tous les presets
		{
		~presetSeqRandList[tr].do {|i|
		~outL[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
		~outR[tr][i] = {rrand(0.0,1.0)} ! ~dur[tr][i].size;
		~presetSeqTextViewG[tr][i].background_(Color.red)
		};
		if (tr == ~tracksValue, {~outingL.value(~tracksValue, seq); ~outingR.value(~tracksValue, seq) });
		}*/
	});















	// Sliders XFade & Quantisation

	~pFadeViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(36*~xSizeMul, 468*~ySizeMul, 75*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| ~pFade[tr] = ~pFadeSpec.map(view.value);
		view.string = ("X:%-%s").format(~pFade[tr], (~pFade[tr] / ~toTempo).round(0.01));
	})
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	// .doAction // utilité ???
	.valueAction_(~pFadeSpec.unmap(~trackXFadeDefault));

	~quantViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(113*~xSizeMul, 468*~ySizeMul, 75*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| ~quant[tr] = ~quantSpec.map(view.value);
		view.string = ("Q:%-%s").format(~quant[tr], (~quant[tr] / ~toTempo).round(0.01));
	})
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	// .doAction // utilité ???
	.valueAction_(~quantSpec.unmap(4));


	~triggerSpaSeqs = 1; // obligé de le déclarer car la GUI est plus loin

	~spaRangePresetViewViewG[tr] = View(~seqCompG[tr], Rect(190*~xSizeMul, 468*~ySizeMul, 48*~xSizeMul, 21*~ySizeMul));

	~spaRangePresetViewG[tr] = PopUpMenu.new(~spaRangePresetViewViewG[tr], Rect(0, 0, 75*~xSizeMul, 21*~ySizeMul))
	// .action_({|menu| ~spaRangeView.valueAction_(~spaRangeSpec[tr][~seqsValue].unmap([menu.item.replace("->", " ").split($ )[1].asFloat, menu.item.replace("->", " ").split($ )[2].asFloat])) })
	.action_({ |menu|
		// ~spaRangeView.valueAction_(~spaRangeSpec[tr][~seqsValue].unmap([min, max]));
		// ~spaRangePresetView.valueAction_(menu.value);
		var min = menu.item.split($-)[1].asInteger;
		var max = menu.item.split($>)[1].asInteger;

		case
		{ ~triggerSpaSeqs == 0} // Séquence de le piste en cours de sélection
		{ var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~spaRangePreset[tr][seq] = menu.value;
			~spaMin[tr][seq] = min;
			~spaMax[tr][seq] = max;
			~spaSpec[tr][seq] = ControlSpec(~spaMin[tr][seq], ~spaMax[tr][seq], \lin, 1);
			~spaSpecStereo[tr][seq] = ControlSpec(0, max.min(5), \lin, 1);
			// ~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerSpaSeqs== 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i|
				~spaRangePreset[tr][i] = menu.value;
				~spaMin[tr][i] = min;
				~spaMax[tr][i] = max;
				~spaSpec[tr][i] = ControlSpec(~spaMin[tr][i], ~spaMax[tr][i], \lin, 1);
				~spaSpecStereo[tr][i] = ControlSpec(0, max.min(5), \lin, 1);
				// ~presetSeqTextViewG[tr][i].background_(Color.red)
			};
		}
		/*{ ~triggerAllSeqs[tr] == 2} // tous les presets
		{
		~presetSeqRandList[tr].do {|i|
		~spaRangePreset[tr][i] = menu.value;
		~spaMin[tr][i] = min;
		~spaMax[tr][i] = max;
		~spaSpec[tr][i] = ControlSpec(~spaMin[tr][i], ~spaMax[tr][i], \lin, 1);
		~spaSpecStereo[tr][i] = ControlSpec(0, max.min(5), \lin, 1);
		~presetSeqTextViewG[tr][i].background_(Color.red)
		};
		}*/
	})
	.allowsReselection_(true)
	/*.background_(Color.blue)
	.stringColor_(Color.white)*/
	.background_(~popUpMenuBackgroundColor)
	.stringColor_(~popUpMenuStringColor)
	.font_(Font(/*"PT Mono"*/"Monaco"/*"Verdana"*/,9*~fontSizeMul));
	~spaRangePresetViewG[tr].items_(~spaRangePresetItemsG)
	.valueAction_(~spaRangePresetItemsG.size-1);


	~spaPatSelViewViewG[tr] = View(~seqCompG[tr], Rect(240*~xSizeMul, 468*~ySizeMul, 38*~xSizeMul, 21*~ySizeMul));

	~spaPatSelViewG[tr] = PopUpMenu.new(~spaPatSelViewViewG[tr], Rect(0, 0, 66*~xSizeMul, 21*~ySizeMul))
	.action_({ |menu|
		case
		{ ~triggerSpaSeqs == 0} // Séquence de le piste en cours de sélection
		{ var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~spaPatSel[tr][seq] = menu.value;
			// ~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerSpaSeqs == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i|
				~spaPatSel[tr][i] = menu.value;
				// ~presetSeqTextViewG[tr][i].background_(Color.red)
			};
		}
		/*{ ~triggerAllSeqs[tr] == 2} // tous les presets
		{
		~presetSeqRandList[tr].do {|i|
		~spaPatSel[tr][i] = menu.value;
		~presetSeqTextViewG[tr][i].background_(Color.red)
		};
		}*/
	})
	.allowsReselection_(true)
	/*.background_(Color.blue)
	.stringColor_(Color.white)*/
	.background_(~popUpMenuBackgroundColor)
	.stringColor_(~popUpMenuStringColor)
	.font_(Font("Verdana",9*~fontSizeMul));
	if (~acousItems.isNil, {
		~spaPatSelViewG[tr].items_(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "Leh_1", "Leh1I", "Leh_2", "Leh2I", "R +1", "R  -1"]) // .valueAction_(4); // Initialisation à Pwhite
	},{
		~spaPatSelViewG[tr].items_(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "Leh_1", "Leh1I", "Leh_2", "Leh2I", "R +1", "R  -1", "R +2",  "R  -2", "R +2b", "R  -2b", "Mi  1", "Mi  2", "Mi  2b"])
		/*(["Rand", "Xrand", "Shuff", "Walk", "White", "Expra", "Lpran", "Meanr", "Hpran", "Gauss", "Brown", "Gbrow", "Cauch", "Leh_1", "Leh_2", "Rg +1", "Rg -1", "Rg +2", "Rg -2", "RMir1", "RMir2"])*/
		// .valueAction_(4); // Initialisation à Pwhite
	})
	.value_(4); // Initialisation à Pwhite


	~spaPatViewG[tr] = RoundButton(~seqCompG[tr], Rect(280*~xSizeMul, 468*~ySizeMul, 21*~xSizeMul, 20*~ySizeMul))
	.states_([["SC", Color.white, Color.blue/*~popUpMenuBackgroundColor*/], ["SP", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({ |a|
		case
		{ ~triggerSpaSeqs == 0} // Séquence de le piste en cours de sélection
		{ var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~spaPat[tr][seq] = a.value;
			// ~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerSpaSeqs == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i|
				~spaPat[tr][i] = a.value;
				// ~presetSeqTextViewG[tr][i].background_(Color.red)
			};
		}
		/*{ ~triggerAllSeqs[tr] == 2} // tous les presets
		{
		~presetSeqRandList[tr].do {|i|
		~spaPat[tr][i] = a.value;
		~presetSeqTextViewG[tr][i].background_(Color.red)
		};
		}*/;

		if (a.value == 1, {
			~spaPatSelViewG[tr].background_(Color.red(0.7)).stringColor_(Color.white); // repris de envir[patView].states
		},{
			~spaPatSelViewG[tr].background_(~popUpMenuBackgroundColor).stringColor_(~popUpMenuStringColor);
		});

		/*if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
		if (~proPat[tr][~seqSeq[tr]] == 0, { // ~currentSeq = ~seqSeq[tr] dans le pattern  - non décalage
		~lemurAdress1.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) );
		},{
		~lemurAdress1.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
		});
		});
		if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
		if (~proPat[tr][~seqSeq[tr]] == 0, { // ~currentSeq = ~seqSeq[tr] dans le pattern  - non décalage
		~lemurAdress2.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) );
		},{
		~lemurAdress2.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
		});
		});*/
	});


	~panRangePresetViewViewG[tr] = View(~seqCompG[tr], Rect(189*~xSizeMul, 444*~ySizeMul, 28*~xSizeMul, 21*~ySizeMul));

	~panRangePresetViewG[tr] = PopUpMenu.new(~panRangePresetViewViewG[tr], /*~rangePresetViewPos5*/ Rect(0, 0, 58*~xSizeMul, 21*~ySizeMul))
	// .action_({ |menu| ~panRangePresetViewFunc[menu.value].value(tr, ~seqsValue)  })
	.action_({ |menu|
		case
		{ ~triggerSpaSeqs == 0} // Séquence de le piste en cours de sélection
		{ var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~panRangePreset[tr][seq] = menu.value;
			~panRangePresetViewFuncG[menu.value].value(tr, seq);
			// ~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerSpaSeqs == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i|
				~panRangePreset[tr][i] = menu.value;
				~panRangePresetViewFuncG[menu.value].value(tr, i);
				// ~presetSeqTextViewG[tr][i].background_(Color.red)
			};
		}
		/*{ ~triggerAllSeqs[tr] == 2} // tous les presets
		{
		~presetSeqRandList[tr].do {|i|
		~panRangePreset[tr][i] = menu.value;
		~panRangePresetViewFuncG[menu.value].value(tr, i);
		~presetSeqTextViewG[tr][i].background_(Color.red)
		};
		}*/
	})
	.allowsReselection_(true)
	/*.background_(Color.blue)
	.stringColor_(Color.white)*/
	.background_(~popUpMenuBackgroundColor)
	.stringColor_(~popUpMenuStringColor)
	.font_(Font("Verdana",9*~fontSizeMul));
	~panRangePresetViewG[tr].items_(~panRangePresetItemsG)
	.valueAction_(~panRangePresetItemsG.size-1);


	~bufFolderViewViewG = View(~seqCompG[tr], Rect(219*~xSizeMul, 444*~ySizeMul, 86*~xSizeMul, 21*~ySizeMul) /*~roundViewPos5*/); // Pour afficher les dossiers-sons dans leur intégralité dans le PopUp menu

	~bufFolderViewG[tr] = PopUpMenu.new(~bufFolderViewViewG, Rect(0,0,120*~xSizeMul,21*~ySizeMul))
	.allowsReselection_(true)
	.background_(~bufFolColor /*Color.grey(0.7)*//*green*//*magenta*/)
	.stringColor_(Color.white/*black*/)
	.font_(Font("Verdana",9*~fontSizeMul /*,bold:true*/));

	if (~twister.isNil, {
		~bufFolderViewG[tr].action_({ |a| var serv, seq;

			if (~server2.isNil or: {(tr/2).asInteger < ~serverTrackSwitch}, {serv = 0}, {serv = 1});
			// if (~curSeqTrig == 1, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });

			case
			{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
			{
				~bufFolderValue[tr][seq] = a.value;
				~bufFolderFunc.value(tr, seq, ~bufFolderValue[tr][seq], /*0*/ serv);
				~bufMin[tr][seq] = ~bufRangeSpec[tr][seq].map(~bufMinRaw[tr][seq]); // ~bufMinRaw[tr][seq] * (~bufFolderM[serv][tr][seq].size) / prev;
				~bufMax[tr][seq] = ~bufRangeSpec[tr][seq].map(~bufMaxRaw[tr][seq]); // ~bufMaxRaw[tr][seq] * (~bufFolderM[serv][tr][seq].size) / prev;
				~bufSpec[tr][seq] = ControlSpec(~bufMin[tr][seq], ~bufMax[tr][seq], \lin, 1);
				~presetSeqTextViewG[tr][seq].background_(Color.red)
			}
			{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
			{ var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
				sequenceSelected.do { |i|
					~bufFolderValue[tr][i] = a.value;
					~bufFolderFunc.value(tr, i, ~bufFolderValue[tr][i], /*0*/ serv);
					~bufMin[tr][i] = ~bufRangeSpec[tr][i].map(~bufMinRaw[tr][i]);
					~bufMax[tr][i] = ~bufRangeSpec[tr][i].map(~bufMaxRaw[tr][i]);
					~bufSpec[tr][i] = ControlSpec(~bufMin[tr][i], ~bufMax[tr][i], \lin, 1);
					~presetSeqTextViewG[tr][i].background_(Color.red)
				}
			}
			/*{ ~triggerAllSeqs[tr] == 2} // tous les presets
			{ ~presetSeqRandList[tr].do {|i| ~proPat[tr][i] = a.value; ~presetSeqTextViewG[tr][i].background_(Color.red) } }*/;

			/* ~bufRangeView.controlSpec_(ControlSpec(0, ~bufFolder[tr][~seqsValue].size-1, \lin, 1)); */
			/*~bufRangeView.step_(1/(~bufFolderM[serv][tr][seq].size - 1));
			~bufRangeView.minRange_(1/(~bufFolderM[serv][tr][seq].size) * 1);
			~bufRangeView.string = "%\n to \n%".format((~bufMax[tr][seq] * ~bufMul[tr][seq]).round(1), (~bufMin[tr][seq] * ~bufMul[tr][seq]).round(1));
			// ~bufRangeView.valueAction_([0, ~bufRangeSpec[tr][~seqsValue].unmap(~bufFolderM[tr][~seqsValue].size-1)]).doAction; /*~buffer.value(tr, ~seqsValue);*/
			~bufRangeView/*.valueAction_(~bufRangeSpec[tr][~seqsValue].unmap([~bufMin[tr][~seqsValue], ~bufMax[tr][~seqsValue]]))*/.doAction;
			// ~bufRangeView.valueAction_(~bufRangeSpec[tr][~seqsValue].unmap([~bufMin[tr][~seqsValue], ~bufMax[tr][~seqsValue]])).doAction;
			// Le .doAction précédent pour mettre à jour les données quand on change le ~bufFolderViewView si le ~bufRangeView reste identique
			// voire si le .doAction ne fait pas redondance avec les actions de ~bufRangeView ????????? - XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			// Pourquoi besoin de relancer le string alors que le valueAction devrait suffire ???

			// ~bufRangeView.string = "%\n to \n%".format((~bufMax[tr][~seqsValue] * ~bufMul[tr][~seqsValue]).round(1), (~bufMin[tr][~seqsValue] * ~bufMul[tr][~seqsValue]).round(1));
			~bufView.valueThumbSize_(max(10, if ((~bufMax[tr][seq] - ~bufMin[tr][seq]+1) > ~multiSliderHeight5,
			{10}, {~multiSliderHeight5 / (~bufMax[tr][seq] - ~bufMin[tr][seq]+1) })));
			~bufView.step_(1/(((~bufMax[tr][seq])-(~bufMin[tr][seq]))));
			~bufIndexView.step_(1/(~bufMax[tr][seq] - ~bufMin[tr][seq]));
			~bufIndexView.string_("At : %".format((~bufSpec[tr][seq].map(~bufIndexView.value) * ~bufMul[tr][seq]).round(1)));*/
			// léger pb de rounding ?*/

			if (~lemurConnected1 == 1 and: {tr == ~tracksValue} , {
				// ~lemurAdress1.sendMsg("/ParC/BufM/value", ~bufFolderValue[tr][~seqsValue]);
				~lemurAdress1.sendMsg( *["/ParC/BufM", "@content", ~bufFolderView.items[~bufFolderValue[tr][seq]] ]);
				~lemurAdress1.sendMsg( *["/ParC/BufMenuL", "@content", ~bufFolderView.items[~bufFolderValue[tr][seq]] ]);
				~lemurAdress1.sendMsg("/ParC/BufLed/value", ~bufFolderValue[tr][seq] /*a.value*/ * ~bufFolderSize1.reciprocal); // à Optimiser ???
			});

		});

	},{
		~bufFolderViewG[tr].action_({ |a| var serv, seq;

			if (~server2.isNil or: {(tr/2).asInteger < ~serverTrackSwitch}, {serv = 0}, {serv = 1});
			// if (~curSeqTrig == 1, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~bufFolValues[tr].value = a.value;

			if  (~bufFolderValue[tr][seq] != ~bufFolValues[tr].value, { // view.value.postln; ~ratValues[tr].value.postln;  "0".postln;

				~bufFolderValue[tr][seq] = a.value;

				case
				{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
				{
					~bufFolderFunc.value(tr, seq, ~bufFolderValue[tr][seq], /*0*/ serv);
					~bufMin[tr][seq] = ~bufRangeSpec[tr][seq].map(~bufMinRaw[tr][seq]); // ~bufMinRaw[tr][seq] * (~bufFolderM[serv][tr][seq].size) / prev;
					~bufMax[tr][seq] = ~bufRangeSpec[tr][seq].map(~bufMaxRaw[tr][seq]); // ~bufMaxRaw[tr][seq] * (~bufFolderM[serv][tr][seq].size) / prev;
					~bufSpec[tr][seq] = ControlSpec(~bufMin[tr][seq], ~bufMax[tr][seq], \lin, 1);
					~presetSeqTextViewG[tr][seq].background_(Color.red)
				}
				{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
				{ var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
					sequenceSelected.do { |i|
						~bufFolderValue[tr][i] = a.value;
						~bufFolderFunc.value(tr, i, ~bufFolderValue[tr][i], /*0*/ serv);
						~bufMin[tr][i] = ~bufRangeSpec[tr][i].map(~bufMinRaw[tr][i]);
						~bufMax[tr][i] = ~bufRangeSpec[tr][i].map(~bufMaxRaw[tr][i]);
						~bufSpec[tr][i] = ControlSpec(~bufMin[tr][i], ~bufMax[tr][i], \lin, 1);
						~presetSeqTextViewG[tr][i].background_(Color.red)
					}
				}
				/*{ ~triggerAllSeqs[tr] == 2} // tous les presets
				{ ~presetSeqRandList[tr].do {|i| ~proPat[tr][i] = a.value; ~presetSeqTextViewG[tr][i].background_(Color.red) } }*/;

				if (~lemurConnected1 == 1 and: {tr == ~tracksValue} , {
					// ~lemurAdress1.sendMsg("/ParC/BufM/value", ~bufFolderValue[tr][~seqsValue]);
					~lemurAdress1.sendMsg( *["/ParC/BufM", "@content", ~bufFolderView.items[~bufFolderValue[tr][seq]] ]);
					~lemurAdress1.sendMsg( *["/ParC/BufMenuL", "@content", ~bufFolderView.items[~bufFolderValue[tr][seq]] ]);
					~lemurAdress1.sendMsg("/ParC/BufLed/value", ~bufFolderValue[tr][seq] /*a.value*/ * ~bufFolderSize1.reciprocal); // à Optimiser ???
				});

				if (tr == ~tracksValue and: { ~currentTab == 0 }, { ~bufFolderView.valueAction_(a.value) })

			});
		});

	});


	if (~foldersStructure == 1, {
		~bufFolderViewG[tr].items_(~arrayOfFolderNames2 ++ ~kindOfFolders.collect{|item, i| (i+~arrayOfFolderNames2.size) +"-"+item} ++ ["ALL"]);
	}, {
		~bufFolderViewG[tr].items_(~arrayOfFolderNames2 ++ ["ALL"]);
	});

	~bufFolderViewG[tr].valueAction_(~bufFolderValue[0][0]);


	~proPatViewG[tr] = RoundButton(~seqCompG[tr], Rect(2*~xSizeMul, 492*~ySizeMul, 32*~xSizeMul, 20*~ySizeMul))
	.states_([["P Cyc", Color.white, Color.blue /*~popUpMenuBackgroundColor*/], ["P Pat", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({ |a| var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
		~proBlock[tr] = 1;
		// if (~proPat[tr][~seqsValue] == 1, {~proPatSelView.background_(Color.red).stringColor_(Color.white)}, {~proPatSelView.background_(~popUpMenuBackgroundColor).stringColor_(~popUpMenuStringColor)} );
		// Pas activé car on n'est pas nécessairement sur la Track de la séquence que l'on active

		case
		{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
		{
			~proPat[tr][seq] = a.value; ~presetSeqTextViewG[tr][seq].background_(Color.red);
		}
		{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
		{ var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i| ~proPat[tr][i] = a.value; ~presetSeqTextViewG[tr][i].background_(Color.red) }
		}
		{ ~triggerAllSeqs[tr] == 2} // tous les presets
		{ ~presetSeqRandList[tr].do {|i| ~proPat[tr][i] = a.value; ~presetSeqTextViewG[tr][i].background_(Color.red) } };

		if (~patFlag == 1, {~seqs.do {|sequence| ~proPat[tr][sequence] = a.value } });

		if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
			if (~proPat[tr][seq] == 0, {
				~lemurAdress1.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) );
			},{
				~lemurAdress1.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
			});
		});
		if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
			if (~proPat[tr][seq] == 0, {
				~lemurAdress2.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) );
			},{
				~lemurAdress2.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
			});
		});
	});


	~proBjorViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(36*~xSizeMul, 492*~ySizeMul, 75*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| ~proBjor[tr][~seqsValue] = ~proBjorSpec[tr][~seqsValue].map(view.value).asInteger;
		view.string = "Hit : %".format(~proBjor[tr][~seqsValue]);
	})
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightNoColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	// .step_(1/~pro[tr][~seqsValue].size) // retrait car intégration de ~proBjorGridsX qui ne doit pas avoir de step
	.valueAction_(1)
	.action_({ |view| var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); val = ~proBjorSpec[tr][seq].map(view.value).asInteger;
		case
		{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
		{
			~proBjor[tr][seq] = val; ~proBjorGridsX[tr][seq] = view.value.round(0.001); ~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i| ~proBjor[tr][i] = ~proBjorSpec[tr][i].map(view.value).asInteger; ~proBjorGridsX[tr][i] = view.value.round(0.001); ~presetSeqTextViewG[tr][i].background_(Color.red) }
		}
		{ ~triggerAllSeqs[tr] == 2} // tous les presets
		{ ~presetSeqRandList[tr].do {|i| ~proBjor[tr][i] = ~proBjorSpec[tr][i].map(view.value).asInteger; ~proBjorGridsX[tr][i] = view.value.round(0.001); ~presetSeqTextViewG[tr][i].background_(Color.red) } };

		view.string = "H: %-%".format( val, ~proBjorGridsX[tr][seq] );

		if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
			~lemurAdress1.sendMsg("/ParC/HitM/value", val); ~lemurAdress1.sendMsg("/ParC/HitLed/value", view.value );
		});
		if (~lemurConnected2 == 1  and: {tr == ~secondLemurX2Track}, {
			~lemurAdress2.sendMsg("/ParC/HitM/value", val); ~lemurAdress2.sendMsg("/ParC/HitLed/value", view.value );
		});
	});


	~proBjor2ViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(113*~xSizeMul, 492*~ySizeMul, 75*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| ~proBjor2[tr][~seqsValue] = ~proBjorSpec[tr][~seqsValue].map(view.value).asInteger;
		view.string = "Off : %".format(~proBjor2[tr][~seqsValue]);
	})
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightNoColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	// .step_(1/~pro[tr][~seqsValue].size) // retrait car intégration de ~proBjorGridsX qui ne doit pas avoir de step
	.valueAction_(1)
	.valueAction_(1)
	.action_({ |view| var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); val = ~proBjorSpec[tr][seq].map(view.value).asInteger;
		case
		{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
		{
			~proBjor2[tr][seq] = val; ~proBjorGridsY[tr][seq] = view.value.round(0.001); ~presetSeqTextViewG[tr][seq].background_(Color.red)
		}
		{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i| ~proBjor2[tr][i] = ~proBjorSpec[tr][i].map(view.value).asInteger; ~proBjorGridsY[tr][i] = view.value.round(0.001); ~presetSeqTextViewG[tr][i].background_(Color.red) }
		}
		{ ~triggerAllSeqs[tr] == 2} // tous les presets
		{ ~presetSeqRandList[tr].do {|i| ~proBjor2[tr][i] = ~proBjorSpec[tr][i].map(view.value).asInteger; ~proBjorGridsY[tr][i] = view.value.round(0.001); ~presetSeqTextViewG[tr][i].background_(Color.red) } };

		view.string = "O: %-%".format( val, ~proBjorGridsY[tr][seq] );

		if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
			~lemurAdress1.sendMsg("/ParC/OffM/value", val); ~lemurAdress1.sendMsg("/ParC/OffLed/value", view.value );
		});
		if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
			~lemurAdress2.sendMsg("/ParC/OffM/value", val); ~lemurAdress2.sendMsg("/ParC/OffLed/value", view.value );
		});
	});


	~proSelectViewG[tr] = RoundButton(~seqCompG[tr], Rect(190*~xSizeMul, 492*~ySizeMul, 32*~xSizeMul, 20*~ySizeMul))
	.states_([["\PROS", Color.white, Color.blue], ["\PRO1", Color.white, Color.red]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({ |a| var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
		~proBlock[tr] = 1;
		[\rtmBlock, \proBlock, \synBlock, \spaBlock, \legBlock, \envBlock, \bufBlock, \ampBlock, \ratBlock, \rat2Block, \offBlock, \strBlock, \str2Block, \cenBlock, \cen2Block, \panBlock, \delBlock, \outLBlock, \outRBlock, \fxLBlock, \fxRBlock].do {|i| currentEnvironment[i][tr] = 1};

		case
		{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
		{
			~proSelect[tr][seq] = a.value; ~presetSeqTextViewG[tr][seq].background_(Color.red);
		}
		{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
		{
			var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
			sequenceSelected.do {|i| ~proSelect[tr][i] = a.value; ~presetSeqTextViewG[tr][i].background_(Color.red) }
		}
		{ ~triggerAllSeqs[tr] == 2} // tous les presets
		{ ~presetSeqRandList[tr].do {|i| ~proSelect[tr][i] = a.value; ~presetSeqTextViewG[tr][i].background_(Color.red) } };

		if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
			if (~proSelect[tr][seq] == 0, {
				~lemurAdress1.sendMsg( *[ ["/ParC/Cyc2"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) ); ~lemurAdress1.sendMsg( *["/ParC/CycT2", "@content", "Pro S" ]);
			},{
				~lemurAdress1.sendMsg( *[ ["/ParC/Cyc2"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) ); ~lemurAdress1.sendMsg( *["/ParC/CycT2", "@content", "Pro 1" ]);
			});
		});
		if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
			if (~proSelect[tr][seq] == 0, {
				~lemurAdress2.sendMsg( *[ ["/ParC/Cyc2"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) ); ~lemurAdress2.sendMsg( *["/ParC/CycT2", "@content", "Pro S" ]);
			},{
				~lemurAdress2.sendMsg( *[ ["/ParC/Cyc2"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) ); ~lemurAdress2.sendMsg( *["/ParC/CycT2", "@content", "Pro 1" ]);
			});
		});
	});


	~rtmMulViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(2*~xSizeMul, 516*~ySizeMul, 75*~xSizeMul, 22*~ySizeMul))
	.action_({ |view|
		~rtmMul[tr][~seqsValue] = ~rtmMulSpec[tr][~seqsValue].map(view.value);
		view.string = "Rtm : %".format(~rtmMul[tr][~seqsValue]);
		if (~rtmRound[tr][~seqsValue] < 0.001,
			{~rtmRangeView.string_("%\n to \n%".format((~rtmMax[tr][~seqsValue] * ~rtmMul[tr][~seqsValue]).round(0.001), (~rtmMin[tr][~seqsValue] * ~rtmMul[tr][~seqsValue]).round(0.001))); ~rtmIndexView.string = "At : %".format((~rtmIndex[tr][~seqsValue] * ~rtmMul[tr][~seqsValue]).round(0.001)); }, {~rtmRangeView.string_("%\n to \n%".format((~rtmMax[tr][~seqsValue] * ~rtmMul[tr][~seqsValue]).round(~rtmRound[tr][~seqsValue]), (~rtmMin[tr][~seqsValue] * ~rtmMul[tr][~seqsValue]).round(~rtmRound[tr][~seqsValue]))); ~rtmIndexView.string = "At : %".format((~rtmIndex[tr][~seqsValue] * ~rtmMul[tr][~seqsValue]).round(~rtmRound[tr][~seqsValue])) }); // léger pb de rounding ?
		~rtmDisplay.string_("~rtmView.valueAction_(~rtmSpec["+tr+"]["+~seqsValue+"].unmap(~rtmMul["+tr+"]["+~seqsValue+"].reciprocal * "+(~rtmSpec[tr][~seqsValue].map(~dur[tr][~seqsValue]) * ~rtmMul[tr][~seqsValue]).round(~rtmRound[tr][~seqsValue]).asCompileString+"));").asString; ~rtmDisplay.setFont((Font("arial",1)), 4, 75);
		~nbTotalBeatsView.doAction;
	})
	.font_(Font("Verdana", 11*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~rtmColor /*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	// .thumbSize_(10) // à retirer pour ne pas l'aligner sur le niveau du slider
	// .stringAlignToKnob = true; // à retirer pour ne pas l'aligner sur le niveau du slider
	// .doAction;
	.valueAction_(~rtmMulSpec[tr][~seqsValue].unmap(1));


	if (~twister.isNil, {
		~rtmMulViewG[tr] .action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); val = ~rtmMulSpec[tr][seq].map(view.value);
			case
			{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
			{
				~rtmMul[tr][seq] = val; ~presetSeqTextViewG[tr][seq].background_(Color.red);
			}
			{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
			{
				var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
				sequenceSelected.do {|i| ~rtmMul[tr][i] = ~rtmMulSpec[tr][seq].map(view.value); ~presetSeqTextViewG[tr][i].background_(Color.red) }
			}
			{ ~triggerAllSeqs[tr] == 2} // tous les presets
			{ ~presetSeqRandList[tr].do {|i| ~rtmMul[tr][i] = ~rtmMulSpec[tr][seq].map(view.value); ~presetSeqTextViewG[tr][i].background_(Color.red) } };

			view.string = "Rtm : %".format( val );

			if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
				~lemurAdress1.sendMsg("/ParC/RtmM/value", val); ~lemurAdress1.sendMsg("/ParC/RtmLed/value",  view.value );
			});
			if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
				~lemurAdress2.sendMsg("/ParC/RtmM/value", val); ~lemurAdress2.sendMsg("/ParC/RtmLed/value", view.value );
			});
		});
	},{
		~rtmMulViewG[tr] .action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~rtmValues[tr].value = view.value;
			val = ~rtmMulSpec[tr][seq].map(view.value);
			if (/*view.value*/ ~rtmMulSpec[tr][seq].unmap(~rtmMul[tr][seq]) == ~rtmValues[tr].value, {
				~rtmMul[tr][seq] = val; {view.string = "Rtm : %".format( val )}.defer; // Vérifier à retirer les .defer XXXXXXXXXXXXXXXXXX
			},{
				case
				{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
				{
					~rtmMul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
				}
				{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
				{
					var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
					sequenceSelected.do {|i| ~rtmMul[tr][i] = ~rtmMulSpec[tr][seq].map(view.value); {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer }
				}
				{ ~triggerAllSeqs[tr] == 2} // tous les presets
				{ ~presetSeqRandList[tr].do {|i| ~rtmMul[tr][i] = ~rtmMulSpec[tr][seq].map(view.value); {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer } };

				view.string = "Rtm : %".format( val );

				if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
					~lemurAdress1.sendMsg("/ParC/RtmM/value", val); ~lemurAdress1.sendMsg("/ParC/RtmLed/value",  view.value );
				});
				if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
					~lemurAdress2.sendMsg("/ParC/RtmM/value", val); ~lemurAdress2.sendMsg("/ParC/RtmLed/value", view.value );
				});
			});
		});
	});


	~legMulViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(104*~xSizeMul, 516*~ySizeMul, 75*~xSizeMul, 22*~ySizeMul))
	.action_({ |view|
		~legMul[tr][~seqsValue] = ~legMulSpec.map(view.value);
		view.string = "Dur : %".format(~legMul[tr][~seqsValue]);
		~legRangeView.string_("%\n to \n%".format(
			(if ((~legMax[tr][~seqsValue] * ~legMul[tr][~seqsValue]) > 100, { (~legMax[tr][~seqsValue] * ~legMul[tr][~seqsValue]).round(1) }, {(~legMax[tr][~seqsValue] * ~legMul[tr][~seqsValue]).round(~legRound[tr][~seqsValue])})),
			(if ((~legMin[tr][~seqsValue] * ~legMul[tr][~seqsValue]) > 100, { (~legMin[tr][~seqsValue] * ~legMul[tr][~seqsValue]).round(1) }, {(~legMin[tr][~seqsValue] * ~legMul[tr][~seqsValue]).round(~legRound[tr][~seqsValue])}))));
		~legIndexView.string_("At : %".format((~legSpec[tr][~seqsValue].map(~legIndexView.value) * ~legMul[tr][~seqsValue]).round(~legRound[tr][~seqsValue]))); // léger pb de rounding ?
		~legDisplay.string_(("~legView.valueAction_(~legSpec["+tr+"]["+~seqsValue+"].unmap(~legMul["+tr+"]["+~seqsValue+"].reciprocal * "+(~legSpec[tr][~seqsValue].map(~leg[tr][~seqsValue]) * ~legMul[tr][~seqsValue]).round(~legRound[tr][~seqsValue]).asCompileString+"));").asString); ~legDisplay.setFont((Font("arial",1)), 4, 75);
	})
	.font_(Font("Verdana", 11*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~legColor /*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~legMulSpec.unmap(1));

	if (~twister.isNil, {
		~legMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); val = ~legMulSpec.map(view.value);
			case
			{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
			{
				~legMul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
			}
			{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
			{
				var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
				sequenceSelected.do {|i| ~legMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer }
			}
			{ ~triggerAllSeqs[tr] == 2} // tous les presets
			{ ~presetSeqRandList[tr].do {|i|  ~legMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer } };

			view.string = "Dur : %".format( val );

			if (~lemurConnected1 == 1, {
				if (tr == ~tracksValue, {
					~lemurAdress1.sendMsg("/ParC/LegM/value", val); ~lemurAdress1.sendMsg("/ParC/LegLed/value", view.value );
				});
				if (~rhythmTracksX2.includes(tr), {
					~lemurAdress1.sendMsg(~lemurLegGTextValues[tr], val); ~lemurAdress1.sendMsg(~lemurLegGLedValues[tr], view.value );
				});
			});
			if (~lemurConnected2 == 1, {
				if (tr == ~secondLemurX2Track, {
					~lemurAdress2.sendMsg("/ParC/LegM/value", val); ~lemurAdress2.sendMsg("/ParC/LegLed/value", view.value );
				});
				if (~rhythmTracksX2.includes(tr), {
					~lemurAdress2.sendMsg(~lemurLegGTextValues[tr], val); ~lemurAdress2.sendMsg(~lemurLegGLedValues[tr], view.value );
				});
			});
		});
	},{
		~legMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~legValues[tr].value = view.value;
			val = ~legMulSpec.map(view.value);
			if (~legMulSpec.unmap(~legMul[tr][seq]) == ~legValues[tr].value, {
				~legMul[tr][seq] = val; view.string = "Dur : %".format( val );
			},{
				case
				{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
				{
					~legMul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
				}
				{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
				{
					var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
					sequenceSelected.do {|i| ~legMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer }
				}
				{ ~triggerAllSeqs[tr] == 2} // tous les presets
				{ ~presetSeqRandList[tr].do {|i|  ~legMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer } };

				view.string = "Dur : %".format( val );

				if (~lemurConnected1 == 1, {
					if (tr == ~tracksValue, {
						~lemurAdress1.sendMsg("/ParC/LegM/value", val); ~lemurAdress1.sendMsg("/ParC/LegLed/value", view.value );
					});
					if (~rhythmTracksX2.includes(tr), {
						~lemurAdress1.sendMsg(~lemurLegGTextValues[tr], val); ~lemurAdress1.sendMsg(~lemurLegGLedValues[tr], view.value );
					});
				});
				if (~lemurConnected2 == 1, {
					if (tr == ~secondLemurX2Track, {
						~lemurAdress2.sendMsg("/ParC/LegM/value", val); ~lemurAdress2.sendMsg("/ParC/LegLed/value", view.value );
					});
					if (~rhythmTracksX2.includes(tr), {
						~lemurAdress2.sendMsg(~lemurLegGTextValues[tr], val); ~lemurAdress2.sendMsg(~lemurLegGLedValues[tr], view.value );
					});
				});
			});
		});
	});


	~rtmMulPresetViewViewG[tr] = View(~seqCompG[tr], Rect(77*~xSizeMul, 516*~ySizeMul, 26*~xSizeMul, 22*~ySizeMul));

	~rtmMulPresetViewG[tr] = PopUpMenu.new(~rtmMulPresetViewViewG[tr], Rect(0, 0, 50*~xSizeMul, 22*~ySizeMul))
	.action_({ |menu| var seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
		~rtmMulViewG[tr].valueAction_(~rtmMulSpec[tr][seq].unmap(menu.item.asFloat));
		if (tr == ~tracksValue, {~rtmMulView.valueAction_(~rtmMulSpec[tr][seq].unmap(menu.item.asFloat)) }); // redondant, mais nécessaire d'updater le slider de la séquence quand on est sur celle-ci.
	})
	.allowsReselection_(true)
	/*.background_(Color.blue)
	.stringColor_(Color.white)*/
	.background_(~popUpMenuBackgroundColor)
	.stringColor_(~popUpMenuStringColor)
	.font_(Font("Verdana",8*~fontSizeMul));
	// ~rtmMulPresetViewG[tr].items_(["0.25", "0.5", "0.75", "1", "1.5", "2", "3", "5", "10"])
	~rtmMulPresetViewG[tr].items_(["0.1", /*"0.125", "0.15",*/ "0.2", "0.25", "0.3", "0.4", "0.5", "0.6", "0.7", "0.75", "0.8", "0.9", "1", "1.5", "2", "2.5", "3", "4", "5", "6", "7", "7.5", "8", "9", "10"])
	.valueAction_(/*3*/ 11);


	~legMulPresetViewViewG[tr] = View(~seqCompG[tr], Rect(179*~xSizeMul, 516*~ySizeMul, 26*~xSizeMul, 22*~ySizeMul));

	~legMulPresetViewG[tr] = PopUpMenu.new(~legMulPresetViewViewG[tr], /*~mulPresetViewPos5*/ Rect(0, 0, 50*~xSizeMul, 22*~ySizeMul))
	.action_({ |menu| ~legMulViewG[tr].valueAction_(~legMulSpec.unmap(menu.item.asFloat));
		if (tr == ~tracksValue, {~legMulView.valueAction_(~legMulSpec.unmap(menu.item.asFloat)) }); // redondant, mais nécessaire d'updater le slider de la séquence quand on est sur celle-ci.
	})
	.allowsReselection_(true)
	.background_(~popUpMenuBackgroundColor)
	.stringColor_(~popUpMenuStringColor)
	.font_(Font("Verdana",8*~fontSizeMul));
	// ~legMulPresetViewG[tr].items_(["0", "0.1", "0.2", "0.5", "1", "2", "3", "5", "10"])
	~legMulPresetViewG[tr].items_(["0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.75", "0.8", "0.9", "1", "1.5", "2", "2.5", "3", "4", "5", "6", "7", "7.5", "8", "9", "10"])
	.valueAction_(/*4*/ 11);


	~proMulViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(224*~xSizeMul, 492*~ySizeMul, 70*~xSizeMul, 22*~ySizeMul))
	.action_({ |view|
		~proMul[tr][~seqsValue] = ~proMulSpec.map(view.value);
		view.string = "Pro : %".format(~proMul[tr][~seqsValue]);
		// ~proRangeView.string_("%\n to \n%".format((~proMax[tr][~seqsValue] * ~proMul[tr][~seqsValue]).round(~proRound[tr][~seqsValue]), (~proMin[tr][~seqsValue] * ~proMul[tr][~seqsValue]).round(~proRound[tr][~seqsValue])));
		~proIndexView.string_("At : %".format((~proSpec[tr][~seqsValue].map(~proIndexView.value * ~proMul[tr][~seqsValue])).round(~proRound[tr][~seqsValue]))); // léger pb de rounding ?
		~proDisplay.string_(("~proView.valueAction_(~proSpec["+tr+"]["+~seqsValue+"].unmap(~proMul["+tr+"]["+~seqsValue+"].reciprocal * "+(~proSpec[tr][~seqsValue].map(~pro[tr][~seqsValue] * ~proMul[tr][~seqsValue])).round(~proRound[tr][~seqsValue]).asCompileString+"));").asString); ~proDisplay.setFont((Font("arial",1)), 4, 75);
	})
	.font_(Font("Verdana", 11*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~proColor /*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~proMulSpec.unmap(1));

	if (~twister.isNil, {
		~proMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); val = ~proMulSpec.map(view.value);
			case
			{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
			{
				~proMul[tr][seq] = val; ~gridsDens[tr][seq] = view.value; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
			}
			{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
			{
				var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
				sequenceSelected.do {|i| ~proMul[tr][i] = val; ~gridsDens[tr][i] = view.value; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer }
			}
			{ ~triggerAllSeqs[tr] == 2} // tous les presets
			{ ~presetSeqRandList[tr].do {|i| ~proMul[tr][i] = val; ~gridsDens[tr][i] = view.value; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer } };

			view.string = "Pro : %".format( val );

			if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
				~lemurAdress1.sendMsg("/ParC/ProM/value", val); ~lemurAdress1.sendMsg("/ParC/ProLed/value", view.value );
			});
			if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
				~lemurAdress2.sendMsg("/ParC/ProM/value", val); ~lemurAdress2.sendMsg("/ParC/ProLed/value", view.value );
			});
		})
	},{
		~proMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~proValues[tr].value = view.value;
			val = ~proMulSpec.map(view.value);
			if ( ~proMulSpec.unmap(~proMul[tr][seq]) == ~proValues[tr].value, {
				~proMul[tr][seq] = val; view.string = "Pro : %".format( val );
			},{
				case
				{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
				{
					~proMul[tr][seq] = val; ~gridsDens[tr][seq] = view.value; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
				}
				{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
				{
					var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
					sequenceSelected.do {|i| ~proMul[tr][i] = val; ~gridsDens[tr][i] = view.value; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer }
				}
				{ ~triggerAllSeqs[tr] == 2} // tous les presets
				{ ~presetSeqRandList[tr].do {|i| ~proMul[tr][i] = val; ~gridsDens[tr][i] = view.value; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer } };

				view.string = "Pro : %".format( val );

				if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
					~lemurAdress1.sendMsg("/ParC/ProM/value", val); ~lemurAdress1.sendMsg("/ParC/ProLed/value", view.value );
				});
				if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
					~lemurAdress2.sendMsg("/ParC/ProM/value", val); ~lemurAdress2.sendMsg("/ParC/ProLed/value", view.value );
				});
			})
		})
	});


	~ratMulViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(206*~xSizeMul, 516*~ySizeMul, 80*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| /*~tracksView.valueAction_(tr);*/
		~ratMul[tr][~seqsValue] = ~ratMulSpec.map(view.value);
		view.string = "Rat : %".format(~ratMul[tr][~seqsValue]);
		~ratRangeView.string_("%\n to \n%".format(
			(if ((~ratMax[tr][~seqsValue] * ~ratMul[tr][~seqsValue]) > 100, { (~ratMax[tr][~seqsValue] * ~ratMul[tr][~seqsValue]).round(1) }, {(~ratMax[tr][~seqsValue] * ~ratMul[tr][~seqsValue]).round(~ratRound[tr][~seqsValue])})),
			(if ((~ratMin[tr][~seqsValue] * ~ratMul[tr][~seqsValue]) > 100, { (~ratMin[tr][~seqsValue] * ~ratMul[tr][~seqsValue]).round(1) }, {(~ratMin[tr][~seqsValue] * ~ratMul[tr][~seqsValue]).round(~ratRound[tr][~seqsValue])}))));
		~ratIndexView.string_("At : %".format((~ratSpec[tr][~seqsValue].map(~ratIndexView.value) * ~ratMul[tr][~seqsValue]).round(~ratRound[tr][~seqsValue]))); // léger pb de rounding ?
		~ratDisplay.string_(("~ratView.valueAction_(~ratSpec["+tr+"]["+~seqsValue+"].unmap(~ratMul["+tr+"]["+~seqsValue+"].reciprocal * "+(~ratSpec[tr][~seqsValue].map(~rat[tr][~seqsValue]) * ~ratMul[tr][~seqsValue]).round(~ratRound[tr][~seqsValue]).asCompileString+"));").asString); ~ratDisplay.setFont((Font("arial",1)), 4, 75);
	})
	.font_(Font("Verdana", 11*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(Color.magenta(0.7) /*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~ratMulSpec.unmap(1));

	if (~twister.isNil, {
		~ratMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); val = ~ratMulSpec.map(view.value);
			case
			{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
			{
				~ratMul[tr][seq] = val; ~rat2Mul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer; // .defer vraiment necessaire ??? apparemment pas pour les autres XXXXXXXXXXXXXXXX
			}
			{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
			{
				var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
				sequenceSelected.do {|i| ~ratMul[tr][i] = val; ~rat2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; }
			}
			{ ~triggerAllSeqs[tr] == 2} // tous les presets
			{ ~presetSeqRandList[tr].do {|i| ~ratMul[tr][i] = val; ~rat2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; } };

			{view.string = "Rat : %".format( val )}.defer;

			if (~lemurConnected1 == 1, {
				if (tr == ~tracksValue, {
					~lemurAdress1.sendMsg("/ParC/RatM/value", val); ~lemurAdress1.sendMsg("/ParC/RatLed/value", view.value );
				});
				if (~rhythmTracksX2.includes(tr), {
					~lemurAdress1.sendMsg(~lemurRatGTextValues[tr], val); ~lemurAdress1.sendMsg(~lemurRatGLedValues[tr], view.value );
				});
			});
			if (~lemurConnected2 == 1, {
				if (tr == ~secondLemurX2Track, {
					~lemurAdress2.sendMsg("/ParC/RatM/value", val); ~lemurAdress2.sendMsg("/ParC/RatLed/value", view.value );
				});
				if (~rhythmTracksX2.includes(tr), {
					~lemurAdress2.sendMsg(~lemurRatGTextValues[tr], val); ~lemurAdress2.sendMsg(~lemurRatGLedValues[tr], view.value );
				});
			});
		});
	},{
		~ratMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~ratValues[tr].value = view.value; // Hack - obligé pour marquer en rouge la séquence dès le 1er changement et non le 2ème
			val = ~ratMulSpec.map(view.value);
			// ~ratMul[tr][seq] = val; ~rat2Mul[tr][seq] = val; {view.string = "Rat : %".format( val )}.defer;
			if (/*view.value*/ ~ratMulSpec.unmap(~ratMul[tr][seq]) == ~ratValues[tr].value, { // view.value.postln; ~ratValues[tr].value.postln;  "0".postln;
				~ratMul[tr][seq] = val; ~rat2Mul[tr][seq] = val; {view.string = "Rat : %".format( val )}.defer;
			},{
				// view.value.postln; ~ratValues[tr].value.postln; "1".postln;
				case
				{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
				{
					~ratMul[tr][seq] = val; ~rat2Mul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
				}
				{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
				{
					var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
					sequenceSelected.do {|i| ~ratMul[tr][i] = val; ~rat2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; }
				}
				{ ~triggerAllSeqs[tr] == 2} // tous les presets
				{ ~presetSeqRandList[tr].do {|i| ~ratMul[tr][i] = val; ~rat2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; } };

				{view.string = "Rat : %".format( val )}.defer;

				if (~lemurConnected1 == 1, {
					if (tr == ~tracksValue, {
						~lemurAdress1.sendMsg("/ParC/RatM/value", val); ~lemurAdress1.sendMsg("/ParC/RatLed/value", view.value );
					});
					if (~rhythmTracksX2.includes(tr), {
						~lemurAdress1.sendMsg(~lemurRatGTextValues[tr], val); ~lemurAdress1.sendMsg(~lemurRatGLedValues[tr], view.value );
					});
				});
				if (~lemurConnected2 == 1, {
					if (tr == ~secondLemurX2Track, {
						~lemurAdress2.sendMsg("/ParC/RatM/value", val); ~lemurAdress2.sendMsg("/ParC/RatLed/value", view.value );
					});
					if (~rhythmTracksX2.includes(tr), {
						~lemurAdress2.sendMsg(~lemurRatGTextValues[tr], val); ~lemurAdress2.sendMsg(~lemurRatGLedValues[tr], view.value );
					});
				});
				/*if (~twister.notNil, {
				~ratValues[tra].value_(view.value/*~ratMulSpec.unmap(~ratMul[tr][~seqSeq[tr]])*/); // Pour mise à jour du Twister
				});*/
			});
		});
	});


	~strMulViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(288*~xSizeMul, 516*~ySizeMul, 78*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| /*~tracksView.valueAction_(tr);*/
		~strMul[tr][~seqsValue] = ~strMulSpec.map(view.value);
		view.string = "Str : %".format(~strMul[tr][~seqsValue]);
		~strRangeView.string_("%\n to \n%".format(
			(if ((~strMax[tr][~seqsValue] * ~strMul[tr][~seqsValue]) > 100, { (~strMax[tr][~seqsValue] * ~strMul[tr][~seqsValue]).round(1) }, {(~strMax[tr][~seqsValue] * ~strMul[tr][~seqsValue]).round(~strRound[tr][~seqsValue])})),
			(if ((~strMin[tr][~seqsValue] * ~strMul[tr][~seqsValue]) > 100, { (~strMin[tr][~seqsValue] * ~strMul[tr][~seqsValue]).round(1) }, {(~strMin[tr][~seqsValue] * ~strMul[tr][~seqsValue]).round(~strRound[tr][~seqsValue])}))));
		~strIndexView.string_("At : %".format((~strSpec[tr][~seqsValue].map(~strIndexView.value) * ~strMul[tr][~seqsValue]).round(~strRound[tr][~seqsValue]))); // léger pb de rounding ?
		~strDisplay.string_(("~strView.valueAction_(~strSpec["+tr+"]["+~seqsValue+"].unmap(~strMul["+tr+"]["+~seqsValue+"].reciprocal * "+(~strSpec[tr][~seqsValue].map(~str[tr][~seqsValue]) * ~strMul[tr][~seqsValue]).round(~strRound[tr][~seqsValue]).asCompileString+"));").asString); ~strDisplay.setFont((Font("arial",1)), 4, 75);
	})
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~strColor /*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~strMulSpec.unmap(1));

	if (~twister.isNil, {
		~strMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); val = ~strMulSpec.map(view.value);
			case
			{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
			{
				~strMul[tr][seq] = val; ~str2Mul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
			}
			{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
			{
				var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
				sequenceSelected.do {|i| ~strMul[tr][i] = val; ~str2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer }
			}
			{ ~triggerAllSeqs[tr] == 2} // tous les presets
			{ ~presetSeqRandList[tr].do {|i| ~strMul[tr][i] = val; ~str2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer } };

			view.string = "Str : %".format( val );

			if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
				~lemurAdress1.sendMsg("/ParC/StrM/value", val); ~lemurAdress1.sendMsg("/ParC/StrLed/value", view.value );
			});
			if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
				~lemurAdress2.sendMsg("/ParC/StrM/value", val); ~lemurAdress2.sendMsg("/ParC/StrLed/value", view.value );
			});
		});
	},{
		~strMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~strValues[tr].value = view.value;
			val = ~strMulSpec.map(view.value);
			if ( ~strMulSpec.unmap(~strMul[tr][seq]) == ~strValues[tr].value, {
				~strMul[tr][seq] = val; view.string = "Str : %".format( val );
			},{
				case
				{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
				{
					~strMul[tr][seq] = val; ~str2Mul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
				}
				{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
				{
					var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
					sequenceSelected.do {|i| ~strMul[tr][i] = val; ~str2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer }
				}
				{ ~triggerAllSeqs[tr] == 2} // tous les presets
				{ ~presetSeqRandList[tr].do {|i| ~strMul[tr][i] = val; ~str2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer } };

				view.string = "Str : %".format( val );

				if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
					~lemurAdress1.sendMsg("/ParC/StrM/value", val); ~lemurAdress1.sendMsg("/ParC/StrLed/value", view.value );
				});
				if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
					~lemurAdress2.sendMsg("/ParC/StrM/value", val); ~lemurAdress2.sendMsg("/ParC/StrLed/value", view.value );
				});
			});
		});
	});


	~cenMulViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(296*~xSizeMul, 492*~ySizeMul, 70*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| /*~tracksView.valueAction_(tr);*/
		~cenMul[tr][~seqsValue] = ~cenMulSpec.map(view.value);
		view.string = "Cen : %".format(~cenMul[tr][~seqsValue]);
		~cenRangeView.string_("%\n to \n%".format(
			(if ((~cenMax[tr][~seqsValue] * ~cenMul[tr][~seqsValue]) > 100, { (~cenMax[tr][~seqsValue] * ~cenMul[tr][~seqsValue]).round(1) }, {(~cenMax[tr][~seqsValue] * ~cenMul[tr][~seqsValue]).round(~cenRound[tr][~seqsValue])})),
			(if ((~cenMin[tr][~seqsValue] * ~cenMul[tr][~seqsValue]) > 100, { (~cenMin[tr][~seqsValue] * ~cenMul[tr][~seqsValue]).round(1) }, {(~cenMin[tr][~seqsValue] * ~cenMul[tr][~seqsValue]).round(~cenRound[tr][~seqsValue])}))));
		~cenIndexView.string_("At : %".format((~cenSpec[tr][~seqsValue].map(~cenIndexView.value) * ~cenMul[tr][~seqsValue]).round(~cenRound[tr][~seqsValue]))); // léger pb de rounding ?
		~cenDisplay.string_(("~cenView.valueAction_(~cenSpec["+tr+"]["+~seqsValue+"].unmap(~cenMul["+tr+"]["+~seqsValue+"].reciprocal * "+(~cenSpec[tr][~seqsValue].map(~cen[tr][~seqsValue]) * ~cenMul[tr][~seqsValue]).round(~cenRound[tr][~seqsValue]).asCompileString+"));").asString); ~cenDisplay.setFont((Font("arial",1)), 4, 75);
	})
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~cenColor /*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~cenMulSpec.unmap(1));

	if (~twister.isNil, {
		~cenMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); val = ~cenMulSpec.map(view.value);
			case
			{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
			{
				~cenMul[tr][seq] = val; ~cen2Mul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
			}
			{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
			{
				var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
				sequenceSelected.do {|i| ~cenMul[tr][i] = val; ~cen2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer }
			}
			{ ~triggerAllSeqs[tr] == 2} // tous les presets
			{ ~presetSeqRandList[tr].do {|i| ~cenMul[tr][i] = val; ~cen2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer } };

			view.string = "Cen : %".format( val );

			if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
				~lemurAdress1.sendMsg("/ParC/CenM/value", val); ~lemurAdress1.sendMsg("/ParC/CenLed/value", view.value );
			});
			if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
				~lemurAdress2.sendMsg("/ParC/CenM/value", val); ~lemurAdress2.sendMsg("/ParC/CenLed/value", view.value );
			});
		});
	},{
		~cenMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~cenValues[tr].value = view.value;
			val = ~cenMulSpec.map(view.value);
			if (~cenMulSpec.unmap(~cenMul[tr][seq]) == ~cenValues[tr].value, {
				~cenMul[tr][seq] = val; view.string = "Cen : %".format( val );
			},{
				case
				{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
				{
					~cenMul[tr][seq] = val; ~cen2Mul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
				}
				{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
				{
					var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
					sequenceSelected.do {|i| ~cenMul[tr][i] = val; ~cen2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer }
				}
				{ ~triggerAllSeqs[tr] == 2} // tous les presets
				{ ~presetSeqRandList[tr].do {|i| ~cenMul[tr][i] = val; ~cen2Mul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer } };

				view.string = "Cen : %".format( val );

				if (~lemurConnected1 == 1 and: {tr == ~tracksValue}, {
					~lemurAdress1.sendMsg("/ParC/CenM/value", val); ~lemurAdress1.sendMsg("/ParC/CenLed/value", view.value );
				});
				if (~lemurConnected2 == 1 and: {tr == ~secondLemurX2Track}, {
					~lemurAdress2.sendMsg("/ParC/CenM/value", val); ~lemurAdress2.sendMsg("/ParC/CenLed/value", view.value );
				});
			});
		});
	});


	~bufMulViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(307*~xSizeMul, 444*~ySizeMul, 66*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| /*~tracksView.valueAction_(tr);*/
		~bufMul[tr][~seqsValue] = ~bufMulSpec.map(view.value);
		view.string = "Buf : %".format(~bufMul[tr][~seqsValue]);
		~bufIndexView.string_("At : %".format((~bufSpec[tr][~seqsValue].map(~bufIndexView.value) * ~bufMul[tr][~seqsValue]).asInteger)); // léger pb de rounding ?
		~bufDisplay.string_(("~bufView.valueAction_(~bufSpec["+tr+"]["+~seqsValue+"].unmap(~bufMul["+tr+"]["+~seqsValue+"].reciprocal * "+(~bufSpec[tr][~seqsValue].map(~buf[tr][~seqsValue]) * ~bufMul[tr][~seqsValue]).asInteger.asCompileString+"));").asString); ~bufDisplay.setFont((Font("arial",1)), 4, 75);
	})
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~bufColor /*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~bufMulSpec.unmap(1));

	if (~twister.isNil, {
		~bufMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); val = ~bufMulSpec.map(view.value);
			case
			{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
			{
				~bufMul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer; // .defer vraiment necessaire ??? apparemment pas pour les autres XXXXXXXXXXXXXXXX
			}
			{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
			{
				var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
				sequenceSelected.do {|i| ~bufMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; }
			}
			{ ~triggerAllSeqs[tr] == 2} // tous les presets
			{ ~presetSeqRandList[tr].do {|i| ~bufMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; } };

			{view.string = "Buf : %".format( val )}.defer;
		});
	},{
		~bufMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~bufValues[tr].value = view.value;
			val = ~bufMulSpec.map(view.value);
			if (/*view.value*/ ~bufMulSpec.unmap(~bufMul[tr][seq]) == ~bufValues[tr].value, { // view.value.postln; ~bufValues[tr].value.postln;
				~bufMul[tr][seq] = val; {view.string = "B : %".format( val )}.defer;
			},{
				/*view.value.postln; ~bufValues[tr].value.postln;*/
				case
				{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
				{
					~bufMul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
				}
				{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
				{
					var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
					sequenceSelected.do {|i| ~bufMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; }
				}
				{ ~triggerAllSeqs[tr] == 2} // tous les presets
				{ ~presetSeqRandList[tr].do {|i| ~bufMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; } };

				{view.string = "Buf : %".format( val )}.defer;
			});
		});
	});


	~offMulViewG[tr] = SmoothSlider(~seqCompG[tr], Rect(303*~xSizeMul, 468*~ySizeMul, 70*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| /*~tracksView.valueAction_(tr);*/
		~offMul[tr][~seqsValue] = ~offMulSpec.map(view.value);
		view.string = "Pos : %".format(~offMul[tr][~seqsValue]);
		~offIndexView.string_("At : %".format((~offSpec[tr][~seqsValue].map(~offIndexView.value) * ~offMul[tr][~seqsValue]).asInteger)); // léger pb de rounding ?
		~offDisplay.string_(("~offView.valueAction_(~offSpec["+tr+"]["+~seqsValue+"].unmap(~offMul["+tr+"]["+~seqsValue+"].reciprocal * "+(~offSpec[tr][~seqsValue].map(~off[tr][~seqsValue]) * ~offMul[tr][~seqsValue]).asInteger.asCompileString+"));").asString); ~offDisplay.setFont((Font("arial",1)), 4, 75);
	})
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~offColor /*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~offMulSpec.unmap(1));

	if (~twister.isNil, {
		~offMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] }); val = ~offMulSpec.map(view.value);
			case
			{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
			{
				~offMul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer; // .defer vraiment necessaire ??? apparemment pas pour les autres XXXXXXXXXXXXXXXX
			}
			{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
			{
				var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
				sequenceSelected.do {|i| ~offMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; }
			}
			{ ~triggerAllSeqs[tr] == 2} // tous les presets
			{ ~presetSeqRandList[tr].do {|i| ~offMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; } };

			{view.string = "Pos : %".format( val )}.defer;
		});
	},{
		~offMulViewG[tr].action_({ |view|
			var val, seq; if (tr == ~tracksValue and: {~curSeqTrig == 1}, { seq = ~seqsValue },{ seq = ~seqSeq[tr] });
			~offValues[tr].value = view.value;
			val = ~offMulSpec.map(view.value);
			if (/*view.value*/ ~offMulSpec.unmap(~offMul[tr][seq]) == ~offValues[tr].value, { // view.value.postln; ~offValues[tr].value.postln;  "0".postln;
				~offMul[tr][seq] = val; {view.string = "B : %".format( val )}.defer;
			},{
				/*view.value.postln; ~offValues[tr].value.postln;*/
				case
				{ ~triggerAllSeqs[tr] == 0} // Séquence de le piste en cours de sélection
				{
					~offMul[tr][seq] = val; {~presetSeqTextViewG[tr][seq].background_(Color.red)}.defer;
				}
				{ ~triggerAllSeqs[tr] == 1} // toutes les séquences sélectionnées
				{
					var sequenceSelected = (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| i };
					sequenceSelected.do {|i| ~offMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; }
				}
				{ ~triggerAllSeqs[tr] == 2} // tous les presets
				{ ~presetSeqRandList[tr].do {|i| ~offMul[tr][i] = val; {~presetSeqTextViewG[tr][i].background_(Color.red)}.defer; } };

				{view.string = "Pos : %".format( val )}.defer;
			});
		});

		// Pourquoi necessaire seulement pour certains, sinon certaines données du global non mis à jour
		// ~ratValues[~tracksValue].value_(~ratMulSpec.unmap(~ratMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~rtmValues[tr].value_(~rtmMulSpec[tr][~seqsValue].unmap(~rtmMul[tr][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~legValues[tr].value_(~legMulSpec.unmap(~legMul[tr][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~strValues[tr].value_(~strMulSpec.unmap(~strMul[tr][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~cenValues[tr].value_(~cenMulSpec.unmap(~cenMul[tr][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		~proValues[tr].value_(~proMulSpec.unmap(~proMul[tr][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		// ~bufFolValues[~tracksValue].value_(~bufFolderValue[~tracksValue][~seqsValue]);
		// ~bufValues[~tracksValue].value_(~bufMulSpec.unmap(~bufMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));
		// ~offValues[~tracksValue].value_(~offMulSpec.unmap(~offMul[~tracksValue][~seqsValue]/*[~seqSeq[~tracksValue]]*/));

	});

};





// OLD - utilisation du Quark Connection pour mettre à jour des données pour l'ancienne spatialisation Acousmonium
/*
// ~multiStereoControlValues = ~nbOfTracks.collect { NumericControlValue() };
// ~multiStereoControlValues[tr].value = i.value; // Dans la GUI
~multiStereoControlConnections = ConnectionList.make {
~multiStereoControlView.connectEach(\value, ~multiStereoControlView2, _.valueSlot);
~multiStereoControlView2.connectEach(\value, ~multiStereoControlView, _.valueSlot);
// ~multiStereoControlView.connectAll({ |slider, i| slider.postln; i.postln });
};*/
// ~multiStereoControlConnections.free; // Pour les connections créées avec le quark Connection
// ~view.onClose = {~multiStereoControlConnections.free }; // Connection retirées lors de la fermeture du Control Panel






/*~seqChangeViewG = 0 ! ~nbOfTracksX2; // Pour Modification de la séquence dès que le RangeSlider change - nécessaire de le déclarer au préalable
~seqChange =  0 ! ~nbOfTracksX2;*/

~nbOfTracksX2.do { |a|
	~seqChangeViewG[a] = RoundButton(~seqCompG[a], Rect(368*~xSizeMul, 517*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["NCh", Color.red, Color.white], ["Cha", Color.black, Color.green]])
	.font_(Font("Verdana",9*~fontSizeMul, bold: true))
	.action_({ |i| ~seqChange[a] = i.value;
		/*if (a.even,
		{ ~seqChangeViewG[a+1].value_(i.value) },
		{ ~seqChangeViewG[a-1].value_(i.value) }
		);*/
	});
};


/*
// trop peu utile pour être affiché
~scrollFollowViewG = 0 ! ~nbOfTracksX2;
~tracksEven = ~tracks.reject({ arg item, i; item.odd });
~tracksOdd = ~tracks.reject({ arg item, i; item.even });
~tracks.do { |tr|
~scrollFollowViewG[tr] = RoundButton(~seqCompG[tr], Rect(336, 467, 30, 20))
.states_([["Fol", Color.black, ~popUpMenuBackgroundColor /*Color.magenta*/]])
.font_(Font("Verdana",9, bold: true));
};
~tracksEven.do { |tr|
~scrollFollowViewG[tr].action_({ // ~tracksOdd.postln;
~tracksEven.do { |tra| ~seqCompG1[tra].visibleOrigin = ~seqCompG1[tr].visibleOrigin } });
};
~tracksOdd.do { |tr|
~scrollFollowViewG[tr].action_({ // ~tracksEven.postln;
~tracksOdd.do { |tra| ~seqCompG1[tra].visibleOrigin = ~seqCompG1[tr].visibleOrigin } });
};
*/










// Obligé de changer les actions des GUI doubles de la séquence - indiqué ci-dessous - quand Global est déclaré

~presetSeqRangeView.valueAction_([1,  ~presetSeqRangeSpec.unmap(1)]);

~pFadeView.valueAction_(~pFadeSpec.unmap(~trackXFadeDefault));
~quantView.valueAction_(~quantSpec.unmap(4));

~proPatView.action_({ |i| ~proPat[~tracksValue][~seqsValue] = i.value;
	~proBlock[~tracksValue] = 1;
	if (~proPat[~tracksValue][~seqsValue] == 1, {~proPatSelView.background_(Color.red(0.7)).stringColor_(Color.white)}, {~proPatSelView.background_(~popUpMenuBackgroundColor).stringColor_(~popUpMenuStringColor)} );
	if (~patFlag == 1, {~seqs.do {|sequence| ~proPat[~tracksValue][sequence] = i.value } });
	// Action sur le global
	~proPatViewG[~tracksValue].value_(~proPat[~tracksValue][~seqsValue]);

	if (~lemurConnected1 == 1, {
		if (~proPat[~tracksValue][~seqsValue] == 0, {
			~lemurAdress1.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) );
		},{
			~lemurAdress1.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
		});
	});
	if (~lemurConnected2 == 1 and: {~tracksValue == ~secondLemurX2Track}, {
		if (~proPat[~tracksValue][~seqsValue] == 0, {
			~lemurAdress2.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) );
		},{
			~lemurAdress2.sendMsg( *[ ["/ParC/Cyc"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
		});
	});
});

~proBjorView.action_({ |view| ~proBjor[~tracksValue][~seqsValue] = ~proBjorSpec[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue].map(view.value).asInteger;
	// 2 mises à jour successives : [~seqSeq[~tracksValue]] donne une première bonne valeur, alors [~seqsValue] donne une première mauvaise valeur qui est bien updaté par la suite -> arrêté car ne donne pas de bonnes valeurs avec Arm
	~proBjorGridsX[~tracksValue][~seqsValue] = view.value.round(0.001);

	if (~proPatSel[~tracksValue][~seqsValue] > 18 /*and: {~proPat[~tracksValue][~seqsValue] == 1}*/, {
		view.string = "GX : %".format(~proBjorGridsX[~tracksValue][~seqsValue]); ~drawSCGrids.();
	}, {
		view.string = "Hit : %".format(~proBjor[~tracksValue][~seqsValue]);
	});
	// Action sur le global
	// ~proBjorViewG[~tracksValue].step_(1/~pro[~tracksValue][~seqsValue].size).value_(~proBjorSpec[~tracksValue][~seqSeq[~tracksValue]]/*[~seqsValue]*/.unmap(~proBjor[~tracksValue][~seqsValue])).string = "Hit : %".format(~proBjor[~tracksValue][~seqsValue]);
	// ~proBjorViewG[~tracksValue].step_(0.001).value_(~proBjorGridsX[~tracksValue][~seqsValue]).string = "GX : %".format(~proBjorGridsX[~tracksValue][~seqsValue]);
	~proBjorViewG[~tracksValue].value_(~proBjorGridsX[~tracksValue][~seqsValue]).string = "H: %-%".format(~proBjor[~tracksValue][~seqsValue], ~proBjorGridsX[~tracksValue][~seqsValue]);

	if (~lemurConnected1 == 1, {
		~lemurAdress1.sendMsg("/ParC/HitM/value", ~proBjor[~tracksValue][~seqsValue]);
		~lemurAdress1.sendMsg("/ParC/HitLed/value", view.value );
	});
	if (~lemurConnected2 == 1 and: {~tracksValue == ~secondLemurX2Track}, {
		~lemurAdress2.sendMsg("/ParC/HitM/value", ~proBjor[~tracksValue][~seqsValue]);
		~lemurAdress2.sendMsg("/ParC/HitLed/value", view.value );
	});
});

~proBjor2View.action_({ |view| ~proBjor2[~tracksValue][~seqsValue] = ~proBjorSpec[~tracksValue]/*[~seqSeq[~tracksValue]]*/[~seqsValue].map(view.value).asInteger;
	// 2 mises à jour successives : [~seqSeq[~tracksValue]] donne une première bonne valeur, alors [~seqsValue] donne une première mauvaise valeur qui est bien updaté par la suite -> arrêté car ne donne pas de bonnes valeurs avec Arm
	~proBjorGridsY[~tracksValue][~seqsValue] = view.value.round(0.001);

	if (~proPatSel[~tracksValue][~seqsValue] > 18 /*and: {~proPat[~tracksValue][~seqsValue] == 1}*/, {
		view.string = "GY : %".format(~proBjorGridsY[~tracksValue][~seqsValue]); ~drawSCGrids.();
	}, {
		view.string = "Off : %".format(~proBjor2[~tracksValue][~seqsValue]);
	});
	// Action sur le global
	// ~proBjor2ViewG[~tracksValue].step_(1/~pro[~tracksValue][~seqsValue].size).value_(~proBjorSpec[~tracksValue][~seqSeq[~tracksValue]]/*[~seqsValue]*/.unmap(~proBjor2[~tracksValue][~seqsValue])).string = "Off : %".format(~proBjor2[~tracksValue][~seqsValue]);
	// ~proBjor2ViewG[~tracksValue].step_(0.001).value_(~proBjorGridsY[~tracksValue][~seqsValue]).string = "GY : %".format(~proBjorGridsY[~tracksValue][~seqsValue]);
	~proBjor2ViewG[~tracksValue].value_(~proBjorGridsY[~tracksValue][~seqsValue]).string = "O: %-%".format(~proBjor2[~tracksValue][~seqsValue], ~proBjorGridsY[~tracksValue][~seqsValue]);

	if (~lemurConnected1 == 1, {
		~lemurAdress1.sendMsg("/ParC/OffM/value", ~proBjor2[~tracksValue][~seqsValue]);
		~lemurAdress1.sendMsg("/ParC/OffLed/value", view.value );
	});
	if (~lemurConnected2 == 1 and: {~tracksValue == ~secondLemurX2Track}, {
		~lemurAdress2.sendMsg("/ParC/OffM/value", ~proBjor2[~tracksValue][~seqsValue]);
		~lemurAdress2.sendMsg("/ParC/OffLed/value", view.value );
	});
});

~proSelectView.action_({|i| ~proSelect[~tracksValue][~seqsValue] = i.value;
	[\rtmBlock, \proBlock, \synBlock, \spaBlock, \legBlock, \envBlock, \bufBlock, \ampBlock, \ratBlock, \rat2Block, \offBlock, \strBlock, \str2Block, \cenBlock, \cen2Block, \panBlock, \delBlock, \outLBlock, \outRBlock, \fxLBlock, \fxRBlock].do {|i| currentEnvironment[i][~tracksValue] = 1};
	// Action sur le global
	~proSelectViewG[~tracksValue].value_(~proSelect[~tracksValue][~seqsValue]);

	if (~lemurConnected1 == 1, {
		if (~proSelect[~tracksValue][~seqsValue] == 0, {
			~lemurAdress1.sendMsg( *[ ["/ParC/Cyc2"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) );
			~lemurAdress1.sendMsg( *["/ParC/CycT2", "@content", "Pro S" ]);
		},{
			~lemurAdress1.sendMsg( *[ ["/ParC/Cyc2"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
			~lemurAdress1.sendMsg( *["/ParC/CycT2", "@content", "Pro 1" ]);
		});
	});
	if (~lemurConnected2 == 1 and: {~tracksValue == ~secondLemurX2Track}, {
		if (~proSelect[~tracksValue][~seqsValue] == 0, {
			~lemurAdress2.sendMsg( *[ ["/ParC/Cyc2"] ++ ["@color"] ++ [~blueLemurColor1, ~blueLemurColor1]  ].flatten(1) );
			~lemurAdress2.sendMsg( *["/ParC/CycT2", "@content", "Pro S" ]);
		},{
			~lemurAdress2.sendMsg( *[ ["/ParC/Cyc2"] ++ ["@color"] ++ [~redLemurColor, ~redLemurColor]  ].flatten(1) );
			~lemurAdress2.sendMsg( *["/ParC/CycT2", "@content", "Pro 1" ]);
		});
	});
});

~rtmMulView.action_({ |view| ~rtmMul[~tracksValue][~seqsValue] = ~rtmMulSpec[~tracksValue][~seqsValue].map(view.value);
	view.string = "%".format(~rtmMul[~tracksValue][~seqsValue]);
	if (~rtmRound[~tracksValue][~seqsValue] < 0.001,
		{~rtmRangeView.string_("%\n to \n%".format((~rtmMax[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(0.001), (~rtmMin[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(0.001))); ~rtmIndexView.string = "At : %".format((~rtmIndex[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(0.001)); }, {~rtmRangeView.string_("%\n to \n%".format((~rtmMax[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(~rtmRound[~tracksValue][~seqsValue]), (~rtmMin[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(~rtmRound[~tracksValue][~seqsValue]))); ~rtmIndexView.string = "At : %".format((~rtmIndex[~tracksValue][~seqsValue] * ~rtmMul[~tracksValue][~seqsValue]).round(~rtmRound[~tracksValue][~seqsValue])) }); // léger pb de rounding ?
	~rtmDisplay.string_("~rtmView.valueAction_(~rtmSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~rtmMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~rtmSpec[~tracksValue][~seqsValue].map(~dur[~tracksValue][~seqsValue]) * ~rtmMul[~tracksValue][~seqsValue]).round(~rtmRound[~tracksValue][~seqsValue]).asCompileString+"));").asString; ~rtmDisplay.setFont((Font("arial",1)), 4, 75);
	~nbTotalBeatsView.doAction;
	// Action sur le global
	~rtmMulViewG[~tracksValue].value_(view.value).string = "Rtm : %".format(~rtmMul[~tracksValue][~seqsValue].round(0.001) );

	if (~lemurConnected1 == 1, {
		~lemurAdress1.sendMsg("/ParC/RtmM/value", ~rtmMul[~tracksValue][~seqsValue]);
		~lemurAdress1.sendMsg("/ParC/RtmLed/value", view.value);
	});
	if (~lemurConnected2 == 1 and: {~tracksValue == ~secondLemurX2Track}, {
		~lemurAdress2.sendMsg("/ParC/RtmM/value", ~rtmMul[~tracksValue][~seqsValue]);
		~lemurAdress2.sendMsg("/ParC/RtmLed/value", view.value);
	});
}).doAction;

~gridsDens = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;

// Intégration du multiplicateur dans le .map
~proMulView.action_({ |view| ~proMul[~tracksValue][~seqsValue] = ~proMulSpec.map(view.value); ~gridsDens[~tracksValue][~seqsValue] = view.value;
	view.string = "%".format(~proMul[~tracksValue][~seqsValue]);
	// ~proRangeView.string_("%\n to \n%".format((~proMax[~tracksValue][~seqsValue]).round(~proRound[~tracksValue][~seqsValue]), (~proMin[~tracksValue][~seqsValue]).round(~proRound[~tracksValue][~seqsValue])));
	~proIndexView.string_("At : %".format((~proSpec[~tracksValue][~seqsValue].map(~proIndexView.value * ~proMul[~tracksValue][~seqsValue])).round(~proRound[~tracksValue][~seqsValue]))); // léger pb de rounding ?
	~proDisplay.string_(("~proView.valueAction_(~proSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~proMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~proSpec[~tracksValue][~seqsValue].map(~pro[~tracksValue][~seqsValue] * ~proMul[~tracksValue][~seqsValue])).round(~proRound[~tracksValue][~seqsValue]).asCompileString+"));").asString); ~proDisplay.setFont((Font("arial",1)), 4, 75);
	// Action sur le global
	~proMulViewG[~tracksValue].value_(view.value).string = "Pro : %".format(~proMul[~tracksValue][~seqsValue]/*plus necessaire .round(0.01)*/ );

	if (~lemurConnected1 == 1, {
		~lemurAdress1.sendMsg("/ParC/ProM/value", ~proMul[~tracksValue][~seqsValue]);
		~lemurAdress1.sendMsg("/ParC/ProLed/value", view.value);
	});
	if (~lemurConnected2 == 1 and: {~tracksValue == ~secondLemurX2Track}, {
		~lemurAdress2.sendMsg("/ParC/ProM/value", ~proMul[~tracksValue][~seqsValue]);
		~lemurAdress2.sendMsg("/ParC/ProLed/value", view.value);
	});
}).doAction;

~ratMulView.action_({ |view| ~ratMul[~tracksValue][~seqsValue] = ~ratMulSpec.map(view.value);
	view.string = "%".format(~ratMul[~tracksValue][~seqsValue]);
	~ratRangeView.string_("%\n to \n%".format(
		(if ((~ratMax[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]) > 100, { (~ratMax[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(1) }, {(~ratMax[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue])})),
		(if ((~ratMin[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]) > 100, { (~ratMin[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(1) }, {(~ratMin[~tracksValue][~seqsValue] * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue])}))));
	{
		~ratIndexView.string_("At : %".format((~ratSpec[~tracksValue][~seqsValue].map(~ratIndexView.value) * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue]))); // léger pb de rounding ?
		~ratDisplay.string_(("~ratView.valueAction_(~ratSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~ratMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~ratSpec[~tracksValue][~seqsValue].map(~rat[~tracksValue][~seqsValue]) * ~ratMul[~tracksValue][~seqsValue]).round(~ratRound[~tracksValue][~seqsValue]).asCompileString+"));").asString); ~ratDisplay.setFont((Font("arial",1)), 4, 75);
		// Action sur le global
		~ratMulViewG[~tracksValue].value_(view.value).string = "Rat : %".format(~ratMul[~tracksValue][~seqsValue].round(0.01) );
	}.defer; // .defer Pour la mise à jour du Twister

	if (~lemurConnected1 == 1, {
		~lemurAdress1.sendMsg("/ParC/RatM/value", ~ratMul[~tracksValue][~seqsValue]);
		~lemurAdress1.sendMsg("/ParC/RatLed/value", view.value);
		if (~rhythmTracksX2.includes(~tracksValue), {
			~lemurAdress1.sendMsg(~lemurRatGTextValues[~tracksValue], ~ratMul[~tracksValue][~seqsValue]); ~lemurAdress1.sendMsg(~lemurRatGLedValues[~tracksValue], view.value );
		});
	});
	if (~lemurConnected2 == 1 and: {~tracksValue == ~secondLemurX2Track}, {
		~lemurAdress2.sendMsg("/ParC/RatM/value", ~ratMul[~tracksValue][~seqsValue]);
		~lemurAdress2.sendMsg("/ParC/RatLed/value", view.value);
		if (~rhythmTracksX2.includes(~tracksValue), {
			~lemurAdress2.sendMsg(~lemurRatGTextValues[~tracksValue], ~ratMul[~tracksValue][~seqsValue]); ~lemurAdress2.sendMsg(~lemurRatGLedValues[~tracksValue], view.value );
		});
	});
}).doAction;

~legMulView.action_({ |view| ~legMul[~tracksValue][~seqsValue] = ~legMulSpec.map(view.value);
	view.string = "%".format(~legMul[~tracksValue][~seqsValue]);
	~legRangeView.string_("%\n to \n%".format(
		(if ((~legMax[~tracksValue][~seqsValue] * ~legMul[~tracksValue][~seqsValue]) > 100, { (~legMax[~tracksValue][~seqsValue] * ~legMul[~tracksValue][~seqsValue]).round(1) }, {(~legMax[~tracksValue][~seqsValue] * ~legMul[~tracksValue][~seqsValue]).round(~legRound[~tracksValue][~seqsValue])})),
		(if ((~legMin[~tracksValue][~seqsValue] * ~legMul[~tracksValue][~seqsValue]) > 100, { (~legMin[~tracksValue][~seqsValue] * ~legMul[~tracksValue][~seqsValue]).round(1) }, {(~legMin[~tracksValue][~seqsValue] * ~legMul[~tracksValue][~seqsValue]).round(~legRound[~tracksValue][~seqsValue])}))));
	~legIndexView.string_("At : %".format((~legSpec[~tracksValue][~seqsValue].map(~legIndexView.value) * ~legMul[~tracksValue][~seqsValue]).round(~legRound[~tracksValue][~seqsValue]))); // léger pb de rounding ?
	~legDisplay.string_(("~legView.valueAction_(~legSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~legMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~legSpec[~tracksValue][~seqsValue].map(~leg[~tracksValue][~seqsValue]) * ~legMul[~tracksValue][~seqsValue]).round(~legRound[~tracksValue][~seqsValue]).asCompileString+"));").asString); ~legDisplay.setFont((Font("arial",1)), 4, 75);
	// Action sur le global
	~legMulViewG[~tracksValue].value_(view.value).string = "Dur : %".format(~legMul[~tracksValue][~seqsValue].round(0.01) );

	if (~lemurConnected1 == 1, {
		~lemurAdress1.sendMsg("/ParC/LegM/value", ~legMul[~tracksValue][~seqsValue]);
		~lemurAdress1.sendMsg("/ParC/LegLed/value", view.value);
	});
	if (~lemurConnected2 == 1 and: {~tracksValue == ~secondLemurX2Track}, {
		~lemurAdress2.sendMsg("/ParC/LegM/value", ~legMul[~tracksValue][~seqsValue]);
		~lemurAdress2.sendMsg("/ParC/LegLed/value", view.value);
	});
}).doAction;

~strMulView.action_({ |view| ~strMul[~tracksValue][~seqsValue] = ~strMulSpec.map(view.value);
	view.string = "%".format(~strMul[~tracksValue][~seqsValue]);
	~strRangeView.string_("%\n to \n%".format(
		(if ((~strMax[~tracksValue][~seqsValue] * ~strMul[~tracksValue][~seqsValue]) > 100, { (~strMax[~tracksValue][~seqsValue] * ~strMul[~tracksValue][~seqsValue]).round(1) }, {(~strMax[~tracksValue][~seqsValue] * ~strMul[~tracksValue][~seqsValue]).round(~strRound[~tracksValue][~seqsValue])})),
		(if ((~strMin[~tracksValue][~seqsValue] * ~strMul[~tracksValue][~seqsValue]) > 100, { (~strMin[~tracksValue][~seqsValue] * ~strMul[~tracksValue][~seqsValue]).round(1) }, {(~strMin[~tracksValue][~seqsValue] * ~strMul[~tracksValue][~seqsValue]).round(~strRound[~tracksValue][~seqsValue])}))));
	~strIndexView.string_("At : %".format((~strSpec[~tracksValue][~seqsValue].map(~strIndexView.value) * ~strMul[~tracksValue][~seqsValue]).round(~strRound[~tracksValue][~seqsValue]))); // léger pb de rounding ?
	~strDisplay.string_(("~strView.valueAction_(~strSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~strMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~strSpec[~tracksValue][~seqsValue].map(~str[~tracksValue][~seqsValue]) * ~strMul[~tracksValue][~seqsValue]).round(~strRound[~tracksValue][~seqsValue]).asCompileString+"));").asString); ~strDisplay.setFont((Font("arial",1)), 4, 75);
	// Action sur le global
	~strMulViewG[~tracksValue].value_(view.value).string = "Str : %".format(~strMul[~tracksValue][~seqsValue].round(0.01) );

	if (~lemurConnected1 == 1, {
		~lemurAdress1.sendMsg("/ParC/StrM/value", ~strMul[~tracksValue][~seqsValue]);
		~lemurAdress1.sendMsg("/ParC/StrLed/value", view.value);
	});
	if (~lemurConnected2 == 1 and: {~tracksValue == ~secondLemurX2Track}, {
		~lemurAdress2.sendMsg("/ParC/StrM/value", ~strMul[~tracksValue][~seqsValue]);
		~lemurAdress2.sendMsg("/ParC/StrLed/value", view.value);
	});
}).doAction;

~cenMulView.action_({ |view| ~cenMul[~tracksValue][~seqsValue] = ~cenMulSpec.map(view.value);
	view.string = "%".format(~cenMul[~tracksValue][~seqsValue]);
	~cenRangeView.string_("%\n to \n%".format(
		(if ((~cenMax[~tracksValue][~seqsValue] * ~cenMul[~tracksValue][~seqsValue]) > 100, { (~cenMax[~tracksValue][~seqsValue] * ~cenMul[~tracksValue][~seqsValue]).round(1) }, {(~cenMax[~tracksValue][~seqsValue] * ~cenMul[~tracksValue][~seqsValue]).round(~cenRound[~tracksValue][~seqsValue])})),
		(if ((~cenMin[~tracksValue][~seqsValue] * ~cenMul[~tracksValue][~seqsValue]) > 100, { (~cenMin[~tracksValue][~seqsValue] * ~cenMul[~tracksValue][~seqsValue]).round(1) }, {(~cenMin[~tracksValue][~seqsValue] * ~cenMul[~tracksValue][~seqsValue]).round(~cenRound[~tracksValue][~seqsValue])}))));
	~cenIndexView.string_("At : %".format((~cenSpec[~tracksValue][~seqsValue].map(~cenIndexView.value) * ~cenMul[~tracksValue][~seqsValue]).round(~cenRound[~tracksValue][~seqsValue]))); // léger pb de rounding ?
	~cenDisplay.string_(("~cenView.valueAction_(~cenSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~cenMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~cenSpec[~tracksValue][~seqsValue].map(~cen[~tracksValue][~seqsValue]) * ~cenMul[~tracksValue][~seqsValue]).round(~cenRound[~tracksValue][~seqsValue]).asCompileString+"));").asString); ~cenDisplay.setFont((Font("arial",1)), 4, 75);
	// Action sur le global
	~cenMulViewG[~tracksValue].value_(view.value).string = "Cen : %".format(~cenMul[~tracksValue][~seqsValue].round(0.01) );

	if (~lemurConnected1 == 1, {
		~lemurAdress1.sendMsg("/ParC/CenM/value", ~cenMul[~tracksValue][~seqsValue]);
		~lemurAdress1.sendMsg("/ParC/CenLed/value", view.value);
	});
	if (~lemurConnected2 == 1 and: {~tracksValue == ~secondLemurX2Track}, {
		~lemurAdress2.sendMsg("/ParC/CenM/value", ~cenMul[~tracksValue][~seqsValue]);
		~lemurAdress2.sendMsg("/ParC/CenLed/value", view.value);
	});
}).doAction;


~spaRangePresetView.action_({ |menu|
	var min, max;
	~spaRangePreset[~tracksValue][~seqsValue] = menu.value;
	/*min = menu.item.replace("->", " ").split($ )[1].asFloat;
	max = menu.item.replace("->", " ").split($ )[2].asFloat;
	~spaRangeView.valueAction_(~spaRangeSpec[~tracksValue][~seqsValue].unmap([min, max]));*/
	~spaRangePresetViewFunc[menu.value].value(~tracksValue, ~seqsValue);
	// Action sur le global
	~spaRangePresetViewG[~tracksValue].value_(menu.value);
}).doAction;

~panRangePresetView.action_({ |menu|
	~panRangePreset[~tracksValue][~seqsValue] = menu.value;
	~panRangePresetViewFunc[menu.value].value(~tracksValue, ~seqsValue);
	// Action sur le global
	~panRangePresetViewG[~tracksValue].value_(menu.value);
}).doAction;

~spaPatSelView.action_({|menu|
	~spaPatSel[~tracksValue][~seqsValue] = menu.value;
	~spaBlock[~tracksValue] = 1;
	if (~patFlag == 1, {~seqs.do {|sequence| ~spaPatSel[~tracksValue][sequence] = menu.value }});
	// Action sur le global
	~spaPatSelViewG[~tracksValue].value_(menu.value);
});

~spaPatView.action_({|i|
	~spaPat[~tracksValue][~seqsValue] = i.value;
	~spaBlock[~tracksValue] = 1;
	if (~spaPat[~tracksValue][~seqsValue] == 1, {~spaPatSelView.background_(Color.red(0.7)).stringColor_(Color.white)}, {~spaPatSelView.background_(~popUpMenuBackgroundColor).stringColor_(~popUpMenuStringColor)} );
	if (~patFlag == 1, {~seqs.do {|sequence| ~spaPat[~tracksValue][sequence] = i.value } });
	// Action sur le global
	~spaPatViewG[~tracksValue].value_(i.value);
	if (~spaPat[~tracksValue][~seqsValue] == 1, {
		~spaPatSelViewG[~tracksValue].background_(Color.red(0.7)).stringColor_(Color.white); // repris de envir[patView].states
	},{
		~spaPatSelViewG[~tracksValue].background_(~popUpMenuBackgroundColor).stringColor_(~popUpMenuStringColor);
	});
});


~bufMulView.action_({ |view| ~bufMul[~tracksValue][~seqsValue] = ~bufMulSpec.map(view.value);
	view.string = "%".format(~bufMul[~tracksValue][~seqsValue]);
	~bufIndexView.string_("At : %".format((~bufSpec[~tracksValue][~seqsValue].map(~bufIndexView.value) * ~bufMul[~tracksValue][~seqsValue]).asInteger)); // léger pb de rounding ?
	~bufDisplay.string_(("~bufView.valueAction_(~bufSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~bufMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~bufSpec[~tracksValue][~seqsValue].map(~buf[~tracksValue][~seqsValue]) * ~bufMul[~tracksValue][~seqsValue]).asInteger.asCompileString+"));").asString); ~bufDisplay.setFont((Font("arial",1)), 4, 75);
	// Action sur le global
	~bufMulViewG[~tracksValue].value_(view.value).string = "Buf : %".format(~bufMul[~tracksValue][~seqsValue].round(0.01) );
	// "x".postln; ~bufMul[~tracksValue][~seqsValue].postln; // Pourquoi appelé 2 fois quand changement de piste ???
}).doAction;


~offMulView.action_({ |view| ~offMul[~tracksValue][~seqsValue] = ~offMulSpec.map(view.value);
	view.string = "%".format(~offMul[~tracksValue][~seqsValue]);
	~offIndexView.string_("At : %".format((~offSpec[~tracksValue][~seqsValue].map(~offIndexView.value) * ~offMul[~tracksValue][~seqsValue]).round(~offRound[~tracksValue][~seqsValue]))); // léger pb de rounding ?
	~offDisplay.string_(("~offView.valueAction_(~offSpec["+~tracksValue+"]["+~seqsValue+"].unmap(~offMul["+~tracksValue+"]["+~seqsValue+"].reciprocal * "+(~offSpec[~tracksValue][~seqsValue].map(~off[~tracksValue][~seqsValue]) * ~offMul[~tracksValue][~seqsValue]).round(~offRound[~tracksValue][~seqsValue]).asCompileString+"));").asString); ~offDisplay.setFont((Font("arial",1)), 4, 75);
	// Action sur le global
	~offMulViewG[~tracksValue].value_(view.value).string = "Pos : %".format(~offMul[~tracksValue][~seqsValue].round(0.01) );
}).doAction;



~bufFolderView.action_({ |a| var serv, seq;

	if (~server2.isNil or: {(~tracksValue/2).asInteger < ~serverTrackSwitch}, {serv = 0}, {serv = 1});
	if (~curSeqTrig == 1, { seq = ~seqsValue },{ seq = ~seqSeq[~tracksValue] });

	~bufFolderValue[~tracksValue][seq] = a.value;
	~bufFolderFunc.value(~tracksValue, seq, ~bufFolderValue[~tracksValue][seq], /*0*/ serv);
	// ~bufRangeSpec[~tracksValue][~seqsValue] = ControlSpec(0, ~bufFolderM[~tracksValue][~seqsValue].size-1, \lin, 1); // intégré dans ~bufFolderFunc ci-dessus

	// ~bufMax[~tracksValue][~seqsValue] = ~bufFolderM[~tracksValue][~seqsValue].size -1; // Pour retitrer la protection dans le pattern à \prepbuf -> ???
	// ~bufMax[~tracksValue][~seqsValue] = ~bufMax[~tracksValue][~seqsValue].min(~bufFolderM[~tracksValue][~seqsValue].size -1); // Pour retitrer la protection dans le pattern à \prepbuf -> ???
	// \prepbuf,	(Pfunc({ |ev| var seq = ~seqSeq[track]; (~bufSpec[track][seq].map(ev.prepbufU) * ~bufMul[track][seq]).min(~bufFolderM[track][seq].size-1) }))/*.trace(prefix: "buf Nb -> ")*/,

	~bufSpec[~tracksValue][seq] = ControlSpec(~bufMin[~tracksValue][seq], ~bufMax[~tracksValue][seq], \lin, 1);
	/* ~bufRangeView.controlSpec_(ControlSpec(0, ~bufFolder[~tracksValue][~seqsValue].size-1, \lin, 1)); */
	~bufRangeView.step_(1/(~bufFolderM[serv][~tracksValue][seq].size - 1));
	~bufRangeView.minRange_(1/(~bufFolderM[serv][~tracksValue][seq].size) * 1);
	~bufRangeView.string = "%\n to \n%".format((~bufMax[~tracksValue][seq] * ~bufMul[~tracksValue][seq]).round(1), (~bufMin[~tracksValue][seq] * ~bufMul[~tracksValue][seq]).round(1));
	// ~bufRangeView.valueAction_([0, ~bufRangeSpec[~tracksValue][~seqsValue].unmap(~bufFolderM[~tracksValue][~seqsValue].size-1)]).doAction; /*~buffer.value(~tracksValue, ~seqsValue);*/
	~bufRangeView/*.valueAction_(~bufRangeSpec[~tracksValue][~seqsValue].unmap([~bufMin[~tracksValue][~seqsValue], ~bufMax[~tracksValue][~seqsValue]]))*/.doAction;
	// ~bufRangeView.valueAction_(~bufRangeSpec[~tracksValue][~seqsValue].unmap([~bufMin[~tracksValue][~seqsValue], ~bufMax[~tracksValue][~seqsValue]])).doAction;
	// Le .doAction précédent pour mettre à jour les données quand on change le ~bufFolderViewView si le ~bufRangeView reste identique
	// voire si le .doAction ne fait pas redondance avec les actions de ~bufRangeView ????????? - XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	// Pourquoi besoin de relancer le string alors que le valueAction devrait suffire ???

	// ~bufRangeView.string = "%\n to \n%".format((~bufMax[~tracksValue][~seqsValue] * ~bufMul[~tracksValue][~seqsValue]).round(1), (~bufMin[~tracksValue][~seqsValue] * ~bufMul[~tracksValue][~seqsValue]).round(1));
	~bufView.valueThumbSize_(max(10, if ((~bufMax[~tracksValue][seq] - ~bufMin[~tracksValue][seq]+1) > ~multiSliderHeight5,
		{10}, {~multiSliderHeight5 / (~bufMax[~tracksValue][seq] - ~bufMin[~tracksValue][seq]+1) })));
	~bufView.step_(1/(((~bufMax[~tracksValue][seq])-(~bufMin[~tracksValue][seq]))));
	~bufIndexView.step_(1/(~bufMax[~tracksValue][seq] - ~bufMin[~tracksValue][seq]));
	~bufIndexView.string_("At : %".format((~bufSpec[~tracksValue][seq].map(~bufIndexView.value) * ~bufMul[~tracksValue][seq]).round(1))); // léger pb de rounding ?

	if (~lemurConnected1 == 1, {
		// ~lemurAdress1.sendMsg("/ParC/BufM/value", ~bufFolderValue[~tracksValue][~seqsValue]);
		~lemurAdress1.sendMsg( *["/ParC/BufM", "@content", ~bufFolderView.items[~bufFolderValue[~tracksValue][seq]] ]);
		~lemurAdress1.sendMsg( *["/ParC/BufMenuL", "@content", ~bufFolderView.items[~bufFolderValue[~tracksValue][seq]] ]);
		~lemurAdress1.sendMsg("/ParC/BufLed/value", ~bufFolderValue[~tracksValue][seq] /*a.value*/ * ~bufFolderSize1.reciprocal); // à Optimiser ???
	});

	// Action sur le global
	~bufFolderViewG[~tracksValue].value_(~bufFolderValue[~tracksValue][seq]);
});

/*if (~foldersStructure == 1, {
~bufFolderView.items_(~arrayOfFolderNames2 /*++'Insultes'++'InsultesOMax'*/ /*++ 'Kik & Hit'*/ ++ ~kindOfFolders ++ ["ALL"]);
~arrayOfFolderNamesALL = ~arrayOfFolderNames ++ ~kindOfFolders ++ ["ALL"];
}, {
~bufFolderView.items_(~arrayOfFolderNames2 /*++'Insultes'++'InsultesOMax'*/ /*++ 'Kik & Hit'*/ ++ ["ALL"]);
~arrayOfFolderNamesALL = ~arrayOfFolderNames ++ ["ALL"];
});*/

// ~bufFolderView.valueAction_(~bufFolderValue[0][0]);






























// TOP GLOBAL Visual feedback & Parametres

{

	// Default

	~seqABVisibleAllViewG = RoundButton(~controlWindowDefault, Rect(4*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["Bll", Color.magenta, Color.white], ["All", Color.white, Color.magenta]])
	.font_(Font("Verdana",10*~fontSizeMul /*, bold: true*/))
	.action_({ |i|
		{
			if (i.value == 0, {
				/*~tracks*//*[2,4,6,8,10,12,14,0]*/[3,5,7,9,11,13,15,1].do { |tr| /*~seqABVisibleViewG[tr].value_(0/*i.value*/)*/~tracksView.value_(tr).doAction;};
				// ~tracks.do { |tr| ~seqABVisibleViewG[tr].value_(0).doAction };
			},{
				/*[3,5,7,9,11,13,15,1]*/[2,4,6,8,10,12,14,0].do { |tr| /*~seqABVisibleViewG[tr].value_(1/*i.value*/)*/~tracksView.value_(tr).doAction;};
			});
			if (~twister.notNil, {

				~twister.knobs[8..15].do { |i, id|
					if (id > 2, {i.ledColor_(Color.magenta)}, {i.ledColor_(Color.green)});
				};
				~twister.knobs[8+(~tracksValue/2).asInteger].ledColor_(Color.red);
			});
		}.fork(AppClock);
	}).valueAction_(1);

	~seqPlayingVisibleAllViewG = RoundButton(~controlWindowDefault, Rect(34*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
	.states_([["SPl", Color.white, Color.magenta], ["0Pl", Color.magenta, Color.white]])
	.font_(Font("Verdana", 10*~fontSizeMul /*, bold: true*/))
	.action_({ |i|
		if (i.value == 0, {
			~tracks.do { |tr| if ( ~playViewValue[tr] == 0, { ~seqABVisibleViewG[tr] /*~tracksView*/.value_(tr.wrap(0, 1)).doAction } ) };
		},{
			~tracks.do { |tr| if ( ~playViewValue[tr] == 1, { ~seqABVisibleViewG[tr] /*~tracksView*/.value_(tr.wrap(0, 1)).doAction } ) };
		});
		if (~twister.notNil, {
			// ~connectionsRateMake.();
			~twister.knobs[8..15].do { |i, id|
				if (id > 2, {i.ledColor_(Color.magenta)}, {i.ledColor_(Color.green)});
			};
			~twister.knobs[8+(~tracksValue/2).asInteger].ledColor_(Color.red);
		});
		~tracksView.valueAction_(~seqCompGABIndex[0]);
	});



	// Tempo

	~resolution = 0.02; // voir impact CPU si trop bas et réellement audible au niveau de la progession

	// Changer le tempo autrement que par un slider par la possibilité d'être précis XXX
	// soit en rajoutant ou en l'échangeant par une Number Box
	~toTempoSpec = ControlSpec(0.1, 10, 2, 0.01);
	~toTempoView = SmoothSlider(~controlWindowTrig, Rect(5*~xSizeMul, 77*~ySizeMul, 250*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| ~toTempo = ~toTempoSpec.map(view.value);
		view.string = "% BPS -> % BPM".format(~toTempo, ~toTempo * 60);
		// Actualisation du BPM pour chaque séquence de chaque Track
		~pFadeView.string = ("XFade : % Beats - % sec").format(~pFade[~tracksValue], (~pFade[~tracksValue] / ~toTempo).round(0.01));
		~quantView.string = ("Quant : % Beats - % sec").format(~quant[~tracksValue], (~quant[~tracksValue] / ~toTempo).round(0.01));
		~nbTotalBeatsView.doAction;
		/*~seqs.do { |seq|
		~nbTotalBeatsView.string = ("% Beats - % Ev in %s - BPM: %").format(~nbTotalBeats[~tracksValue][~seqsValue],
		/*(8.collect({|i| ~nbBeat[~tracksValue][~seqsValue][i]})).sum;*/ // Correction du code pour faire le sum du collect seulement si ~pBeat > 0
		(8.collect({|i| (~pBeat[~tracksValue][~seqsValue][i] > 0).if ({~nbBeat[~tracksValue][~seqsValue][i]}, {0}) })).sum, (~nbTotalBeats[~tracksValue][~seqsValue] / ~toTempo).round(0.01), ((8.collect({|i| (~pBeat[~tracksValue][~seqsValue][i] > 0).if ({~nbBeat[~tracksValue][~seqsValue][i]}, {0}) })).sum / ~nbTotalBeats[~tracksValue][~seqsValue] * ~toTempo * 60).round(0.01));
		}*/
		if (~toSec == 0, {
			~gblTempo.tempo = ~toTempo;
			view.hilightColor_(~sliderHilightColor);
		},{
			view.hilightColor_(Color.red);
		});
	})
	.font_(Font("Verdana", 12*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	// .hilightColor_(~sliderHilightColor) // + utile voir ci-dessous car update de la couleur si changement
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.valueAction_(~toTempoSpec.unmap(2))
	.doAction;

	~toTempoView.hilightColor_(~sliderHilightColor);

	~toSecSpec = ControlSpec(0, 60, \lin, 1);
	~toSecView = SmoothSlider(~controlWindowTrig, Rect(5*~xSizeMul, 99*~ySizeMul, 250*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| ~toSec = ~toSecSpec.map(view.value);
		view.string = "% sec".format(~toSec);
	})
	.font_(Font("Verdana", 12*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.doAction;

	// Essayer de faire un décompte visuel du temps restant avant que le changement de tempo ne se termine
	~tempoPlay = Routine({
		~doNextTempo.states_([["Changing", Color.white, Color.red]]);
		~gblTempo.sync(~toTempo, ~toSec, ~resolution);
		{~toTempoView.acceptsMouse_(false)}.defer;
		~toSec.wait;
		// "Changed Tempo done".postln;
		~doNextTempo.states_([["Do Tempo", Color.white, Color.blue]]);
		{~toTempoView.acceptsMouse_(true)}.defer;
		"Done".yield;
	});

	~doNextTempo = RoundButton(~controlWindowTrig, Rect(218*~xSizeMul, 52*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
	.states_([["Do Tempo", Color.white, Color.blue]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({
		if (~toSec != 0, {
		~toTempoView.hilightColor_(~sliderHilightColor);
		~tempoPlay.reset; ~tempoPlay.play(AppClock);
		});
	});

	~automationActive = 0;
	~automationGUI = RoundButton(~controlWindowTrig, Rect(272*~xSizeMul, 52*~ySizeMul, 38*~xSizeMul, 20*~ySizeMul))
	.states_([["Auto", Color.white, Color.red], ["Auto", Color.white, Color.blue]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({ |i| ~automationActive = i.value; if (~automationActive == 1, {~automationLoad.(); }, {~automationWindow.close} ); });










	// Sélection des séquences globales

	~gblSeqSpec = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~gblSeqStart = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~gblSeqStop = 3 ! ~nbOfSeqs ! ~nbOfTracksX2; // // ATTENTION seulement pour module Parameters triggering
	~gblSeqIndexSpec = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;
	~gblSeqIndex = 0 ! ~nbOfSeqs ! ~nbOfTracksX2;


	~tracks.collect { |tr|
		~seqs.collect { |seq|
			~gblSeqSpec[tr][seq] = ControlSpec(0, ~dur[tr][seq].size, \lin, 1);
			~gblSeqIndexSpec[tr][seq] = ControlSpec(0, ~dur[tr][seq].size, \lin, 1);
			~gblSeqStart[tr][seq] = 0;
			~gblSeqStop[tr][seq] = (~gblSeqSpec[tr][seq].map(1) -1).asInteger;
	}};

	~gblSeqView = SmoothRangeSlider(~rtmCompb, Rect(2*~xSizeMul, 56*~ySizeMul, 333*~xSizeMul /*260*/, 22*~ySizeMul)) // (~controlWindowTrig, Rect(5, 142, 250, 22))
	.action_({ |view| ~gblSeqStart[~tracksValue][~seqsValue] = ~gblSeqSpec[~tracksValue][~seqsValue].map(view.lo).asInteger; ~gblSeqStop[~tracksValue][~seqsValue] = (~gblSeqSpec[~tracksValue][~seqsValue].map(view.hi)-1).asInteger;
		view.string = ("% to % (Dur :"+(~gblSeqStop[~tracksValue][~seqsValue] - ~gblSeqStart[~tracksValue][~seqsValue] + 1).asInteger+")").format(~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]);
		// if (view.range != 1, {view.background = Color.red}, {view.background = ~sliderBackgroundColor} );
		~rtmSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~proSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~synSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~spaSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~legSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~envSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~bufSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~offSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~off2SeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~off3SeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~off4SeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~ratSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~rat2SeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~ampSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~strSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~str2SeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~cenSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~cen2SeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~panSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~delSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~outLSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~outRSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~fxLSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
		~fxRSeqView.valueAction_(~gblSeqSpec[~tracksValue][~seqsValue].unmap([~gblSeqStart[~tracksValue][~seqsValue], ~gblSeqStop[~tracksValue][~seqsValue]+1]));
	})
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightNoColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.minRange_(1/(~dur[~tracksValue][~seqsValue].size))
	.step_(1/(~dur[~tracksValue][~seqsValue].size))
	.valueAction_([0, 1])
	.doAction;

	~gblSeqIndexView = RoundSlider(~rtmCompb, Rect(2*~xSizeMul, 78*~ySizeMul, 333*~xSizeMul /*260*/, 18*~ySizeMul))
	.action_({ |view| ~gblSeqIndex[~tracksValue][~seqsValue] = ~gblSeqIndexSpec[~tracksValue][~seqsValue].map(view.value).asInteger;
		view.string = "At : %".format(~gblSeqIndex[~tracksValue][~seqsValue]);
		~gblSeqView.valueAction_([~gblSeqIndexSpec[~tracksValue][~seqsValue].unmap(~gblSeqIndex[~tracksValue][~seqsValue]), ~gblSeqIndexSpec[~tracksValue][~seqsValue].unmap(~gblSeqIndex[~tracksValue][~seqsValue])]);
	})
	// .valueAction_(0) // pour initialiser les valeurs du View au chargement
	.font_(Font("Verdana", 10*~fontSizeMul))
	.background_(~sliderBackgroundColor)
	.hilightColor_(~sliderHilightColor)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1/(~dur[~tracksValue][~seqsValue].size))
	.doAction;

	~gblSeqAllView = RoundButton(~rtmCompb, Rect(340*~xSizeMul, 57*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["All Seq", Color.black, ~popUpMenuBackgroundColor]])
	.font_(Font("Verdana",8*~fontSizeMul))
	/*.action_({if (~patFlag == 0,
	{~gblSeqView.valueAction_([0, 1]);
	}, {~seqs.do {|i| ~gblSeqView[i].valueAction_([0, 1]);
	}});
	})*/
	.action_({
		if (~patFlag == 0, {
			if (~gblSeqView.range != 1,
				{ ~gblSeqView.valueAction_([0, 1]);
				}, { // nécéssaire car ~gblSeqView.valueAction_([0, 1]); ne déclenche rien si les valeurs sont déjà à 0 & 1
					~rtmSeqView.valueAction_([0, 1]);
					~proSeqView.valueAction_([0, 1]);
					~synSeqView.valueAction_([0, 1]);
					~spaSeqView.valueAction_([0, 1]);
					~legSeqView.valueAction_([0, 1]);
					~envSeqView.valueAction_([0, 1]);
					~bufSeqView.valueAction_([0, 1]);
					~offSeqView.valueAction_([0, 1]); ~off2SeqView.valueAction_([0, 1]); ~off3SeqView.valueAction_([0, 1]); ~off4SeqView.valueAction_([0, 1]);
					~ratSeqView.valueAction_([0, 1]); ~rat2SeqView.valueAction_([0, 1]);
					~ampSeqView.valueAction_([0, 1]);
					~strSeqView.valueAction_([0, 1]); ~str2SeqView.valueAction_([0, 1]);
					~cenSeqView.valueAction_([0, 1]); ~cen2SeqView.valueAction_([0, 1]);
					~panSeqView.valueAction_([0, 1]);
					~delSeqView.valueAction_([0, 1]);
					~outLSeqView.valueAction_([0, 1]);
					~outRSeqView.valueAction_([0, 1]);
					~fxLSeqView.valueAction_([0, 1]);
					~fxRSeqView.valueAction_([0, 1]);
			});
		}, {
			~seqs.do {|i| ~gblSeqView.valueAction_([0, 1]);
				~gblSeqStart[~tracksValue][i] = 0; ~gblSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~rtmSeqStart[~tracksValue][i] = 0; ~rtmSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~proSeqStart[~tracksValue][i] = 0; ~proSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~synSeqStart[~tracksValue][i] = 0; ~synSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~spaSeqStart[~tracksValue][i] = 0; ~spaSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~legSeqStart[~tracksValue][i] = 0; ~legSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~envSeqStart[~tracksValue][i] = 0; ~envSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~bufSeqStart[~tracksValue][i] = 0; ~bufSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~offSeqStart[~tracksValue][i] = 0; ~offSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~off2SeqStart[~tracksValue][i] = 0; ~off2SeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~off3SeqStart[~tracksValue][i] = 0; ~off3SeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~off4SeqStart[~tracksValue][i] = 0; ~off4SeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~ratSeqStart[~tracksValue][i] = 0; ~ratSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~rat2SeqStart[~tracksValue][i] = 0; ~rat2SeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~ampSeqStart[~tracksValue][i] = 0; ~ampSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~strSeqStart[~tracksValue][i] = 0; ~strSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~str2SeqStart[~tracksValue][i] = 0; ~str2SeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~cenSeqStart[~tracksValue][i] = 0; ~cenSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~cen2SeqStart[~tracksValue][i] = 0; ~cen2SeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~panSeqStart[~tracksValue][i] = 0; ~panSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~delSeqStart[~tracksValue][i] = 0; ~delSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~outLSeqStart[~tracksValue][i] = 0; ~outLSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~outRSeqStart[~tracksValue][i] = 0; ~outRSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~fxLSeqStart[~tracksValue][i] = 0; ~fxLSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
				~fxRSeqStart[~tracksValue][i] = 0; ~fxRSeqStop[~tracksValue][i] = ~dur[~tracksValue][i].size -1;
			};
		});
	})
	.valueAction_(1);

	~gblSeqAllView.valueAction_(1);

	~gblSeqMode = RoundButton(~rtmCompb, Rect(340*~xSizeMul, 77*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["\Drag", Color.black, ~popUpMenuBackgroundColor], ["\Jump", Color.black, ~popUpMenuBackgroundColor]])
	.font_(Font("Verdana",8*~fontSizeMul))
	.action_({|i| ~gblSeqView.mode_(~modes[i.value])})
	.valueAction_(1);





	// Gestion Visuels Sliders & Données

	~controlWindowGlobal = CompositeView(~rtmCompb, Rect(0, 105*~ySizeMul, 266*~xSizeMul, 42*~ySizeMul)).background = Color.grey(0.6);

	~visuelTabView = RoundButton(~controlWindowGlobal, Rect(122*~xSizeMul, 2*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["Tab", Color.white, Color.red], ["Tab", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({|i| ~visuelTab = i.value})
	.valueAction_(1);

	~visuelLocView = RoundButton(~controlWindowGlobal, Rect(122*~xSizeMul, 22*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["Loc", Color.white, Color.blue]])
	.font_(Font("Verdana",10*~fontSizeMul))
	// .action_({|i| ~seqsView.valueAction_(~seqSeq[t.activeTab])}); // valable avec TabbedView
	.action_({|i| ~seqsView.valueAction_(~seqSeq[~currentTab])}); // ??????

	~visuelValView = RoundButton(~controlWindowGlobal, Rect(161*~xSizeMul, 2*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["Val", Color.white, Color.red], ["Val", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({|i| ~visuelVal = i.value})
	.valueAction_(1);

	~visuelSliderView = RoundButton(~controlWindowGlobal, Rect(161*~xSizeMul, 22*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["Mul", Color.white, Color.red], ["Sli", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({|i| ~visuelSlider = i.value;
		if(~visuelSlider == 0, {
			[~rtmView, ~proView, ~synView, ~spaView, ~legView, ~envView, ~bufView, ~offView, ~off2View, ~off3View, ~off4View, ~ratView, ~ampView, ~strView, ~cenView, ~panView,  ~delView, ~outLView, ~outRView, ~fxLView, ~fxRView, ~rat2View, ~str2View, ~cen2View].do { |i| i.showIndex_(1) };
		},{
			[~rtmView, ~proView, ~synView, ~spaView, ~legView, ~envView, ~bufView, ~offView, ~off2View, ~off3View, ~off4View, ~ratView, ~ampView, ~strView, ~cenView, ~panView, ~delView, ~outLView, ~outRView, ~fxLView, ~fxRView, ~rat2View, ~str2View, ~cen2View].do { |i| i.showIndex_(0) };
		}
		)
	})
	.valueAction_(1);

	~cutSynthView = RoundButton(~controlWindowGlobal, Rect(5*~xSizeMul, 2*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["CutS", Color.black, Color.green], ["CutS", Color.white, Color.red]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({|i| ~cutSynth = i.value})
	// .value_(0).doAction; // Pour effectuer l'action lorsque l'état ne change pas
	.valueAction_(1);

	~updateSoundFile = 0;
	~updateSoundFileView = RoundButton(~controlWindowGlobal, Rect(5*~xSizeMul, 22*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["Buf", Color.white, Color.red,], ["Buf", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({|i| ~updateSoundFile = i.value;
		if (~updateSoundFile == 1, {
			// ~soundFileViewWindow = Window.new("SoundfileView", Rect(1517+~windowWidth-1920, 683+~windowHeight-1200, 400, 180)).alwaysOnTop_(true);
			~soundFileViewWindow = Window.new("SoundfileView").setTopLeftBounds(Rect(/*1517+~windowWidth-1920*/ ~windowWidth-(400*~xSizeMul), 292+(~windowUpperMargin.neg*4)*~ySizeMul, 400*~xSizeMul, 180*~ySizeMul)).alwaysOnTop_(true);
			~soundFileView = SoundFileView.new(~soundFileViewWindow, Rect(0, 0, 400*~xSizeMul, 180*~ySizeMul));
			~soundFileViewWindow.front;
			// ~updateSoundFile = i.value;
		} , {~soundFileViewWindow.close});
		// ne marche pas ???
		~soundFileViewWindow.onClose = {~updateSoundFileView.valueAction_(0)};
	});

	// A renommer -> sélection du QuickPreset
	~updateVisualPreset = 0;
	~updateVisualPresetView = RoundButton(~controlWindowGlobal, Rect(83*~xSizeMul, 2*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["QPre", Color.white, Color.red], ["QPre", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({|i| ~updateVisualPreset = i.value;
		// coupure de l'affichage graphique lorque QuickPreset est sélectionné (au moins lorsqu'un pattern aléatoire est sélectionné
		~updateVisualRandView.valueAction_(~updateVisualPreset); /*~visuelValView.valueAction_(~updateVisualPreset);*/
	});

	~updateVisualRandView = RoundButton(~controlWindowGlobal, Rect(83*~xSizeMul, 22*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["VRan", Color.black, Color.green], ["VRan", Color.white, Color.red]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({|i| ~updateVisualRand = i.value})
	.value_(0).doAction; // Pour effectuer l'action lorsque l'état ne change pas

	~zoomMultiSliderView = RoundButton(~controlWindowGlobal, Rect(44*~xSizeMul, 2*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["Z MS", Color.white, Color.red], ["Z MS", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({|i|
		var seqSize = ~dur[~tracksValue][~seqsValue].size;
		var seqVSize = seqSize-1;
		var thumbsize = max((333 / seqSize)*~xSizeMul, ~readViewThumbSize);
		~zoomMultiSlider = i.value;
		if (~zoomMultiSlider == 0,
			{ // Pour revenir à la normale sans le zoom MultiSlider
				~rtmView.valueAction_(~dur[~tracksValue][~seqsValue]);
				~rtmView.startIndex_(0);
				~rtmView.indexThumbSize_(~rtmView.bounds.width / 4); // ~rtmView.indexThumbSize_(~rtmView.bounds.width / (~dur[~tracksValue][~seqsValue].size));
				~rtmSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~rtmSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~rtmReadView.thumbSize_(thumbsize);

				~proView.valueAction_(~pro[~tracksValue][~seqsValue]);
				~proView.startIndex_(0);
				~proView.indexThumbSize_(~proView.bounds.width / 4); // ~proView.indexThumbSize_(~proView.bounds.width / (~pro[~tracksValue][~seqsValue].size));
				~proSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~proSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~proReadView.thumbSize_(thumbsize);

				~synView.valueAction_(~syn[~tracksValue][~seqsValue]);
				~synView.startIndex_(0);
				~synView.indexThumbSize_(~synView.bounds.width / 4); // ~synView.indexThumbSize_(~synView.bounds.width / (~syn[~tracksValue][~seqsValue].size));
				~synSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~synSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~synReadView.thumbSize_(thumbsize);

				~spaView.valueAction_(~spa[~tracksValue][~seqsValue]);
				~spaView.startIndex_(0);
				~spaView.indexThumbSize_(~spaView.bounds.width / 4); // ~spaView.indexThumbSize_(~spaView.bounds.width / (~spa[~tracksValue][~seqsValue].size));
				~spaSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~spaSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~spaReadView.thumbSize_(thumbsize);

				~legView.valueAction_(~leg[~tracksValue][~seqsValue]);
				~legView.startIndex_(0);
				~legView.indexThumbSize_(~legView.bounds.width / 4); // ~legView.indexThumbSize_(~legView.bounds.width / (~leg[~tracksValue][~seqsValue].size));
				~legSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~legSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~legReadView.thumbSize_(thumbsize);

				~envView.valueAction_(~env[~tracksValue][~seqsValue]);
				~envView.startIndex_(0);
				~envView.indexThumbSize_(~envView.bounds.width / 4); // ~envView.indexThumbSize_(~envView.bounds.width / (~env[~tracksValue][~seqsValue].size));
				~envSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~envSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~envReadView.thumbSize_(thumbsize);

				~bufView.valueAction_(~buf[~tracksValue][~seqsValue]);
				~bufView.startIndex_(0);
				~bufView.indexThumbSize_(~bufView.bounds.width / 4); // ~bufView.indexThumbSize_(~bufView.bounds.width / (~buf[~tracksValue][~seqsValue].size));
				~bufSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~bufSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~bufReadView.thumbSize_(thumbsize);

				~offView.valueAction_(~off[~tracksValue][~seqsValue]);
				~offView.startIndex_(0);
				~offView.indexThumbSize_(~offView.bounds.width / 4); // ~offView.indexThumbSize_(~offView.bounds.width / (~off[~tracksValue][~seqsValue].size));
				~offSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~offSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~offReadView.thumbSize_(thumbsize);

				~off2View.valueAction_(~off2[~tracksValue][~seqsValue]);
				~off2View.startIndex_(0);
				~off2View.indexThumbSize_(~off2View.bounds.width / 4); // ~offView.indexThumbSize_(~offView.bounds.width / (~off[~tracksValue][~seqsValue].size));
				~off2SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~off2SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~off2ReadView.thumbSize_(thumbsize);

				~off3View.valueAction_(~off3[~tracksValue][~seqsValue]);
				~off3View.startIndex_(0);
				~off3View.indexThumbSize_(~off3View.bounds.width / 4); // ~offView.indexThumbSize_(~offView.bounds.width / (~off[~tracksValue][~seqsValue].size));
				~off3SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~off3SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~off3ReadView.thumbSize_(thumbsize);

				~off4View.valueAction_(~off4[~tracksValue][~seqsValue]);
				~off4View.startIndex_(0);
				~off4View.indexThumbSize_(~off4View.bounds.width / 4); // ~offView.indexThumbSize_(~offView.bounds.width / (~off[~tracksValue][~seqsValue].size));
				~off4SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~off4SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~off4ReadView.thumbSize_(thumbsize);

				~ratView.valueAction_(~rat[~tracksValue][~seqsValue]);
				~ratView.startIndex_(0);
				~ratView.indexThumbSize_(~ratView.bounds.width / 4); // ~ratView.indexThumbSize_(~ratView.bounds.width / (~rat[~tracksValue][~seqsValue].size));
				~ratSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~ratSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~ratReadView.thumbSize_(thumbsize);

				~rat2View.valueAction_(~rat2[~tracksValue][~seqsValue]);
				~rat2View.startIndex_(0);
				~rat2View.indexThumbSize_(~rat2View.bounds.width / 4); // ~ratView.indexThumbSize_(~ratView.bounds.width / (~rat[~tracksValue][~seqsValue].size));
				~rat2SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~rat2SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~rat2ReadView.thumbSize_(thumbsize);

				~ampView.valueAction_(~amp[~tracksValue][~seqsValue]);
				~ampView.startIndex_(0);
				~ampView.indexThumbSize_(~ampView.bounds.width / 4); // ~ampView.indexThumbSize_(~ampView.bounds.width / (~amp[~tracksValue][~seqsValue].size));
				~ampSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~ampSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~ampReadView.thumbSize_(thumbsize);

				~strView.valueAction_(~str[~tracksValue][~seqsValue]);
				~strView.startIndex_(0);
				~strView.indexThumbSize_(~strView.bounds.width / 4); // ~strView.indexThumbSize_(~strView.bounds.width / (~str[~tracksValue][~seqsValue].size));
				~strSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~strSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~strReadView.thumbSize_(thumbsize);

				~str2View.valueAction_(~str2[~tracksValue][~seqsValue]);
				~str2View.startIndex_(0);
				~str2View.indexThumbSize_(~str2View.bounds.width / 4); // ~strView.indexThumbSize_(~strView.bounds.width / (~str[~tracksValue][~seqsValue].size));
				~str2SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~str2SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~str2ReadView.thumbSize_(thumbsize);

				~cenView.valueAction_(~cen[~tracksValue][~seqsValue]);
				~cenView.startIndex_(0);
				~cenView.indexThumbSize_(~cenView.bounds.width / 4); // ~cenView.indexThumbSize_(~cenView.bounds.width / (~cen[~tracksValue][~seqsValue].size));
				~cenSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~cenSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~cenReadView.thumbSize_(thumbsize);

				~cen2View.valueAction_(~cen2[~tracksValue][~seqsValue]);
				~cen2View.startIndex_(0);
				~cen2View.indexThumbSize_(~cen2View.bounds.width / 4); // ~cenView.indexThumbSize_(~cenView.bounds.width / (~cen[~tracksValue][~seqsValue].size));
				~cen2SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~cen2SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~cen2ReadView.thumbSize_(thumbsize);

				~panView.valueAction_(~pan[~tracksValue][~seqsValue]);
				~panView.startIndex_(0);
				~panView.indexThumbSize_(~panView.bounds.width / 4); // ~panView.indexThumbSize_(~panView.bounds.width / (~pan[~tracksValue][~seqsValue].size));
				~panSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~panSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~panReadView.thumbSize_(thumbsize);

				~delView.valueAction_(~del[~tracksValue][~seqsValue]);
				~delView.startIndex_(0);
				~delView.indexThumbSize_(~delView.bounds.width / 4); // ~delView.indexThumbSize_(~delView.bounds.width / (~del[~tracksValue][~seqsValue].size));
				~delSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~delSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~delReadView.thumbSize_(thumbsize);

				~outLView.valueAction_(~outL[~tracksValue][~seqsValue]);
				~outLView.startIndex_(0);
				~outLView.indexThumbSize_(~outLView.bounds.width / 4); // ~outLView.indexThumbSize_(~outLView.bounds.width / (~outL[~tracksValue][~seqsValue].size));
				~outLSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~outLSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~outLReadView.thumbSize_(thumbsize);

				~outRView.valueAction_(~outR[~tracksValue][~seqsValue]);
				~outRView.startIndex_(0);
				~outRView.indexThumbSize_(~outRView.bounds.width / 4); // ~outRView.indexThumbSize_(~outRView.bounds.width / (~outR[~tracksValue][~seqsValue].size));
				~outRSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~outRSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~outRReadView.thumbSize_(thumbsize);

				~fxLView.valueAction_(~fxL[~tracksValue][~seqsValue]);
				~fxLView.startIndex_(0);
				~fxLView.indexThumbSize_(~fxLView.bounds.width / 4); // ~fxLView.indexThumbSize_(~fxLView.bounds.width / (~fxL[~tracksValue][~seqsValue].size));
				~fxLSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~fxLSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~fxLReadView.thumbSize_(thumbsize);

				~fxRView.valueAction_(~fxR[~tracksValue][~seqsValue]);
				~fxRView.startIndex_(0);
				~fxRView.indexThumbSize_(~fxRView.bounds.width / 4); // ~fxRView.indexThumbSize_(~fxRView.bounds.width / (~fxR[~tracksValue][~seqsValue].size));
				~fxRSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqSize, \lin, 1, 1);
				~fxRSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, seqVSize, \lin, 1, 1);
				~fxRReadView.thumbSize_(thumbsize);

			}, {

				~rtmView.valueAction_(~dur[~tracksValue][~seqsValue][(0..max(0,~rtmSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~rtmView.startIndex_(~rtmSeqStart[~tracksValue][~seqsValue]);
				~rtmView.indexThumbSize_(~rtmView.bounds.width / ~seqDurRtm[~tracksValue][~seqsValue]);
				~rtmSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurRtm[~tracksValue][~seqsValue], \lin, 1, 1);
				~rtmSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurRtm[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~rtmReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurRtm[~tracksValue][~seqsValue])*~xSizeMul));

				~proView.valueAction_(~pro[~tracksValue][~seqsValue][(0..max(0,~proSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~proView.startIndex_(~proSeqStart[~tracksValue][~seqsValue]);
				~proView.indexThumbSize_(~proView.bounds.width / ~seqDurPro[~tracksValue][~seqsValue]);
				~proSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurPro[~tracksValue][~seqsValue], \lin, 1, 1);
				~proSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurPro[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~proReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurPro[~tracksValue][~seqsValue])*~xSizeMul));

				~synView.valueAction_(~syn[~tracksValue][~seqsValue][(0..max(0,~synSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~synView.startIndex_(~synSeqStart[~tracksValue][~seqsValue]);
				~synView.indexThumbSize_(~synView.bounds.width / ~seqDurSyn[~tracksValue][~seqsValue]);
				~synSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurSyn[~tracksValue][~seqsValue], \lin, 1, 1);
				~synSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurSyn[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~synReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurSyn[~tracksValue][~seqsValue])*~xSizeMul));

				~spaView.valueAction_(~spa[~tracksValue][~seqsValue][(0..max(0,~spaSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~spaView.startIndex_(~spaSeqStart[~tracksValue][~seqsValue]);
				~spaView.indexThumbSize_(~spaView.bounds.width / ~seqDurSpa[~tracksValue][~seqsValue]);
				~spaSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurSpa[~tracksValue][~seqsValue], \lin, 1, 1);
				~spaSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurSpa[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~spaReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurSpa[~tracksValue][~seqsValue])*~xSizeMul));

				~legView.valueAction_(~leg[~tracksValue][~seqsValue][(0..max(0,~legSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~legView.startIndex_(~legSeqStart[~tracksValue][~seqsValue]);
				~legView.indexThumbSize_(~legView.bounds.width / ~seqDurLeg[~tracksValue][~seqsValue]);
				~legSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurLeg[~tracksValue][~seqsValue], \lin, 1, 1);
				~legSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurLeg[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~legReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurLeg[~tracksValue][~seqsValue])*~xSizeMul));

				~envView.valueAction_(~env[~tracksValue][~seqsValue][(0..max(0,~envSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~envView.startIndex_(~envSeqStart[~tracksValue][~seqsValue]);
				~envView.indexThumbSize_(~envView.bounds.width / ~seqDurEnv[~tracksValue][~seqsValue]);
				~envSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurEnv[~tracksValue][~seqsValue], \lin, 1, 1);
				~envSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurEnv[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~envReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurEnv[~tracksValue][~seqsValue])*~xSizeMul));

				~bufView.valueAction_(~buf[~tracksValue][~seqsValue][(0..max(0,~bufSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~bufView.startIndex_(~bufSeqStart[~tracksValue][~seqsValue]);
				~bufView.indexThumbSize_(~bufView.bounds.width / ~seqDurBuf[~tracksValue][~seqsValue]);
				~bufSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurBuf[~tracksValue][~seqsValue], \lin, 1, 1);
				~bufSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurBuf[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~bufReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurBuf[~tracksValue][~seqsValue])*~xSizeMul));

				~offView.valueAction_(~off[~tracksValue][~seqsValue][(0..max(0,~offSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~offView.startIndex_(~offSeqStart[~tracksValue][~seqsValue]);
				~offView.indexThumbSize_(~offView.bounds.width / ~seqDurOff[~tracksValue][~seqsValue]);
				~offSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOff[~tracksValue][~seqsValue], \lin, 1, 1);
				~offSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOff[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~offReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurOff[~tracksValue][~seqsValue])*~xSizeMul));

				~off2View.valueAction_(~off2[~tracksValue][~seqsValue][(0..max(0,~off2SeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~off2View.startIndex_(~off2SeqStart[~tracksValue][~seqsValue]);
				~off2View.indexThumbSize_(~off2View.bounds.width / ~seqDurOff2[~tracksValue][~seqsValue]);
				~off2SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOff2[~tracksValue][~seqsValue], \lin, 1, 1);
				~off2SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOff2[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~off2ReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurOff2[~tracksValue][~seqsValue])*~xSizeMul));

				~off3View.valueAction_(~off3[~tracksValue][~seqsValue][(0..max(0,~off3SeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~off3View.startIndex_(~off3SeqStart[~tracksValue][~seqsValue]);
				~off3View.indexThumbSize_(~off3View.bounds.width / ~seqDurOff3[~tracksValue][~seqsValue]);
				~off3SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOff3[~tracksValue][~seqsValue], \lin, 1, 1);
				~off3SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOff3[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~off3ReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurOff3[~tracksValue][~seqsValue])*~xSizeMul));

				~off4View.valueAction_(~off4[~tracksValue][~seqsValue][(0..max(0,~off4SeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~off4View.startIndex_(~off4SeqStart[~tracksValue][~seqsValue]);
				~off4View.indexThumbSize_(~off4View.bounds.width / ~seqDurOff4[~tracksValue][~seqsValue]);
				~off4SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOff4[~tracksValue][~seqsValue], \lin, 1, 1);
				~off4SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOff4[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~off4ReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurOff4[~tracksValue][~seqsValue])*~xSizeMul));

				~ratView.valueAction_(~rat[~tracksValue][~seqsValue][(0..max(0,~ratSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~ratView.startIndex_(~ratSeqStart[~tracksValue][~seqsValue]);
				~ratView.indexThumbSize_(~ratView.bounds.width / ~seqDurRat[~tracksValue][~seqsValue]);
				~ratSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurRat[~tracksValue][~seqsValue], \lin, 1, 1);
				~ratSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurRat[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~ratReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurRat[~tracksValue][~seqsValue])*~xSizeMul));

				~rat2View.valueAction_(~rat2[~tracksValue][~seqsValue][(0..max(0,~rat2SeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~rat2View.startIndex_(~rat2SeqStart[~tracksValue][~seqsValue]);
				~rat2View.indexThumbSize_(~rat2View.bounds.width / ~seqDurRat2[~tracksValue][~seqsValue]);
				~rat2SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurRat2[~tracksValue][~seqsValue], \lin, 1, 1);
				~rat2SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurRat2[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~rat2ReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurRat2[~tracksValue][~seqsValue])*~xSizeMul));

				~ampView.valueAction_(~amp[~tracksValue][~seqsValue][(0..max(0,~ampSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~ampView.startIndex_(~ampSeqStart[~tracksValue][~seqsValue]);
				~ampView.indexThumbSize_(~ampView.bounds.width / ~seqDurAmp[~tracksValue][~seqsValue]);
				~ampSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurAmp[~tracksValue][~seqsValue], \lin, 1, 1);
				~ampSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurAmp[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~ampReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurAmp[~tracksValue][~seqsValue])*~xSizeMul));

				~strView.valueAction_(~str[~tracksValue][~seqsValue][(0..max(0,~strSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~strView.startIndex_(~strSeqStart[~tracksValue][~seqsValue]);
				~strView.indexThumbSize_(~strView.bounds.width / ~seqDurStr[~tracksValue][~seqsValue]);
				~strSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurStr[~tracksValue][~seqsValue], \lin, 1, 1);
				~strSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurStr[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~strReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurStr[~tracksValue][~seqsValue])*~xSizeMul));

				~str2View.valueAction_(~str2[~tracksValue][~seqsValue][(0..max(0,~str2SeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~str2View.startIndex_(~str2SeqStart[~tracksValue][~seqsValue]);
				~str2View.indexThumbSize_(~str2View.bounds.width / ~seqDurStr2[~tracksValue][~seqsValue]);
				~str2SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurStr2[~tracksValue][~seqsValue], \lin, 1, 1);
				~str2SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurStr2[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~str2ReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurStr2[~tracksValue][~seqsValue])*~xSizeMul));

				~cenView.valueAction_(~cen[~tracksValue][~seqsValue][(0..max(0,~cenSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~cenView.startIndex_(~cenSeqStart[~tracksValue][~seqsValue]);
				~cenView.indexThumbSize_(~cenView.bounds.width / ~seqDurCen[~tracksValue][~seqsValue]);
				~cenSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurCen[~tracksValue][~seqsValue], \lin, 1, 1);
				~cenSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurCen[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~cenReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurCen[~tracksValue][~seqsValue])*~xSizeMul));

				~cen2View.valueAction_(~cen2[~tracksValue][~seqsValue][(0..max(0,~cen2SeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~cen2View.startIndex_(~cen2SeqStart[~tracksValue][~seqsValue]);
				~cen2View.indexThumbSize_(~cen2View.bounds.width / ~seqDurCen2[~tracksValue][~seqsValue]);
				~cen2SeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurCen2[~tracksValue][~seqsValue], \lin, 1, 1);
				~cen2SeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurCen2[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~cen2ReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurCen2[~tracksValue][~seqsValue])*~xSizeMul));

				~panView.valueAction_(~pan[~tracksValue][~seqsValue][(0..max(0,~panSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~panView.startIndex_(~panSeqStart[~tracksValue][~seqsValue]);
				~panView.indexThumbSize_(~panView.bounds.width / ~seqDurPan[~tracksValue][~seqsValue]);
				~panSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurPan[~tracksValue][~seqsValue], \lin, 1, 1);
				~panSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurPan[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~panReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurPan[~tracksValue][~seqsValue])*~xSizeMul));

				~delView.valueAction_(~del[~tracksValue][~seqsValue][(0..max(0,~delSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~delView.startIndex_(~delSeqStart[~tracksValue][~seqsValue]);
				~delView.indexThumbSize_(~delView.bounds.width / ~seqDurDel[~tracksValue][~seqsValue]);
				~delSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurDel[~tracksValue][~seqsValue], \lin, 1, 1);
				~delSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurDel[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~delReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurDel[~tracksValue][~seqsValue])*~xSizeMul));

				~outLView.valueAction_(~outL[~tracksValue][~seqsValue][(0..max(0,~outLSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~outLView.startIndex_(~outLSeqStart[~tracksValue][~seqsValue]);
				~outLView.indexThumbSize_(~outLView.bounds.width / ~seqDurOutL[~tracksValue][~seqsValue]);
				~outLSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOutL[~tracksValue][~seqsValue], \lin, 1, 1);
				~outLSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOutL[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~outLReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurOutL[~tracksValue][~seqsValue])*~xSizeMul));

				~outRView.valueAction_(~outR[~tracksValue][~seqsValue][(0..max(0,~outRSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~outRView.startIndex_(~outRSeqStart[~tracksValue][~seqsValue]);
				~outRView.indexThumbSize_(~outRView.bounds.width / ~seqDurOutR[~tracksValue][~seqsValue]);
				~outRSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOutR[~tracksValue][~seqsValue], \lin, 1, 1);
				~outRSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurOutR[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~outRReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurOutR[~tracksValue][~seqsValue])*~xSizeMul));

				~fxLView.valueAction_(~fxL[~tracksValue][~seqsValue][(0..max(0,~fxLSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~fxLView.startIndex_(~fxLSeqStart[~tracksValue][~seqsValue]);
				~fxLView.indexThumbSize_(~fxLView.bounds.width / ~seqDurFxL[~tracksValue][~seqsValue]);
				~fxLSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurFxL[~tracksValue][~seqsValue], \lin, 1, 1);
				~fxLSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurFxL[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~fxLReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurFxL[~tracksValue][~seqsValue])*~xSizeMul));

				~fxRView.valueAction_(~fxR[~tracksValue][~seqsValue][(0..max(0,~fxRSeqStop[~tracksValue][~seqsValue]))]); // apparemment pas besoin de flat
				~fxRView.startIndex_(~fxRSeqStart[~tracksValue][~seqsValue]);
				~fxRView.indexThumbSize_(~fxRView.bounds.width / ~seqDurFxR[~tracksValue][~seqsValue]);
				~fxRSeqSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurFxR[~tracksValue][~seqsValue], \lin, 1, 1);
				~fxRSeqVSpec2[~tracksValue][~seqsValue] = ControlSpec(0, ~seqDurFxR[~tracksValue][~seqsValue]-1, \lin, 1, 1);
				~fxRReadView.thumbSize_(max(~readViewThumbSize, (333 / ~seqDurFxR[~tracksValue][~seqsValue])*~xSizeMul));

		});
	})
	.value_(0).doAction; // Pour effectuer l'action lorsque l'état ne change pas


}.value;




























{


	// GUI Pour les créations de trajectoire

	~trajectoryBuffers = {0 ! 2} !100 ! 2; // Initialisation de 100 Buffers de trajectoires et de 100 durées


	~presetTrajectorySetFunction = { | index |

		//  Stockage de la trajectoire dans une envelope
		~trajectoryEnvX = Env( ~trajectoryView.object.positions.collect(_.x), ~trajectoryView.object.times );
		~trajectoryEnvY = Env( ~trajectoryView.object.positions.collect(_.y), ~trajectoryView.object.times );
		// ~trajectoryDur = ~trajectoryView.object.duration;
		/*
		In Adverbs for Binary Operators
		The cross adverb 'x' is like table, except that the result is a flat array:
		[10, 20, 30, 40, 50] +.x [1, 2, 3]
		returns:
		[ 11, 12, 13, 21, 22, 23, 31, 32, 33, 41, 42, 43, 51, 52, 53 ]
		*/
		~presetsTrajectory.put(index, Array.with(~trajectoryEnvX, ~trajectoryEnvY));
		~presetsTrajectory.put('TrajectoryAllList', ~presetTrajectorySelectionView.items.collect({ |i| i.asString.split($ )[i.asString.split($ ).size -1]}) )
	};
	/*
	~presetTrajectorySetFunction.value(~presetTrajectoryStoringName)
	~presetsTrajectory.cs
	~presetsTrajectory['test'][0]
	~presetsTrajectory['TrajectoryAllList']
	~presetsTrajectory['TrajectoryAllList'].swap(~presetTrajectorySelectionView.value, ~presetTrajectorySelectionView.value+1)
	~presetsTrajectory['TrajectoryAllList'].swap(~presetTrajectorySelectionView.value, ~presetTrajectorySelectionView.value+1).collect({ |i, index| (index.asString ++ " ->  " ++ i.asString).asSymbol
	})
	*/

	~presetTrajectoryGetFunction = { | index |
		//  Envoi des envelopes dans la trajectoire
		// ~trajectoryView.object = WFSPath2( [ ~trajectoryEnvX.levels, ~trajectoryEnvY.levels ].flop.collect(_.asPoint), ~trajectoryEnvX.times );
		~trajectoryView.object = WFSPath2( [ ~presetsTrajectory[index][0].levels, ~presetsTrajectory[index][1].levels ].flop.collect(_.asPoint), ~presetsTrajectory[index][0].times );
	};

	/*
	// Pour lecture dans WFSPlayer
	~trajectoryBuffers[0][0] = ~trajectoryView.object.asBuffer(s);
	~trajectoryBuffers[0][0].plot
	~trajectoryBuffers
	*/


	// ~trajectoryWindow = Window.new("TrajectoryView", Rect(400, 200, 1100, 800)).alwaysOnTop_(true);

	// ~trajectoryWindowStatus = 0; // Pourquoi besoin d'assigner la valeur alors que doit déjà être fait par .valueAction ??? OK
	~trajectoryOpenView = RoundButton(~controlWindowGlobal, Rect(44*~xSizeMul, 22*~ySizeMul, 35*~xSizeMul, 18*~ySizeMul))
	.states_([["Traj", Color.white, Color.red,], ["Traj", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul))
	.action_({|i| ~trajectoryWindowStatus = i.value;
		if (~trajectoryWindowStatus == 1, {
			~trajectoryWindow = Window.new("TrajectoryView", Rect(/*(380+~windowWidth-1920)*~xSizeMul*/ ~windowWidth-(1480*~xSizeMul), ~windowHeight-(136+740*~ySizeMul) /*(128+~windowHeight-1200+(~windowUpperMargin*4))*~ySizeMul*/, 1480*~xSizeMul, 740*~ySizeMul)).alwaysOnTop_(true);
			~trajectoryCompositeView = CompositeView(~trajectoryWindow, Rect(5*~xSizeMul, 5*~ySizeMul, 800*~xSizeMul, 700*~ySizeMul));
			~trajectoryView = WFSPathGUI2.new(~trajectoryCompositeView);
			~trajectoryView.openGeneratorView2(~trajectoryWindow, Rect(850*~xSizeMul, 25*~ySizeMul, 200*~xSizeMul, 200*~ySizeMul) );
			// ~trajectoryView.generatorView.view.findWindow.close


			~presetTrajectoryStoringNameView = TextField(~trajectoryWindow, Rect(1100*~xSizeMul, 25*~ySizeMul, 190*~xSizeMul, 20*~ySizeMul))
			.string_("TrajectoryName")
			.action_({|field| ~presetTrajectoryStoringName = field.value.asSymbol })
			.font_(Font("Verdana",10*~fontSizeMul));


			~presetTrajectoryStoringButtonView = RoundButton(~trajectoryWindow, Rect(1300*~xSizeMul, 25*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
			.states_([["Store", Color.black, Color.green]])
			.font_(Font("Verdana",10*~fontSizeMul))
			.action_({ var presetList, currentItemIndex, currentItemIndex2;
				~presetTrajectoryStoringNameView.doAction;

				/* mis en bas pour enregistrer l'ordre de la nouvelle liste de presets
				~presetsTrajectoryFile = ZArchive.write(~presetsTrajectoryPath);
				~presetsTrajectoryFile.writeItem(~presetsTrajectory.put(~presetTrajectorySetFunction.value(~presetTrajectoryStoringName)));
				~presetsTrajectoryFile.writeClose;
				~presetsTrajectoryFileW = ZArchive.read(~presetsTrajectoryPath);
				~presetsTrajectory = ~presetsTrajectoryFileW.readItem;
				~presetsTrajectoryFileW.close;
				*/

				currentItemIndex = (~presetTrajectorySelectionView.value ? 0);
				currentItemIndex2 = (~presetTrajectorySelectionView.value ? 0) +1;

				if (~presetTrajectorySelectionView.items.size > 0, {

					presetList = ~presetTrajectorySelectionView.items.collect({ |i| i.asString.split($ )[i.asString.split($ ).size -1]; });
					presetList = presetList.reject({ |i| i == "TrajectoryAllList" });
					if (~presetsTrajectory.keys.includes(~presetTrajectoryStoringName), { }, {
						presetList = presetList.insert(~presetTrajectorySelectionView.value +1, ~presetTrajectoryStoringName) });
					presetList = presetList.collect({ |i, index| (index.asString ++ " ->  " ++ i.asString).asSymbol });
					~presetTrajectorySelectionView.items_(presetList);

					if (~server2.notNil, {

						if (~presetsTrajectory.keys.asArray.includes(~presetTrajectoryStoringName), {
							// Pourquoi besoin de déferrer sinon pas pris en compte ???
							{~presetTrajectorySelectionView.valueAction_(currentItemIndex)}.defer(0.001);
							~trajectoryBuffers[0][currentItemIndex][0] = ~trajectoryView.object.asBuffer(~server1); ~trajectoryBuffers[0][currentItemIndex][1] = ~trajectoryView.object.duration;
							~trajectoryBuffers[1][currentItemIndex][0] = ~trajectoryView.object.asBuffer(~server2); ~trajectoryBuffers[1][currentItemIndex][1] = ~trajectoryView.object.duration;
						},{
							{~presetTrajectorySelectionView.valueAction_(currentItemIndex2)}.defer(0.001);
							~trajectoryBuffers[0][currentItemIndex2][0] = ~trajectoryView.object.asBuffer(~server1); ~trajectoryBuffers[0][currentItemIndex2][1] = ~trajectoryView.object.duration;
							~trajectoryBuffers[1][currentItemIndex2][0] = ~trajectoryView.object.asBuffer(~server2); ~trajectoryBuffers[1][currentItemIndex2][1] = ~trajectoryView.object.duration
						});

					},{

						if (~presetsTrajectory.keys.asArray.includes(~presetTrajectoryStoringName), {
							// Pourquoi besoin de déferrer sinon pas pris en compte ???
							{~presetTrajectorySelectionView.valueAction_(currentItemIndex)}.defer(0.001);
							~trajectoryBuffers[0][currentItemIndex][0] = ~trajectoryView.object.asBuffer(~server1); ~trajectoryBuffers[0][currentItemIndex][1] = ~trajectoryView.object.duration;
						},{
							{~presetTrajectorySelectionView.valueAction_(currentItemIndex2)}.defer(0.001);
							~trajectoryBuffers[0][currentItemIndex2][0] = ~trajectoryView.object.asBuffer(~server1); ~trajectoryBuffers[0][currentItemIndex2][1] = ~trajectoryView.object.duration;
						});

					});

				},{

					if (~server2.notNil, {
						~presetTrajectorySelectionView.items_(["0 ->  " ++ ~presetTrajectoryStoringName]);
						~trajectoryBuffers[0][0][0] = ~trajectoryView.object.asBuffer(~server1); ~trajectoryBuffers[0][0][1] = ~trajectoryView.object.duration;
						~trajectoryBuffers[1][0][0] = ~trajectoryView.object.asBuffer(~server2); ~trajectoryBuffers[1][0][1] = ~trajectoryView.object.duration
					},{
						~presetTrajectorySelectionView.items_(["0 ->  " ++ ~presetTrajectoryStoringName]);
						~trajectoryBuffers[0][0][0] = ~trajectoryView.object.asBuffer(~server1); ~trajectoryBuffers[0][0][1] = ~trajectoryView.object.duration
					});

				});

				// ~presetTrajectorySelectionView.items.collect({ |i| i.asString.split($ )[i.asString.split($ ).size -1].postln;  });
				// ~presetTrajectorySelectionView.items.collect({ |i, index| (index.asString ++ " ->  " ++ i.asString).asSymbol })
				// ~presetTrajectorySelectionView.items_(~presetsTrajectory.keys.asArray);

				~presetsTrajectoryFile = ZArchive.write(~presetsTrajectoryPath);
				~presetsTrajectoryFile.writeItem(~presetsTrajectory.put(~presetTrajectorySetFunction.value(~presetTrajectoryStoringName)) );
				~presetsTrajectoryFile.writeClose;
				~presetsTrajectoryFileW = ZArchive.read(~presetsTrajectoryPath);
				~presetsTrajectory = ~presetsTrajectoryFileW.readItem;
				~presetsTrajectoryFileW.close;

			});


			~presetTrajectorySelectionView = ListView(~trajectoryWindow, Rect(1100*~xSizeMul, 50*~ySizeMul, 300*~xSizeMul, 640*~ySizeMul))
			.background_(Color./*clear*/grey(0.3, alpha: 0.8))
			.hiliteColor_(Color.yellow(alpha: 1))
			.selectedStringColor_(Color.black)
			.stringColor_(Color.white)
			.font_(Font("Verdana",10*~fontSizeMul))
			.action_({ |menu|
				~presetTrajectorySelection = menu.item.asString.split($ )[menu.item.asString.split($ ).size -1].asSymbol;
				~presetTrajectoryGetFunction.value(~presetTrajectorySelection);
				~presetTrajectoryStoringNameView.value_(~presetTrajectorySelection);
			});


			~presetTrajectoryRemoveButtonView = RoundButton(~trajectoryWindow, Rect(1360*~xSizeMul, 25*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
			.states_([["Del", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul))
			.action_({ var presetList, presetListValue; // + nécessaire
				if (~presetTrajectorySelectionView.items.size > 0, {
					presetListValue = ~presetTrajectorySelectionView.value;

					~presetsTrajectory.removeAt(~presetTrajectorySelectionView.item.asString.split($ )[~presetTrajectorySelectionView.item.asString.split($ ).size -1].asSymbol);

					presetList = ~presetTrajectorySelectionView.items.collect({ |i| i.asString.split($ )[i.asString.split($ ).size -1]; });
					// presetList = presetList.reject({ |i| i == "TrajectoryAllList" });
					// presetList = presetList.insert(~presetTrajectorySelectionView.value, ~presetTrajectoryStoringName);
					presetList.removeAt(/*presetListValue*/~presetTrajectorySelectionView.value);
					presetList = presetList.collect({ |i, index| (index.asString ++ " ->  " ++ i.asString).asSymbol });
					~presetTrajectorySelectionView.items_(presetList);

					// Mise à jour de la liste dans le fichier de sauvegarde
					~presetsTrajectory.put('TrajectoryAllList', ~presetTrajectorySelectionView.items.collect({ |i| i.asString.split($ )[i.asString.split($ ).size -1]}) );

					~presetsTrajectoryFile = ZArchive.write(~presetsTrajectoryPath);
					~presetsTrajectoryFile.writeItem(~presetsTrajectory);
					~presetsTrajectoryFile.writeClose;
					~presetsTrajectoryFileW = ZArchive.read(~presetsTrajectoryPath);
					~presetsTrajectory = ~presetsTrajectoryFileW.readItem;
					~presetsTrajectoryFileW.close;

					~presetTrajectorySelectionView.value_(presetListValue-1);

					if (~server2.notNil, {
						~trajectoryBuffers[0][presetListValue][0].free; // libère le buffer
						~trajectoryBuffers[0].removeAt(presetListValue); // et réorganisation de l'array
						~trajectoryBuffers[0] = ~trajectoryBuffers[0].add([0, 0]);
						~trajectoryBuffers[1][presetListValue][0].free; // libère le buffer
						~trajectoryBuffers[1].removeAt(presetListValue); // et réorganisation de l'array
						~trajectoryBuffers[1] = ~trajectoryBuffers[1].add([0, 0]);
					},{
						~trajectoryBuffers[0][presetListValue][0].free; // libère le buffer
						~trajectoryBuffers[0].removeAt(presetListValue); // et réorganisation de l'array
						~trajectoryBuffers[0] = ~trajectoryBuffers[0].add([0, 0]);
					});

				})
			});


			~presetTrajectoryUpButtonView = RoundButton(~trajectoryWindow, Rect(1410*~xSizeMul, 60*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
			.states_([["Up", Color.white, Color.blue]])
			.font_(Font("Verdana",10*~fontSizeMul))
			.action_({ var currentItemIndex;
				currentItemIndex = ~presetTrajectorySelectionView.value -1;
				if (~presetTrajectorySelectionView.value > 0, {
					if (~server2.notNil, {
						~trajectoryBuffers[0].swap(~presetTrajectorySelectionView.value, currentItemIndex); // change l'organisation de l'array des buffers
						~trajectoryBuffers[1].swap(~presetTrajectorySelectionView.value, currentItemIndex); // change l'organisation de l'array des buffers
					},{
						~trajectoryBuffers[0].swap(~presetTrajectorySelectionView.value, currentItemIndex); // change l'organisation de l'array des buffers
					});
					~presetTrajectorySelectionView.items_(~presetsTrajectory['TrajectoryAllList'].swap(~presetTrajectorySelectionView.value, currentItemIndex).collect({ |i, index| (index.asString ++ " ->  " ++ i.asString).asSymbol }));
					~presetTrajectorySelectionView.valueAction_(currentItemIndex);

					// Mise à jour de la liste dans le fichier de sauvegarde
					~presetsTrajectory.put('TrajectoryAllList', ~presetTrajectorySelectionView.items.collect({ |i| i.asString.split($ )[i.asString.split($ ).size -1]}) );

					~presetsTrajectoryFile = ZArchive.write(~presetsTrajectoryPath);
					~presetsTrajectoryFile.writeItem(~presetsTrajectory);
					~presetsTrajectoryFile.writeClose;
					~presetsTrajectoryFileW = ZArchive.read(~presetsTrajectoryPath);
					~presetsTrajectory = ~presetsTrajectoryFileW.readItem;
					~presetsTrajectoryFileW.close;
				});

			});


			~presetTrajectoryDownButtonView = RoundButton(~trajectoryWindow, Rect(1410*~xSizeMul, 90*~ySizeMul, 50*~xSizeMul, 20*~ySizeMul))
			.states_([["Down", Color.white, Color.blue]])
			.font_(Font("Verdana",10*~fontSizeMul))
			.action_({ var currentItemIndex;
				currentItemIndex = ~presetTrajectorySelectionView.value +1;
				if (~presetTrajectorySelectionView.items.size > currentItemIndex, {
					if (~server2.notNil, {
						~trajectoryBuffers[0].swap(~presetTrajectorySelectionView.value, currentItemIndex); // change l'organisation de l'array des buffers
						~trajectoryBuffers[1].swap(~presetTrajectorySelectionView.value, currentItemIndex); // change l'organisation de l'array des buffers
					},{
						~trajectoryBuffers[0].swap(~presetTrajectorySelectionView.value, currentItemIndex); // change l'organisation de l'array des buffers
					});
					~presetTrajectorySelectionView.items_(~presetsTrajectory['TrajectoryAllList'].swap(~presetTrajectorySelectionView.value, currentItemIndex).collect({ |i, index| (index.asString ++ " ->  " ++ i.asString).asSymbol }));
					~presetTrajectorySelectionView.valueAction_(currentItemIndex);

					// Mise à jour de la liste dans le fichier de sauvegarde
					~presetsTrajectory.put('TrajectoryAllList', ~presetTrajectorySelectionView.items.collect({ |i| i.asString.split($ )[i.asString.split($ ).size -1]}) );

					~presetsTrajectoryFile = ZArchive.write(~presetsTrajectoryPath);
					~presetsTrajectoryFile.writeItem(~presetsTrajectory);
					~presetsTrajectoryFile.writeClose;
					~presetsTrajectoryFileW = ZArchive.read(~presetsTrajectoryPath);
					~presetsTrajectory = ~presetsTrajectoryFileW.readItem;
					~presetsTrajectoryFileW.close;
				});

			});


			~presetTrajectoryUpdateMultiSlider = RoundButton(~trajectoryWindow, Rect(1410*~xSizeMul, 120*~ySizeMul, 50*~xSizeMul, 60*~ySizeMul))
			.states_([["Update \n Multi \n Slider", Color.white, Color.blue]])
			.font_(Font("Verdana",10*~fontSizeMul))
			.action_({
				// ~allSpasGUI = ["Stereo", "Traj 0->1", "Traj 1->0", "Traj 0->1->0", "Traj 1->0->1", /*"Bad PanB2", "Bad Pan"*/ "Circ_1_GD", "Circ_1_DG", "CircM_GD", "CircM_DG", "A"];
				~allSpasGUIBase = ~allSpasGUI[0..~allSpasGUI.size -2];
				// ~allSpasGUIAmbi = ~presetsTrajectory['TrajectoryAllList'].size.collect { |i| ~allSpasGUI.last ++ "_" ++ ~presetsTrajectory['TrajectoryAllList'][i] };
				~allSpasGUIAmbi = ~presetsTrajectory['TrajectoryAllList'].size.collect { |i| ~allSpasGUI.last /*~allSpasGUI[~allSpasGUI.size-1]*/ ++ i ++ "_" ++~presetsTrajectory['TrajectoryAllList'][i] };
				~allSpasGUIFinal = ~allSpasGUIBase ++ ~allSpasGUIAmbi;

				case
				{~numChannelsConfig == "16-Dome-8-6-2-Clock" or: {~numChannelsConfig == "16-Dome-8-6-2-Clock-CC"} or: {~numChannelsConfig == "16-UsineC-2Octo"} or: {~numChannelsConfig == "24-UsineC-3Octo"}}
				{
					~acousFunction.();
				};

				~tracks.collect { |tr|
					~seqs.collect { |seq|
						~spaRangeSpec[tr][seq] = ControlSpec(0, ~allSpasGUIFinal.size-1, \lin, 1);
						~spaMax[tr][seq] = ~allSpasGUIFinal.size -1;
						~spaSpec[tr][seq] = ControlSpec(~spaMin[tr][seq], ~spaMax[tr][seq], \lin, 1);
				}};

				~spaRoundView.items_(~allSpasGUIFinal.size.collect {|i| i+~allSpasGUIFinal[i]});
				// obligé de mettre 2 .valueAction afin qu'il y ait un update visuel - non juste un .doAction
				/*~spaRangeView.valueAction_([0, 0.5]); */~spaRangeView.valueAction_([0, 1]).doAction;

				// ~spaRangePresetView.items_(["0->4 T", "5->8 C", "0->8 TC", ("9->"++"~allSpasGUIFinal.size -1".interpret) ++ " A", "0->"++"~allSpasGUIFinal.size -1".interpret]).valueAction_(4)
				~spaRangePresetView/*.items_(~spaRangePresetItems)*/.valueAction_(~spaRangePresetItems.size-1)

			});


			if (~presetsTrajectory.keys.size > 0, {~presetTrajectorySelectionView.items_(~presetsTrajectory['TrajectoryAllList'].reject({ |i| i.asString == "TrajectoryAllList" }).collect({ |i, index| (index.asString ++ " ->  " ++ i.asString) })).asSymbol });


			~trajectoryWindow.front;

		} , {~trajectoryWindow.close});

		~trajectoryWindow.onClose = {~trajectoryOpenView.valueAction_(0)};

	});


	~trajectoryOpenView.valueAction_(1);

	// if (~presetsTrajectory.keys.size > 0, {~presetTrajectorySelectionView.items_(~presetsTrajectory.keys.asArray.reject({ |i| i.asString == "TrajectoryAllList" }).collect({ |i, index| (index.asString ++ " " ++ i.asString) })).asSymbol });
	// ci-dessous afin d'afficher la liste des trajectoires selon l'ordre prédéfini dans le fichier text de ZArchive
	// ~presetsTrajectory['TrajectoryAllList']
	if (~presetsTrajectory.keys.size > 0, {~presetTrajectorySelectionView.items_(~presetsTrajectory['TrajectoryAllList'].reject({ |i| i.asString == "TrajectoryAllList" }).collect({ |i, index| (index.asString ++ " ->  " ++ i.asString) })).asSymbol;
		// Chargement initial des buffers des trajectoires
		~presetTrajectorySelectionView.items.size.do { |i|
			~presetTrajectorySelectionView.valueAction_(i);
			if (~server2.notNil, {
				~trajectoryBuffers[0][i][0] = ~trajectoryView.object.asBuffer(~server1); ~trajectoryBuffers[0][i][1] = ~trajectoryView.object.duration;
				~trajectoryBuffers[1][i][0] = ~trajectoryView.object.asBuffer(~server2); ~trajectoryBuffers[1][i][1] = ~trajectoryView.object.duration;
			},{
				~trajectoryBuffers[0][i][0] = ~trajectoryView.object.asBuffer(~server1); ~trajectoryBuffers[0][i][1] = ~trajectoryView.object.duration;
			});
		};
	});

	~trajectoryOpenView.valueAction_(0);




















	// Preset Variations

	~nbOfpresetVarsPages = 10;

	// Besoin d'initialiser dans la GUI, même si modifié par la suite...
	// ~sequenceAssociationTrackFormat = [0,4] ! ~nbOfpresetVarsPages;
	~sequenceAssociationTrackFormat = [ [0,2], [0,2], [0,2], [0,2], [0,2], [0,2], [0,2], [0,2], [0,2], [9,11] /*[9, 11, 13], [9, 11, 13], [9, 11, 13], [9, 11, 13], [9, 11, 13]*/ ];
	// [ [0,4], [0,4], [0,4], [0,4], [0,7], 6, 7, 8, 9, 10 /*[9, 11, 13], [9, 11, 13], [9, 11, 13], [9, 11, 13], [9, 11, 13]*/ ];
	~globalRandAssPresets = [0,0] ! 60 ! ~nbOfpresetVarsPages; // à associer à la variable du nombre de pages de presets (~nbOfpresetVarsPages) ? non
	/*~globalRandAssPresets.do { |i, id|
	~globalRandAssPresets[id] = { [ ~presetSeqRandList[~sequenceAssociationTrackFormat[id][0]/*~tracksValue*/].choose, ~presetSeqRandList[~sequenceAssociationTrackFormat[id][1]/*~tracksValue*/].choose ] } ! 60;
	};*/

	~presetVarsLastSelection = 0 ! ~nbOfpresetVarsPages;

	if (~presetAssociationNames.isNil, {
		~presetAssociationNames = 0 ! ~nbOfpresetVarsPages;
		if (  ~presetTracksVariations.notNil, { ~presetAssociationNames[0] = ~presetTracksVariations.keys.asArray.sort; } );
	});

	~rhythmTrack1 = 8; ~rhythmTrack2 = 10; ~rhythmTrack3 = 12; ~rhythmTrack4 = 14;


	(
		~presetVarsWindow = Window("Preset Associations", border:false).setTopLeftBounds(Rect(1516*~xSizeMul, 587*~ySizeMul, 400*~xSizeMul, 540*~ySizeMul))/*.alpha_(0.8)*/.alwaysOnTop_(true);

		// Comment faire pour appliquer les actions du clavier sur cette fenêtre qui est instancié à chaque ouverture ?
		// Qu'elle soit toujours présente et juste la cachée ???
		~presetVarsWindow.view./*global*/keyDownAction_(~keyActions);

		WindowHandleView(~presetVarsWindow, Rect(1*~xSizeMul, 0, 398*~xSizeMul, 4*~ySizeMul))/*.minHeight_(4)*/;

		/*~presetVarsSliderView = EZSlider.new2(~presetVarsWindow, Rect(0,50,400,20) /*400@20*/, nil, ControlSpec(1, 60, \lin, 1, 1),
		{ |ez| ~presetVarsSlider = (ez.value-1)/*.postln*/;
		~presetVarsSliderViewFunction.(~presetVarsSlider);
		},
		unitWidth:0, initVal:0, numberWidth:25, layout:\horz,)
		.setColors(Color.grey,Color.white)
		.font_(Font("Helvetica",11));*/

		~presetVarsSliderSpec = ControlSpec(1,60, \lin, 1,1);
		~presetVarsSliderView = RoundSlider(~presetVarsWindow, Rect(1*~xSizeMul, 6*~ySizeMul, 398*~xSizeMul, 24*~ySizeMul))
		.action_({ |view|
			~presetVarsSlider = ~presetVarsSliderSpec.map(view.value) -1;
			~presetVarsSliderViewFunction.(~presetVarsSlider);
			view.string = "Preset Ass N° : %".format((~presetVarsSlider+1).asInteger);
		})
		.font_(Font("Verdana", 12*~fontSizeMul,true))
		.background_(~sliderBackgroundColor)
		.hilightColor_(~sliderHilightColor)
		.stringColor_(Color.white)
		.border_(~border)
		.borderColor_(~borderColor)
		.step_(1/60)
		.string = "Preset Ass N° 0";
		// .valueAction_(1);


		~tabbedPresetVars = TabbedView2(~presetVarsWindow, Rect(1*~xSizeMul, 32*~ySizeMul, 398*~xSizeMul, 510*~ySizeMul))
		.lockPosition_(true)
		.lockEdges_(true)
		.backgrounds_([Color(0.8, 0.8, 0.8)])
		.unfocusedColors_([Color.white])
		.labelColors_([Color.magenta])
		.tabHeight_(28*~ySizeMul).tabWidth_(39*~xSizeMul).tabCurve_(8)
		.font_(Font("Verdana",12*~fontSizeMul, bold: false));

		~tabbedPresetVarsPage = 0;
		// ~tabbedPresetVars.add( ~tabbedPresetVarsPages = ~nbOfpresetVarsPages.collect{|i| ~tabbedPresetVars.add((i+1).asString)}); // Classique numérotation de 1 à 10
		~tabbedPresetVars.add( ~tabbedPresetVarsPages = ~nbOfpresetVarsPages.collect{|i| ~tabbedPresetVars.add(~sequenceAssociationTrackFormat[i].asString.replace(" ", "") )} );
		~nbOfpresetVarsPages.do{ |i| ~tabbedPresetVarsPages[i].focusAction={ ~tabbedPresetVarsPage = i} };

		/*~tabbedPresetVars.tabAt(5).unfocusedColor_(Color.yellow).labelColor_(Color.red);
		~tabbedPresetVars.tabAt(6).unfocusedColor_(Color.yellow).labelColor_(Color.red);
		~tabbedPresetVars.tabAt(7).unfocusedColor_(Color.yellow).labelColor_(Color.red);
		~tabbedPresetVars.tabAt(8).unfocusedColor_(Color.yellow).labelColor_(Color.red);
		~tabbedPresetVars.tabAt(9).unfocusedColor_(Color.red/*yellow*/).labelColor_(Color.red);*/
		// ~tabbedPresetVars.stringColors_([Color.white]); // ne semble pas marcher comme cela ???

		~presetVarsMatrices = ~nbOfpresetVarsPages.collect{ |i|
			BoxMatrix(~tabbedPresetVars.tabAt(i),(394*~xSizeMul)@(476*~ySizeMul), 6, 10);
		};


		~randAssociationFunction = { |tracks, array|
			/*[0, 4]*/tracks.do { |a, at|
				~presetSeqRangeViewG[a].valueAction_(~presetSeqRangeSpec.unmap([ array[at], array[at] ]));
				~seqCompG1[a].visibleOrigin = 0@( (~presetSeqStart[a]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin);

				/*var p;
				if (p.isArray, {
				~presetSeqRangeViewG[a].valueAction_(~presetSeqRangeSpec.unmap([ p[0]-1, p[1] ]));
				}, {
				~presetSeqRangeViewG[a].valueAction_(~presetSeqRangeSpec.unmap([ p, p ]));
				});*/
			};
		};

		~randRyAssociationFunction = { |tracks, array|
			/*[0, 4]*/tracks.do { |a, at|
				~presetSeqRangeViewG[a].valueAction_(~presetSeqRangeSpec.unmap([ array[at].round(10)-10, array[at].round(10) ]));
				~seqCompG1[a].visibleOrigin = 0@( (~presetSeqStart[a]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin);

				/*var p;
				if (p.isArray, {
				~presetSeqRangeViewG[a].valueAction_(~presetSeqRangeSpec.unmap([ p[0]-1, p[1] ]));
				}, {
				~presetSeqRangeViewG[a].valueAction_(~presetSeqRangeSpec.unmap([ p, p ]));
				});*/
			};
		};


		// Plusieurs fonctions aléatoires - voire aussi ~loadPresetTracksRanges

		/*~randRhythmAssociationFunction1 = { | track |
		// Range d'1
		var rand = ~presetSeqRandList[track].choose;
		~presetSeqRangeViewG[track].valueAction_(~presetSeqRangeSpec.unmap([ rand, rand+1 ]));
		~seqCompG1[track].visibleOrigin = 0@( (~presetSeqStart[track]-10)*20).max(0).min(~seqCompG1MaxVisibleOrigin);
		};

		~randRhythmAssociationFunction2 = { | track, dur |
		// Range de 2 à 6, sauf si on est sur la dernière sélection, dans ce cas 1 & Dur de 1 à 6
		var rand, range; rand = ~presetSeqRandList[track].choose; range = 5.rand+2;
		~presetSeqRangeViewG[track].valueAction_(~presetSeqRangeSpec.unmap([ rand, (rand+range).min(~presetSeqRandList[track].last+1) ]));
		// [ rand, (rand+range).min(~presetSeqRandList[track].last) ].postln;
		~seqCompG1[track].visibleOrigin = 0@( (~presetSeqStart[track]-10)*20).max(0).min(~seqCompG1MaxVisibleOrigin);
		(~presetSeqStart[track] .. (~presetSeqStop[track]) ).do { |i| ~presetSeqNbSelectDurViewG[track][i].valueAction_(/*6*/dur.rand+1); };
		};

		~randRhythmAssociationFunction3 = { | track, dur |
		// Range de 2 à 6 non consécutifs, & Dur de 1 à 6
		var rand = Array.rand(5.rand+2, 1, ~presetSeqRandList[track].last+1).sort;
		~lemurNewSeqsUpdate.(track, rand);
		rand.do { |i| ~presetSeqNbSelectDurViewG[track][i-1].valueAction_(/*6*/dur.rand+1); };
		};*/

		~randRhythmAssociationFunctionClear = { | tracks |
			tracks.do { |tr| ~presetSeqRandList[tr].do { |i| if (~presetSeqNbSelectDurValue[tr][i] != 1, {~presetSeqNbSelectDurViewG[tr][i].valueAction_(1); }) } };
			// ~nbOfTracksX2.do { |t| ~nbOfSeqs.do { |s,sd| if ( ~presetSeqNbSelectDurValue[t][s] != 1, { ~presetSeqNbSelectDurViewG[t][s].valueAction_(1) }) } }; // Bouton pour remettre toutes les durées de toutes les pistes à 1 ?
		};

		~randRhythmSel1AssociationFunction = { | track |
			// Range d'1
			var rand = ~presetSeqRandList[track].choose;
			~presetSeqRangeViewG[track].valueAction_(~presetSeqRangeSpec.unmap([ rand, rand+1 ]));
			~seqCompG1[track].visibleOrigin = 0@( (~presetSeqStart[track]-10)*20*~ySizeMul).max(0).min(~seqCompG1MaxVisibleOrigin);
		};

		~randRhythmSelMulAssociationFunction = { | track, range |
			// Range de 2 à 6 non consécutifs avec un range de 4 ou de 8 pour aller jusqu'à 10
			var rand = Array.rand(range.rand+3, 1, ~presetSeqRandList[track].last+1).sort;
			~lemurNewSeqsUpdate.(track, rand);
		};

		~randRhythmDurAssociationFunction = { | track, dur |
			// Plus lourd de chercher une classe
			// { 10000.do { ~lemurNewSeqs[0].size == 0 } }.bench
			// { 10000.do { ~lemurNewSeqs[0].class == Integer } }.bench

			( // Change l'odre des durées sélectionnées de la piste en cours - Dur de 1 à ?
				[track].do { |t|
					if ( ~lemurNewSeqs[t].size == 0, {
						if (~presetSeqStart[t] - ~presetSeqStop[t] == 0, {
							// [~presetSeqStart[t]].do{ |s|~presetSeqNb2ViewG[t][s].valueAction_(200.rand) } // cela ne sert à rien de le faire sur une seule piste
						}, {
							( ~presetSeqStart[t]..~presetSeqStop[t] ).do{ |s| ~presetSeqNbSelectDurViewG[t][s].valueAction_(/*6*/dur.rand+1) }
						});
					}, {
						~lemurNewSeqs[t].do{ |s| ~presetSeqNbSelectDurViewG[t][s-1].valueAction_(/*6*/dur.rand+1) }
					})
				};
			)
		};

		~randRhythmDur1AssociationFunction = { | track |
			( // Change l'odre des durées sélectionnées de la piste en cours - Dur de 1 à ?
				[track].do { |t|
					if ( ~lemurNewSeqs[t].size == 0, {
						// if (~presetSeqStart[t] - ~presetSeqStop[t] == 0, {
						// [~presetSeqStart[t]].do{ |s|~presetSeqNb2ViewG[t][s].valueAction_(200.rand) } // cela ne sert à rien de le faire sur une seule piste
						// }, {
						( ~presetSeqStart[t]..~presetSeqStop[t] ).do{ |s| ~presetSeqNbSelectDurViewG[t][s].valueAction_(1) }
						// });
					}, {
						~lemurNewSeqs[t].do{ |s| ~presetSeqNbSelectDurViewG[t][s-1].valueAction_(1) }
					})
				};
			)
		};

		~randRhythmOrderAssociationFunction = { | track |
			( // Change l'odre des séquences sélectionnées de la piste en cours
				[track].do { |t|
					if ( ~lemurNewSeqs[t].size == 0, {
						if (~presetSeqStart[t] - ~presetSeqStop[t] == 0, {
							// [~presetSeqStart[t]].do{ |s|~presetSeqNb2ViewG[t][s].valueAction_(200.rand) } // cela ne sert à rien de le faire sur une seule piste
						}, {
							( ~presetSeqStart[t]..~presetSeqStop[t] ).do{ |s| ~presetSeqNb2ViewG[t][s].valueAction_(200.rand) }
						});
					}, {
						~lemurNewSeqs[t].do{ |s| ~presetSeqNb2ViewG[t][s-1].valueAction_(200.rand) }
					})
				};
			)
		};

		~randRhythmReOrderAssociationFunction = { | track |
			[track].do { |t| ~nbOfSeqs.do { |s,sd| if (sd+1 != ~presetSeqNb2Value[t][s], { ~presetSeqNb2ViewG[t][s].valueAction_(sd+1) }) } }; // Remise en ordre des séquences de la piste en cours
		};


		// 3 fonctions à modifer pour la sélection des PresetVars :
		// ~presetVarsMatrices[i].mouseDownAction dans GUI
		// ~presetVarsSliderViewFunction pour le slider dans GUI
		// ~lemurPresetMenuFunction dans Lemur2

		~presetVarsSliderViewFunction = { |i|

			var a, b, p, x, y, prevX, prevY;

			if (~presetVarsLastSelection[~tabbedPresetVarsPage] != 0, { // Pour n'avoir q'une sélection à la fois
				~presetVarsMatrices[~tabbedPresetVarsPage].at(~presetVarsLastSelection[~tabbedPresetVarsPage]).playing_(false); ~presetVarsMatrices[~tabbedPresetVarsPage].removeStyle(~presetVarsMatrices[~tabbedPresetVarsPage].at(~presetVarsLastSelection[~tabbedPresetVarsPage]), 'playing'); // ~presetVarsMatrices[0].refresh
			});

			x = i %10; y = i.div(10);
			b = ~presetVarsMatrices[~tabbedPresetVarsPage].at(y@x);
			p = b.pattern/*.postln*/;
			~presetVarsLastSelection[~tabbedPresetVarsPage] = y@x;

			{
				case
				{ p.class == Symbol /*!= Nil*/ }
				{
					if (~tabbedPresetVarsPage == 0 or: {~tabbedPresetVarsPage == 1}, {
						~loadPresetTracksRanges.(\tabbedPresetVarsPage, p, ~sequenceAssociationTrackFormat[0]); ("Preset Ass :" + p).postln
					}, {
						~loadPresetTracksRanges.(\tabbedPresetVarsPage, p); ("Preset Ass :" + p).postln
					});
				}
				{ p.class == Array }
				{
					if (~tabbedPresetVarsPage > 4, {
						~randRyAssociationFunction.(~sequenceAssociationTrackFormat[~tabbedPresetVarsPage], p); ("Preset Ass Rand :" + ~sequenceAssociationTrackFormat[~tabbedPresetVarsPage].asString + p).postln
					},{
						~randAssociationFunction.(~sequenceAssociationTrackFormat[~tabbedPresetVarsPage], p); ("Preset Ass Rand :" + ~sequenceAssociationTrackFormat[~tabbedPresetVarsPage].asString + p).postln
					})
				}
				{ p == 0 }
				{ ~randRhythmSel1AssociationFunction.(~rhythmTrack1) }
				{ p == 1 }
				{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack1,2) }
				{ p == 2 }
				{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack1,5) }
				{ p == 3 }
				{ ~randRhythmDur1AssociationFunction.(~rhythmTrack1) }
				{ p == 4 }
				{ ~randRhythmDurAssociationFunction.(~rhythmTrack1,3) }
				{ p == 5 }
				{ ~randRhythmDurAssociationFunction.(~rhythmTrack1,6) }
				{ p == 6 }
				{ ~randRhythmOrderAssociationFunction.(~rhythmTrack1) }
				{ p == 7 }
				{ ~randRhythmReOrderAssociationFunction.(~rhythmTrack1) }
				{ p == 8 }
				{ ~randRhythmAssociationFunctionClear.([~rhythmTrack1,~rhythmTrack2,~rhythmTrack3]) }
				{ p == 10 }
				{ ~randRhythmSel1AssociationFunction.(~rhythmTrack2) }
				{ p == 11 }
				{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack2,2) }
				{ p == 12 }
				{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack2,5) }
				{ p == 13 }
				{ ~randRhythmDur1AssociationFunction.(~rhythmTrack2) }
				{ p == 14 }
				{ ~randRhythmDurAssociationFunction.(~rhythmTrack2,3) }
				{ p == 15 }
				{ ~randRhythmDurAssociationFunction.(~rhythmTrack2,6) }
				{ p == 16 }
				{ ~randRhythmOrderAssociationFunction.(~rhythmTrack2) }
				{ p == 17 }
				{ ~randRhythmReOrderAssociationFunction.(~rhythmTrack2) }
				{ p == 20 }
				{ ~randRhythmSel1AssociationFunction.(~rhythmTrack3) }
				{ p == 21 }
				{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack3,2) }
				{ p == 22 }
				{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack3,5) }
				{ p == 23 }
				{ ~randRhythmDur1AssociationFunction.(~rhythmTrack3) }
				{ p == 24 }
				{ ~randRhythmDurAssociationFunction.(~rhythmTrack3,3) }
				{ p == 25 }
				{ ~randRhythmDurAssociationFunction.(~rhythmTrack3,6) }
				{ p == 26 }
				{ ~randRhythmOrderAssociationFunction.(~rhythmTrack3) }
				{ p == 27 }
				{ ~randRhythmReOrderAssociationFunction.(~rhythmTrack3) }
				{ p == 30 }
				{ ~randRhythmSel1AssociationFunction.(~rhythmTrack4) }
				{ p == 31 }
				{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack4,2) }
				{ p == 32 }
				{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack4,5) }
				{ p == 33 }
				{ ~randRhythmDur1AssociationFunction.(~rhythmTrack4) }
				{ p == 34 }
				{ ~randRhythmDurAssociationFunction.(~rhythmTrack4,3) }
				{ p == 35 }
				{ ~randRhythmDurAssociationFunction.(~rhythmTrack4,6) }
				{ p == 36 }
				{ ~randRhythmOrderAssociationFunction.(~rhythmTrack4) }
				{ p == 37 }
				{ ~randRhythmReOrderAssociationFunction.(~rhythmTrack4) }
				{ p == 40 }
				{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmSel1AssociationFunction.(a) } }
				{ p == 41 }
				{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmSelMulAssociationFunction.(a,2) } }
				{ p == 42 }
				{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmSelMulAssociationFunction.(a,5) } }
				{ p == 43 }
				{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmDur1AssociationFunction.(a) } }
				{ p == 44 }
				{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmDurAssociationFunction.(a,3) } }
				{ p == 45 }
				{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmDurAssociationFunction.(a,6) } }
				{ p == 46 }
				{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmOrderAssociationFunction.(a) } }
				{ p == 47 }
				{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmReOrderAssociationFunction.(a) } }
				{ p == 50 }
				{ ~randRhythmAssociationFunctionClear.([~rhythmTrack1,~rhythmTrack2,~rhythmTrack3]) };

				~presetVarsMatrices[~tabbedPresetVarsPage].at(y@x).playing_(true); ~presetVarsMatrices[~tabbedPresetVarsPage].addStyle(~presetVarsMatrices[~tabbedPresetVarsPage].at(y@x), 'playing'); ~presetVarsMatrices[~tabbedPresetVarsPage].refresh;

			}.defer;

		};


		~presetVarsAssociationRefresh = { |i|

			6.do { |h|
				10.do { |v| var b, nb;
					b = ~presetVarsMatrices[i].at(h@v);
					nb = (((h)*10)+(v+1))-1;
					// b.pattern = i;
					// b.title = (i+1).asString + "-" + (((h)*10)+(v+1)).asString;
					// (((h)*10)+(v+1))-1
					if (~presetAssociationNames[i] != 0, {
						if ( ~presetAssociationNames[i][nb].notNil, {
							// b.title = ~presetAssociationNames[i][nb].asString; // Ci dessous pour mettre à la ligne après "-" (à optimiser)
							b.title =
							if ( ~presetAssociationNames[i][nb].asString.contains("-"), {
								~presetAssociationNames[i][nb].asString.split($-)[0].stripWhiteSpace ++ "\n" ++ ~presetAssociationNames[i][nb].asString.split($-)[1].stripWhiteSpace ++ (if (~presetAssociationNames[i][nb].asString.split($-)[2].notNil, { "\n" ++ ~presetAssociationNames[i][nb].asString.split($-)[2].stripWhiteSpace }, {""} ) )
							}, {
								~presetAssociationNames[i][nb].asString;
							});

							/*
							~presetAssociationNames[0][1].asString.split($-)[0] ++ "\n" ++~presetAssociationNames[0][1].asString.split($-)[1] ++
							(if (~presetAssociationNames[0][1].asString.split($-)[2].notNil, { "\n" ++~presetAssociationNames[0][1].asString.split($-)[2] } ) )
							*/

							b.pattern = /*b.title*/ ~presetAssociationNames[i][nb].asSymbol/*.asString*/;
							b.boxColor_(Color.blue(0.7))
						}, {
							/*b.title = "rand";
							b.pattern = Nil;*/
							if (i.inclusivelyBetween(0,8), {
								b.pattern = ~globalRandAssPresets[i][nb];
								b.title = "Rand :" ++ "\n" ++ b.pattern.asString
								/*case
								{ h == 0 }
								{ b.pattern = [~globalDouxPresets[i][0][v], ~globalDouxPresets[i][1][v]] }
								{ h == 1 }
								{ b.pattern = [~globalMixPresets[i][0][v], ~globalMixPresets[i][1][v]] }
								{ h == 2 }
								{ b.pattern = [~globalHardPresets[i][0][v], ~globalHardPresets[i][1][v]] }
								{ h == 3 }
								{ b.pattern = [~global7Presets[i][0][v], ~global7Presets[i][1][v]] }
								{ h == 4 }
								{ b.pattern = [~global8Presets[i][0][v], ~global8Presets[i][1][v]] }
								{ h == 5 }
								{ b.pattern = [~global9Presets[i][0][v], ~global9Presets[i][1][v]] };*/
							}, {
								b.pattern = Nil;
								b.title = "nil";
							});
						})
					}, {
						/*b.title = "rand";
						b.pattern = Nil;*/
						if (i.inclusivelyBetween(0,8), {
							b.pattern = ~globalRandAssPresets[i][nb];
							b.title = "Rand :" ++ "\n" ++ b.pattern.asString
							/*case
							{ h == 0 }
							{ b.pattern = [~globalDouxPresets[i][0][v], ~globalDouxPresets[i][1][v]] }
							{ h == 1 }
							{ b.pattern = [~globalMixPresets[i][0][v], ~globalMixPresets[i][1][v]] }
							{ h == 2 }
							{ b.pattern = [~globalHardPresets[i][0][v], ~globalHardPresets[i][1][v]] }
							{ h == 3 }
							{ b.pattern = [~global7Presets[i][0][v], ~global7Presets[i][1][v]] }
							{ h == 4 }
							{ b.pattern = [~global8Presets[i][0][v], ~global8Presets[i][1][v]] }
							{ h == 5 }
							{ b.pattern = [~global9Presets[i][0][v], ~global9Presets[i][1][v]] };*/
						}, {
							if (i == 9 and: { [0,1,2,3,4,5,6,7,8,10,11,12,13,14,15,16,17,20,21,22,23,24,25,26,27,30,31,32,33,34,35,37,36,37,40,41,42,43,44,45,46,47,50].includes(nb) }, {
								case
								{ nb == 0 }
								{ b.title = "R 5 \nOne"; b.pattern = 0 }
								{ nb == 1 }
								{ b.title = "R 5 \nSel 2 - 4"; b.pattern = 1 }
								{ nb == 2 }
								{ b.title = "R 5 \nSel 2 - 7"; b.pattern = 2 }
								{ nb == 3 }
								{ b.title = "R 5 \nDur 1"; b.pattern = 3 }
								{ nb == 4 }
								{ b.title = "R 5 \nDur 1 - 3"; b.pattern = 4 }
								{ nb == 5 }
								{ b.title = "R 5 \nDur 1 - 6"; b.pattern = 5 }
								{ nb == 6 }
								{ b.title = "R 5 \nRand Order"; b.pattern = 6 }
								{ nb == 7 }
								{ b.title = "R 5 \nReorder"; b.pattern = 7 }
								{ nb == 8 }
								{ b.title = "Clear All\nDurations"; b.pattern = 8 }
								{ nb == 10 }
								{ b.title = "R 6 \nOne"; b.pattern = 10 }
								{ nb == 11 }
								{ b.title = "R 6 \nSel 2 - 4"; b.pattern = 11 }
								{ nb == 12 }
								{ b.title = "R 6 \nSel 2 - 7"; b.pattern = 12 }
								{ nb == 13 }
								{ b.title = "R 6 \nDur 1"; b.pattern = 13 }
								{ nb == 14 }
								{ b.title = "R 6 \nDur 1 - 3"; b.pattern = 14 }
								{ nb == 15 }
								{ b.title = "R 6 \nDur 1 - 6"; b.pattern = 15 }
								{ nb == 16 }
								{ b.title = "R 6 \nRand Order"; b.pattern = 16 }
								{ nb == 17 }
								{ b.title = "R 6 \nReorder"; b.pattern = 17 }
								{ nb == 20 }
								{ b.title = "R 7 \nOne"; b.pattern = 20 }
								{ nb == 21 }
								{ b.title = "R 7 \nSel 2 - 4"; b.pattern = 21 }
								{ nb == 22 }
								{ b.title = "R 7 \nSel 2 - 7"; b.pattern = 22 }
								{ nb == 23 }
								{ b.title = "R 7 \nDur 1"; b.pattern = 23 }
								{ nb == 24 }
								{ b.title = "R 7 \nDur 1 - 3"; b.pattern = 24 }
								{ nb == 25 }
								{ b.title = "R 7 \nDur 1 - 6"; b.pattern = 25 }
								{ nb == 26 }
								{ b.title = "R 7 \nRand Order"; b.pattern = 26 }
								{ nb == 27 }
								{ b.title = "R 7 \nReOrder"; b.pattern = 27 }
								{ nb == 30 }
								{ b.title = "R 8 \nOne"; b.pattern = 30 }
								{ nb == 31 }
								{ b.title = "R 8 \nSel 2 - 4"; b.pattern = 31 }
								{ nb == 32 }
								{ b.title = "R 8 \nSel 2 - 7"; b.pattern = 32 }
								{ nb == 33 }
								{ b.title = "R 8 \nDur 1"; b.pattern = 33 }
								{ nb == 34 }
								{ b.title = "R 8 \nDur 1 - 3"; b.pattern = 34 }
								{ nb == 35 }
								{ b.title = "R 8 \nDur 1 - 6"; b.pattern = 35 }
								{ nb == 36 }
								{ b.title = "R 8 \nRand Order"; b.pattern = 36 }
								{ nb == 37 }
								{ b.title = "R 8 \nReOrder"; b.pattern = 37 }
								{ nb == 40 }
								{ b.title = "R All \nOne"; b.pattern = 40 }
								{ nb == 41 }
								{ b.title = "R All \nSel 2 - 4"; b.pattern = 41 }
								{ nb == 42 }
								{ b.title = "R All \nSel 2 - 7"; b.pattern = 42 }
								{ nb == 43 }
								{ b.title = "R All \nDur 1"; b.pattern = 43 }
								{ nb == 44 }
								{ b.title = "R All \nDur 1 - 3"; b.pattern = 44 }
								{ nb == 45 }
								{ b.title = "R All \nDur 1 - 6"; b.pattern = 45 }
								{ nb == 46 }
								{ b.title = "R All \nRand Order"; b.pattern = 46 }
								{ nb == 47 }
								{ b.title = "R All \nReorder"; b.pattern = 47 }
								{ nb == 50 }
								{ b.title = "Clear All\nDurations"; b.pattern = 50 }
							},{
								b.pattern = Nil;
								b.title = "nil";
							});
						});
					});
					b.playing = false;
				}
			};

			~presetVarsMatrices[i].mouseDownAction = { arg box, modifiers, buttonNumber, clicks;

				// [box,modifiers,buttonNumber,clicks].debug;
				/*if (clicks==2,{
				box.title = 100.rand.asString
				});*/

				if (~presetVarsLastSelection[i] != 0, { // Pour n'avoir q'une sélection à la fois
					~presetVarsMatrices[i].at(~presetVarsLastSelection[i]).playing_(false); ~presetVarsMatrices[i].removeStyle(~presetVarsMatrices[i].at(~presetVarsLastSelection[i]), 'playing'); // {~presetVarsMatrices[0].refresh }.defer;
				});

				if (box[\playing] == true, {
					box.playing = false;
					// ["stop:",box.pattern].postln; // kill a sound
					~presetVarsMatrices[i].removeStyle(box,'playing');
				}, {
					// box.postln;
					// box.title.asSymbol.postln;

					/*if (box.pattern.class == Symbol /*!= Nil*/) { ~loadPresetTracksRanges.(\tabbedPresetVarsPage, box.pattern); ("Preset Ass :" + box.pattern).postln }
					{ if (box.pattern.class == Array) { ~randAssociationFunction.(~sequenceAssociationTrackFormat[i], box.pattern); ("Preset Ass Rand :" + ~sequenceAssociationTrackFormat[i].asString + box.pattern).postln } };*/

					case
					{ box.pattern.class == Symbol /*!= Nil*/ }
					{
						if (i == 0  or: {i == 1}, {
							~loadPresetTracksRanges.(\tabbedPresetVarsPage, box.pattern, ~sequenceAssociationTrackFormat[i]); ("Preset Ass :" + box.pattern).postln;
						},{
							~loadPresetTracksRanges.(\tabbedPresetVarsPage, box.pattern); ("Preset Ass :" + box.pattern).postln;
						})
					}
					{ box.pattern.class == Array }
					{
						if (i > 4, {
							~randRyAssociationFunction.(~sequenceAssociationTrackFormat[i], box.pattern); ("Preset Ass Rand :" + ~sequenceAssociationTrackFormat[i].asString + box.pattern).postln
						},{
							~randAssociationFunction.(~sequenceAssociationTrackFormat[i], box.pattern); ("Preset Ass Rand :" + ~sequenceAssociationTrackFormat[i].asString + box.pattern).postln
						});
					}
					{ box.pattern == 0 }
					{ ~randRhythmSel1AssociationFunction.(~rhythmTrack1); }
					{ box.pattern == 1 }
					{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack1,2) }
					{ box.pattern == 2 }
					{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack1,5) }
					{ box.pattern == 3 }
					{ ~randRhythmDur1AssociationFunction.(~rhythmTrack1) }
					{ box.pattern == 4 }
					{ ~randRhythmDurAssociationFunction.(~rhythmTrack1,3) }
					{ box.pattern == 5 }
					{ ~randRhythmDurAssociationFunction.(~rhythmTrack1,6) }
					{ box.pattern == 6 }
					{ ~randRhythmOrderAssociationFunction.(~rhythmTrack1) }
					{ box.pattern == 7 }
					{ ~randRhythmReOrderAssociationFunction.(~rhythmTrack1) }
					{ box.pattern == 8 }
					{ ~randRhythmAssociationFunctionClear.([~rhythmTrack1,~rhythmTrack2,~rhythmTrack3]) }
					{ box.pattern == 10 }
					{ ~randRhythmSel1AssociationFunction.(~rhythmTrack2) }
					{ box.pattern == 11 }
					{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack2,2) }
					{ box.pattern == 12 }
					{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack2,5) }
					{ box.pattern == 13 }
					{ ~randRhythmDur1AssociationFunction.(~rhythmTrack2) }
					{ box.pattern == 14 }
					{ ~randRhythmDurAssociationFunction.(~rhythmTrack2,3) }
					{ box.pattern == 15 }
					{ ~randRhythmDurAssociationFunction.(~rhythmTrack2,6) }
					{ box.pattern == 16 }
					{ ~randRhythmOrderAssociationFunction.(~rhythmTrack2) }
					{ box.pattern == 17 }
					{ ~randRhythmReOrderAssociationFunction.(~rhythmTrack2) }
					{ box.pattern == 20 }
					{ ~randRhythmSel1AssociationFunction.(~rhythmTrack3) }
					{ box.pattern == 21 }
					{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack3,2) }
					{ box.pattern == 22 }
					{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack3,5) }
					{ box.pattern == 23 }
					{ ~randRhythmDur1AssociationFunction.(~rhythmTrack3) }
					{ box.pattern == 24 }
					{ ~randRhythmDurAssociationFunction.(~rhythmTrack3,3) }
					{ box.pattern == 25 }
					{ ~randRhythmDurAssociationFunction.(~rhythmTrack3,6) }
					{ box.pattern == 26 }
					{ ~randRhythmOrderAssociationFunction.(~rhythmTrack3) }
					{ box.pattern == 27 }
					{ ~randRhythmReOrderAssociationFunction.(~rhythmTrack3) }
					{ box.pattern == 30 }
					{ ~randRhythmSel1AssociationFunction.(~rhythmTrack4) }
					{ box.pattern == 31 }
					{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack4,2) }
					{ box.pattern == 32 }
					{ ~randRhythmSelMulAssociationFunction.(~rhythmTrack4,5) }
					{ box.pattern == 33 }
					{ ~randRhythmDur1AssociationFunction.(~rhythmTrack4) }
					{ box.pattern == 34 }
					{ ~randRhythmDurAssociationFunction.(~rhythmTrack4,3) }
					{ box.pattern == 35 }
					{ ~randRhythmDurAssociationFunction.(~rhythmTrack4,6) }
					{ box.pattern == 36 }
					{ ~randRhythmOrderAssociationFunction.(~rhythmTrack4) }
					{ box.pattern == 37 }
					{ ~randRhythmReOrderAssociationFunction.(~rhythmTrack4) }
					{ box.pattern == 40 }
					{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmSel1AssociationFunction.(a) } }
					{ box.pattern == 41 }
					{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmSelMulAssociationFunction.(a,2) } }
					{ box.pattern == 42 }
					{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmSelMulAssociationFunction.(a,5) } }
					{ box.pattern == 43 }
					{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmDur1AssociationFunction.(a) } }
					{ box.pattern == 44 }
					{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmDurAssociationFunction.(a,3) } }
					{ box.pattern == 45 }
					{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmDurAssociationFunction.(a,6) } }
					{ box.pattern == 46 }
					{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmOrderAssociationFunction.(a) } }
					{ box.pattern == 47 }
					{ [~rhythmTrack1,~rhythmTrack2,~rhythmTrack3].do { |a| ~randRhythmReOrderAssociationFunction.(a) } }
					{ box.pattern == 50 }
					{ ~randRhythmAssociationFunctionClear.([~rhythmTrack1,~rhythmTrack2,~rhythmTrack3]) };

					// ~loadPresetTracksRanges.(\tabbedPresetVarsPage, 'R1');
					box.playing = true;
					// ["play:",box.pattern].postln; // launch a sound
					~presetVarsMatrices[i].addStyle(box,'playing');
				});

				// box[\playing].postln;

				~presetVarsLastSelection[i] = (box.point.x)@(box.point.y);

			};

			// Copy or move
			/*~presetVarsMatrices[i].onBoxDrag = { arg fromBox,toBox,modifier;
			var newTitle;
			[fromBox,toBox].debug;
			if(modifier.isAlt,{
			// option drag copies
			~presetVarsMatrices[i].copy(fromBox.point,toBox.point);

			newTitle = (fromBox.title ? "") + "copy";
			// won't work: we just copied into that location
			// so the toBox we have here has been replaced
			// toBox.title = newTitle;

			toBox = ~presetVarsMatrices[i].at(toBox.point);
			toBox.title = newTitle;
			~presetVarsMatrices[i].refresh
			},{
			// else move it
			~presetVarsMatrices[i].move(fromBox.point,toBox.point);
			});
			};*/

			// Swap si Alt Clic - ne marche pas ???
			~presetVarsMatrices[i].onBoxDrag = { arg fromBox, toBox, modifier;

				if (modifier.isAlt, {
					var t1, t2, p1, p2;
					t1 = fromBox.title; t2 = toBox.title; p1 = fromBox.pattern; p2 = toBox.pattern;
					fromBox.title = t2; toBox.title = t1; fromBox.pattern = p2; toBox.pattern = p1;
					// ~presetVarsMatrices[i].swap(fromBox.point,toBox.point); // ne marche pas ???
					// [fromBox,toBox].debug;
					// ~presetVarsMatrices[i].refresh
				});
			};

			/*~presetVarsSliderView.action_({ |view|
			~presetVarsSlider = ~presetVarsSliderSpec.map(view.value) -1;
			~presetVarsSliderViewFunction.(~presetVarsSlider);
			view.string = "Preset Ass N° : %".format((~presetVarsSlider+1).asInteger);
			});*/

			~presetVarsMatrices[i].refresh;

		};


		~nbOfpresetVarsPages.do{ |i|

			~presetVarsMatrices[i].defaultStyle
			.boxColor_(Color.grey(0.4)).borderColor_(Color.red)
			.font_(Font("Helvetica", 12*~fontSizeMul)).fontColor_(Color.white).center_(true);

			// ~presetVarsMatrices[i].styles['down'] = (boxColor: { arg c; c.darken(Color.red,0.9) });
			~presetVarsMatrices[i].styles['focused'] =  (borderColor: Color.yellow);
			~presetVarsMatrices[i].styles['playing'] = (boxColor: Color.red(1));

			~presetVarsMatrices[i].defaultStyle.center = true;

			~presetVarsAssociationRefresh.(i);

			~presetVarsWindow.front;

	});


	~presetVarsChangeView = RoundSlider(~controlWindowTrig, Rect(260*~xSizeMul, 80*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
	.action_({ |view|
		case
		{view.value == 1} { ~presetVarsWindow.setTopLeftBounds(Rect(/*(1516+~windowWidth-1920)*~xSizeMul*/ ~windowWidth-5-(399*~xSizeMul), (586+~windowTopMargin)*~ySizeMul, 400*~xSizeMul, 540*~ySizeMul) /*(1515, 511, 402, 594+14+4)*/); }
		{view.value == (3/4)} { ~presetVarsWindow.setTopLeftBounds(Rect(/*(1516+~windowWidth-1920)*~xSizeMul*/ ~windowWidth-5-(399*~xSizeMul), (44+~windowTopMargin)*~ySizeMul, 400*~xSizeMul, 540*~ySizeMul)); }
		{view.value == (2/4)} { ~presetVarsWindow.setTopLeftBounds(Rect(/*(1116+~windowWidth-1920)*~xSizeMul*/ ~windowWidth-5-(399*2*~xSizeMul), (44+~windowTopMargin)*~ySizeMul, 400*~xSizeMul, 540*~ySizeMul)); }
		{view.value == (1/4)} { ~presetVarsWindow.setTopLeftBounds(Rect(/*(717+~windowWidth-1920)*~xSizeMul*/ ~windowWidth-5-(399*3*~xSizeMul), (44+~windowTopMargin)*~ySizeMul, 400*~xSizeMul, 540*~ySizeMul)); }
		{view.value == 0} { ~presetVarsWindow.setTopLeftBounds(Rect(/*(317+~windowWidth-1920)*~xSizeMul*/  ~windowWidth-5-(399*4*~xSizeMul), (586+~windowTopMargin)*~ySizeMul, 400*~xSizeMul, 540*~ySizeMul)); } // 1920 - 317
	})
	.font_(Font("Verdana", 10*~fontSizeMul,true))
	.background_(Color.blue/*~sliderBackgroundColor*/)
	.hilightColor_(Color.new255(138, 43, 226)/*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1/4)
	.valueAction_(1);


	~presetVarsOpenView = RoundButton(~controlWindowTrig, Rect(260*~xSizeMul, 100*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
	.states_([["PVarsW", Color.white, Color.red], ["PVarsW", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({|i| ~presetVarsWindowStatus = i.value;

		if (~presetVarsWindowStatus == 1, {
			~presetVarsWindow.visible_(1);
		}, {
			// ~presetVarsWindow.close;
			~presetVarsWindow.visible_(0);
		});

		// ~presetVarsWindow.onClose = {~presetVarsOpenView.valueAction_(0); ~presetVarsWindowStatus = 0}; // Plus necessaire car la fenêtre est juste rendue invisible

		if (~lemurConnected1 == 1, { ~lemurAdress1.sendMsg( "/OpenPresetWindow/x", ~presetVarsWindowStatus) });
		if (~lemurConnected2 == 1, { ~lemurAdress2.sendMsg( "/OpenPresetWindow/x", ~presetVarsWindowStatus) });

	});

	~presetVarsOpenView.value_(/*1*/ if (~initSeqOrPerfMode == 0, {0}, {1}) ).doAction;


	~listPresetAssociationNewSort = { |i| 6.do { |h| 10.do { |v| var b, nb; b = ~presetVarsMatrices[i].at(h@v); b.pattern.postln; } } };
	// ~listPresetAssociationNewSort.(0); // Postln les new ~presetAssociationNames[0] swapés
	~listPresetAssociationNewSortA = { |i| "~presetAssociationNames["++i++"] = "++ 6.collect { |h| 10.collect { |v| var b, nb; b = ~presetVarsMatrices[i].at(h@v); b.pattern; } }.flatten.cs };
	// ~listPresetAssociationNewSortA.(0); // Post l'Array des new ~presetAssociationNames[0] swapés




















	// Contrôle de les pistes rythmiques (Volume / Spatialisation / Buffers ...)

	~controlWindowSpaRy = CompositeView(~controlWindow, Rect(0, 360*~ySizeMul, 315*~xSizeMul, 134*~ySizeMul)).background = Color.grey(0.6);

	~presetVarsVolFocusView = RoundButton(~controlWindowSpaRy, Rect(4*~xSizeMul, 2*~ySizeMul, 32*~xSizeMul, 22*~ySizeMul))
	.states_([["VFoc", Color.white, Color.red], ["VFoc", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i| ~presetVarsVolFocus = i.value;

		// Le code ci-dessous pour permettre de couper ou d'allumer aléatoirement les volumes avec r n'a pas l'air de marcher...
		// Rebasculement vers les KeyActions

		/*if (~presetVarsVolFocus == 0, {
		~presetVarsVolSliderView.view.canFocus_(false).focus(false)
		},{
		~presetVarsVolSliderView.view.canFocus_(true).focus(true);
		~presetVarsWindow.view.focus(true)
		// ~presetVarsVolSliderView.valueAction_(0).valueAction_(1);
		});*/
		/*if (~lemurConnected1 == 1, { ~lemurAdress1.sendMsg( "/RatPresetVar/x", ~presetRyRatSwitch) });
		if (~lemurConnected2 == 1, { ~lemurAdress2.sendMsg( "/RatPresetVar/x", ~presetRyRatSwitch) });*/

	}).valueAction_(0);

	~defaultPresetVarsMenuView = View(~controlWindowSpaRy, Rect(38*~xSizeMul, 2*~ySizeMul, 38*~xSizeMul, 22*~ySizeMul)); // Pour afficher les dossiers-sons dans leur intégralité dans le PopUp menu

	~defaultPresetVarsMenu = PopUpMenu.new(~defaultPresetVarsMenuView,  Rect(0, 0, 68*~xSizeMul, 22*~ySizeMul))
	.action_({|menu| ~defaultPresetVars = menu./*item*/value/*.asInteger*/;
		case
		{ ~defaultPresetVars == 0 } { ~presetVarsSpaTimeRandSlider.valueAction_(0.04); ~presetVarsRatTimeRandSlider.valueAction_(0.31); }
		{ ~defaultPresetVars == 1 } { ~presetVarsSpaTimeRandSlider.valueAction_(0.09); ~presetVarsRatTimeRandSlider.valueAction_(0.48); }
		{ ~defaultPresetVars == 2 } { ~presetVarsSpaTimeRandSlider.valueAction_(0.16); ~presetVarsRatTimeRandSlider.valueAction_(0.61); }
	})
	.allowsReselection_(true)
	.background_(Color.yellow)
	.stringColor_(Color.red)
	.font_(Font("Verdana", 9*~fontSizeMul /*, bold: true*/))
	.items_([ "T1", "T2", "T3" ])
	.value_(1); // .valueAction_(0);

	~triggerSpaSeqsView = RoundButton(~controlWindowSpaRy, Rect(78*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 22*~ySizeMul))
	.states_([["S1", Color.white, Color.blue], ["SSel", Color.white, Color.magenta] /*, ["Pre", Color.black, Color.yellow]*/ ])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({ |i| ~triggerSpaSeqs = i.value })
	.valueAction_(1);

	~multiStereoRyView = RoundButton(~controlWindowSpaRy, Rect(110*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 22*~ySizeMul))
	.states_([["Ster Ry", Color.white, Color.blue], ["Multi Ry", Color.white, Color.green(0.4)]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i| var a = i.value;
		~rhythmTracks.do { |tr| ~multiStereoControlView[tr].valueAction_(a) };
		if (a == 1, {
			~multiStereoRandRyRout2View.valueAction_(0);
			~rhythmTracks.do { |b| ~outsConfigControlView[b].valueAction_(0) };
			~multiStereoRandRyRout2View.visible_(0); ~stereoRandSelectView.visible_(0);
		},{
			// if (~multiStereoA == 1, { ~multiStereoRandRyRout2View.valueAction_(1) }, { ~multiStereoRandRyRout2View.valueAction_(0) }); // Pour lancer l'aléatoire de la Stéréo dès que le Multi est enclenché
			~rhythmTracks.do { |b| ~outsConfigControlView[b].valueAction_(0) };
			~multiStereoRandRyRout2View.visible_(1); ~stereoRandSelectView.visible_(1);
		})
	});

	~folderRyGroupItems = ( ["All", "Buf"] ++ [ "dbd", "din", "dtv", "nbi", "ntx" ] ++ ~kindOfFolders ); // Parme
	// ~folderRyGroupItems = ( ["All", "Buf"] ++ [ "dbd", "din", "dtv", "nbi", /*"ntx"*/ ] ++ ~kindOfFolders ); // Adaptation Parme / Dhomont

	~folderRyRandViewView  = View(~controlWindowSpaRy, Rect(162*~xSizeMul, 2*~ySizeMul, 44*~xSizeMul, 21*~ySizeMul)); // Pour afficher les dossiers-sons dans leur intégralité dans le PopUp menu

	~folderRyRandView = PopUpMenu.new(~folderRyRandViewView, Rect(0, 0, 74*~xSizeMul, 21*~ySizeMul))
	.action_({|menu| ~folderRyRand = menu./*item*/value.asInteger })
	.allowsReselection_(true)
	.background_(Color.white)
	.stringColor_(Color.red)
	.font_(Font("Verdana",(10*~fontSizeMul).asInteger /*, bold: true*/));
	// ~folderRyRandView.items_([ "Buf", "A", "D", "I", "P", "P+", "ALL"]) // Valeur par défault 5
	~folderRyRandView.items_(~folderRyGroupItems) // Pour Parme & Suite
	.valueAction_(1);

	~folRandViewRy = RoundButton(~controlWindowSpaRy, Rect(208*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 22*~ySizeMul))
	.states_([["FOL", Color.red, Color.white]])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({ |a|
		~rhythmTracksX2.do {|i| ~folRandViewG[i].valueAction_(1); }
	});

	~retriggerPresetViewRy = RoundButton(~controlWindowSpaRy, Rect(260*~xSizeMul, 2*~ySizeMul, 52*~xSizeMul, 22*~ySizeMul))
	.states_([["Sel Ry", Color.black, Color.new255(255, 165, 0) ]])
	.font_(Font("Verdana",10*~fontSizeMul, bold: true))
	.action_({ |a|
		{ "WAIT RESETTING PRESETS OF RHYTHM TRACKS !".postln;
			~rhythmTracksX2.do {|i| ~retriggerPresetViewG[i].valueAction_(1); 0.02.wait; };
			"OK GO !".postln;
		}.fork(AppClock);
	});


	~prevRyTrackVols = 0 ! ~rhythmTracks.size;
	case
	{ ~rhythmTracks.size == 3 }
	{ ~presetVarsVolMuteSwitch = [ [0,0,0], [1,0,0], [0,1,0], [0,0,1], [1,1,0], [1,0,1], [0,1,1], [1,1,1] ]; }
	{ ~rhythmTracks.size == 4 }
	{ ~presetVarsVolMuteSwitch = [ [ 0, 0, 0, 0 ], [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ], [ 1, 1, 0, 0 ], [ 1, 0, 1, 0 ], [ 1, 0, 0, 1 ], [ 0, 0, 1, 1 ], [ 0, 1, 1, 0 ], [ 0, 1, 0, 1 ], [ 1, 1, 1, 0 ], [ 1, 1, 0, 1 ], [ 1, 0, 1, 1 ], [ 0, 1, 1, 1 ], [ 1, 1, 1, 1 ] ] }
	{ ~rhythmTracks.size == 5 }
	// [1, 2, 3].powerset.postln // Returns all possible combinations of the array's elements.
	// [1, 2, 3].powerset.sort({ |a, b| a.size > b.size }); // sort by size, big first
	// [1, 2, 3].powerset.sort({ |a, b| a.size > b.size }).reverse; // by size, small first
	// allTuples([0,1]!4)
	// 4.enum([0,1]).cs
	// f = { |n=4| allTuples([0,1]!n) }; // f.(5);
	{ ~presetVarsVolMuteSwitch = [ [ 0, 0, 0, 0, 0 ], [ 1, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 1 ],
		[ 1, 1, 0, 0, 0 ], [ 1, 0, 1, 0, 0 ], [ 1, 0, 0, 1, 0 ], [ 1, 0, 0, 0, 1 ], [ 0, 1, 1, 0, 0 ], [ 0, 1, 0, 1, 0 ], [ 0, 1, 0, 0, 1 ], [ 0, 0, 1, 1, 0 ], [ 0, 0, 1, 0, 1 ], [ 0, 0, 0, 1, 1 ],
		[ 1, 1, 1, 0, 0 ], [ 1, 1, 0, 1, 0 ], [ 1, 1, 0, 0, 1 ], [ 1, 0, 1, 0, 1 ], [ 1, 0, 1, 1, 0 ], [ 1, 0, 0, 1, 1 ], [ 0, 1, 1, 0, 1 ], [ 0, 1, 1, 1, 0 ], [ 0, 1, 0, 1, 1 ], [ 0, 0, 1, 1, 1 ],
		[ 1, 1, 1, 1, 0 ], [ 1, 1, 1, 0, 1 ], [ 1, 1, 0, 1, 1 ], [ 1, 0, 1, 1, 1 ], [ 0, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ] };

	~presetVarsVol2Spec = ControlSpec(0, ~presetVarsVolMuteSwitch.size-1, \lin, 1);
	~presetVarsVol2SliderView = SmoothSlider(~controlWindowSpaRy, Rect(4*~xSizeMul, 27*~ySizeMul, 70*~xSizeMul, 26*~ySizeMul))
	.action_({ |view| ~presetVarsVol2 = ~presetVarsVol2Spec.map(view.value);
		~rhythmTracks.do { |i, id|
			if (~trackVol[i] !=0, { ~prevRyTrackVols[id] = ~trackVol[i] });
			~trackVolView[i].valueAction_(~presetVarsVolMuteSwitch[~presetVarsVol2][id] * ~prevRyTrackVols[id])
		};
		// view.string = "At : %".format(~presetVarsVol);
		view.string = (~presetVarsVolMuteSwitch[~presetVarsVol2]).asString.replace(" ",""); // Y a t-il qqch de plus performant pour retirer les espaces ???
		if (~presetVarsVol2 == 0, { ~presetVarsVolSliderView.value_(0).string = "Mute"; });
		if (~presetVarsVol2 == (~presetVarsVolMuteSwitch.size-1), { ~presetVarsVolSliderView.value_(1).string = "ALL"; });
	})
	.font_(Font("Verdana", 10*~fontSizeMul /*,true*/))
	.background_(Color.red/*~sliderBackgroundColor*/)
	.hilightColor_(Color.new255(138, 43, 226)/*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1/(~presetVarsVolMuteSwitch.size-1));
	// .valueAction_(7);

	~presetVarsVolSlider0 = (0 ! ~rhythmTracks.size).asString.replace(" ","");
	~presetVarsVolSliderA = (1 ! ~rhythmTracks.size).asString.replace(" ","");

	~presetVarsVolSpec = ControlSpec(0,1, \lin, 1);
	~presetVarsVolSliderView = SmoothSlider(~controlWindowSpaRy, Rect(76*~xSizeMul, 27*~ySizeMul, 32*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| var prev; ~presetVarsVol = ~presetVarsVolSpec.map(view.value);
		// view.string = "At : %".format(~presetVarsVol);
		prev = ~insSliderFadeTime; ~insSliderFadeTime = 0.7; // n'a pas l'air de marcher ???????????
		~rhythmTracks.do { |i, ind| if (~trackVol[i] !=0, { ~prevRyTrackVols[ind] = ~trackVol[i] }) };
		if (~presetVarsVol == 0, {
			~rhythmTracks.do { |i, id| ~trackVolView[i].valueAction_(0) };
			view.string = "Mute";
			~presetVarsVol2SliderView.value_(0).string = ~presetVarsVolSlider0;
		},{
			~rhythmTracks.do { |i, id| ~trackVolView[i].valueAction_(1 * ~prevRyTrackVols[id]) };
			view.string = "ALL";
			~presetVarsVol2SliderView.value_(7).string = ~presetVarsVolSliderA;
		});
		// ~insSliderFadeTime.postln;
		~insSliderFadeTime = prev;
	})
	.font_(Font("Verdana", 10*~fontSizeMul /*,true*/))
	.background_(Color.red/*~sliderBackgroundColor*/)
	.hilightColor_(Color.new255(138, 43, 226)/*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1)
	.valueAction_(1);


	~presetVarsSpaSwitchNames = [ "C 1", "C SD", "CMul Reg-", "CMul Reg+", "CMul Var-", "CMul Var+", "C All-", "C All+" , "2", "All", "MPan Def" /*, "Multi Ry Default", "Acous Big Stereo"*/ ];

	~presetVarsSpaSwitchF = [ // voir la variation en rajoutant un ListView entre ~spaRandViewG[i].valueAction_(1) & la fonction PWhite - TO DO

		{ |tracks| // C1 // Peu de rotations XXXXXX
			tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(4); // de 4 à 9 pour les circulaires (6 pour Circulaire Mul Var)
				~panRangePresetViewG[i].valueAction_([0,3,5].choose); // 0 pour L (extrême) / 3 LC (moyen) / 5 Mid (encore plus modéré)
				~spaRandViewG[i].valueAction_(1); ~spaPatViewG[i].valueAction_(0) } },

		{ |tracks| // C SD // XXXXXX
			tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(8); // de 4 à 9 pour les circulaires (6 pour Circulaire Mul Var)
				~panRangePresetViewG[i].valueAction_([0,3,5].choose); // 0 pour L (extrême) / 3 LC (moyen) / 5 Mid (encore plus modéré)
				~spaRandViewG[i].valueAction_(1); ~spaPatViewG[i].valueAction_(0) } },

		{ |tracks| // C Mul Reg - // Rotations très rapides mais parfois un peu moins - pour + de variations XXX
			tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(5);
				~panRangePresetViewG[i].valueAction_([0,3,5].choose);
				~spaRandViewG[i].valueAction_(1); ~spaPatViewG[i].valueAction_(0) } },

		{ |tracks| // C Mul Reg + // Rotations tout le temps très rapide à cause du L XXXXXX
			tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(5);
				~panRangePresetViewG[i].valueAction_(0);
				~spaRandViewG[i].valueAction_(1); ~spaPatViewG[i].valueAction_(0) } },

		{ |tracks| // C Mul Var - // Rotations très rapides mais parfois un peu moins - pour + de variations XXXXXX
			tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(6);
				~panRangePresetViewG[i].valueAction_([0,3,5].choose);
				~spaRandViewG[i].valueAction_(1); ~spaPatViewG[i].valueAction_(0) } },

		{ |tracks| // C Mul Var + // Rotation très rapide à cause du L XXX
			tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(6);
				~panRangePresetViewG[i].valueAction_(0);
				~spaRandViewG[i].valueAction_(1); ~spaPatViewG[i].valueAction_(0) } },

		{ |tracks| // C ALL - // XXXXXX
			tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(9);
				~panRangePresetViewG[i].valueAction_([0,3,5].choose);
				~spaRandViewG[i].valueAction_(1); ~spaPatViewG[i].valueAction_(0) } },

		{ |tracks| // C ALL + // Rotation très rapide à cause du L mais avec quelques éléments + statiques XXXXXX
			tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(9);
				~panRangePresetViewG[i].valueAction_(0);
				~spaRandViewG[i].valueAction_(1); ~spaPatViewG[i].valueAction_(0) } },

		{ |tracks| // 2 Mob // Peu de rotations XXXXXX
			tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(2);
				~panRangePresetViewG[i].valueAction_([0,3,5].choose);
				~spaRandViewG[i].valueAction_(1); ~spaPatViewG[i].valueAction_(0) } },

		{ |tracks| // ALL // Beaucoup de rotations XXXXXX
			tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(13);
				~panRangePresetViewG[i].valueAction_(0);
				~spaRandViewG[i].valueAction_(1); ~spaPatViewG[i].valueAction_(0) } },

		{ |tracks| // Pan classique // Spatialisation par défaut tournante XXXXXX // N° 10 en partant de 0
			tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(0);
				~panRangePresetViewG[i].valueAction_(1); // 1 pour être extrêmement centré et ne pas avoir de panning.... à voir ?
				// Mais quand on repasse dans un range plus grand, discrétisation en 3 points, donc ~spaRandViewG[i].valueAction_(1); necessaire pour randomizer de nouveau le multislider du pan et du span
				~spaRandViewG[i].valueAction_(1); ~spaPatViewG[i].valueAction_(0) } }

		/*
		( // 12 Traj (TROP aléatoire) -> oublier
		[9,11,13].do { |i| ~spaRangePresetViewG[i].valueAction_(12);
		~panRangePresetViewG[i].valueAction_([0,3,5].choose);
		~spaRandViewG[i].valueAction_(1);  ~spaPatViewG[i].valueAction_(0) };
		)

		( // 13 All (ASSEZ aléatoire, et parfois bonnes surprises)
		[9,11,13].do { |i| ~spaRangePresetViewG[i].valueAction_(13);
		~panRangePresetViewG[i].valueAction_([0,3,5].choose);
		~spaRandViewG[i].valueAction_(1);  ~spaPatViewG[i].valueAction_(0) };
		)
		*/

		/*
		if (~lemurConnected1 == 1, { ~lemurAdress1.sendMsg( "/MultiStereoRandRySwitch/x", ~multiStereoRandRySwitch) }); // Sert à quoi ????
		if (~lemurConnected2 == 1, { ~lemurAdress2.sendMsg( "/MultiStereoRandRySwitch/x", ~multiStereoRandRySwitch) });
		}*/

	];

	~controlWindowSpaRyBts = CompositeView(~controlWindowSpaRy, Rect(185*~xSizeMul, 27*~ySizeMul, 91*~xSizeMul, 28*~ySizeMul)).background = Color.grey(0.7);

	~multiStereoRandRy1View = RoundButton(~controlWindowSpaRyBts, Rect(0, 0, 18*~xSizeMul, 14*~ySizeMul))
	.states_([["C1", Color.white, Color.green(0.3)]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i|	~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(0)).doAction; // ~presetVarsSpaSwitchF[0].([9,11,13]); // ~presetVarsSpaSwitchNames[0].postln;
	});

	~multiStereoRandRy2View = RoundButton(~controlWindowSpaRyBts, Rect(0, 15*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
	.states_([["SD", Color.white, Color.green(0.3)]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i|	~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(1)).doAction; });

	~multiStereoRandRy3View = RoundButton(~controlWindowSpaRyBts, Rect(18*~xSizeMul, 0, 18*~xSizeMul, 14*~ySizeMul))
	.states_([["R-", Color.white, Color.green(0.3)]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i|	~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(2)).doAction; });

	~multiStereoRandRy4View = RoundButton(~controlWindowSpaRyBts, Rect(18*~xSizeMul, 15*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
	.states_([["R+", Color.green(0.3), Color.white]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i|	~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(3)).doAction; });

	~multiStereoRandRy5View = RoundButton(~controlWindowSpaRyBts, Rect(36*~xSizeMul, 0, 18*~xSizeMul, 14*~ySizeMul))
	.states_([["V-", Color.white, Color.green(0.3)]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i|	~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(4)).doAction; });

	~multiStereoRandRy6View = RoundButton(~controlWindowSpaRyBts, Rect(36*~xSizeMul, 15*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
	.states_([["V+", Color.green(0.3), Color.white]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i|	~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(5)).doAction; });

	~multiStereoRandRy7View = RoundButton(~controlWindowSpaRyBts, Rect(54*~xSizeMul, 0, 18*~xSizeMul, 14*~ySizeMul))
	.states_([["C-", Color.white, Color.green(0.3)]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i|	~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(6)).doAction; });

	~multiStereoRandRy8View = RoundButton(~controlWindowSpaRyBts, Rect(54*~xSizeMul, 15*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
	.states_([["C+", Color.white, Color.green(0.3)]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i|	~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(7)).doAction; });

	~multiStereoRandRy9View = RoundButton(~controlWindowSpaRyBts, Rect(72*~xSizeMul, 0, 18*~xSizeMul, 14*~ySizeMul))
	.states_([["2", Color.white, Color.green(0.3)]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i|	~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(8)).doAction; });

	~multiStereoRandRy10View = RoundButton(~controlWindowSpaRyBts, Rect(72*~xSizeMul, 15*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
	.states_([["A+", Color.white, Color.green(0.3)]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i|	~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(9)).doAction; });


	if (~acousItems.notNil, {

		~presetVarsSpaSwitchNames = ~presetVarsSpaSwitchNames.addAll ([ "Acous 11",  "Acous 1a",  "Acous 1b", "Acous 21",  "Acous 2a",  "Acous 2b", "Acous 31",  "Acous 3a",  "Acous 3b", "Acous 41",  "Acous 4a",  "Acous 4b", "Acous A1",  "Acous Aa",  "Acous Ab"  ]);

		~spaPatAcousFunc = { |t, v|
			case
			{ ~acousTypeSens == 0 }
			{ ~spaPatSelViewG[t].valueAction_(/*15*/v); ~spaPatViewG[t].valueAction_(1); ~panRangePresetViewG[t].valueAction_(1); }
			{ ~acousTypeSens == 1 }
			{ ~spaPatSelViewG[t].valueAction_(v+1); ~spaPatViewG[t].valueAction_(1); ~panRangePresetViewG[t].valueAction_(1); }
			{ ~acousTypeSens == 2 }
			{ ~spaPatSelViewG[t].valueAction_(v+2); ~spaPatViewG[t].valueAction_(1); ~panRangePresetViewG[t].valueAction_(1); }
			{ ~acousTypeSens == 3 }
			{ ~spaPatSelViewG[t].valueAction_(v+3.rand); ~spaPatViewG[t].valueAction_(1); ~panRangePresetViewG[t].valueAction_(1); }
			{ ~acousTypeSens == 4 }
			{ ~spaPatSelViewG[t].valueAction_(4); ~spaPatViewG[t].valueAction_(1) }
		};

		~presetVarsSpaSwitchF = ~presetVarsSpaSwitchF.addAll ([
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(14); ~spaPatAcousFunc.(i, 15) }; }, // Acous 11 - 11
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(14); ~spaPatAcousFunc.(i, 18) }; }, // Acous 1a - 12
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(14); ~spaPatAcousFunc.(i, 21) }; }, // Acous 1b - 13
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(15); ~spaPatAcousFunc.(i, 15) }; }, // Acous 21 - 14
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(15); ~spaPatAcousFunc.(i, 18) }; }, // Acous 2a - 15
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(15); ~spaPatAcousFunc.(i, 21) }; }, // Acous 2b - 16
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(16); ~spaPatAcousFunc.(i, 15) }; }, // Acous 31 - 17
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(16); ~spaPatAcousFunc.(i, 18) }; }, // Acous 3a - 18
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(16); ~spaPatAcousFunc.(i, 21) }; }, // Acous 3b - 19
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(17); ~spaPatAcousFunc.(i, 15) }; }, // Acous 41 - 20
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(17); ~spaPatAcousFunc.(i, 18) }; }, // Acous 4a - 21
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(17); ~spaPatAcousFunc.(i, 21) }; }, // Acous 4b - 22
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(18); ~spaPatAcousFunc.(i, 15) }; }, // Acous A1 - 23
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(18); ~spaPatAcousFunc.(i, 18) }; }, // Acous Aa - 24
			{ |tracks| tracks.do { |i| ~spaRangePresetViewG[i].valueAction_(18); ~spaPatAcousFunc.(i, 21) }; }, // Acous Ab - 25
		]);

		~controlWindowSpaRyABts = CompositeView(~controlWindowSpaRy, Rect(131*~xSizeMul, 56*~ySizeMul, 145*~xSizeMul, 28*~ySizeMul)).background = Color.grey(0.7);

		~multiStereoRandRy1AcView = RoundButton(~controlWindowSpaRyABts, Rect(0, 0, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["11", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(11)).doAction; });

		~multiStereoRandRy2AcView = RoundButton(~controlWindowSpaRyABts, Rect(18*~xSizeMul, 0, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["1a", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(12)).doAction; });

		~multiStereoRandRy3AcView = RoundButton(~controlWindowSpaRyABts, Rect(36*~xSizeMul, 0, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["1b", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(13)).doAction; });

		~multiStereoRandRy4AcView = RoundButton(~controlWindowSpaRyABts, Rect(0, 14*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["21", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(14)).doAction; });

		~multiStereoRandRy5AcView = RoundButton(~controlWindowSpaRyABts, Rect(18*~xSizeMul, 14*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["2a", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(15)).doAction; });

		~multiStereoRandRy6AcView = RoundButton(~controlWindowSpaRyABts, Rect(36*~xSizeMul, 14*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["2b", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(16)).doAction; });

		~multiStereoRandRy7AcView = RoundButton(~controlWindowSpaRyABts, Rect(54*~xSizeMul, 0, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["31", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(17)).doAction; });

		~multiStereoRandRy8AcView = RoundButton(~controlWindowSpaRyABts, Rect(72*~xSizeMul, 0, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["3a", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(18)).doAction; });

		~multiStereoRandRy9AcView = RoundButton(~controlWindowSpaRyABts, Rect(90*~xSizeMul, 0, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["3b", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(19)).doAction; });

		~multiStereoRandRy10AcView = RoundButton(~controlWindowSpaRyABts, Rect(54*~xSizeMul, 14*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["41", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(20)).doAction; });

		~multiStereoRandRy11AcView = RoundButton(~controlWindowSpaRyABts, Rect(72*~xSizeMul, 14*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["4a", Color.green(0.3), Color.white]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(21)).doAction; });

		~multiStereoRandRy12AcView = RoundButton(~controlWindowSpaRyABts, Rect(90*~xSizeMul, 14*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["4b", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(22)).doAction; });

		~multiStereoRandRy13AcView = RoundButton(~controlWindowSpaRyABts, Rect(108*~xSizeMul, 0, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["A1", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(23)).doAction; });

		~multiStereoRandRy14AcView = RoundButton(~controlWindowSpaRyABts, Rect(126*~xSizeMul, 0, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["Aa", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(24)).doAction; });

		~multiStereoRandRy15AcView = RoundButton(~controlWindowSpaRyABts, Rect(108*~xSizeMul, 14*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["Ab", Color.white, Color.green(0.3)]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(25)).doAction; });

		~multiStereoRandRy16AcView = RoundButton(~controlWindowSpaRyABts, Rect(126*~xSizeMul, 14*~ySizeMul, 18*~xSizeMul, 14*~ySizeMul))
		.states_([["R", Color.green(0.3), Color.white]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i|
			var r = (0..24).wchoose( ([(0.5/10)!10] ++ [(0.5/14)!14]).flatten ); // Pour que les spatialisations "Mobiles" au nombre de 10 aient les mêmes chances que les "Acousmonium" au nombre de 14
			~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(r)).doAction;
		});

		~acousTypeSensView = ListView(~controlWindowSpaRy, Rect(77*~xSizeMul, 51*~ySizeMul, 28*~xSizeMul, 58*~ySizeMul))
		.background_( Color.green(0.3)  /*Color./*clear*/grey(0.3, alpha: 0.8)*/)
		.hiliteColor_(Color.yellow(alpha: 1))
		.selectedStringColor_(Color.black)
		.stringColor_(Color.white)
		.font_(Font("Verdana",(9*~fontSizeMul).asInteger /*, bold: true*/))
		.items_(["+", "-", "Mir", "Ran", "Whi"])
		.action_({ |menu| ~acousTypeSens = menu.value })
		.valueAction_(3);


		~multiStereoRandRyAc1View = RoundButton(~controlWindowSpaRy, Rect(106*~xSizeMul, 57*~ySizeMul, 24*~xSizeMul, 14*~ySizeMul))
		.states_([["Ac1", Color.green(0.3), Color.white]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| var r = [(11..13).choose, (23..25).choose, (17..22).choose].scramble; // Acousmatique moins Aléatoire
			// La variation spatiale sur 3 pistes : Acous 1 / Acous A / Acous 3/4 a l'air de bien marcher
			{~presetVarsSpaSwitchF[r[0]].([9]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[1]].([11]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[2]].([13]); ~ryWaitTime.wait;
			/*"Ry Acousmonium".postln;*/ }.fork(AppClock);
		});

		~multiStereoRandRyAcView = RoundButton(~controlWindowSpaRy, Rect(106*~xSizeMul, 71*~ySizeMul, 24*~xSizeMul, 14*~ySizeMul))
		.states_([["AcR", Color.green(0.3), Color.white]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| var r = [(11..25).choose, (11..25).choose, (11..25).choose]; // Acousmatique Aléatoire
			{~presetVarsSpaSwitchF[r[0]].([9]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[1]].([11]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[2]].([13]); ~ryWaitTime.wait;
			/*"Ry Acousmonium".postln;*/ }.fork(AppClock);
		});

		~multiStereoRandRyMView = RoundButton(~controlWindowSpaRy, Rect(106*~xSizeMul, (61+26)*~ySizeMul, 24*~xSizeMul, 20*~ySizeMul))
		.states_([["Mob", Color.red, Color.white]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| var r = [(0..9).choose, (0..9).choose, (0..9).choose];
			{~presetVarsSpaSwitchF[r[0]].([9]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[1]].([11]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[2]].([13]); ~ryWaitTime.wait;
			/*"Ry Mobile".postln;*/ }.fork(AppClock);
		});

		~multiStereoRandRy3EView = RoundButton(~controlWindowSpaRy, Rect(130*~xSizeMul, (61+26)*~ySizeMul, 24*~xSizeMul, 20*~ySizeMul))
		.states_([["3E", Color.green(0.3), Color.white]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| var r = [(0..9).choose, (17..22).choose, (0..25).choose].scramble; // Mobile // Acous 3 ou 4 // ALL
			{~presetVarsSpaSwitchF[r[0]].([9]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[1]].([11]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[2]].([13]); ~ryWaitTime.wait;
			/*"Ry All".postln;*/ }.fork(AppClock);
		});

		~multiStereoRandRyALLView = RoundButton(~controlWindowSpaRy, Rect(154*~xSizeMul, (61+26)*~ySizeMul, 24*~xSizeMul, 20*~ySizeMul))
		.states_([["AllR", Color.green(0.3), Color.white]])
		.font_(Font("Verdana",9*~fontSizeMul /*,true*/))
		.action_({ |i| var r = [(0..25).choose, (0..25).choose, (0..25).choose]; // Aléatoire complet
			// L'intérêt de l'aléatoire spatiale et notamment AllR, mais même des autres aléatoires est de déterminer des combinaisons qui marchent...
			{~presetVarsSpaSwitchF[r[0]].([9]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[1]].([11]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[2]].([13]); ~ryWaitTime.wait;
			/*"Ry All".postln;*/ }.fork(AppClock);
		});

	},{

		~multiStereoRandRyMView = RoundButton(~controlWindowSpaRy, Rect(223*~xSizeMul, 58*~ySizeMul, 27*~xSizeMul, 20*~ySizeMul) /*(214, 58, 30, 20)*/)
		.states_([["3 E", Color.red, Color.white]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i| var r = [(0..9).choose, (0..9).choose, (0..9).choose];
			{~presetVarsSpaSwitchF[r[0]].([9]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[1]].([11]); ~ryWaitTime.wait;
				~presetVarsSpaSwitchF[r[2]].([13]); ~ryWaitTime.wait;
			/*"Ry Mobile".postln;*/ }.fork(AppClock);
		});

		~multiStereoRandRy16AcView = RoundButton(~controlWindowSpaRy, Rect(251*~xSizeMul, 58*~ySizeMul, 27*~xSizeMul, 20*~ySizeMul))
		.states_([["R", Color.green(0.3), Color.white]])
		.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
		.action_({ |i|
			var r = (0..10).wchoose( ([(0.1)!10]).flatten );
			~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(r)).doAction;
		});

	});


	// jeu avec la distinction stéréo sur les différentes pistes
	~multiStereoRandRyRout2View = RoundButton(~controlWindowSpaRy, Rect(131*~xSizeMul, 56*~ySizeMul, 36*~xSizeMul, 28*~ySizeMul))
	.states_([["2 Ry\nFix", Color.white, Color.blue], ["2 Ry\nRand", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i|
		// Mise en place d'une quantisation sur la routine aléatoire (Task de spatialisation) -> la même que celle d'une des pistes rythmiques (la 1ère)
		// Mais comme une quantisation n'aura aucun effet si les changements de séquence sont effectuées avec ~seqChange à 1 -> quantisation seulement si ~seqChange de la piste est à 0
		var q, s, x; if (x.isNil, {x = 0});
		q = ~quant[~rhythmTracksX2[0]]; if (~seqChange[~rhythmTracksX2[0]] == 0, {q = ~quant[~rhythmTracksX2[0]]}, {q = 0});
		s = ~outsConfigControlView[0].items.size-1;
		~multiStereoRandRyRout2 = i.value;

		if ( /*~multiStereoA*/ ~multiStereoRandRyRout2 == 0, { ~rhythmTracks.do { |b| ~outsConfigControlView[b].valueAction_(0) } }); // Pour remettre les sorties stéréo par défaut en avant

		if (~multiStereoRandRyRout2 == 1, {

			{ block { |break| inf.do {
				case
				{ ~stereoRandSelect == 0 } // R
				{
					~rhythmTracks.do { |a| ~outsConfigControlView[a].valueAction_(~outsConfigControlView[0].items.size.rand) };
					(~presetVarsSpaTimeRand).wait; if ( ~multiStereoRandRyRout2 == 0, { break.value(1) });
				}
				{ ~stereoRandSelect == 1 } // ->
				{
					/*[4].do { |a| ~outsConfigControlView[a].valueAction_(x.wrap(0,s)) };
					[5].do { |a| ~outsConfigControlView[a].valueAction_((x+1).wrap(0,s)) };
					[6].do { |a| ~outsConfigControlView[a].valueAction_((x+2).wrap(0,s)) };*/
					~rhythmTracks.do { |a, ad| ~outsConfigControlView[a].valueAction_((x+ad).wrap(0,s)) };
					x = x+1;
					(~presetVarsSpaTimeRand).wait; if ( ~multiStereoRandRyRout2 == 0, { break.value(1) });
				}
				{ ~stereoRandSelect == 2 } // <-
				{
					/*[4].do { |a| ~outsConfigControlView[a].valueAction_(x.wrap(0,s)) };
					[5].do { |a| ~outsConfigControlView[a].valueAction_((x-1).wrap(0,s)) };
					[6].do { |a| ~outsConfigControlView[a].valueAction_((x-2).wrap(0,s)) };*/
					~rhythmTracks.do { |a, ad| ~outsConfigControlView[a].valueAction_((x-ad).wrap(0,s)) };
					x = x+1;
					(~presetVarsSpaTimeRand).wait; if ( ~multiStereoRandRyRout2 == 0, { break.value(1) });
				}

			} } }.fork(AppClock, quant: q); // q.postln;
		});

		/*if (~lemurConnected1 == 1, { ~lemurAdress1.sendMsg( "/SPARout/x", ~multiStereoRandRyRout) });
		if (~lemurConnected2 == 1, { ~lemurAdress2.sendMsg( "/SPARout/x", ~multiStereoRandRyRout) });*/

	})/*.valueAction_(0)*/;

	~stereoRandSelectViewView = View(~controlWindowSpaRy, Rect(167*~xSizeMul, 56*~ySizeMul, 54*~xSizeMul, 28*~ySizeMul)); // Pour afficher les dossiers-sons dans leur intégralité dans le PopUp menu

	~stereoRandSelectView = PopUpMenu.new(~stereoRandSelectViewView,  Rect(0, 0, 84*~xSizeMul, 28*~ySizeMul))
	.action_({|menu| ~stereoRandSelect = menu./*item*/value/*.asInteger*/;
	})
	.allowsReselection_(true)
	.background_(Color.yellow)
	.stringColor_(Color.red)
	.font_(Font("Verdana",(10*~fontSizeMul).asInteger /*, bold: true*/))
	.items_([ "Rand", "---->", "<----" ])
	.valueAction_(1);

	~multiStereoRandRyRoutF = { |b|
		if (~multiStereoRandRyRout == 1, {
			~rySpaTypeTrackView.valueAction_(0); // Pour que la sélection soit sur All et non sur Follow
		},{
			~multiStereoPanDefView.valueAction_(1); // Pan par défaut quand on sort de la routine
			~rySpaTypeTrackView.valueAction_(1);
			b.value(1);
		});
	};

	~multiStereoRandRyRoutView = RoundButton(~controlWindowSpaRy, Rect(4*~xSizeMul, 56*~ySizeMul, 34*~xSizeMul, 26*~ySizeMul))
	.states_([["SPR\nOUT", Color.white, Color.red], ["SPR\nOUT", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul ,true))
	.action_({ |i|
		// Mise en place d'une quantisation sur la routine aléatoire (Task de spatialisation) -> la même que celle d'une des pistes rythmiques (la 1ère)
		// Mais comme une quantisation n'aura aucun effet si les changements de séquence sont effectuées avec ~seqChange à 1 -> quautisation seulement si ~seqChange de la piste est à 0
		var q = ~quant[9]; if (~seqChange[9] == 0, {q = ~quant[9]}, {q = 0});

		~multiStereoRandRyRout = i.value;

		// Mise en place d'une Boucle de spatialisation avec variation aléatoire au lieu d'un random comlètement aléatoire
		// Pour l'instant le 1 er preset a 6 éléments fixes de 11 durées
		// Faire 2 ou 3 autres boucles... (1 multi / diverses circulaires) & (1 multi / Stereo & EackRy)
		// Faire aussi des variations dur la durée des boucles

		if (~multiStereoRandRyRout == 1, {

			{ block { |break| inf.do {

				case

				{ ~spaRoutType == 0 } // D 10
				{
					~multiStereoPanDefView.valueAction_(1); (~presetVarsSpaTimeRand*2).wait; ~multiStereoRandRyRoutF.(break); // Pan Def

					~multiStereoRandRy2View.valueAction_(1); (~presetVarsSpaTimeRand*2).wait; ~multiStereoRandRyRoutF.(break); // SD
					// Mettre les noms à chaque fois dans le postln avec ~presetVarsSpaSwitchNames[10].postln; comme dans le bouton ci-dessusb~multiStereoPanDefView

					~multiStereoRandRy4View.valueAction_(1); (~presetVarsSpaTimeRand*2).wait; ~multiStereoRandRyRoutF.(break); // R+

					// ~multiStereoRandRy6View.valueAction_(1); (~presetVarsSpaTimeRand*2).wait; ~multiStereoRandRyRoutF.(break); // V+

					if (~multiStereoRandRyAcView.isNil, { ~multiStereoRandRyAcView.valueAction_(1); (~presetVarsSpaTimeRand*2).wait; ~multiStereoRandRyRoutF.(break); }); // Acous

					if (~multiStereoRandRyALLView.isNil, { ~multiStereoRandRyALLView.valueAction_(1); (~presetVarsSpaTimeRand*2).wait; ~multiStereoRandRyRoutF.(break); }); // Each Ry All different

					// ~multiStereoRandRyALLView.valueAction_(1); (~presetVarsSpaTimeRand*2).wait; ~multiStereoRandRyRoutF.(break); // Each Ry All different
				}

				{ ~spaRoutType == 1 } // C 10
				{
					~multiStereoRandRy1View.valueAction_(1); ~presetVarsSpaTimeRand.wait; ~multiStereoRandRyRoutF.(break); // C1

					~multiStereoRandRy1View.valueAction_(1); ~presetVarsSpaTimeRand.wait;~multiStereoRandRyRoutF.(break); // C1

					~multiStereoRandRy2View.valueAction_(1); ~presetVarsSpaTimeRand.wait; ~multiStereoRandRyRoutF.(break); // SD

					// ~multiStereoRandRy4View.valueAction_(1); ~presetVarsSpaTimeRand.wait; ~multiStereoRandRyRoutF.(break); // R+

					~multiStereoRandRy6View.valueAction_(1); ~presetVarsSpaTimeRand.wait; ~multiStereoRandRyRoutF.(break); // V+

					~multiStereoRandRy8View.valueAction_(1); ~presetVarsSpaTimeRand.wait; ~multiStereoRandRyRoutF.(break); // C+

					~multiStereoPanDefView.valueAction_(1); (~presetVarsSpaTimeRand*5).wait; ~multiStereoRandRyRoutF.(break); // Pan Def
				}

				{ ~spaRoutType == 2 } // A 10
				{
					~multiStereoRandRy1View.valueAction_(1); ~presetVarsSpaTimeRand.wait; ~multiStereoRandRyRoutF.(break); // C1

					if (~multiStereoRandRyAcView.isNil, { ~multiStereoRandRyAcView.valueAction_(1); (~presetVarsSpaTimeRand*3).wait; ~multiStereoRandRyRoutF.(break); // Acous

						~multiStereoRandRyAcView.valueAction_(1); (~presetVarsSpaTimeRand*3).wait; ~multiStereoRandRyRoutF.(break); }); // Acous

					~multiStereoPanDefView.valueAction_(1); (~presetVarsSpaTimeRand*3).wait; ~multiStereoRandRyRoutF.(break); // Pan Def
				}

			} } }.fork(AppClock, quant: q); // q.postln;

		});

		if (~lemurConnected1 == 1, { ~lemurAdress1.sendMsg( "/SPARout/x", ~multiStereoRandRyRout) });
		if (~lemurConnected2 == 1, { ~lemurAdress2.sendMsg( "/SPARout/x", ~multiStereoRandRyRout) });

	});

	~spaRoutTypeViewView = View(~controlWindowSpaRy, Rect(40*~xSizeMul, 57*~ySizeMul, 34*~xSizeMul, 24*~ySizeMul)); // Pour afficher les dossiers-sons dans leur intégralité dans le PopUp menu

	~spaRoutTypeView = PopUpMenu.new(~spaRoutTypeViewView, Rect(0, 0, 64*~xSizeMul, 24*~ySizeMul))
	.action_({|menu| ~spaRoutType = menu./*item*/value.asInteger })
	.allowsReselection_(true)
	.background_(Color.yellow)
	.stringColor_(Color.red)
	.font_(Font("Verdana",(10*~fontSizeMul).asInteger /*, bold: true*/));
	~spaRoutTypeView.items_([ "D", "C", "A" ])
	.valueAction_(0);

	~rySpaTypeTrackView = ListView(~controlWindowSpaRy, Rect(280*~xSizeMul, 26*~ySizeMul, 30*~xSizeMul, 80*~ySizeMul))
	.background_( Color.green(0.4)  /*Color./*clear*/grey(0.3, alpha: 0.8)*/)
	.hiliteColor_(Color.yellow(alpha: 1))
	.selectedStringColor_(Color.black)
	.stringColor_(Color.white)
	.font_(Font("Verdana",(9*~fontSizeMul).asInteger /*, bold: true*/))
	.items_(["All", "Fol", "5", "6", "7", "8", "4"])
	.action_({ |menu| ~rySpaTypeTrack = menu.value;
		if (~lemurConnected1 == 1, {
			if (~rySpaTypeTrack == 0, {
				~lemurAdress1.sendMsg( *["/Ry14", "@content", "ALL" ]);
				~lemurAdress1.sendMsg( *["/RyWinC/SpaC/Ry14b", "@content", "ALL" ]);
			},{
				~lemurAdress1.sendMsg( *["/Ry14", "@content", "Follow" ]);
				~lemurAdress1.sendMsg( *["/RyWinC/SpaC/Ry14b", "@content", "Follow" ]);
			});
		});
		if (~lemurConnected2 == 1, {
			if (~rySpaTypeTrack == 0, {
				~lemurAdress2.sendMsg( *["/Ry14", "@content", "ALL" ]);
				~lemurAdress2.sendMsg( *["/RyWinC/SpaC/Ry14b", "@content", "ALL" ]);
			},{
				~lemurAdress2.sendMsg( *["/Ry14", "@content", "Follow" ]);
				~lemurAdress2.sendMsg( *["/RyWinC/SpaC/Ry14b", "@content", "Follow" ]);
			});
		});
	})
	.valueAction_(0);

	~rySpaTypeTrackIndex = 0;
	~rySpaTypeTrackAction = ~rhythmTracksX2;
	~rySpaTypeTrackFunc = { // ne faire qu'actionner que celles qui sont actives et rythmiques dans le Follow - TO DO
		case
		{ ~rySpaTypeTrack == 0 } { ~rySpaTypeTrackAction = ~rhythmTracksX2 }
		{ ~rySpaTypeTrack == 1 } { ~rySpaTypeTrackIndex = (~rySpaTypeTrackIndex+1).wrap(0, (~rhythmTracks.size-1)); ~rySpaTypeTrackAction = [~rhythmTracksX2[~rySpaTypeTrackIndex]] }
		{ ~rySpaTypeTrack == 2 } { ~rySpaTypeTrackAction = [~rhythmTracksX2[0]] /*[9]*/ }
		{ ~rySpaTypeTrack == 3 } { ~rySpaTypeTrackAction = [~rhythmTracksX2[1]] /*[11]*/ }
		{ ~rySpaTypeTrack == 4 } { ~rySpaTypeTrackAction = [~rhythmTracksX2[2]] /*[13]*/ }
		{ ~rySpaTypeTrack == 5 } { ~rySpaTypeTrackAction = [~rhythmTracksX2[3]] /*[15]*/ }
		{ ~rySpaTypeTrack == 6 } { ~rySpaTypeTrackAction = [~rhythmTracksX2[4]] /*[7]*/ }
	};


	~presetVarsSpaTimeRandSpec = ControlSpec(0.125 /*0.5*/, 7.5, \lin, 0.125); // 0.125*60
	~presetVarsSpaTimeRandSlider = SmoothSlider(~controlWindowSpaRy, Rect(4*~xSizeMul, (58+26)*~ySizeMul, 70*~xSizeMul, 22*~ySizeMul))
	.action_({ |view| ~presetVarsSpaTimeRand = ~presetVarsSpaTimeRandSpec.map(view.value);
		view.string = ~presetVarsSpaTimeRand.asString +"s";
	})
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.background_(Color.grey/*~sliderBackgroundColor*/)
	.hilightColor_(Color.green(0.3)/*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1/60)
	.valueAction_(0.05);


	~multiStereoPanDefView = RoundButton(~controlWindowSpaRy, Rect(148*~xSizeMul, 27*~ySizeMul, 34*~xSizeMul, 26*~ySizeMul))
	.states_([["Pan\nDef", Color.black, Color.new255(255, 165, 0)]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i| // remet la spatialisation par défaut, mais la séquence reste en rouge, car le preset n'a pas été rappelé
		// ~presetVarsSpaSwitchF[10].([9,11,13]); // ~presetVarsSpaSwitchNames[10].postln;
		if (~rySpaTypeTrack == 1, {
			~rhythmTracks.size.do { ~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(10)).doAction; };
		},{
			~presetVarsSpa1SwitchSlider.value_(~presetVarsSpa1Spec.unmap(10)).doAction;
		});
	});

	~ryWaitTime = 0.01;

	~multiStereoSwapView = RoundButton(~controlWindowSpaRy, Rect(112*~xSizeMul, 27*~ySizeMul, 34*~xSizeMul, 26*~ySizeMul))
	.states_([["Pan\nSwap", Color.green(0.3), Color.white]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ // // Ajout d'un bouton qui permet de (swaper) / wraper les spatialisations entre les pistes rythmiques
		var a,b,c,d,s; s =~rhythmTracks.size;
		a= 0!s; b= 0!s; c= 0!s; d= 0!s;
		a = ~rhythmTracksX2.collect { |i| ~spaRangePreset[i][~seqSeq[i]] };
		b = ~rhythmTracksX2.collect { |i| ~panRangePreset[i][~seqSeq[i]] };
		c = ~rhythmTracksX2.collect { |i| ~spaPatSel[i][~seqSeq[i]] };
		d = ~rhythmTracksX2.collect { |i| ~spaPat[i][~seqSeq[i]] };
		/*a = [ ~spaRangePreset[9][~seqSeq[9]], ~spaRangePreset[11][~seqSeq[11]], ~spaRangePreset[13][~seqSeq[13]] ];
		b = [ ~panRangePreset[9][~seqSeq[9]], ~panRangePreset[11][~seqSeq[11]], ~panRangePreset[13][~seqSeq[13]] ];
		c = [ ~spaPatSel[9][~seqSeq[9]], ~spaPatSel[11][~seqSeq[11]], ~spaPatSel[13][~seqSeq[13]] ];
		d = [	 ~spaPat[9][~seqSeq[9]], ~spaPat[11][~seqSeq[11]], ~spaPat[13][~seqSeq[13]] ];*/

		{ /*[9,11,13]*/~rhythmTracksX2.do { |i, id| var ind = (i+2).wrap(~rhythmTracksX2[0], ~rhythmTracksX2.last+1)/*(9,14)*/;
			~spaRangePresetViewG[ind].valueAction_( a[id] );
			~panRangePresetViewG[ind].valueAction_( b[id] );
			~spaPatSelViewG[ind].valueAction_( c[id] );
			~spaPatViewG[ind].valueAction_( d[id] );
			0.01.wait;
		}}.fork(AppClock);
	});


	~presetVarsSpa1Spec = ControlSpec(0,~presetVarsSpaSwitchNames.size-1, \lin, 1);
	~presetVarsSpa1SwitchSlider = SmoothSlider(~controlWindowSpaRy, Rect(180*~xSizeMul, (61+26)*~ySizeMul, 96*~xSizeMul, 20*~ySizeMul))
	.action_({ |view| ~presetVarsSpa1 = ~presetVarsSpa1Spec.map(view.value);
		~rySpaTypeTrackFunc.(); // pour définir ~rySpaTypeTrackAction
		~presetVarsSpaSwitchF[~presetVarsSpa1].(~rySpaTypeTrackAction);
		view.string = ~presetVarsSpaSwitchNames[~presetVarsSpa1].asString/*.postln*/;
	})
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.background_(Color.grey(0.5) /*Color.grey*//*~sliderBackgroundColor*/)
	.hilightColor_(Color.green(0.3)/*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1/(~presetVarsSpaSwitchNames.size-1))
	.value_(0).string = ~presetVarsSpaSwitchNames[0].asString/*.doAction*/;


	~presetRatSwitch3View = RoundButton(~controlWindowSpaRy, Rect(4*~xSizeMul, (84+26)*~ySizeMul, 35*~xSizeMul, 20*~ySizeMul))
	.states_([["S Rat", Color.white, Color.red], ["S Rat", Color.black, Color.green]])
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i| ~presetRyRa3tSwitch = i.value;
		~presetRatSwitchView.valueAction_(i.value);
		~presetRatSwitch2View.valueAction_(i.value);
		// ~presetVarsRatWait = 0; ~presetVarsRatWait2 = 0 // car parfois reste bloqué
		/*if (~lemurConnected1 == 1, { ~lemurAdress1.sendMsg( "/RatPresetVar/x", ~presetRyRatSwitch) });
		if (~lemurConnected2 == 1, { ~lemurAdress2.sendMsg( "/RatPresetVar/x", ~presetRyRatSwitch) });*/
	}).valueAction_(0);

	~presetRatSwitchView = RoundButton(~controlWindowSpaRy, Rect(41*~xSizeMul, (84+26)*~ySizeMul, 35*~xSizeMul, 20*~ySizeMul))
	.states_([["T1", Color.white, Color.red], ["S T1", Color.black, Color.green]]) // "SRat Ry"
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i| ~presetRyRatSwitch = i.value;
	});//.valueAction_(1);

	~presetRatSwitch2View = RoundButton(~controlWindowSpaRy, Rect(78*~xSizeMul, (84+26)*~ySizeMul, 35*~xSizeMul, 20*~ySizeMul))
	.states_([["R2", Color.white, Color.red], ["S R2", Color.black, Color.green]]) // "SRat Tx"
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.action_({ |i| ~presetRyRat2Switch = i.value;
		if (~lemurConnected1 == 1, { ~lemurAdress1.sendMsg( "/RatPresetVar/x", ~presetRyRatSwitch) });
		if (~lemurConnected2 == 1, { ~lemurAdress2.sendMsg( "/RatPresetVar/x", ~presetRyRatSwitch) });
		// ~presetVarsRatWait = 0; ~presetVarsRatWait2 = 0 // car parfois reste bloqué
	});//.valueAction_(1);

	~presetVarsRatTimeRandSpec = ControlSpec(/*0,125*/ 0.125, 7.5, \lin, 0.125); // 0.125*60
	~presetVarsRatTimeRandSlider = SmoothSlider(~controlWindowSpaRy, Rect(115*~xSizeMul, (84+26)*~ySizeMul, 62*~xSizeMul, 20*~ySizeMul))
	.action_({ |view| ~presetVarsRatTimeRand = ~presetVarsRatTimeRandSpec.map(view.value);
		~presetVarsRatWaitTime = ~presetVarsRatTimeRand;
		view.string = ~presetVarsRatTimeRand.asString + "s";
	})
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.background_(Color.grey/*~sliderBackgroundColor*/)
	.hilightColor_(Color.red/*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1/60)
	.valueAction_(0.48);

	~presetRatRoutView = RoundButton(~controlWindowSpaRy, Rect(278*~xSizeMul, (84+26)*~ySizeMul, 34*~xSizeMul, 20*~ySizeMul))
	.states_([["RAT\nOUT", Color.white, Color.red], ["RAT\nOUT", Color.black, Color.green]])
	.font_(Font("Verdana",8*~fontSizeMul,true))
	.action_({ |i| var bt;
		~presetRatRout = i.value;
		{ block { |break| inf.do {
			~presetVarsRatWaitTime/*0.1*/.wait;

			~presetVarsRatSliderView.value_(~presetVarsRatSliderSpec.unmap(3.0.rand)).doAction;

			if ( ~presetRatRout == 0, {break.value(1)}); } } }.fork(AppClock);

		if (~lemurConnected1 == 1, { ~lemurAdress1.sendMsg( "/RatRout/x", ~presetRatRout) });
		if (~lemurConnected2 == 1, { ~lemurAdress2.sendMsg( "/RatRout/x", ~presetRatRout) });
		/*
		~presetVarsRatWait = 0;
		*/

	});

	/*~presetVarsRatSliderView = EZSlider.new2(~presetVarsWindow, Rect(0,30,156,20) /*400@20*/, nil, ControlSpec(1, 60, \lin, 1, 1),
	{ |ez| ~presetVarsRatSlider = (ez.value-1)/*.postln*/;
	// ~presetVarsSliderViewFunction.(~presetVarsSlider);
	if (~presetVarsRatWait == 0 and: { ~presetVarsRatWaitT.isPlaying == false }, {
	~controlRandLineCollection.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: ( -0.7 /*~presetVarsRatSlider.neg*/), post: 1, serv: 1); // Uniquement sur le 2ème server - à spécifier que sur les pistes rythmiques ou toutes ???
	{
	~presetVarsRatWaitF.(); (~presetVarsRatWaitTime+0.01).wait;
	if (~presetVarsRatWaitT.isPlaying == false, { ~presetVarsRatWait = 0 } );
	}.fork
	});
	},
	unitWidth:0, initVal:0, numberWidth:25, layout:\horz,)
	.setColors(Color.grey,Color.white)
	.font_(Font("Helvetica",11));*/

	~presetVarsRatWait = 0;
	~presetVarsRatWaitT = Task.new( { ~presetVarsRatWait = 1; ~presetVarsRatWaitTime.wait; ~presetVarsRatWaitT.stop; } );
	~presetVarsRatWaitF = { ~presetVarsRatWaitT.reset; ~presetVarsRatWaitT.start };


	// relier ~presetVarsRatSliderView à l'argument de rat de ~controlRandLineCollection, mais comment ???
	~presetVarsRatSliderSpec = ControlSpec(0,3, \lin, 0.01,0);
	~presetVarsRatSliderView = SmoothSlider(~controlWindowSpaRy, Rect(180*~xSizeMul, (84+26)*~ySizeMul, 96*~xSizeMul, 20*~ySizeMul))
	.action_({ |view|  var a = ~ryRatRange.rand; if (a > 0, { a = a+~ryRatBase }, { a = a-~ryRatBase }); // a.postln;
		~prevTrigAll = ~trigAllView.value;
		~presetVarsRatSlider = ~presetVarsRatSliderSpec.map(view.value)/*.postln*/;
		// ~presetVarsSliderViewFunction.(~presetVarsSlider);
		if (~presetVarsRatWait == 0 and: { ~presetVarsRatWaitT.isPlaying == false }, {

			if (~presetRyRatSwitch == 1 and: { /*"S".postln;*/ ~tabbedPresetVarsPage.inclusivelyBetween(6, 9) } , {~controlRandLineCollectionPVars.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: 0) });
			if (~presetRyRat2Switch == 1 and: { /*"R".postln;*/ ~tabbedPresetVarsPage.inclusivelyBetween(6, 9) } , {~controlRandLineCollectionPVars.(par: ~controlBusTypeArg, func: ~controlRandFunc, val: a, post: 1, serv: 1) });

			{
				~presetVarsRatWaitF.(); (~presetVarsRatWaitTime+0.01).wait;
				if (~presetVarsRatWaitT.isPlaying == false, { ~presetVarsRatWait = 0 } );
			}.fork;

		});
		view.string = "Rat : % at :".format(~presetVarsRatSlider);
	})
	.font_(Font("Verdana",10*~fontSizeMul /*,true*/))
	.background_(~sliderBackgroundColor)
	.hilightColor_(Color.red/*~sliderHilightColor*/)
	.stringColor_(Color.white)
	.border_(~border)
	.borderColor_(~borderColor)
	.step_(1/600)
	.string = "Rat : 0 at :";
	// .valueAction_(1);


}.value;






























{

	// CHECK SERVER CPU

	// Server
	// Comment obtenir un update des valeurs du CPU encore + rapidement ???
	// provoque toujours des clics & une surcharge du serveur lorsque de nombreux synthés volumineux sont générés ???

	// Set up your responder as you posted, then run your own routine:
	// If you send the message /status to server, it will reply you back (/server.reply) with the data you want as fast as possible.
	// fork({ loop({ s.sendMsg("/status"); 0.02.wait; }); });

	/* // Ancienne méthode
	~osc = OSCresponderNode(nil, '/status.reply', {arg time, resp, msg;
	(msg[7] > 70).if({
	// "CPU Too High!!".postln;
	~cpuServer = 1},
	{// "CPU OK!!".postln;
	~cpuServer = 0}
	);
	}).add;*/
	// o.remove;

	/* // méthode équivalente
	// s.avgCPU;
	// s.peakCPU;
	~updateTimeServer = 0.02;
	fork{inf.do { // s.peakCPU.postln;
	(s.peakCPU > 70).if({
	// "CPU Too High!!".postln;
	~cpuServer = 1},
	{// "CPU OK!!".postln;
	~cpuServer = 0}
	);
	~updateTimeServer.wait} };
	// il faut de toute façon changer s.aliveThreadPeriod */


	// nouvelle méthode avec OSCFunc -> différence avec Oscdef ???
	/*
	OSCFunc.trace(true); // for debugging

	// create and activate an osc responder that sets the freq of above synth
	OSCFunc({|msg|
	~mySynth.set(\freq,msg[1].linlin(0,127,200,1000));
	}, '/wii/1/accel/pry/0');
	};

	~osc = OSCFunc({ |msg, time, addr, recvPort| msg[#[2, 3, 6, 7]].debug("u, s, avg, pk") }, '/status.reply', s.addr);
	~osc = OSCFunc({ |msg, time, addr, recvPort| msg.postln; s.peakCPU.postln; }, '/n_go', s.addr);
	*/

	// The only other thing I can think of is to set up an OSCresponder (well, OSCFunc in 3.5) to send a /status request whenever the server sends back /n_go -- in other words, check CPU use after a new synth has been created. I'm not sure if that would really work (not sure how long it takes for the server's CPU measurement to climb after the new synth is instantiated), but at least it's one way to avoid polling the server so often.
	// de toute façon, besoinde changer s.aliveThreadPeriod pour avoir un changement réel des valeurs
	// & la requête peut être demandée plus souvent que nécessaire (see s.ping) si les synthés sont déclenchés trop rapidement
	/*~osc = OSCFunc({ |msg, time, addr, recvPort|
	s.peakCPU.postln;
	(s.peakCPU > 70).if({
	// "CPU Too High!!".postln;
	~cpuServer = 1},
	{// "CPU OK!!".postln;
	~cpuServer = 0}
	);
	}, '/n_go', s.addr);
	*/

	// Les infos sont envoyées selon selon le temps indiqué dans s.aliveThreadPeriod

	~cpuStopViewView = View(~controlWindowGlobal, Rect(200*~xSizeMul, 22*~ySizeMul, 32*~xSizeMul, 18*~ySizeMul));

	// ~cpuStop = 70; // pas nécessaire
	~cpuStopView = PopUpMenu.new(~cpuStopViewView, Rect(0, 0, 60*~xSizeMul, 18*~ySizeMul))
	.action_({|menu| ~cpuStop = menu.item.asInteger })
	.allowsReselection_(true)
	.background_(Color.yellow)
	.stringColor_(Color.red)
	.font_(Font("Verdana",9*~fontSizeMul, bold: true));
	~cpuStopView.items_(["40", "50", "55", "60", "65", "70", "75", "80", "90"])
	.valueAction_(3);

	~osc = 0 ! 2;
	~cpuServer = 0 ! 2;

	~osc[0] = OSCFunc({ |msg, time, addr, recvPort|
		// s.peakCPU.postln;
		(msg[7] > ~cpuStop).if({
			// "CPU High!!".postln;
			~cpuServer[0] = 1;
			// (msg[7] > 85).if({ "CPU Server > 85 % - Wait !!!".postln }); // voir si ne génère pas trop de CPU ???
		},
		{// "CPU OK!!".postln;
			~cpuServer[0] = 0}
		);
		// ("S1->"++msg[7]).postln;
		/*msg[7].postln;
		msg.postln;*/
	}, '/status.reply', ~server1.addr);

	// ~osc.permanent = true; // persists to Cmd.
	~osc[0].fix; // .fix is a concise synonym for permanent = true

	if (~server2.notNil, {

		~osc[1] = OSCFunc({ |msg, time, addr, recvPort|
			// s.peakCPU.postln;
			(msg[7] > ~cpuStop).if({
				// "CPU High!!".postln;
				~cpuServer[1] = 1;
				// (msg[7] > 85).if({ "CPU Server > 85 % - Wait !!!".postln }); // voir si ne génère pas trop de CPU ???
			},
			{// "CPU OK!!".postln;
				~cpuServer[1] = 0}
			);
			// ("S2->"++msg[7]).postln;
			/*msg[7].postln;
			msg.postln;*/
		}, '/status.reply', ~server2.addr);

		~osc[1].fix;

	});

	/*
	~osc = OSCdef({ \OSCStatusReply, |msg, time, addr, recvPort|
	// s.peakCPU.postln;
	(msg[7] > ~cpuStop).if({
	// "CPU Too High!!".postln;
	~cpuServer = 1},
	{// "CPU OK!!".postln;
	~cpuServer = 0}
	);
	}, '/status.reply', s.addr);

	if(s.serverRunning/*.not*/,{"server running".postln}, {"server not running".postln })
	*/

	/*
	OSC Message Received:
	time: 795.451025639
	address: a NetAddr(127.0.0.1, 57110)
	recvPort: 57120
	msg: [ /status.reply, 1, 146, 28, 3, 1280, 1.5391709804535, 2.9295492172241, 44100, 44096.617157363 ]
	*/

	// ou + rapide
	// BTW, use Server:ping to check the OSC for a round trip to and from the server. This will give you an idea how long it takes, in the server's alive thread, for the /status request to reach the server and the /status.reply to get back to the client. On my Linux machine, it tends to run about 36-40 ms. If I set the alive thread wait time to 0.01, I would be sending three or four status requests in the time that it takes the first one to come back. So, even if human perception isn't the objective, you might still be overdoing it on the update frequency.
	/*
	s.ping; // légèrement + élevé lorsque le serveur est très occuppé.
	s.ping(200, 0.025);
	s.ping(n: 1, wait: 0.1); // default
	s.ping(n: 100, wait: 0.025); // resulting max after n number of times
	*/

	// s.ping(200, 0.005);

	// Plus la période est petite, plus la possibilité de provoquer des arrêts de communication avec le server -> Boost avec des late messages -> peut provoquer des late en boucle et crasher le langage
	// 0.1 semble ok ??? - empêche l'arrêt de communication avec le server quand surcharge avec Master EQ enclenché
	// update des infos du serveur
	/*
	s.aliveThreadPeriod = 0.005; // Distorsion plus importante & le serveur flashe
	s.aliveThreadPeriod = 0.01;
	s.aliveThreadPeriod = 0.02;
	s.aliveThreadPeriod = 0.04;
	s.aliveThreadPeriod = 0.05; // semble ok pour ne pas créer trop d'arrêt de communication entre le langage et le server (status Reply)
	s.aliveThreadPeriod = 0.1;
	s.aliveThreadPeriod = 0.2; // update des infos du serveur mini pour ne pas couper le server (quit & boot) et enregistrer - mais moins réactif et des clics peuvent apparaitre
	s.aliveThreadPeriod = 0.7; // par défaut
	*/

	if (~server2.notNil, {

		~aliveThreadPeriodFunc = [
			{ ~aliveThreadPeriod = 0.001; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 3500; ~server2.aliveThreadPeriod = ~aliveThreadPeriod; ~server2.options.pingsBeforeConsideredDead = 3500 },
			{ ~aliveThreadPeriod = 0.003; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 1200; ~server2.aliveThreadPeriod = ~aliveThreadPeriod; ~server2.options.pingsBeforeConsideredDead = 1200 },
			{ ~aliveThreadPeriod = 0.005; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 700; ~server2.aliveThreadPeriod = ~aliveThreadPeriod; ~server2.options.pingsBeforeConsideredDead = 700 },
			{ ~aliveThreadPeriod = 0.01; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 350; ~server2.aliveThreadPeriod = ~aliveThreadPeriod; ~server2.options.pingsBeforeConsideredDead = 350 },
			// { ~aliveThreadPeriod = 0.016; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 220 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			{ ~aliveThreadPeriod = 0.02; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 175; ~server2.aliveThreadPeriod = ~aliveThreadPeriod; ~server2.options.pingsBeforeConsideredDead = 175 },
			{ ~aliveThreadPeriod = 0.025; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 140; ~server2.aliveThreadPeriod = ~aliveThreadPeriod; ~server2.options.pingsBeforeConsideredDead = 140 },
			{ ~aliveThreadPeriod = 0.05; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 70; ~server2.aliveThreadPeriod = ~aliveThreadPeriod; ~server2.options.pingsBeforeConsideredDead = 70 },
			{ ~aliveThreadPeriod = 0.1; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 35; ~server2.aliveThreadPeriod = ~aliveThreadPeriod; ~server2.options.pingsBeforeConsideredDead = 35 },
			{ ~aliveThreadPeriod = 0.25; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 14; ~server2.aliveThreadPeriod = ~aliveThreadPeriod; ~server2.options.pingsBeforeConsideredDead = 14 },
			{ ~aliveThreadPeriod = 0.5; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 7; ~server2.aliveThreadPeriod = ~aliveThreadPeriod; ~server2.options.pingsBeforeConsideredDead = 7 },
			{ ~aliveThreadPeriod = 0.7; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 5; ~server2.aliveThreadPeriod = ~aliveThreadPeriod; ~server2.options.pingsBeforeConsideredDead = 5 }
		];

	},{

		~aliveThreadPeriodFunc = [
			{ ~aliveThreadPeriod = 0.001; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 3500 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			{ ~aliveThreadPeriod = 0.003; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 1200 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			{ ~aliveThreadPeriod = 0.005; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 700 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			{ ~aliveThreadPeriod = 0.01; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 350 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			// { ~aliveThreadPeriod = 0.016; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 220 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			{ ~aliveThreadPeriod = 0.02; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 175 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			{ ~aliveThreadPeriod = 0.025; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 140 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			{ ~aliveThreadPeriod = 0.05; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 70 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			{ ~aliveThreadPeriod = 0.1; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 35 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			{ ~aliveThreadPeriod = 0.25; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 14 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			{ ~aliveThreadPeriod = 0.5; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 7 /*3.5 / ~server1.aliveThreadPeriod;*/ },
			{ ~aliveThreadPeriod = 0.7; ~server1.aliveThreadPeriod = ~aliveThreadPeriod; ~server1.options.pingsBeforeConsideredDead = 5 /*3.5 / ~server1.aliveThreadPeriod;*/ }
		];

	});

	~aliveThreadPeriodViewView = View(~controlWindowGlobal, Rect(200*~xSizeMul, 2*~ySizeMul, 42*~xSizeMul, 18*~ySizeMul));

	~aliveThreadPeriodView = PopUpMenu.new(~aliveThreadPeriodViewView, Rect(0, 0, 70*~xSizeMul, 18*~ySizeMul))
	.action_({|menu| ~aliveThreadPeriodFunc[menu.value].value })
	.allowsReselection_(true)
	.background_(Color.yellow)
	.stringColor_(Color.red)
	.font_(Font("Verdana",9*~fontSizeMul, bold: true));
	~aliveThreadPeriodView.items_(["0.001", "0.003", "0.005", "0.01", /*"0.016",*/ "0.02", "0.025", "0.05", "0.1", "0.25", "0.5", "0.7"])
	.valueAction_(4);

}.value;
































// CODE TextView

// même avec .hasHorizontalScroller_(true) pas d'affichage de la ligne dans son entier ???
// Espacement de 2 lignes au lieu d'1 quand on charge un fichier HTML ???
// Quand on sélectionne et déclenche tout, affihcage d'une erreur si on a sauté une ligne ???
// nécessaire de retirer les accents sinon Ã© ???

~codeDisplay = TextView(~tabCode, Rect(5*~xSizeMul, 5*~ySizeMul, 900*~xSizeMul, 255*~ySizeMul))
.hasVerticalScroller_(true)
.autohidesScrollers_(true)
.font_(Font("Verdana", 11*~fontSizeMul))
.enterInterpretsSelection_(1)
.syntaxColorize // Pourquoi pas nécessaire ???
// .string_(); // + pratique de charger un fichier Html
// .open("/Users/Xon/Documents/Projets/ConsProject3_BeatCut2011/WithMathis/Live4Life/_code Live for Life.html");
// .open("/Users/Xon/Documents/Projets/ConsProject3_BeatCut2011/WithMathis/Live4Life/_code Live for Life Voices Trigger.html");

// Avant le nouvel IDE, cette ligne de code ci-dessous marchait
// .open(Document.current.dir ++ "/_code Live for Life MasterEQ Trigger.html");
// Mais Document.current.path doit être remplacé avec le nouvel IDE par thisProcess.nowExecutingPath pour l'instant
// Mais pourquoi ~currentPath doit être indiqué auparavant et non pas dans ce fichier ???
.open(PathName.new(~currentPath).pathOnly ++ "_code Live for Life Voices Trigger.html");

~codeDisplayb = TextView(~tabCode, Rect(910*~xSizeMul, 5*~ySizeMul, 650*~xSizeMul, 255*~ySizeMul))
.hasVerticalScroller_(true)
// .hasHorizontalScroller_(true)
.autohidesScrollers_(true)
.font_(Font("Verdana", 11*~fontSizeMul))
.enterInterpretsSelection_(1)
.syntaxColorize // Pourquoi pas nécessaire ???
.open(PathName.new(~currentPath).pathOnly ++ "_code Live for Life Voices Load2.html");

~codeDisplay2 = TextView(~tabCode, Rect(5*~xSizeMul, 265*~ySizeMul, 900*~xSizeMul, 255*~ySizeMul))
.hasVerticalScroller_(true)
.autohidesScrollers_(true)
.font_(Font("Verdana", 11*~fontSizeMul))
.enterInterpretsSelection_(1)
.syntaxColorize // Pourquoi pas nécessaire ???
.open(PathName.new(~currentPath).pathOnly ++ "_code Live for Life MasterEQ Trigger.html");

~codeDisplay2b = TextView(~tabCode, Rect(910*~xSizeMul, 265*~ySizeMul, 650*~xSizeMul, 255*~ySizeMul))
.hasVerticalScroller_(true)
.autohidesScrollers_(true)
.font_(Font("Verdana", 11*~fontSizeMul))
.enterInterpretsSelection_(1)
.syntaxColorize // Pourquoi pas nécessaire ???
.open(PathName.new(~currentPath).pathOnly ++ "_code Live for Life MasterEQ Load.html");

~codeDisplay3 = TextView(~tabCode, Rect(5*~xSizeMul, 525*~ySizeMul, 1400*~xSizeMul, 255*~ySizeMul))
.hasVerticalScroller_(true)
.autohidesScrollers_(true)
.font_(Font("Verdana", 11*~fontSizeMul))
.enterInterpretsSelection_(1)
.syntaxColorize // Pourquoi pas nécessaire ???
.open(PathName.new(~currentPath).pathOnly ++ "_code Live for Life Pdefn.html");

~codeDisplay4 = TextView(~tabCode, Rect(5*~xSizeMul, 785*~ySizeMul, 1400*~xSizeMul, 255*~ySizeMul))
.hasVerticalScroller_(true)
.autohidesScrollers_(true)
.font_(Font("Verdana", 11*~fontSizeMul))
.enterInterpretsSelection_(1)
.syntaxColorize // Pourquoi pas nécessaire ???
.open(PathName.new(~currentPath).pathOnly ++ "_code Live for Life GUI actions.html");






























// FX

// Bus.audio(s, 200); // ???

{
	// Initialisation des effets multi-canaux

	~fxSynth = 0 ! ~numEffects ! 2; // Post << ~fxSynth
	~fxSynth2 = 0 ! ~numEffects ! 2; // Synthés In/Out
	~fxSelect = 0 ! ~numEffects ! 2;

	~fxXfadePlaying  = 0 ! ~numEffects ! 2;
	~fxXfadePlayingT = 0 ! 2;
	~nbOfServers.do { |s| ~fxXfadePlayingT[s] = ~numEffects.collect { |i| Task.new( { ~fxXfadePlaying[s][i] = 1; ~fadeTimeSynthFx[s].wait; ~fxXfadePlayingT[s][i].stop; } ) }; };
	~fxXfadePlayingF = { |a, serverNb| ~fxXfadePlayingT[serverNb][a].reset; ~fxXfadePlayingT[serverNb][a].start; };
	// ~fxXfadePlayingT[0].isPlaying

	~fxXIOfadePlaying  = 0 ! ~numEffects ! 2;
	~fxXIOfadePlayingT = 0 ! 2;
	~nbOfServers.do { |s| ~fxXIOfadePlayingT[s] = ~numEffects.collect { |i| Task.new( { ~fxXIOfadePlaying[s][i] = 1; ~fadeTimeSynthFx[s].wait; ~fxXIOfadePlayingT[s][i].stop; } ) }; };
	~fxXIOfadePlayingF = { |a, serverNb| ~fxXIOfadePlayingT[serverNb][a].reset; ~fxXIOfadePlayingT[serverNb][a].start; };

	~fxSelectPrevValue = 0 ! ~numEffects ! 2;
	~fxName = 0 ! (~numEffects+1) ! 2; // Pourquoi + 1 ???????????????????????????

	// if (~numChannels <= 16 or: {~numChannelsConfig ==  "16-Dome-8-6-2-Clock-CC"}, { ~fxMulChannel = 20 }, { if (~numChannels > 32, {~fxMulChannel = 70}, {~fxMulChannel = 40 }); });
	// Etalement des effets sur les bus - si 20, les effets multicanaux pouvant aller de 0 à 20 seront décalés de 20 en 20 -> 1er effet sur 20, 2ème effet sur 40...

	case
	{ ~numChannels <= 18 } { ~fxMulChannel = 20 } // Prise en considération du bus d'entrée de 2 canaux après les canaux de sorties
	{ ~numChannels == 128 } {~fxMulChannel = 130 }
	{ ~numChannels == 96 } {~fxMulChannel = 100 }
	{ ~numChannels == 64 } {~fxMulChannel = 70 }
	{ ~numChannels <= 38 } { ~fxMulChannel = 40 }
	{~numChannels > 38 } { ~fxMulChannel = 40 }; // au cas où

	if (~serverFX == 1, { ~fxSeverChannelAdd = ~severOptionsFX.numOutputBusChannels }, { ~fxSeverChannelAdd = 0 } ); // mis dans le 1er fichier Init Buffers Synths



	// GUI d'effets en haut

	~fxSelectView = 0 ! ~numEffects ! 2;
	~fxDefaultView = 0 ! ~numEffects ! 2;
	~fxRandView = 0 ! ~numEffects ! 2;
	~fxRandParametersView = 0 ! ~numEffects ! 2;

	~fxTabbedView = TabbedView2(~globalWindow, Rect(373*~xSizeMul, 2*~ySizeMul, 1228*~xSizeMul, 40*~ySizeMul))
	.lockPosition_(true)
	.lockEdges_(true)
	.followEdges_(false)
	.backgrounds_([Color.black/*Color(0.8, 0.8, 0.8)*/])
	.unfocusedColors_([Color.white])
	.labelColors_([Color.blue])
	.font_(Font("Verdana",11*~fontSizeMul, bold: true))
	.tabHeight_(20*~ySizeMul).tabWidth_(30*~xSizeMul).tabPosition_(\left)/*.tabCurve_(10)*/
	.font_(Font("Verdana",11*~fontSizeMul, bold: false));

	~fxComp = 0 ! 2;
	~fxViewComp = 0 ! 2;

	~fxComp[0] = ~fxTabbedView.add("S1", 0, scroll:false).focusAction={ ~currentServerTab = 0;
		if (~fxSelect[1].sum > 0, {~fxComp[1].unfocusedColor_(Color.red)}, {~fxComp[1].unfocusedColor_(Color.white)} ); ~fxTabbedView.refresh;// Marquer le Tab si le FX de l'autre serveur est actif
	};
	~fxViewComp[0] = CompositeView(~fxComp[0], Rect(82*~xSizeMul, 0, 1144*~xSizeMul, 40*~ySizeMul) /*Rect(480, 2, 1118, 40)*/).background = Color.black /*Color.magenta*/;

	if (~server2.notNil, {
		~fxComp[1] = ~fxTabbedView.add("S2", 1, scroll:false).focusAction={~currentServerTab = 1;
			if (~fxSelect[0].sum > 0, {~fxComp[0].unfocusedColor_(Color.red)}, {~fxComp[0].unfocusedColor_(Color.white)} ); ~fxTabbedView.refresh;// Marquer le Tab si le FX de l'autre serveur est actif
		};
		~fxViewComp[1] = CompositeView(~fxComp[1], Rect(82*~xSizeMul, 0, 1144*~xSizeMul, 40*~ySizeMul) /*Rect(480, 2, 1118, 40)*/).background = Color.black /*Color.magenta*/;
	});

	// Pour afficher les dossiers-sons dans leur intégralité dans le PopUp menu
	~fxSelectViewViewPos = 0 ! 2;
	~nbOfServers.do { |s|
		~fxSelectViewViewPos[s] = [ View(~fxViewComp[s], Rect( 2*~xSizeMul, 2*~ySizeMul, 80*~xSizeMul, 18*~ySizeMul)), View(~fxViewComp[s], Rect( 2*~xSizeMul, 20*~ySizeMul, 80*~xSizeMul, 18*~ySizeMul)), View(~fxViewComp[s], Rect( 162*~xSizeMul, 2*~ySizeMul, 80*~xSizeMul, 18*~ySizeMul)), View(~fxViewComp[s], Rect( 162*~xSizeMul, 20*~ySizeMul, 80*~xSizeMul, 18*~ySizeMul)), View(~fxViewComp[s], Rect( 322*~xSizeMul, 2*~ySizeMul, 80*~xSizeMul, 18*~ySizeMul)) ];
	};
	~fxSelectViewPos = Rect( 0, 0, 120*~xSizeMul, 20*~ySizeMul); /* ! ~numEffects*/
	// ~fxSelectViewPos = [Rect( 460, 2, 80, 20), Rect( 460, 24, 80, 20), Rect( 570, 2, 80, 20), Rect( 570, 24, 80, 20), Rect( 680, 2, 80, 20)]; // OLD sans agrandissement

	~fxRandViewPos = [Rect( 84*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 84*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 244*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 244*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 404*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul)];
	~fxRandViewPos2 = [Rect( 109*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 109*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 269*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 269*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 429*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul)];
	~fxDefaultViewPos = [Rect( 133*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 133*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 293*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 293*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( 453*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul)];

	~fadeTimeSynthFx = 1 ! 2;





	// Functions to trigger the appropriate effect

	// Constitution des fonctions pour changer l'attribution des synthés
	~fxSelectFunctionA = { |a, fxNb, serverNb| var syn, mixLagTime;

		if ( ~lagMixSwitch[serverNb] == 0, {
			mixLagTime = 1;
		},{
			mixLagTime = ~fxSynthDefValues[serverNb][(~fxSynthDef[fxNb].name ++ ~fxSynthDef[fxNb].metadata['order'][1]).asSymbol]/*.postln*/;
		});

		~fxSynth[serverNb][a].release; // ~fxSynth[a].postln;
		// if (~fxSynthA[a] == 0, {syn = ~fxSynth2[a]}, {syn = ~fxSynthA[a]} ); // Avant les EQ après les effets - voire ci-dessous
		if (~fxSynthA[serverNb][a] == 0, { if (~eqChaFXSynth[serverNb][a] == 0, {syn = ~fxSynth2[serverNb][a]}, {syn = ~eqChaFXSynth[serverNb][a]}) }, {syn = ~fxSynthA[serverNb][a]} );
		~fxSynth[serverNb][a] = Synth.before(syn /*~fxSynth2[a]*/, ~fxSynthDef[fxNb].name, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, \fadeTime, ~fadeTimeSynthFx[serverNb], \lagM, mixLagTime] ++ ([~fxSynthDef[fxNb].metadata['order']] ++ [~fxSynthDef[fxNb].metadata['specs'].size.collect { |y| ~fxSynthDefValues[serverNb][(~fxSynthDef[fxNb].name ++ ~fxSynthDef[fxNb].metadata['order'][y]).asSymbol]/*.postln*/ } ]).flop.flat
			++ if (~fxSynthDef[fxNb].metadata['orderMod'].notNil, {
				([~fxSynthDef[fxNb].metadata['orderMod']] ++ [~fxSynthDef[fxNb].metadata['specsM'].size.collect { |y| ~fxSynthDefHPModValues[serverNb][(~fxSynthDef[fxNb].name ++ ~fxSynthDef[fxNb].metadata['orderMod'][y]).asSymbol] }]).flop.flatten });
		);

		/*
		([\in_bus, (a+1)*~fxMulChannel, \fadeTime, ~fadeTimeSynthFx] ++ ([~fxSynthDef[fxNb].metadata['order']] ++ [~fxSynthDef[fxNb].metadata['specs'].size.collect { |y| ~fxSynthDefValues[(~fxSynthDef[fxNb].name ++ ~fxSynthDef[fxNb].metadata['order'][y]).asSymbol] } ]).flop.flat
		++ (if (~fxSynthDef[fxNb].metadata['orderMod'].notNil, {
		([~fxSynthDef[fxNb].metadata['orderMod']] ++ [~fxSynthDef[fxNb].metadata['specsM'].size.collect { |y| ~fxSynthDefHPModValues[(~fxSynthDef[fxNb].name ++ ~fxSynthDef[fxNb].metadata['orderMod'][y]).asSymbol] }]).flop.flatten })) ).postln;
		*/

		/*~fxSynthDef[6].metadata['orderMod']
		.flat*/

		/*
		([~fxSynthDef[0].metadata['order']] ++ [~fxSynthDef[0].metadata['specs'].size.collect { |y| ~fxSynthDefValues[(~fxSynthDef[0].name ++ ~fxSynthDef[0].metadata['order'][y]).asSymbol] } ]).flop.flat
		++ if (~fxSynthDef[0].metadata['orderMod'].notNil, {
		[~fxSynthDef[0].metadata['orderMod']].flat ++ ~fxSynthDef[0].metadata['specsM'].size.collect { |y| ~fxSynthDefHPModValues[(~fxSynthDef[0].name ++ ~fxSynthDef[0].metadata['orderMod'][y]).asSymbol] } });*/

		// Rajout des données de modulation HP
		// [~fadeTimeSynthFx] ++ ([~fxSynthDef[0].metadata['order']].flat ++ ~fxSynthDef[0].metadata['specs'].size.collect { |y| ~fxSynthDefValues[(~fxSynthDef[0].name ++ ~fxSynthDef[0].metadata['order'][y]).asSymbol] }).flop.flat ++
		// [~fxSynthDef[0].metadata['orderMod']].flat ++ ~fxSynthDef[0].metadata['specsM'].size.collect { |y| ~fxSynthDefHPModValues[(~fxSynthDef[0].name ++ ~fxSynthDef[0].metadata['orderMod'][y]).asSymbol] }
		// [~fxSynthDef[fxNb].metadata['orderMod']].flat ++ ~fxSynthDef[fxNb].metadata['specsM'].size.collect { |y| ~fxSynthDefHPModValues[(~fxSynthDef[fxNb].name ++ ~fxSynthDef[fxNb].metadata['orderMod'][y]).asSymbol] }
		// [~fxSynthDef[fxNb].metadata['order']] ++ [~fxSynthDef[fxNb].metadata['specs'].size.collect { |y| ~fxSynthDefValues[(~fxSynthDef[fxNb].name ++ ~fxSynthDef[fxNb].metadata['order'][y]).asSymbol] } ]

	};

	// Constitution des fonctions pour changer l'attribution des synthés avec les variants
	~fxSelectFunctionB = { |a, fxNb, vari, serverNb | var syn, mixLagTime;

		if ( ~lagMixSwitch[serverNb] == 0, {
			mixLagTime = 1;
		},{
			mixLagTime = ~fxSynthDefValues[serverNb][(~fxSynthDef[fxNb].name ++ ~fxSynthDef[fxNb].metadata['order'][1]).asSymbol]/*.postln*/;
		});

		~fxSynth[serverNb][a].release;
		// if (~fxSynthA[a] == 0, {syn = ~fxSynth2[a]}, {syn = ~fxSynthA[a]} ); // Avant les EQ après les effets - voire ci-dessous
		if (~fxSynthA[serverNb][a] == 0, { if (~eqChaFXSynth[serverNb][a] == 0, {syn = ~fxSynth2[serverNb][a]}, {syn = ~eqChaFXSynth[serverNb][a]}) }, {syn = ~fxSynthA[serverNb][a]} );
		~fxSynth[serverNb][a] = Synth.before(syn /*~fxSynth2[a]*/, ~fxSynthDef[fxNb].name ++ "." ++ ~fxSynthDef[fxNb].variants.keys.asArray.sort[vari]/*.asSymbol*/, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, \fadeTime, ~fadeTimeSynthFx[serverNb], \lagM, mixLagTime]
			// Rajout des données de modulation HP
			++ if (~fxSynthDef[fxNb].metadata['orderMod'].notNil, {
				([~fxSynthDef[fxNb].metadata['orderMod']] ++ [~fxSynthDef[fxNb].metadata['specsM'].size.collect { |y| ~fxSynthDefHPModValues[serverNb][(~fxSynthDef[fxNb].name ++ ~fxSynthDef[fxNb].metadata['orderMod'][y]).asSymbol] }]).flop.flatten });

		);/*.register*/ // verifier si .asSymbol peut être retiré ???

		// Action sur les sliders pour récupérer les arguments des variants - vraiment nécessaire ???
		// car pas d'action sur le synthé d'effet avec slider car sinon pas possible d'avoir le même synthé avec 2 configs / variant différents - vraiment utile ???
		// TO KEEP
		if (~fxSynthDef[fxNb].variants.notNil, {
			(~fxSynthDef[fxNb].variants[~fxSynthDef[fxNb].variants.keys.asArray.sort[vari].asSymbol].size / 2)/*~fxSynthDef[fxNb].variants.size*/.do { |i| var a, b;
				a = ~fxSynthDef[fxNb].name;
				b = ~fxSynthDef[fxNb].variants[~fxSynthDef[fxNb].variants.keys.asArray.sort[vari].asSymbol].clump(2).flop;
				~fxSynthDefViews[serverNb][(a ++ b[0][i]).asSymbol].valueAction_(b[1][i])
			}
		});
	};

	// Constitution des fonctions pour changer l'attribution des synthés EQ
	~fxSelectFunctionC1 = { |a, /*fxNb,*/ serverNb| var syn;
		~fxSynth[serverNb][a].release;
		// if (~fxSynthA[a] == 0, {syn = ~fxSynth2[a]}, {syn = ~fxSynthA[a]} ); // Avant les EQ après les effets - voire ci-dessous
		if (~fxSynthA[serverNb][a] == 0, { if (~eqChaFXSynth[serverNb][a] == 0, {syn = ~fxSynth2[serverNb][a]}, {syn = ~eqChaFXSynth[serverNb][a]}) }, {syn = ~fxSynthA[serverNb][a]} );
		~fxSynth[serverNb][a] = Synth.before(syn /*~fxSynth2[a]*/, ~fxSynthDef2b[0].name, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, \fadeTime, ~fadeTimeSynthFx[serverNb], \eqSetting, ~eqUnitLib[serverNb][0]] ) };
	~fxSelectFunctionC2 = { |a, /*fxNb,*/ serverNb| var syn;
		~fxSynth[serverNb][a].release;
		// if (~fxSynthA[a] == 0, {syn = ~fxSynth2[a]}, {syn = ~fxSynthA[a]} ); // Avant les EQ après les effets - voire ci-dessous
		if (~fxSynthA[serverNb][a] == 0, { if (~eqChaFXSynth[serverNb][a] == 0, {syn = ~fxSynth2[serverNb][a]}, {syn = ~eqChaFXSynth[serverNb][a]}) }, {syn = ~fxSynthA[serverNb][a]} );
		~fxSynth[serverNb][a] = Synth.before(syn /*~fxSynth2[a]*/, ~fxSynthDef2b[1].name, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, \fadeTime, ~fadeTimeSynthFx[serverNb], \eqSetting, ~eqUnitLib[serverNb][1]] ) };
	~fxSelectFunctionC3 = { |a, /*fxNb,*/ serverNb| var syn;
		~fxSynth[serverNb][a].release;
		// if (~fxSynthA[a] == 0, {syn = ~fxSynth2[a]}, {syn = ~fxSynthA[a]} ); // Avant les EQ après les effets - voire ci-dessous
		if (~fxSynthA[serverNb][a] == 0, { if (~eqChaFXSynth[serverNb][a] == 0, {syn = ~fxSynth2[serverNb][a]}, {syn = ~eqChaFXSynth[serverNb][a]}) }, {syn = ~fxSynthA[serverNb][a]} );
		~fxSynth[serverNb][a] = Synth.before(syn /*~fxSynth2[a]*/, ~fxSynthDef2b[2].name, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, \fadeTime, ~fadeTimeSynthFx[serverNb], \eqSetting, ~eqUnitLib[serverNb][2]] ) };


	// Constitution des fonctions pour changer l'attribution des synthés Spectraux
	~fxSelectFunctionF1 = { |a, /*fxNb,*/ serverNb| var syn;
		~fxSynth[serverNb][a].release;
		// if (~fxSynthA[a] == 0, {syn = ~fxSynth2[a]}, {syn = ~fxSynthA[a]} ); // Avant les EQ après les effets - voire ci-dessous
		if (~fxSynthA[serverNb][a] == 0, { if (~eqChaFXSynth[serverNb][a] == 0, {syn = ~fxSynth2[serverNb][a]}, {syn = ~eqChaFXSynth[serverNb][a]}) }, {syn = ~fxSynthA[serverNb][a]} );
		~fxSynth[serverNb][a] = Synth.before(syn /*~fxSynth2[a]*/, ~fxSynthDef2c[0].name, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, \fadeTime, ~fadeTimeSynthFx[serverNb], \fftEQSize, ~fftEQSize, \bufnum1, ~fftEQBufs[serverNb][0], \bufnum2, ~fftEQBufs[serverNb][1]] ) };
	~fxSelectFunctionF2 = { |a, /*fxNb,*/ serverNb| var syn;
		~fxSynth[serverNb][a].release;
		// if (~fxSynthA[a] == 0, {syn = ~fxSynth2[a]}, {syn = ~fxSynthA[a]} ); // Avant les EQ après les effets - voire ci-dessous
		if (~fxSynthA[serverNb][a] == 0, { if (~eqChaFXSynth[serverNb][a] == 0, {syn = ~fxSynth2[serverNb][a]}, {syn = ~eqChaFXSynth[serverNb][a]}) }, {syn = ~fxSynthA[serverNb][a]} );
		~fxSynth[serverNb][a] = Synth.before(syn /*~fxSynth2[a]*/, ~fxSynthDef2c[1].name, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, \fadeTime, ~fadeTimeSynthFx[serverNb], \fftDelSize, ~fftDelSize, \dels1, ~fftDelfbBufs[serverNb][0], \fb1, ~fftDelfbBufs[serverNb][1], \dels2, ~fftDelfbBufs[serverNb][2], \fb2, ~fftDelfbBufs[serverNb][3]] ) };
	~fxSelectFunctionF3 = { |a, /*fxNb,*/ serverNb| var syn;
		~fxSynth[serverNb][a].release;
		// if (~fxSynthA[a] == 0, {syn = ~fxSynth2[a]}, {syn = ~fxSynthA[a]} ); // Avant les EQ après les effets - voire ci-dessous
		if (~fxSynthA[serverNb][a] == 0, { if (~eqChaFXSynth[serverNb][a] == 0, {syn = ~fxSynth2[serverNb][a]}, {syn = ~eqChaFXSynth[serverNb][a]}) }, {syn = ~fxSynthA[serverNb][a]} );
		~fxSynth[serverNb][a] = Synth.before(syn /*~fxSynth2[a]*/, ~fxSynthDef2c[2].name, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, \fadeTime, ~fadeTimeSynthFx[serverNb], \fftOutSize, ~fftOutSize, scaleBufs: ~fftOutBufs[serverNb][0]++~fftOutBufs[serverNb][1]] ) };

	/*
	~fxSynthDef[5].metadata['specs'].keys.asArray[1]
	~fxSynthDef[5].metadata['specs'][~fxSynthDef[5].metadata['specs'].keys.asArray[1]]

	~fxSynthDef[5].metadata['order'][1]
	~fxSynthDef[5].metadata['specs'][~fxSynthDef[5].metadata['order'][1]]
	*/

	/*
	(~fxSynth2[0], ~fxSynthDef[0].name, [\in_bus, ~fxbNum[0].interpret[pos], \fadeTime, ~fadeTimeSynthFx])
	[\in_bus, 0, \fadeTime, ~fadeTimeSynthFx] ++ ([~fxSynthDef[0].metadata['specs'].keys.asArray] ++ [~fxSynthDef[0].metadata['specs'].size.collect { |i| ~fxSynthDefValues[(~fxSynthDef[0].name++~fxSynthDef[0].metadata['specs'].keys.asArray[i]).asSymbol] } ]).flop.flat
	*/



	// Regroupement des fonctions pour changer l'attribution des synthés
	~fxSelectFunctions =
	~fxSynthDef.collect { |syn, syni| {|a, serverNb| ~fxSelectFunctionA.value(a, syni, serverNb) } }
	.addFirst({ |a, serverNb| ~fxSynth[serverNb][a].release; ~fxSynth[serverNb][a] = 0;  /*~fxSynth[i].set(\gate, 0)*/ }) ++
	// ~fxSynth[i] = 0; Pour avoir une idée des synthés d'effets en cours - à voir si celà ne coupe pas le release ??? -> OK
	{ |a, serverNb| ~fxSelectFunctionC1.value(a, serverNb) } ++ { |a, serverNb| ~fxSelectFunctionC2.value(a, serverNb) } ++ { |a, serverNb| ~fxSelectFunctionC3.value(a, serverNb) } ++
	{ |a, serverNb| ~fxSelectFunctionF1.value(a, serverNb) } ++ { |a, serverNb| ~fxSelectFunctionF2.value(a, serverNb) } ++ { |a, serverNb| ~fxSelectFunctionF3.value(a, serverNb) } ++
	~fxSynthDef.collect {
		|syn, syni| ~fxSynthDef[syni].variants.size.collect {
			|varia| { |a, serverNb| ~fxSelectFunctionB.value(a, syni, varia, serverNb) } } }.flat;

	// ~fxSynthDef[2].variants
	// ~fxSelectFunctionB.def.sourceCode.postcs





	~compFxBackgroundColors = [Color.gray(0.2).alpha_(0.175) /*Color.blue*/, Color.red];

	// ~alphabet = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
	// Changement pour s'adapter à des listes de FX variables selon la taille des 4 colonnes - Autre manière de distinguer chacun des FX tout en économisant de la place en l'écrivant ???
	~alphabet = "1" ! ~numFxSynthDef1 ++ ("2" ! ~numFxSynthDef2) ++ ("3" ! ~numFxSynthDef3) ++ ("4" ! ~numFxSynthDef4);


	~nbOfServers.do { |s|

		~numEffects.do { |a|

			~fxSelectView[s][a] = PopUpMenu.new(~fxSelectViewViewPos[s][a], ~fxSelectViewPos/*[a]*/)
			.action_({|menu|

				~fxSelect[s][a]/*[~tracksValue][~seqsValue]*/ = menu.value;
				~fxName[s][a+1] = ~fxNameList[a][~fxSelect[s][a]]; // pour l'afficher dans le visu
				~fxSelectFunctions[menu.value].value(a, s); // Fonction d'action sur les synthés


				// Changement du Background pour repérer les sliders qui ont 1 effet car synthé d'effets activés - voire si pas trop lourd en CPU ???

				// Remise à 0 en agissant sur tous les effets ci-dessous est au moins 10/20 x plus lente qu'en agissant seulement sur le Composite View et le bouton pour revenir à la normale
				/*~numFxSynthDef1.do { |i| ~fxTabComp1[i].background_(~compFxBackgroundColors[0]); ~numEffects.do { |fx| ~fxTabCompSel1View[i][fx].value_(0)} };
				~numFxSynthDef2.do { |i| ~fxTabComp2[i].background_(~compFxBackgroundColors[0]); ~numEffects.do { |fx| ~fxTabCompSel2View[i][fx].value_(0)} };
				~numFxSynthDef3.do { |i| ~fxTabComp3[i].background_(~compFxBackgroundColors[0]); ~numEffects.do { |fx| ~fxTabCompSel3View[i][fx].value_(0)} };
				~numFxSynthDef4.do { |i| ~fxTabComp4[i].background_(~compFxBackgroundColors[0]); ~numEffects.do { |fx| ~fxTabCompSel4View[i][fx].value_(0)} };*/
				case
				{ ~fxSelectPrevValue[s][a].inclusivelyBetween(1, ~numFxSynthDef1) and: {~fxSelectPrevValue[s][a] != ~fxSelect[s][a]} } // 2ème condition utilisée pour éviter la remise à 0 si le précédent n'a pas changé et utile aussi pour les ~fftEQRoutRandView qui sont remis à 0 quand on store un preset avec une old selection - à intégrer aussi dans le 2ème case (Changement du Background du Composite View et du bouton de l'effet) ci-dessous -> voire impact CPU ???
				{ var sel = ~fxSelectPrevValue[s][a]-1;
					~fxTabCompSel1View[s][sel][a].value_(0); ~fxTabCompSel1Values[s][sel][a] = 0;
					if (~fxTabCompSel1Values[s][sel].includes(1), {}, {~fxTabComp1[s][sel].background_(~compFxBackgroundColors[0])} ) }
				{ ~fxSelectPrevValue[s][a].inclusivelyBetween(~numFxSynthDef1+1,~numFxSynthDef2Cum) and: {~fxSelectPrevValue[s][a] != ~fxSelect[s][a]} }
				{ var sel = ~fxSelectPrevValue[s][a]-1-~numFxSynthDef1; ~fxSelect[s][0]-1; // [0] sans affectation A quoi celà sert ???????????????????????????
					~fxTabCompSel2View[s][sel][a].value_(0); ~fxTabCompSel2Values[s][sel][a] = 0;
					if (~fxTabCompSel2Values[s][sel].includes(1), {}, {~fxTabComp2[s][sel].background_(~compFxBackgroundColors[0])} ) }
				{ ~fxSelectPrevValue[s][a].inclusivelyBetween(~numFxSynthDef2Cum+1,~numFxSynthDef3Cum) and: {~fxSelectPrevValue[s][a] != ~fxSelect[s][a]} }
				{ var sel = ~fxSelectPrevValue[s][a]-1-~numFxSynthDef1-~numFxSynthDef2;
					~fxTabCompSel3View[s][sel][a].value_(0); ~fxTabCompSel3Values[s][sel][a] = 0;
					if (~fxTabCompSel3Values[s][sel].includes(1), {}, {~fxTabComp3[s][sel].background_(~compFxBackgroundColors[0])} ) }
				{ ~fxSelectPrevValue[s][a].inclusivelyBetween(~numFxSynthDef3Cum+1,~numFxSynthDef) and: {~fxSelectPrevValue[s][a] != ~fxSelect[s][a]} }
				{ var sel = ~fxSelectPrevValue[s][a]-1-~numFxSynthDef1-~numFxSynthDef2-~numFxSynthDef3;
					~fxTabCompSel4View[s][sel][a].value_(0); ~fxTabCompSel4Values[s][sel][a] = 0;
					if (~fxTabCompSel4Values[s][sel].includes(1), {}, {~fxTabComp4[s][sel].background_(~compFxBackgroundColors[0])} ) }
				{ ~fxSelectPrevValue[s][a] == (~numFxSynthDef+1) and: {~fxSelectPrevValue[s][a] != ~fxSelect[s][a]} } // Pour les EQ
				{ ~fxTabCompSel2bView[s][0][a].value_(0); ~fxTabCompSel2bValues[s][0][a] = 0;
					if (~fxTabCompSel2bValues[s][0].includes(1), {}, {~fxTabCompNameEQ1View[s].background_(~sliderBackgroundColor)} ) }
				{ ~fxSelectPrevValue[s][a] == (~numFxSynthDef+2) and: {~fxSelectPrevValue[s][a] != ~fxSelect[s][a]} }
				{ ~fxTabCompSel2bView[s][1][a].value_(0); ~fxTabCompSel2bValues[s][1][a] = 0;
					if (~fxTabCompSel2bValues[s][1].includes(1), {}, {~fxTabCompNameEQ2View[s].background_(~sliderBackgroundColor)} ) }
				{ ~fxSelectPrevValue[s][a] == (~numFxSynthDef+3) and: {~fxSelectPrevValue[s][a] != ~fxSelect[s][a]} }
				{ ~fxTabCompSel2bView[s][2][a].value_(0); ~fxTabCompSel2bValues[s][2][a] = 0;
					if (~fxTabCompSel2bValues[s][2].includes(1), {}, {~fxTabCompNameEQ3View[s].background_(~sliderBackgroundColor)} ) }
				{ ~fxSelectPrevValue[s][a] == (~numFxSynthDef+4) and: {~fxSelectPrevValue[s][a] != ~fxSelect[s][a]} } // Pour les Synthés spectraux
				{ ~fftTabCompSelView[s][0][a].value_(0); ~fftTabCompSelValues[s][0][a] = 0;
					if (~fftTabCompSelValues[s][0].includes(1), {}, {~fftEQTabCompNameView[s].background_(~sliderBackgroundColor); ~fftEQRoutRandView[s].valueAction_(0)} ) }
				{ ~fxSelectPrevValue[s][a] == (~numFxSynthDef+5) and: {~fxSelectPrevValue[s][a] != ~fxSelect[s][a]} }
				{ ~fftTabCompSelView[s][1][a].value_(0); ~fftTabCompSelValues[s][1][a] = 0;
					if (~fftTabCompSelValues[s][1].includes(1), {}, {~fftDelTabCompNameView[s].background_(~sliderBackgroundColor); ~fftDelRoutRandView[s].valueAction_(0)} ) }
				{ ~fxSelectPrevValue[s][a] == (~numFxSynthDef+6) and: {~fxSelectPrevValue[s][a] != ~fxSelect[s][a]} }
				{ ~fftTabCompSelView[s][2][a].value_(0); ~fftTabCompSelValues[s][2][a] = 0;
					if (~fftTabCompSelValues[s][2].includes(1), {}, {~fftOutTabCompNameView[s].background_(~sliderBackgroundColor); ~fftOutRoutRandView[s].valueAction_(0)} ) };

				~fxSelectPrevValue[s][a] = ~fxSelect[s][a];

				// Changement du Background du Composite View et du bouton de l'effet
				case
				{ ~fxSelect[s][a].inclusivelyBetween(1, ~numFxSynthDef1) /*and: {~fxSelectPrevValue[a] != ~fxSelect[a]} /*voire bénéfice CPU de l'intégrer ???*/ */ }
				{ var sel2 = ~fxSelect[s][a]-1;
					~fxTabComp1[s][sel2].background_(~compFxBackgroundColors[1]); ~fxTabCompSel1View[s][sel2][a].value_(1); ~fxTabCompSel1Values[s][sel2][a] = 1 }
				{ ~fxSelect[s][a].inclusivelyBetween(1+~numFxSynthDef1, ~numFxSynthDef2Cum) }
				{ var sel2 = ~fxSelect[s][a]-1-~numFxSynthDef1;
					~fxTabComp2[s][sel2].background_(~compFxBackgroundColors[1]); ~fxTabCompSel2View[s][sel2][a].value_(1); ~fxTabCompSel2Values[s][sel2][a] = 1 }
				{ ~fxSelect[s][a].inclusivelyBetween(1+~numFxSynthDef2Cum, ~numFxSynthDef3Cum) }
				{ var sel2 = ~fxSelect[s][a]-1-~numFxSynthDef1-~numFxSynthDef2;
					~fxTabComp3[s][sel2].background_(~compFxBackgroundColors[1]); ~fxTabCompSel3View[s][sel2][a].value_(1); ~fxTabCompSel3Values[s][sel2][a] = 1 }
				{ ~fxSelect[s][a].inclusivelyBetween(1+~numFxSynthDef3Cum, ~numFxSynthDef) }
				{ var sel2 = ~fxSelect[s][a]-1-~numFxSynthDef1-~numFxSynthDef2-~numFxSynthDef3;
					~fxTabComp4[s][sel2].background_(~compFxBackgroundColors[1]); ~fxTabCompSel4View[s][sel2][a].value_(1); ~fxTabCompSel4Values[s][sel2][a] = 1 }
				{ ~fxSelect[s][a] == (~numFxSynthDef+1) } // Pour les EQ -> action sur le StaticText au lieu du CompositeView pour la visibilité
				{ /*~fxTabEQComp1*/~fxTabCompNameEQ1View[s].background_(~compFxBackgroundColors[1]); ~fxTabCompSel2bView[s][0][a].value_(1); ~fxTabCompSel2bValues[s][0][a] = 1 }
				{ ~fxSelect[s][a] == (~numFxSynthDef+2) }
				{ /*~fxTabEQComp2*/~fxTabCompNameEQ2View[s].background_(~compFxBackgroundColors[1]); ~fxTabCompSel2bView[s][1][a].value_(1); ~fxTabCompSel2bValues[s][1][a] = 1 }
				{ ~fxSelect[s][a] == (~numFxSynthDef+3) }
				{ /*~fxTabEQComp3*/~fxTabCompNameEQ3View[s].background_(~compFxBackgroundColors[1]); ~fxTabCompSel2bView[s][2][a].value_(1); ~fxTabCompSel2bValues[s][2][a] = 1 }
				{ ~fxSelect[s][a] == (~numFxSynthDef+4) }
				{ ~fftEQTabCompNameView[s].background_(~compFxBackgroundColors[1]); ~fftTabCompSelView[s][0][a].value_(1); ~fftTabCompSelValues[s][0][a] = 1 }
				{ ~fxSelect[s][a] == (~numFxSynthDef+5) }
				{ ~fftDelTabCompNameView[s].background_(~compFxBackgroundColors[1]); ~fftTabCompSelView[s][1][a].value_(1); ~fftTabCompSelValues[s][1][a] = 1 }
				{ ~fxSelect[s][a] == (~numFxSynthDef+6) }
				{ ~fftOutTabCompNameView[s].background_(~compFxBackgroundColors[1]); ~fftTabCompSelView[s][2][a].value_(1); ~fftTabCompSelValues[s][2][a] = 1 };


				if (menu.value == 0, {menu.background_(~popUpMenuBackgroundColor/*Color.yellow*/).stringColor_(Color.black) },
					{menu.background_(Color.red(0.7)).stringColor_(Color.white) } );

				~eqChaUpdate1Function.(a, s); // 0 pour le serveur

			})
			.allowsReselection_(false/*true*/) // Pour ne pas permettre de relancer le même effet qui relance un crossfade et donc augmente le CPU - defaults to false - apparemment ne marche pas ??????
			.background_(~popUpMenuBackgroundColor/*Color.yellow*/)
			.stringColor_(Color.black)
			.font_(Font("Verdana",10*~fontSizeMul, bold: true));

			~fxSelectView[s][a].items_(
				// (~fxSynthDef.collect { |item, i| ~fxSynthDef[i].variants.size.collect { |y| (a+1).asString ++ "." ++ ~fxSynthDef[i].name ++ "." ++ ~fxSynthDef[i].variants.keys.asArray.sort[y].asSymbol } }.flatten).addFirst((a+1).asString++".No Fx")
				([(a+1).asString++".No Fx"]) ++
				(~fxSynthDef.collect { |item, i| (a+1).asString ++ ~alphabet.wrapAt(i) ++ "." ++ item.name }) ++
				~fxSynthDef2b[0].name ++ ~fxSynthDef2b[1].name ++ ~fxSynthDef2b[2].name ++ ~fxSynthDef2c[0].name ++ ~fxSynthDef2c[1].name ++ ~fxSynthDef2c[2].name ++
				(~fxSynthDef.collect { |item, i| ~fxSynthDef[i].variants.size.collect { |y| (a+1).asString ++ "." ++ ~fxSynthDef[i].name ++ "." ++ ~fxSynthDef[i].variants.keys.asArray.sort[y].asSymbol } }.flatten)
				/*(a+1).asString++".No Fx",
				(a+1).asString++".Echo1", (a+1).asString++".Echo2", (a+1).asString++".Echo3", (a+1).asString++".Echo4",
				(a+1).asString++".Distort1", (a+1).asString++".Distort2", (a+1).asString++".Distort3", (a+1).asString++".Distort4",
				(a+1).asString++".DisTanh1", (a+1).asString++".DisTanh2",
				(a+1).asString++".Wah1", (a+1).asString++".Wah2", (a+1).asString++".Wah3", (a+1).asString++".Wah4",
				(a+1).asString++".Reverb1", (a+1).asString++".Reverb2", (a+1).asString++".Reverb3", (a+1).asString++".Reverb4",
				(a+1).asString++".RevBath", (a+1).asString++".RevLiving", (a+1).asString++".RevChurch", (a+1).asString++".RevCathe", (a+1).asString++".RevCanyon",*/
			);
			// .valueAction_(0);


			// - 5 pour ne pas sélectionner les synthés de réverb avec GVerb qui provoquent des Spikes CPU à l'intantiation XXXXXX
			~fxListSize = ~fxSelectView[s][0].items.size -1 /*-5*/;

			// Remplacement de ~fxListSize par ~numFxSynthDef+4 pour ne pas avoir un random sur les synthés FFT Diffusion et Delay lorsque le nb de canaux est trop important
			if (~numChannelsFX > 8, {

				~fxRandView[s][a] = RoundButton(~fxViewComp[s], ~fxRandViewPos[a])
				.states_([["R", Color.white, Color.red]])
				.font_(Font("Verdana",9*~fontSizeMul, bold: true))
				.action_({
					if (~fxXfadePlaying[s][a] == 0 and: {~fxXfadePlayingT[s][a].isPlaying == false}, {
						~fxSelectView[s][a].valueAction_((1..~numFxSynthDef+4/*~fxListSize*//*-4*/).choose);
						// Remplacement de ~fxListSize par ~numFxSynthDef+4 pour ne pas avoir un random sur les synthés FFT Diffusion et Delay
						{
							~fxXfadePlayingF.value(a, s);
							("FX Xfade begins - End in" + ( ~fadeTimeSynthFx[s] /*/ ~toTempo*/) ++ "s !!!").warn; (~fadeTimeSynthFx[s]+0.01).wait; "End of Xfade - OK to retrigger".inform;
							if (~fxXfadePlayingT[s][a].isPlaying == false, { ~fxXfadePlaying[s][a] = 0 } );
						}.fork;
					},{
						("Could not trigger randomized FX"+(a+1)).postln;
					});
				});

			},{

				~fxRandView[s][a] = RoundButton(~fxViewComp[s], ~fxRandViewPos[a])
				.states_([["R", Color.white, Color.red]])
				.font_(Font("Verdana",9*~fontSizeMul, bold: true))
				.action_({
					if (~fxXfadePlaying[s][a] == 0 and: {~fxXfadePlayingT[s][a].isPlaying == false}, {
						~fxSelectView[s][a].valueAction_((1..~fxListSize/*-4*/).choose);
						// Remplacement de ~fxListSize par ~numFxSynthDef+4 pour ne pas avoir un random sur les synthés FFT Diffusion et Delay
						{
							~fxXfadePlayingF.value(a, s);
							("FX Xfade begins - End in" + ( ~fadeTimeSynthFx[s] /*/ ~toTempo*/) ++ "s !!!").warn; (~fadeTimeSynthFx[s]+0.01).wait; "End of Xfade - OK to retrigger".inform;
							if (~fxXfadePlayingT[s][a].isPlaying == false, { ~fxXfadePlaying[s][a] = 0 } );
						}.fork;
					},{
						("Could not trigger randomized FX"+(a+1)).postln;
					});
				});

			});

			~fxRandParametersView[s][a] = RoundButton(~fxViewComp[s], ~fxRandViewPos2[a])
			.states_([["RP", Color.red, Color.white]])
			.font_(Font("Verdana",9*~fontSizeMul, bold: true))
			.action_({ case
				{~fxSelect[s][a].inclusivelyBetween(1, ~numFxSynthDef+3)}
				{~fxTabCompRandView[s][~fxSelect[s][a]-1].valueAction_(1);
				}

				// Pour les effets spectraux, Action spécifique pour changer le xfade entre les buffers spectraux
				{~fxSelect[s][a].inclusivelyBetween(1, ~numFxSynthDef+4)}
				{ /*~fftEQRandSlView.valueAction_(1)*/ // Avant juste rand sur le plot mais pas de crossfade entre les buffers
					if (~fftEQBufChoose[s] == 0, {
						~fftEQCompChooseView[s].valueAction_(1); ~fftEQRandSlView[s].valueAction_(1); ~fftEQBufChooseView[s].valueAction_(1);
					},{
						~fftEQCompChooseView[s].valueAction_(0); ~fftEQRandSlView[s].valueAction_(1); ~fftEQBufChooseView[s].valueAction_(0);
					});
					{ /*"".postln;*/ "FFT EQ Xfade in action - Wait !!!".warn; ~fadeTimeSynthFx[s].wait; "FFT EQ Xfade finsished - OK to retrigger".inform }.fork;
				}

				{~fxSelect[s][a].inclusivelyBetween(1, ~numFxSynthDef+5)}
				{ // Avant juste rand sur le plot mais pas de crossfade entre les buffers
					/*case {~fftDelCompChoose == 1} {~fftDelCompChooseView.valueAction_(0)} {~fftDelCompChoose == 3} {~fftDelCompChooseView.valueAction_(2)};
					~fftDelRandSlView.valueAction_(1); ~fftDelCompChooseView.valueAction_(~fftDelCompChoose+1); ~fftDelRandSlView.valueAction_(1); ~fftDelCompChooseView.valueAction_(~fftDelCompChoose-1)*/
					if (~fftDelBufChoose[s] == 0, {
						~fftDelCompChooseView[s].valueAction_(2); ~fftDelRandSlView[s].valueAction_(1);
						~fftDelCompChooseView[s].valueAction_(~fftDelCompChoose[s]+1); ~fftDelRandSlView[s].valueAction_(1); ~fftDelCompChooseView[s].valueAction_(~fftDelCompChoose[s]-1);
						~fftDelBufChooseView[s].valueAction_(1);
					},{
						~fftDelCompChooseView[s].valueAction_(0); ~fftDelRandSlView[s].valueAction_(1);
						~fftDelCompChooseView[s].valueAction_(~fftDelCompChoose[s]+1); ~fftDelRandSlView[s].valueAction_(1); ~fftDelCompChooseView[s].valueAction_(~fftDelCompChoose[s]-1);
						~fftDelBufChooseView[s].valueAction_(0);
					});
					{ /*"".postln;*/ "FFT Delay Xfade in action - Wait !!!".warn; ~fftDelSliderLag[s].wait; "FFT Delay Xfade finsished - OK to retrigger".inform }.fork;
				}

				{~fxSelect[s][a].inclusivelyBetween(1, ~numFxSynthDef+6)}
				{ /*~fftOutRandSlView.valueAction_(1)*/ // Avant juste rand sur le plot mais pas de crossfade entre les buffers
					if (~fftOutBufChoose[s] == 0, {
						~fftOutCompChooseView[s].valueAction_(1); ~fftOutRandSlView[s].valueAction_(1); ~fftOutBufChooseView[s].valueAction_(1);
					},{
						~fftOutCompChooseView[s].valueAction_(0); ~fftOutRandSlView[s].valueAction_(1); ~fftOutBufChooseView[s].valueAction_(0);
					});
					{ /*"".postln;*/ "FFT Out Xfade in action - Wait !!!".warn; ~fftOutSliderLag[s].wait; "FFT Out Xfade finsished - OK to retrigger".inform }.fork;
				}
			});

			~fxDefaultView[s][a] = RoundButton(~fxViewComp[s], ~fxDefaultViewPos[a])
			.states_([["D", Color.white, Color.blue]])
			.font_(Font("Verdana",9*~fontSizeMul, bold: true))
			.action_({ ~fxSelectView[s][a].valueAction_(0);
			});
		};

	};

	~fxNameList = ~numEffects.collect{ |i| ~fxSelectView[0][i].items.put(0,0) }; // pour l'afficher dans le visu


	// Le fait d'utiliser un fork permet d'annuler les CPU spikes ??? non
	// Comment non de réduire l'augmentation de CPU inévitable ???
	// RESULT = 0 si rand sur tous les 5 effets sans qu'il n'y ait de synthés d'effets déjà lancés ??????
	// Nécessaire de lancer les effets une 1ère fois qui provoque 1 CPU spike la 1ère fois que SC est lancé une fois que la machine est redémarrée
	// Pourquoi le synthé distanh provoque un CPU spike à l'instantiation ??????
	// if (~numChannelsFX >= 8, {~fxSynthWaitTime = 0.01}, {~fxSynthWaitTime = 0.1});
	~fxSynthWaitTime = 0.1;

	~fxRandAllView = 0 ! 2;
	~fxRandParametersAllView = 0 ! 2;
	~fxDefaultAllView = 0 ! 2;
	~fxDefaultAll2View = 0 ! 2;

	~nbOfServers.do { |s|

		// Remplacement de ~fxListSize par ~numFxSynthDef+4 pour ne pas avoir un random sur les synthés FFT Diffusion et Delay lorsque le nb de canaux est trop important
		if (~numChannelsFX > 8, {

			~fxRandAllView[s] = RoundButton(~fxViewComp[s], Rect( 325*~xSizeMul, 21*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
			.states_([["RA", Color.white, Color.red]])
			.font_(Font("Verdana",9*~fontSizeMul, bold: true))
			.action_({ // ~numEffects.do {|a| ~fxSelectView[a].valueAction_(((~fxSynthDef.size+1)..~fxListSize).choose) };
				// {~numEffects.do {|a| ~fxSelectView[a].valueAction_(( 1 /*(~fxSynthDef.size+1+2/*EQ*/)*/..~numFxSynthDef+4/*-4*/).choose) ; ~fxSynthWaitTime.wait; } }.fork(AppClock);
				// { ("Try to Wait" + ( ~fadeTimeSynthFx /*/ ~toTempo*/) ++ "s - end of FX Xfade !!!").warn; ~fadeTimeSynthFx.wait; "End of FX Xfade - OK to retrigger".inform }.fork;
				~numEffects.do {|a| ~fxRandView[s][a].valueAction_(1); /*~fxSynthWaitTime.wait;*/ };
			});

		},{

			~fxRandAllView[s] = RoundButton(~fxViewComp[s], Rect( 325*~xSizeMul, 21*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
			.states_([["RA", Color.white, Color.red]])
			.font_(Font("Verdana",9*~fontSizeMul, bold: true))
			.action_({ // ~numEffects.do {|a| ~fxSelectView[a].valueAction_(((~fxSynthDef.size+1)..~fxListSize).choose) };
				// {~numEffects.do {|a| ~fxSelectView[a].valueAction_(( 1 /*(~fxSynthDef.size+1+2/*EQ*/)*/..~fxListSize/*-4*/).choose) ; ~fxSynthWaitTime.wait; } }.fork(AppClock);
				~numEffects.do {|a| ~fxRandView[s][a].valueAction_(1); /*~fxSynthWaitTime.wait;*/ };
			});
		});

		~fxRandParametersAllView[s] = RoundButton(~fxViewComp[s], Rect( 355*~xSizeMul, 21*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
		.states_([["RPA", Color.red, Color.white]])
		.font_(Font("Verdana",9*~fontSizeMul, bold: true))
		.action_({ ~numEffects.do {|a| ~fxRandParametersView[s][a].valueAction_(1) }; if (~fxSelect[s].sum > 0, { "FX Parameters randomized".postln; });
		});

		if ( ~hpModulation == 1, {

			~fxDefaultAllView[s] = RoundButton(~fxViewComp[s], Rect( 385*~xSizeMul, 21*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
			.states_([["RHP", Color.white, Color.blue(0.6)]])
			.font_(Font("Verdana",9*~fontSizeMul, bold: true))
			.action_({
				~fxSelect[s].do { |i|
					if ( i.inclusivelyBetween(1, ~numFxSynthDef),
						{if (~fxTabCompRandHView[s][i-1] != 0, {~fxTabCompRandHView[s][i-1].valueAction_(1) });
					})
				};
				if (~fxSelect[s].sum > 0, {  "FX HP Modulation randomized".postln; });
			});

		},{

			~fxDefaultAllView[s] = RoundButton(~fxViewComp[s], Rect( 385*~xSizeMul, 21*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
			.states_([["D1", Color.black, Color.green]])
			.font_(Font("Verdana",9*~fontSizeMul, bold: true))
			.action_({
				{
					~fxSelectView[s][0].valueAction_(~numFxSynthDef+1+6/*EQ*/); ~fxSynthWaitTime.wait;
					~fxSelectView[s][1].valueAction_(~numFxSynthDef+5+6/*EQ*/); ~fxSynthWaitTime.wait;
					~fxSelectView[s][2].valueAction_(~numFxSynthDef+9+6/*EQ*/); ~fxSynthWaitTime.wait;
					~fxSelectView[s][3].valueAction_(~numFxSynthDef+10+6/*EQ*/); ~fxSynthWaitTime.wait;
					~fxSelectView[s][4].valueAction_(~numFxSynthDef+13+6/*EQ*/); ~fxSynthWaitTime.wait;
				}.fork(AppClock)
			});

		});

		~fxDefaultAll2View[s] = RoundButton(~fxViewComp[s], Rect( 415*~xSizeMul, 21*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
		.states_([["DN", Color.white, Color.blue]])
		.font_(Font("Verdana",9*~fontSizeMul, bold: true))
		.action_({

			var presStart, presStop;

			// ~numEffects.do {|a| ~fxSelectView[a].valueAction_(0) };
			// Remise à 0 seulement si aucun preset n'a de E à la fin dans tous les presets
			// if (~presetSelection.deepCollect(2, { |i| if (i != 0, {i.endsWith("E")}, {false}) }).flat.includes(true), {}, {~numEffects.do {|a| ~fxSelectView[a].valueAction_(0) } });

			if (~fxSelect[s].sum > 0, {

				// Remise à 0 seulement si aucun preset dans la sélection n'a de E à la fin dans toutes les pistes
				if (
					~tracks.collect { |tr|

						presStart = ~presetSeqStart[tr];
						presStop = ~presetSeqStop[tr];

						// (presStart..presStop).collect { |i| if (~presetSeqNbTextViewG[tr][i].isNil, {~presetSeqTextViewG[tr][ i /*~presetSeqNbSelectViewG[tr][i-~nbOfSeqs/*40*/].value-1*/].string.endsWith("E")}, {~presetSeqTextViewG[tr][~presetSeqNbTextViewG[tr][i].string.asInteger-1].string.endsWith("E")}) }
						(presStart..presStop).collect { |i| ~presetSeqTextViewG[tr][ i ].string.endsWith("E") }
					}.flatten.includes(false),
					{~numEffects.do {|a| ~fxSelectView[s][a].valueAction_(0) }; "FX soon stopped".warn; } );

				if (s != ~currentServerTab, { ~fxComp[s].unfocusedColor_(Color.white); ~fxTabbedView.refresh; }); // DéMarquer le Tab si le FX de l'autre serveur est actif

			});

			// ~retriggerPresetViewG[tr].valueAction_(1);
			/*(~presetSeqStart[tr]..~presetSeqStop[tr]).do {|item, i|
			if (~presetSelection[tr][item] != "0", {
			~presetGetFunctionQuick.value(~presetSelection[tr][item].asSymbol, tr, sequenceSelected[i]) })*/
		});

	};










	// Fx pour les synthés ambisoniques

	~fxSynthA = 0 ! ~numEffects ! 2; // Synthés de spatialisation ambisonique qui s'intercalent
	~fxASelect = 0 ! ~numEffects ! 2;
	~fxASelectPrevValue = 0 ! ~numEffects ! 2;
	~fxAName = 0 ! (~numEffects+1) ! 2; // Poursquoi + 1 à ~fxAName ??????

	~fxASelectView = 0 ! ~numEffects ! 2;
	~fxADefaultView = 0 ! ~numEffects ! 2;
	~fxARandView = 0 ! ~numEffects ! 2;
	~fxARandParametersView = 0 ! ~numEffects ! 2;

	~fxARandAllView = 0 ! 2;
	~fxARandParametersAllView = 0 ! 2;
	~fxADefaultAllView = 0 ! 2;
	~fxADefaultAll2View = 0 ! 2;


	~fxARightShift = 665;
	~fxASelectViewViewPos = 0 ! 2;
	~nbOfServers.do { |s|
		~fxASelectViewViewPos[s] = [ View(~fxViewComp[s], Rect( (2+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 70*~xSizeMul, 18*~ySizeMul)), View(~fxViewComp[s], Rect( (2+~fxARightShift)*~xSizeMul, 20*~ySizeMul, 70*~xSizeMul, 18*~ySizeMul)), View(~fxViewComp[s], Rect( (152+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 70*~xSizeMul, 18*~ySizeMul)), View(~fxViewComp[s], Rect( (152+~fxARightShift)*~xSizeMul, 20*~ySizeMul, 70*~xSizeMul, 18*~ySizeMul)), View(~fxViewComp[s], Rect( (302+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 70*~xSizeMul, 18*~ySizeMul)) ];
	};
	~fxASelectViewPos = Rect( 0, 0, 100*~xSizeMul, 20*~ySizeMul) ! ~numEffects;

	~fxARandViewPos = [Rect( (74+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (74+~fxARightShift)*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (224+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (224+~fxARightShift)*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (374+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul)];
	~fxARandViewPos2 = [Rect( (99+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (99+~fxARightShift)*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (249+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (249+~fxARightShift)*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (399+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul)];
	~fxADefaultViewPos = [Rect( (124+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (124+~fxARightShift)*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (274+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (274+~fxARightShift)*~xSizeMul, 20*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul), Rect( (424+~fxARightShift)*~xSizeMul, 2*~ySizeMul, 25*~xSizeMul, 18*~ySizeMul)];



	~fxASelectFunctionA = { |a, fxNb, serverNb|
		~fxSynthA[serverNb][a].release;
		case
		{fxNb.inclusivelyBetween(0, ~numFxSynthDef5-1)}
		{
			~fxSynthA[serverNb][a] = Synth.before(~fxSynth2[serverNb][a], ~fxSynthDefA[fxNb].name, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, /*\out_bus, ~foaBus,*/ \fadeTime, ~fadeTimeSynthFx[serverNb], \distMin, ~distMinAllFxA[serverNb]] ++ ([~fxSynthDefA[fxNb].metadata['order']] ++ [~fxSynthDefA[fxNb].metadata['specs'].size.collect { |y| ~fxSynthDefValues[serverNb][(~fxSynthDefA[fxNb].name.asString[0..2/*(~fxSynthDefA[fxNb].name.asString.size-2)*/] ++ fxNb.asSymbol ++ ~fxSynthDefA[fxNb].metadata['order'][y]).asSymbol] } ]).flop.flat )
		}
		{fxNb.inclusivelyBetween(~numFxSynthDef5, ~numFxSynthDef6Cum-1)}
		{
			~fxSynthA[serverNb][a] = Synth.before(~fxSynth2[serverNb][a], ~fxSynthDefA[fxNb].name, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, /*\out_bus, ~foaBus,*/ \fadeTime, ~fadeTimeSynthFx[serverNb], \distMin, ~distMinAllFxA[serverNb]] ++ ([~fxSynthDefA[fxNb].metadata['order']] ++ [~fxSynthDefA[fxNb].metadata['specs'].size.collect { |y| ~fxSynthDefValues[serverNb][(~fxSynthDefA[fxNb].name.asString[0..2/*(~fxSynthDefA[fxNb].name.asString.size-2)*/] ++ (fxNb-~numFxSynthDef5).asSymbol ++ ~fxSynthDefA[fxNb].metadata['order'][y]).asSymbol] } ]).flop.flat )
		}
		{fxNb.inclusivelyBetween(~numFxSynthDef6Cum, ~numFxSynthDef7Cum-1)}
		{
			~fxSynthA[serverNb][a] = Synth.before(~fxSynth2[serverNb][a], ~fxSynthDefA[fxNb].name, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, /*\out_bus, ~foaBus,*/ \fadeTime, ~fadeTimeSynthFx[serverNb], \distMin, ~distMinAllFxA[serverNb]] ++ ([~fxSynthDefA[fxNb].metadata['order']] ++ [~fxSynthDefA[fxNb].metadata['specs'].size.collect { |y| ~fxSynthDefValues[serverNb][(~fxSynthDefA[fxNb].name.asString[0..1/*(~fxSynthDefA[fxNb].name.asString.size-2)*/] ++ (fxNb-~numFxSynthDef6Cum).asSymbol ++ ~fxSynthDefA[fxNb].metadata['order'][y]).asSymbol] } ]).flop.flat )
		}
		{fxNb.inclusivelyBetween(~numFxSynthDef7Cum, ~numFxSynthDefA-1)}
		{
			~fxSynthA[serverNb][a] = Synth.before(~fxSynth2[serverNb][a], ~fxSynthDefA[fxNb].name, [\in_bus, ((a+1)*~fxMulChannel)+~fxSeverChannelAdd, /*\out_bus, ~foaBus,*/ \fadeTime, ~fadeTimeSynthFx[serverNb], \distMin, ~distMinAllFxA[serverNb]] ++ ([~fxSynthDefA[fxNb].metadata['order']] ++ [~fxSynthDefA[fxNb].metadata['specs'].size.collect { |y| ~fxSynthDefValues[serverNb][(~fxSynthDefA[fxNb].name.asString[0..4/*(~fxSynthDefA[fxNb].name.asString.size-2)*/] ++ (fxNb-~numFxSynthDef7Cum).asSymbol ++ ~fxSynthDefA[fxNb].metadata['order'][y]).asSymbol] } ]).flop.flat )
		}
	};

	// ~fxSynthDefA[~numFxSynthDef6Cum]
	// ~fxSynthDefValues[(~fxSynthDefA[8].name.asString[0..1/*(~fxSynthDefA[fxNb].name.asString.size-2)*/] ++ (8-~numFxSynthDef6Cum).asSymbol ++ ~fxSynthDefA[8].metadata['order'][0]).asSymbol]
	// ~fxSynthDefValues[(~fxSynthDefA[12].name.asString[0..4/*(~fxSynthDefA[fxNb].name.asString.size-2)*/] ++ (12-~numFxSynthDef7Cum).asSymbol ++ ~fxSynthDefA[12].metadata['order'][0]).asSymbol]
	/*
	~fxSynthDefValues['SD0angle']
	~fxSynthDefValues['SDRev1mix']
	~fxSynthDefValues['SDRev2mix']
	~fxSynthDefValues['SDRev3mix']
	~fxSynthDefValues['SDRev4mix']
	~fxSynthDefValues['SDRev0angle']
	~fxSynthDefValues['SDRev0freqMax']
	*/

	~fxASelectFunctions =
	~fxSynthDefA.collect { |syn, syni| {|a, serverNb| ~fxASelectFunctionA.value(a, syni, serverNb) } }
	.addFirst({ |a, serverNb| ~fxSynthA[serverNb][a].release; ~fxSynthA[serverNb][a] = 0;  /*~fxSynth[i].set(\gate, 0)*/ });

	~fxATabCompSelValues = 0 ! 2;


	~nbOfServers.do { |s|

		~numEffects.do { |a|

			~fxASelectView[s][a] = PopUpMenu.new(~fxASelectViewViewPos[s][a], ~fxASelectViewPos[a])
			.action_({|menu|

				~fxASelect[s][a]/*[~tracksValue][~seqsValue]*/ = menu.value;
				~fxAName[s][a+1] = ~fxANameList[a][~fxASelect[s][a]]; // pour l'afficher dans le visu

				~fxASelectFunctions[menu.value].value(a, s); // Fonction d'action sur les synthés


				// Changement du Background pour repérer les sliders qui ont 1 effet car synthé d'effets activés - voire si pas trop lourd en CPU ???

				// Remise à 0 en agissant sur tous les effets ci-dessous est au moins 10/20 x plus lente qu'en agissant seulement sur le Composite View et le bouton pour revenir à la normale
				/*~numFxSynthDef1.do { |i| ~fxTabComp1[i].background_(~compFxBackgroundColors[0]); ~numEffects.do { |fx| ~fxTabCompSel1View[i][fx].value_(0)} };
				~numFxSynthDef2.do { |i| ~fxTabComp2[i].background_(~compFxBackgroundColors[0]); ~numEffects.do { |fx| ~fxTabCompSel2View[i][fx].value_(0)} };
				~numFxSynthDef3.do { |i| ~fxTabComp3[i].background_(~compFxBackgroundColors[0]); ~numEffects.do { |fx| ~fxTabCompSel3View[i][fx].value_(0)} };
				~numFxSynthDef4.do { |i| ~fxTabComp4[i].background_(~compFxBackgroundColors[0]); ~numEffects.do { |fx| ~fxTabCompSel4View[i][fx].value_(0)} };*/
				case
				{ ~fxASelectPrevValue[s][a].inclusivelyBetween(1, ~numFxSynthDef5) and: {~fxASelectPrevValue[s][a] != ~fxASelect[s][a]} } // 2ème condition utilisée pour éviter la remise  à 0 si le précédent n'a pas changé et utile aussi pour les ~fftEQRoutRandView qui sont remis à 0 quand on store un preset avec une old selection - à intégrer aussi dans le 2ème case (Changement du Background du Composite View et du bouton de l'effet) ci-dessous -> voire impact CPU ???
				{ var sel = ~fxASelectPrevValue[s][a]-1;
					~fxTabCompSel5View[s][sel][a].value_(0); ~fxTabCompSel5Values[s][sel][a] = 0;
					~fxACompView[s][sel].background_(~compFxBackgroundColors[0]);
					if (~fxTabCompSel5Values[s][sel].includes(1), {}, {~fxTabComp5[s][sel].background_(~compFxBackgroundColors[0])} ) }
				{ ~fxASelectPrevValue[s][a].inclusivelyBetween(~numFxSynthDef5+1,~numFxSynthDef6Cum) and: {~fxASelectPrevValue[s][a] != ~fxASelect[s][a]} }
				{ var sel = ~fxASelectPrevValue[s][a]-1-~numFxSynthDef5; ~fxASelect[s][0]-1; // [0] sans affectation A quoi celà sert ???????????????????????????
					~fxTabCompSel6View[s][sel][a].value_(0); ~fxTabCompSel6Values[s][sel][a] = 0;
					~fxACompView[s][~fxASelectPrevValue[s][a]-1].background_(~compFxBackgroundColors[0]);
					if (~fxTabCompSel6Values[s][sel].includes(1), {}, {~fxTabComp6[s][sel].background_(~compFxBackgroundColors[0])} ) }
				{ ~fxASelectPrevValue[s][a].inclusivelyBetween(~numFxSynthDef6Cum+1,~numFxSynthDef7Cum) and: {~fxASelectPrevValue[s][a] != ~fxASelect[s][a]} }
				{ var sel = ~fxASelectPrevValue[s][a]-1-~numFxSynthDef5-~numFxSynthDef6;
					~fxTabCompSel7View[s][sel][a].value_(0); ~fxTabCompSel7Values[s][sel][a] = 0;
					if (~fxTabCompSel7Values[s][sel].includes(1), {}, {~fxTabComp7[s][sel].background_(~compFxBackgroundColors[0])} ) }
				{ ~fxASelectPrevValue[s][a].inclusivelyBetween(~numFxSynthDef7Cum+1,~numFxSynthDefA) and: {~fxASelectPrevValue[s][a] != ~fxASelect[s][a]} }
				{ var sel = ~fxASelectPrevValue[s][a]-1-~numFxSynthDef5-~numFxSynthDef6-~numFxSynthDef7;
					~fxTabCompSel8View[s][sel][a].value_(0); ~fxTabCompSel8Values[s][sel][a] = 0;
					if (~fxTabCompSel8Values[s][sel].includes(1), {}, {~fxTabComp8[s][sel].background_(~compFxBackgroundColors[0])} ) };

				~fxASelectPrevValue[s][a] = ~fxASelect[s][a];

				// Changement du Background du Composite View et du bouton de l'effet
				case
				{ ~fxASelect[s][a].inclusivelyBetween(1, ~numFxSynthDef5) /*and: {~fxASelectPrevValue[a] != ~fxASelect[a]} /*voire bénéfice CPU de l'intégrer ???*/ */ }
				{ var sel2 = ~fxASelect[s][a]-1;
					~fxTabComp5[s][sel2].background_(~compFxBackgroundColors[1]); ~fxTabCompSel5View[s][sel2][a].value_(1);
					~fxTabCompSel5Values[s][sel2][a] = 1; ~fxACompView[s][sel2].background_(~compFxBackgroundColors[1]); }
				{ ~fxASelect[s][a].inclusivelyBetween(1+~numFxSynthDef5, ~numFxSynthDef6Cum) }
				{ var sel2 = ~fxASelect[s][a]-1-~numFxSynthDef5;
					~fxTabComp6[s][sel2].background_(~compFxBackgroundColors[1]); ~fxTabCompSel6View[s][sel2][a].value_(1); ~fxTabCompSel6Values[s][sel2][a] = 1;
					~fxACompView[s][ ~fxASelect[s][a]-1].background_(~compFxBackgroundColors[1]); }
				{ ~fxASelect[s][a].inclusivelyBetween(1+~numFxSynthDef6Cum, ~numFxSynthDef7Cum) }
				{ var sel2 = ~fxASelect[s][a]-1-~numFxSynthDef5-~numFxSynthDef6;
					~fxTabComp7[s][sel2].background_(~compFxBackgroundColors[1]); ~fxTabCompSel7View[s][sel2][a].value_(1); ~fxTabCompSel7Values[s][sel2][a] = 1 }
				{ ~fxASelect[s][a].inclusivelyBetween(1+~numFxSynthDef7Cum, ~numFxSynthDefA) }
				{ var sel2 = ~fxASelect[s][a]-1-~numFxSynthDef5-~numFxSynthDef6-~numFxSynthDef7;
					~fxTabComp8[s][sel2].background_(~compFxBackgroundColors[1]); ~fxTabCompSel8View[s][sel2][a].value_(1); ~fxTabCompSel8Values[s][sel2][a] = 1 };

				if (menu.value == 0, {menu.background_(~popUpMenuBackgroundColor/*Color.yellow*/).stringColor_(Color.black) },
					{menu.background_(Color.red(0.7)).stringColor_(Color.white) } );

			})
			// .allowsReselection_(true) // Pour ne pas permettre de relancer le même effet qui relance un crossfade et donc augmente le CPU
			.background_(~popUpMenuBackgroundColor/*Color.yellow*/)
			.stringColor_(Color.black)
			.font_(Font("Verdana",10*~fontSizeMul, bold: true));

			~fxASelectView[s][a].items_(
				([(a+1).asString++".No AFx"]) ++
				~numFxSynthDef5.collect { |i| "Pos" + (i+1).asString } ++
				~numFxSynthDef6.collect { |i| "Rot" + (i+1).asString } ++
				~numFxSynthDef7.collect { |i| "SD" + (i+1).asString } ++
				~numFxSynthDef8.collect { |i| "SDRev" + (i+1).asString }
			);
			// .valueAction_(0);


			~fxAListSize = ~fxASelectView[s][0].items.size -1;

			~fxARandView[s][a] = RoundButton(~fxViewComp[s], ~fxARandViewPos[a])
			.states_([["R", Color.white, Color.red]])
			.font_(Font("Verdana",9*~fontSizeMul, bold: true))
			.action_({ var rand, randTyp;
				// rand = (1..~fxAListSize).rand; // peut déclencher 2 effets identiques - préférable de répérer les effets déjà utilisées pour ne pas les resélectionner
				~fxATabCompSelValues[s] = ~fxTabCompSel5Values[s] ++ ~fxTabCompSel6Values[s] ++ ~fxTabCompSel7Values[s] ++ ~fxTabCompSel8Values[s];
				rand = ~fxATabCompSelValues[s].collect { |i, index| ~fxATabCompSelValues[s][index].includes(1) }.indicesOfEqual(false).choose +1;
				case
				{rand.inclusivelyBetween(1, ~numFxSynthDef5)}
				{
					// Pour ne pas avoir des types identiques
					randTyp = (0..3).reject{ arg item; ~fxSynthDef5SwitchTyp[s].as(Set).as(Array).includes(item) }.choose;
					~fxSynthDef5SwitchTypView[s][rand-1].valueAction_(randTyp /*4.rand*/);
				}
				{rand.inclusivelyBetween(1+~numFxSynthDef5, ~numFxSynthDef6Cum)}
				{
					randTyp = (0..3).reject{ arg item; ~fxSynthDef6SwitchTyp[s].as(Set).as(Array).includes(item) }.choose;
					~fxSynthDef6SwitchTypView[s][rand-1-~numFxSynthDef5].valueAction_(randTyp /*4.rand*/);
				}
				{rand.inclusivelyBetween(1+~numFxSynthDef6Cum, ~numFxSynthDef7Cum)}
				{
					// Pas de random sur le Typ car distribution diversifiée déjà faite
					/*if (~fxSynthDef7SwitchTyp.as(Set).as(Array).size != 4, {
					randTyp = (0..3).reject{ arg item; ~fxSynthDef7SwitchTyp.as(Set).as(Array).includes(item) }.choose;
					~fxSynthDef7SwitchTypView[rand-1-~numFxSynthDef6Cum].valueAction_(randTyp /*4.rand*/);
					});*/
					~fxSynthDef7SwitchTypPCView[s][rand-1-~numFxSynthDef6Cum].valueAction_(2.rand);
				}
				{rand.inclusivelyBetween(1+~numFxSynthDef7Cum, ~numFxSynthDefA)}
				{
					randTyp = (0..3).reject{ arg item; ~fxSynthDef8SwitchTyp[s].as(Set).as(Array).includes(item) }.choose;
					~fxSynthDef8SwitchTypView[s][rand-1-~numFxSynthDef7Cum].valueAction_(randTyp /*4.rand*/);
					~fxSynthDef8SwitchTypPCView[s][rand-1-~numFxSynthDef7Cum].valueAction_(2.rand);
					~fxSynthDef8SwitchRevView[s][rand-1-~numFxSynthDef7Cum].valueAction_(6.rand);
				};
				~fxASelectView[s][a].valueAction_(rand);
				~fxARandParametersView[s][a].valueAction_(1); // mise en place d'un random des paramètres
			});

			~fxARandParametersView[s][a] = RoundButton(~fxViewComp[s], ~fxARandViewPos2[a])
			.states_([["RP", Color.red, Color.white]])
			.font_(Font("Verdana",9*~fontSizeMul, bold: true))
			.action_({
				case
				{~fxASelect[s][a].inclusivelyBetween(1, ~numFxSynthDefA)}
				{~fxATabCompRandView[s][~fxASelect[s][a]-1].valueAction_(1)}
			});

			~fxADefaultView[s][a] = RoundButton(~fxViewComp[s], ~fxADefaultViewPos[a])
			.states_([["D", Color.white, Color.blue]])
			.font_(Font("Verdana",9*~fontSizeMul, bold: true))
			.action_({ ~fxASelectView[s][a].valueAction_(0);
			});
		};

		~fxANameList = ~numEffects.collect{ |i| ~fxASelectView[s][0].items.put(0,0) }; // pour l'afficher dans le visu
		// A retirer du .do





		~fxARandAllView[s] = RoundButton(~fxViewComp[s], Rect( (305+~fxARightShift)*~xSizeMul, 21*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
		.states_([["RA", Color.white, Color.red]])
		.font_(Font("Verdana",9*~fontSizeMul, bold: true))
		.action_({

			{~numEffects.do {|a| /*~fxASelectView[a].valueAction_(( 1..~fxAListSize).choose)*/ ~fxARandView[s][a].valueAction_(1); ~fxSynthWaitTime.wait; } }.fork(AppClock)
		});

		~fxARandParametersAllView[s] = RoundButton(~fxViewComp[s], Rect( (335+~fxARightShift)*~xSizeMul, 21*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
		.states_([["RPA", Color.red, Color.white]])
		.font_(Font("Verdana",9*~fontSizeMul, bold: true))
		.action_({ ~numEffects.do {|a| ~fxARandParametersView[s][a].valueAction_(1) }
		});

		~fxADefaultAllView[s] = RoundButton(~fxViewComp[s], Rect( (365+~fxARightShift)*~xSizeMul, 21*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
		.states_([["D1", Color.black, Color.green]])
		.font_(Font("Verdana",9*~fontSizeMul, bold: true))
		.action_({
			{
				~fxASelectView[s][0].valueAction_(1); ~fxSynthWaitTime.wait;
				~fxASelectView[s][1].valueAction_(4); ~fxSynthWaitTime.wait;
				~fxASelectView[s][2].valueAction_(7); ~fxSynthWaitTime.wait;
				~fxASelectView[s][3].valueAction_(9); ~fxSynthWaitTime.wait;
				~fxASelectView[s][4].valueAction_(11); ~fxSynthWaitTime.wait;
			}.fork(AppClock)
		});

		~fxADefaultAll2View[s] = RoundButton(~fxViewComp[s], Rect( (395+~fxARightShift)*~xSizeMul, 21*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
		.states_([["DN", Color.white, Color.blue]])
		.font_(Font("Verdana",9*~fontSizeMul, bold: true))
		.action_({
			// ~numEffects.do {|a| ~fxSelectView[a].valueAction_(0) };
			// Remise à 0 seulement si aucun preset n'a de E à la fin dans tous les presets
			// if (~presetSelection.deepCollect(2, { |i| if (i != 0, {i.endsWith("E")}, {false}) }).flat.includes(true), {}, {~numEffects.do {|a| ~fxSelectView[a].valueAction_(0) } });

			// Remise à 0 seulement si aucun preset dans la sélection n'a de E à la fin dans tous les presets
			if (
				~tracks.collect { |tr|
					// (~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| if (~presetSeqNbTextViewG[tr][i].isNil, {~presetSeqTextViewG[tr][ i /*~presetSeqNbSelectViewG[tr][i-~nbOfSeqs/*40*/].value-1*/].string.endsWith("E")}, {~presetSeqTextViewG[tr][~presetSeqNbTextViewG[tr][i].string.asInteger-1].string.endsWith("E")}) }
					(~presetSeqStart[tr]..~presetSeqStop[tr]).collect { |i| ~presetSeqTextViewG[tr][ i ].string.endsWith("E") }
				}.flatten.includes(false),
				{~numEffects.do {|a| ~fxASelectView[s][a].valueAction_(0) } } );

			// ~retriggerPresetViewG[tr].valueAction_(1);
			/*(~presetSeqStart[tr]..~presetSeqStop[tr]).do {|item, i|
			if (~presetSelection[tr][item] != "0", {
			~presetGetFunctionQuick.value(~presetSelection[tr][item].asSymbol, tr, sequenceSelected[i])  })*/
		});

	};
















	// Création automatique des GUI des sliders de synthés d'effets

	/*
	~fxSynthDef[0].name
	~fxSynthDef[0].variants
	~fxSynthDef[0].variants.size
	~fxSynthDef[0].variants.keys.asArray.sort
	~fxSynthDef[0].allControlNames
	~fxSynthDef[0].controls
	~fxSynthDef[0].desc

	~fxSynthDef[0].metadata
	~fxSynthDef[0].metadata['specs']
	~fxSynthDef[0].metadata['specs'].keys
	~fxSynthDef[0].metadata['specs'].keys.size
	~fxSynthDef[0].metadata['specs'].keys.asArray[0]
	~fxSynthDef[0].metadata['specs']['dtime']
	~fxSynthDef[0].metadata[\order].reject{|x| x.key==\out}
	*/

	~fxTabComp1 = 0 ! ~numFxSynthDef1 ! 2;
	~fxTabComp2 = 0 ! ~numFxSynthDef2 ! 2;
	~fxTabComp3 = 0 ! ~numFxSynthDef3 ! 2;
	~fxTabComp4 = 0 ! ~numFxSynthDef4 ! 2;
	~fxTabComp5 = 0 ! ~numFxSynthDef5 ! 2;
	~fxTabComp6 = 0 ! ~numFxSynthDef6 ! 2;
	~fxTabComp7 = 0 ! ~numFxSynthDef7 ! 2;
	~fxTabComp8 = 0 ! ~numFxSynthDef8 ! 2;
	~fxTabCompName1View = 0 ! ~numFxSynthDef1 ! 2;
	~fxTabCompName2View = 0 ! ~numFxSynthDef2 ! 2;
	~fxTabCompName3View = 0 ! ~numFxSynthDef3 ! 2;
	~fxTabCompName4View = 0 ! ~numFxSynthDef4 ! 2;
	~fxTabCompName5View = 0 ! ~numFxSynthDef5 ! 2;
	~fxTabCompName6View = 0 ! ~numFxSynthDef6 ! 2;
	~fxTabCompName7View = 0 ! ~numFxSynthDef7 ! 2;
	~fxTabCompName8View = 0 ! ~numFxSynthDef8 ! 2;

	~fxTabCompRandM1View = 0 ! ~numFxSynthDef1 ! 2;
	~fxTabCompRandM2View = 0 ! ~numFxSynthDef2 ! 2;
	~fxTabCompRandM3View = 0 ! ~numFxSynthDef3 ! 2;
	~fxTabCompRandM4View = 0 ! ~numFxSynthDef4 ! 2;
	~fxTabCompRandL1View = 0 ! ~numFxSynthDef1 ! 2;
	~fxTabCompRandL2View = 0 ! ~numFxSynthDef2 ! 2;
	~fxTabCompRandL3View = 0 ! ~numFxSynthDef3 ! 2;
	~fxTabCompRandL4View = 0 ! ~numFxSynthDef4 ! 2;
	~fxTabCompRand1View = 0 ! ~numFxSynthDef1 ! 2;
	~fxTabCompRand2View = 0 ! ~numFxSynthDef2 ! 2;
	~fxTabCompRand3View = 0 ! ~numFxSynthDef3 ! 2;
	~fxTabCompRand4View = 0 ! ~numFxSynthDef4 ! 2;

	~fxTabCompRand5View = 0 ! ~numFxSynthDef5 ! 2;
	~fxTabCompRand6View = 0 ! ~numFxSynthDef6 ! 2;
	~fxTabCompRand7View = 0 ! ~numFxSynthDef7 ! 2;
	~fxTabCompRand8View = 0 ! ~numFxSynthDef8 ! 2;
	~fxTabCompRandA1View = 0 ! ~numFxSynthDef1 ! 2;
	~fxTabCompRandA2View = 0 ! ~numFxSynthDef2 ! 2;
	~fxTabCompRandA3View = 0 ! ~numFxSynthDef3 ! 2;
	~fxTabCompRandA4View = 0 ! ~numFxSynthDef4 ! 2;
	~fxTabCompRandA5View = 0 ! ~numFxSynthDef5 ! 2;
	~fxTabCompRandA6View = 0 ! ~numFxSynthDef6 ! 2;
	~fxTabCompRandA7View = 0 ! ~numFxSynthDef7 ! 2;
	~fxTabCompRandA8View = 0 ! ~numFxSynthDef8 ! 2;
	~fxTabCompRandH1View = 0 ! ~numFxSynthDef1 ! 2;
	~fxTabCompRandH2View = 0 ! ~numFxSynthDef2 ! 2;
	~fxTabCompRandH3View = 0 ! ~numFxSynthDef3 ! 2;
	~fxTabCompRandH4View = 0 ! ~numFxSynthDef4 ! 2;
	~fxTabCompRandH5View = 0 ! ~numFxSynthDef5 ! 2;
	~fxTabCompRandH6View = 0 ! ~numFxSynthDef6 ! 2;
	~fxTabCompRandH7View = 0 ! ~numFxSynthDef7 ! 2;
	~fxTabCompRandH8View = 0 ! ~numFxSynthDef8 ! 2;
	~fxTabCompDef1View = 0 ! ~numFxSynthDef1 ! 2;
	~fxTabCompDef2View = 0 ! ~numFxSynthDef2 ! 2;
	~fxTabCompDef3View = 0 ! ~numFxSynthDef3 ! 2;
	~fxTabCompDef4View = 0 ! ~numFxSynthDef4 ! 2;
	~fxTabCompDef5View = 0 ! ~numFxSynthDef5 ! 2;
	~fxTabCompDef6View = 0 ! ~numFxSynthDef6 ! 2;
	~fxTabCompDef7View = 0 ! ~numFxSynthDef7 ! 2;
	~fxTabCompDef8View = 0 ! ~numFxSynthDef8 ! 2;

	~fxSynthDef5SwitchTypView = 0 ! ~numFxSynthDef5 ! 2;
	~fxSynthDef5SwitchTyp = 0 ! ~numFxSynthDef5 ! 2;
	~fxSynthDef6SwitchTypView = 0 ! ~numFxSynthDef6 ! 2;
	~fxSynthDef6SwitchTyp = 0 ! ~numFxSynthDef6 ! 2;

	~fxSynthDef7SwitchTypView = 0 ! ~numFxSynthDef7 ! 2;
	~fxSynthDef7SwitchTyp = 0 ! ~numFxSynthDef7 ! 2;
	~fxSynthDef7SwitchTypPCView = 0 ! ~numFxSynthDef7 ! 2;
	~fxSynthDef7SwitchTypPC = 0 ! ~numFxSynthDef7 ! 2;

	~fxSynthDef8SwitchRevView = 0 ! ~numFxSynthDef8 ! 2;
	~fxSynthDef8SwitchRev = 0 ! ~numFxSynthDef8 ! 2;
	~fxSynthDef8SwitchTypView = 0 ! ~numFxSynthDef8 ! 2;
	~fxSynthDef8SwitchTyp = 0 ! ~numFxSynthDef8 ! 2;
	~fxSynthDef8SwitchTypPCView = 0 ! ~numFxSynthDef8 ! 2;
	~fxSynthDef8SwitchTypPC = 0 ! ~numFxSynthDef8 ! 2;

	~fxTabCompSel1View = {0 ! ~numEffects ! ~numFxSynthDef1} ! 2;
	~fxTabCompSel2View = {0 ! ~numEffects ! ~numFxSynthDef2} ! 2;
	~fxTabCompSel3View = {0 ! ~numEffects ! ~numFxSynthDef3} ! 2;
	~fxTabCompSel4View = {0 ! ~numEffects ! ~numFxSynthDef4} ! 2;
	~fxTabCompSel5View = {0 ! ~numEffects ! ~numFxSynthDef5} ! 2;
	~fxTabCompSel6View = {0 ! ~numEffects ! ~numFxSynthDef6} ! 2;
	~fxTabCompSel7View = {0 ! ~numEffects ! ~numFxSynthDef7} ! 2;
	~fxTabCompSel8View = {0 ! ~numEffects ! ~numFxSynthDef8} ! 2;
	~fxTabCompSel1Values = {0 ! ~numEffects ! ~numFxSynthDef1} ! 2;
	~fxTabCompSel2Values = {0 ! ~numEffects ! ~numFxSynthDef2} ! 2;
	~fxTabCompSel3Values = {0 ! ~numEffects ! ~numFxSynthDef3} ! 2;
	~fxTabCompSel4Values = {0 ! ~numEffects ! ~numFxSynthDef4} ! 2;
	~fxTabCompSel5Values = {0 ! ~numEffects ! ~numFxSynthDef5} ! 2;
	~fxTabCompSel6Values = {0 ! ~numEffects ! ~numFxSynthDef6} ! 2;
	~fxTabCompSel7Values = {0 ! ~numEffects ! ~numFxSynthDef7} ! 2;
	~fxTabCompSel8Values = {0 ! ~numEffects ! ~numFxSynthDef8} ! 2;

	// ~tabFx.view.decorator = FlowLayout(~tabFx.view.bounds);
	// ~tabFx.layout_(VLayout(HLayout(~fxTabComp)));
	// ~tabFx.view.decorator.gap = 5@5;

	~fxSynthDefValues = 0 ! 2;
	~fxSynthDefHPModValues = 0 ! 2;
	~fxSynthDefViews = 0 ! 2;
	~fxSynthDefValues = 0 ! 2;
	~fxSynthDefHPModValues = 0 ! 2;
	~nbOfServers.do { |s| ~fxSynthDefValues[s] = IdentityDictionary.new; ~fxSynthDefHPModValues[s] = IdentityDictionary.new; ~fxSynthDefViews[s] = IdentityDictionary.new; };
	/*
	~fxSynthDefValues[\echodtime]
	~fxSynthDefViews[\echodtime]
	*/



	// ~fxTabCompSelFunction = 0 ! (4 + 4); // 4 colonnes // à supprimer ??????

	~fxTabCompSelFunctions = [
		{ |fxNb, sel, serverNb| ~fxSelectView[serverNb][fxNb].valueAction_(sel)},
		{ |fxNb, sel, serverNb| ~fxSelectView[serverNb][fxNb].valueAction_(sel+~numFxSynthDef1)},
		{ |fxNb, sel, serverNb| ~fxSelectView[serverNb][fxNb].valueAction_(sel+~numFxSynthDef1+~numFxSynthDef2)},
		{ |fxNb, sel, serverNb| ~fxSelectView[serverNb][fxNb].valueAction_(sel+~numFxSynthDef1+~numFxSynthDef2+~numFxSynthDef3)},

		{ |fxNb, sel, serverNb| ~fxASelectView[serverNb][fxNb].valueAction_(sel)},
		{ |fxNb, sel, serverNb| ~fxASelectView[serverNb][fxNb].valueAction_(sel+~numFxSynthDef5)},
		{ |fxNb, sel, serverNb| ~fxASelectView[serverNb][fxNb].valueAction_(sel+~numFxSynthDef5+~numFxSynthDef6)},
		{ |fxNb, sel, serverNb| ~fxASelectView[serverNb][fxNb].valueAction_(sel+~numFxSynthDef5+~numFxSynthDef6+~numFxSynthDef7)}
	];

	~fxSynthDefASwitchRevViewItems = ~ambATKSynthDefSDRevDelaytimes.collect { |i, index| (index+1).asString ++". Rev - Delay: "++ ~ambATKSynthDefSDRevDelaytimes[index].asString ++ " - Decay: " ++ ~ambATKSynthDefSDRevDecaytimes[index].asString};
	~fxSynthDefASwitchTypViewItems = ["Zoom","Focus","Push","Press"];



	~lagMixSwitch = 0 ! 2;

	// Affichage des synthés d'effets dans une colonne selon la catégorie

	~makeFxColumn = { | envir, nb, widthPos, heightPos, tab,
		fxSynthDefNb, fxTabCompNb, fxTabCompNameNbView, fxTabCompRandMNbView, fxTabCompRandLNbView, fxTabCompRandNbView, fxTabCompRandANbView, fxTabCompRandHNbView, fxTabCompDefNbView, fxTabCompSelNbView, fxTabCompSelNbValues, serverNb
		|

		// ~makeFxColumn.(currentEnvironment, 1, 2, 4, ~tabFx[0], \fxSynthDef1, \fxTabComp1, \fxTabCompName1View, \fxTabCompRandM1View, \fxTabCompRandL1View, \fxTabCompRand1View, \fxTabCompRandA1View, \fxTabCompRandH1View, \fxTabCompDef1View, \fxTabCompSel1View, \fxTabCompSel1Values);

		envir[fxSynthDefNb].do { |item, syni|

			var lastHeight;
			var metadata, synthDef, mod;
			synthDef = envir[fxSynthDefNb][syni];
			metadata = synthDef.metadata;
			mod = ~numChannelsFX.collect { |a| ( ( ((a) / (~numChannelsFX-1) /*- 0.5*/) * 0 ) ) }; // à simplifier puisque 0

			if (envir[fxTabCompNb][serverNb][syni-1].isNil, {lastHeight = heightPos}, {lastHeight = envir[fxTabCompNb][serverNb][syni-1].bounds.top + envir[fxTabCompNb][serverNb][syni-1].bounds.height + 5} );

			// ~fxTabComp[syni] = CompositeView(tab, Rect(2, 2, 308, 6 + ((~fxSynthDef[syni].metadata['specs'].keys.size + 1) * 22))).background = Color.blue;

			if (~hpModulation == 1, {

				envir[fxTabCompNb][serverNb][syni] = CompositeView(tab, Rect(widthPos, lastHeight, 383*~xSizeMul, (8 + (( (if (~fxSynthDefNoHPMod.includes(envir[fxSynthDefNb][syni].name) == false, {envir[fxSynthDefNb][syni].metadata['specsM'].keys.size},{0})) + envir[fxSynthDefNb][syni].metadata['specs'].keys.size + 1) * 19))*~ySizeMul)).background = ~compFxBackgroundColors[0] /*~compFxBackgroundColors.wrapAt(syni)*/;

			}, {

				envir[fxTabCompNb][serverNb][syni] = CompositeView(tab, Rect(widthPos, lastHeight, 383*~xSizeMul, (8 + ((envir[fxSynthDefNb][syni].metadata['specs'].keys.size + 1) * 19))*~ySizeMul)).background = ~compFxBackgroundColors[0] /*~compFxBackgroundColors.wrapAt(syni)*/;

			});

			// if (i > 1 and: {~fxSynthDefNoHPMod.includes(envir[fxSynthDefNb][syni].name) == false}, {

			envir[fxTabCompNb][serverNb][syni].decorator = FlowLayout(tab.view.bounds);
			envir[fxTabCompNb][serverNb][syni].decorator.gap = (1*~xSizeMul)@(1*~ySizeMul);

			envir[fxTabCompNameNbView][serverNb][syni] = StaticText(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 113*~xSizeMul /*8*/, 20*~ySizeMul)).stringColor_(Color.yellow).background_(Color.grey(0.5)).font_(Font("Verdana",12*~fontSizeMul, bold: true)).align_(\center);

			case
			{nb == 1}
			{~fxTabCompName1View[serverNb][syni].string = ~alphabet[syni] ++ ". " ++ ~fxSynthDef1[syni].name;}
			{nb == 2}
			{~fxTabCompName2View[serverNb][syni].string = ~alphabet[syni+~numFxSynthDef1] ++ ". " ++ ~fxSynthDef2[syni].name;}
			{nb == 3}
			{~fxTabCompName3View[serverNb][syni].string = ~alphabet[syni+~numFxSynthDef1+~numFxSynthDef2] ++ ". " ++ ~fxSynthDef3[syni].name;}
			{nb == 4}
			{~fxTabCompName4View[serverNb][syni].string = ~alphabet[syni+~numFxSynthDef1+~numFxSynthDef2+~numFxSynthDef3] ++ ". " ++ ~fxSynthDef4[syni].name;};


			~numEffects.do { |fx|
				envir[fxTabCompSelNbView][serverNb][syni][fx] = RoundButton(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
				.states_([[(fx+1).asString, Color.white, Color.grey(0.5)],[(fx+1).asString, Color.red, Color.yellow]])
				.font_(Font("Verdana",10*~fontSizeMul, bold: true))
				.action_({ |a| // fx.postln; syni.postln;
					envir[fxTabCompSelNbValues][serverNb][syni][fx] = a.value;
					if (a.value == 1, {
						~fxTabCompSelFunctions[nb-1].(fx,syni+1, serverNb);
					},{
						~fxSelectView[serverNb][fx].valueAction_(0);
					})
				})
			};


			if (~hpModulation == 1 and: {envir[fxSynthDefNb][syni].metadata['specsM'].notNil}, {

				envir[fxTabCompDefNbView][serverNb][syni] = RoundButton(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
				.states_([["Def", Color.white, Color.blue]])
				.font_(Font("Verdana",10*~fontSizeMul, bold: true))
				.action_({ |a|
					envir[fxSynthDefNb][syni].metadata['specs'].keys.size.do { |i|
						~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['order'][i]).asSymbol].valueAction_(envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i]].default);
					};
					envir[fxSynthDefNb][syni].metadata['specsM'].keys.size.do { |i|
						~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['orderM'][i]).asSymbol].valueAction_(0);
					}
				});

			},{

				envir[fxTabCompDefNbView][serverNb][syni] = RoundButton(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
				.states_([["Def", Color.white, Color.blue]])
				.font_(Font("Verdana",10*~fontSizeMul, bold: true))
				.action_({ |a|
					envir[fxSynthDefNb][syni].metadata['specs'].keys.size.do { |i|
						~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['order'][i]).asSymbol].valueAction_(envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i]].default);
					}
				});
			});

			envir[fxTabCompRandMNbView][serverNb][syni] = RoundButton(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
			.states_([["M", Color.black, Color.white/*grey*/]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				/*(envir[fxSynthDefNb][syni].metadata['specsR'].keys.size).do { |i|
				~fxSynthDefViews[(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['specsR'].keys.asArray[i]).asSymbol].valueAction_(envir[fxSynthDefNb][syni].metadata['specsR'][envir[fxSynthDefNb][syni].metadata['specsR'].keys.asArray[i]].map(1.0.rand))};*/

				~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ \mix /*listSpecR.keys.asArray[i]*/).asSymbol].valueAction_(1.0.rand2)/*(listSpecR[listSpecR.keys.asArray[i]].map(1.0.rand))*/
			});

			envir[fxTabCompRandLNbView][serverNb][syni] = RoundButton(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
			.states_([["L", Color.black, Color.white/*grey*/]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				/*(envir[fxSynthDefNb][syni].metadata['specsR'].keys.size).do { |i|
				~fxSynthDefViews[(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['specsR'].keys.asArray[i]).asSymbol].valueAction_(envir[fxSynthDefNb][syni].metadata['specsR'][envir[fxSynthDefNb][syni].metadata['specsR'].keys.asArray[i]].map(1.0.rand))};*/

				~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ \lag /*listSpecR.keys.asArray[i]*/).asSymbol].valueAction_(30.0.rand)/*(listSpecR[listSpecR.keys.asArray[i]].map(1.0.rand))*/
			});

			envir[fxTabCompRandNbView][serverNb][syni] = RoundButton(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
			.states_([["RP", Color.red, Color.white]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				/*(envir[fxSynthDefNb][syni].metadata['specsR'].keys.size).do { |i|
				~fxSynthDefViews[(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['specsR'].keys.asArray[i]).asSymbol].valueAction_(envir[fxSynthDefNb][syni].metadata['specsR'][envir[fxSynthDefNb][syni].metadata['specsR'].keys.asArray[i]].map(1.0.rand))};*/
				var listSpecR = envir[fxSynthDefNb][syni].metadata['specsR'];
				listSpecR.keys.size.do { |i|
					~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ listSpecR.keys.asArray[i]).asSymbol].valueAction_(listSpecR[listSpecR.keys.asArray[i]].map(1.0.rand))};
			});


			if (~hpModulation == 1 and: {envir[fxSynthDefNb][syni].metadata['specsM'].notNil}, {

				envir[fxTabCompRandANbView][serverNb][syni] = RoundButton(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
				.states_([["A", Color.white, Color.blue(0.6)]])
				.font_(Font("Verdana",10*~fontSizeMul, bold: true))
				.action_({ |a|
					/*(envir[fxSynthDefNb][syni].metadata['specsR'].keys.size).do { |i|
					~fxSynthDefViews[(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['specsR'].keys.asArray[i]).asSymbol].valueAction_(envir[fxSynthDefNb][syni].metadata['specsR'][envir[fxSynthDefNb][syni].metadata['specsR'].keys.asArray[i]].map(1.0.rand))};*/

					var listSpecR = envir[fxSynthDefNb][syni].metadata['specsR'];
					var listSpecM = envir[fxSynthDefNb][syni].metadata['specsM'];

					listSpecR.keys.size.do { |i|
						~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ listSpecR.keys.asArray[i]).asSymbol].valueAction_(listSpecR[listSpecR.keys.asArray[i]].map(1.0.rand))};

					listSpecM.keys.size.do { |i|
						~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ listSpecM.keys.asArray[i]).asSymbol].valueAction_(listSpecM[listSpecM.keys.asArray[i]].map(1.0.rand))};
				});

				envir[fxTabCompRandHNbView][serverNb][syni] = RoundButton(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
				.states_([["RH", Color.white, Color.blue(0.6)]])
				.font_(Font("Verdana",10*~fontSizeMul, bold: true))
				.action_({ |a|
					/*(envir[fxSynthDefNb][syni].metadata['specsR'].keys.size).do { |i|
					~fxSynthDefViews[(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['specsR'].keys.asArray[i]).asSymbol].valueAction_(envir[fxSynthDefNb][syni].metadata['specsR'][envir[fxSynthDefNb][syni].metadata['specsR'].keys.asArray[i]].map(1.0.rand))};*/
					var listSpecR = envir[fxSynthDefNb][syni].metadata['specsM'];
					listSpecR.keys.size.do { |i|
						~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ listSpecR.keys.asArray[i]).asSymbol].valueAction_(listSpecR[listSpecR.keys.asArray[i]].map(1.0.rand))};
				});
			});


			if (~hpModulation == 1 and: {envir[fxSynthDefNb][syni].metadata['specsM'].notNil}, {

				envir[fxSynthDefNb][syni].metadata['specs'].keys.size.do { |i|

					envir[fxTabCompNb][serverNb][syni].decorator.nextLine;

					~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['order'][i]).asSymbol] =
					EZSlider.new2(envir[fxTabCompNb][serverNb][syni], (375*~xSizeMul)@(18*~ySizeMul), envir[fxSynthDefNb][syni].metadata['order'][i].asString, envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i]],
						{ |ez| var orderM, mod, mixLagTime;

							//	{
							~fxSynthDefValues[serverNb][(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['order'][i]).asSymbol] = ez.value/*.postln*/;
							/*(ez.value.asString ++" is the value of " ++ ez).postln*/

							if ( ~lagMixSwitch[serverNb] == 0, { // Ajout pour le lag du mix
								mixLagTime = 1;
							},{
								// "hey".postln;
								// mixLagTime = ~fxSynthDefValues[(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['order'][1]).asSymbol];
								mixLagTime = ~fxSynthDefValues[serverNb][(synthDef.name ++ metadata['order'][1]).asSymbol];
								/*~fxSynthDefValues[(~fxSynthDef[fxNb].name ++ ~fxSynthDef[fxNb].metadata['order'][1]).asSymbol]*/ /*.postln*/
							});

							// Synth(~fxSynthDef[0].name).isPlaying.postln; // only if .register
							// Synth(~fxSynthDef[0].name).set(~fxSynthDef[0].metadata['specs'].keys.asArray[i], ez.value);
							// Check sur tous les synthés fx en cours parmi la liste pour actionner le controle d'un synthé spécifique repéré sur chacun des HP
							// ~fxSynth[0].defName == ~fxSynthDef[0].name
							// ~fxSynth[0].defName.asString.contains(~fxSynthDef[0].name.asString)
							~fxSynth[serverNb].do { |itemk, k| if (~fxSynth[serverNb][k] != 0 and: {~fxSynth[serverNb][k].defName.asString /*.contains(*/ == envir[fxSynthDefNb][syni].name.asString /*)*/ }, {

								// ~fxSynthDefNoHPMod.includes(~fxSynthDef[6].name) == false

								// 0.1.wait;

								if (i > 1 and: {~fxSynthDefNoHPMod.includes(envir[fxSynthDefNb][syni].name) == false}, {

									orderM = ~fxSynthDefValues[serverNb][(synthDef.name ++ metadata['orderM'][i-2]).asSymbol];
									mod = ~numChannelsFX.collect { |a| ( ( ((a) / (~numChannelsFX-1) /*- 0.5*/) * orderM ) ) };

									~fxSynthDefHPModValues[serverNb][(synthDef.name ++ metadata['orderMod'][i-2]).asSymbol] = ((
										/*metadata['specs'][metadata['order'][i+2]].map(
										metadata['specs'][envir[metadata['order'][i+2]].unmap(*/
										~fxSynthDefValues[serverNb][(synthDef.name ++ metadata['order'][i]).asSymbol]/*)*/ /*.postln*/

										/*+ (mod.abs.lincurve(0, 1, 0, metadata['specs'][metadata['order'][i+2]].clipHi, metadata['specs'][metadata['order'][i+2]].warp) * mod.sign).postln*/
										+ ((metadata['specs'][metadata['order'][i]].map((mod.abs + (metadata['specs'][metadata['order'][i]].unmap( ~fxSynthDefValues[serverNb][(synthDef.name ++ metadata['order'][i]).asSymbol] ))).fold(0, 1) ) ) * mod.sign)/*.postln*/
										// - metadata['specs'][metadata['order'][i+2]].clipLo

									).wrap /*clip*/(metadata['specs'][metadata['order'][i]].clipLo, metadata['specs'][metadata['order'][i]].clipHi))/*.postln*/;

									itemk.set(envir[fxSynthDefNb][syni].metadata['order'][i], ez.value,
										\lagM, mixLagTime, // Ajout pour le lag du mix
										metadata['orderM'][i-2], orderM,
										metadata['orderMod'][i-2], (~fxSynthDefHPModValues[serverNb][(synthDef.name ++ metadata['orderMod'][i-2]).asSymbol]));

									// ~fxSynthDefViews[(~fxSynthDef[0].name ++ ~fxSynthDef[0].metadata['orderM'][0]).asSymbol]
									// ~fxSynthDefViews[(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['orderM'][i-2]).asSymbol].doAction;
								},{

									// itemk.set(envir[fxSynthDefNb][syni].metadata['order'][i], ez.value);
									itemk.set(envir[fxSynthDefNb][syni].metadata['order'][i], ez.value, \lagM, mixLagTime);

								});

								/*itemk.set(envir[fxSynthDefNb][syni].metadata['orderMod'][i], ((~fxSynthDefValues[(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['order'][i+2]).asSymbol].postln + (mod * envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i+2]].range).postln).wrap/*clip*/(envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i+2]].clipLo, envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i+2]].clipHi)).postln)*/

							} ) };
							//	}.fork(AppClock);
						},
						unitWidth:0, initVal:envir[fxSynthDefNb][syni].controls[5+i], numberWidth:60*~xSizeMul, labelWidth:70*~xSizeMul, layout:\horz)
					.setColors(Color.grey,Color.white)
					.font_(Font("Helvetica",11*~fontSizeMul))
					.valueAction_(envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i]].default);

				};


				// ~fxSynthDefNoHPMod.includes(~fxSynthDef[6].name)

				if (~fxSynthDefNoHPMod.includes(envir[fxSynthDefNb][syni].name), { }, {

					envir[fxSynthDefNb][syni].metadata['specsM'].keys.size.do { |i|

						envir[fxTabCompNb][serverNb][syni].decorator.nextLine;

						~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['orderM'][i]).asSymbol] =
						EZSlider.new2(envir[fxTabCompNb][serverNb][syni], (375*~xSizeMul)@(18*~ySizeMul), envir[fxSynthDefNb][syni].metadata['orderM'][i].asString, envir[fxSynthDefNb][syni].metadata['specsM'][envir[fxSynthDefNb][syni].metadata['orderM'][i]],
							{ |ez| var mod;
								~fxSynthDefValues[serverNb][(synthDef.name ++ metadata['orderM'][i]).asSymbol] = ez.value/*.postln*/;
								mod = ~numChannelsFX.collect { |i| ( ( ((i) / (~numChannelsFX-1) /*- 0.5*/) * ez.value) ) }/*.postln*/;
								/*(ez.value.asString ++" is the value of " ++ ez).postln*/

								// Synth(~fxSynthDef[0].name).isPlaying.postln; // only if .register
								// Synth(~fxSynthDef[0].name).set(~fxSynthDef[0].metadata['specs'].keys.asArray[i], ez.value);
								// Check sur tous les synthés fx en cours parmi la liste pour actionner le controle d'un synthé spécifique repéré sur chacun des HP
								// ~fxSynth[0].defName == ~fxSynthDef[0].name
								// ~fxSynth[0].defName.asString.contains(~fxSynthDef[0].name.asString)
								~fxSynth[serverNb].do { |itemk, k| if (~fxSynth[serverNb][k] != 0 and: {~fxSynth[serverNb][k].defName.asString /*.contains(*/ == envir[fxSynthDefNb][syni].name.asString /*)*/ }, {

									// {

									~fxSynthDefHPModValues[serverNb][(synthDef.name ++ metadata['orderMod'][i]).asSymbol] = ((
										/*metadata['specs'][metadata['order'][i+2]].map(
										metadata['specs'][envir[metadata['order'][i+2]].unmap(*/
										~fxSynthDefValues[serverNb][(synthDef.name ++ metadata['order'][i+2]).asSymbol]/*)*/ /*.postln*/

										/*+ (mod.abs.lincurve(0, 1, 0, metadata['specs'][metadata['order'][i+2]].clipHi, metadata['specs'][metadata['order'][i+2]].warp) * mod.sign).postln*/
										+ ((metadata['specs'][metadata['order'][i+2]].map((mod.abs + (metadata['specs'][metadata['order'][i+2]].unmap( ~fxSynthDefValues[serverNb][(synthDef.name ++ metadata['order'][i+2]).asSymbol] ))).fold(0, 1) ) ) * mod.sign) /*.postln*/
										// - metadata['specs'][metadata['order'][i+2]].clipLo

									).wrap /*clip*/(metadata['specs'][metadata['order'][i+2]].clipLo, metadata['specs'][metadata['order'][i+2]].clipHi)).postln;

									/*~fxSynthDefHPModValues[(synthDef.name ++ metadata['orderMod'][i]).asSymbol] = (
									/*metadata['specs'][metadata['order'][i+2]].map(
									metadata['specs'][envir[metadata['order'][i+2]].unmap(*/


									(metadata['specs'][metadata['order'][i+2]].map(
									(~fxSynthDefViews[(synthDef.name ++ metadata['order'][i+2]).asSymbol].value/*)*/ .postln

									/*+ (mod.abs.lincurve(0, 1, 0, metadata['specs'][metadata['order'][i+2]].clipHi, metadata['specs'][metadata['order'][i+2]].warp) * mod.sign).postln*/
									+ mod).fold(0, 1) /*.postln*/
									// - metadata['specs'][metadata['order'][i+2]].clipLo
									)

									))/*.fold /*clip*/(metadata['specs'][metadata['order'][i+2]].clipLo, metadata['specs'][metadata['order'][i+2]].clipHi)*/.postln;*/

									itemk.set(metadata['orderM'][i], ez.value, metadata['orderMod'][i], (~fxSynthDefHPModValues[serverNb][(synthDef.name ++ metadata['orderMod'][i]).asSymbol]));
									// 0.1.wait;
									// itemk.set(metadata['orderMod'][i], (~fxSynthDefHPModValues[(synthDef.name ++ metadata['orderMod'][i]).asSymbol])/*.postln*/)

									// }.fork(AppClock);

								} ) };

								// ~fxSynthDefValues[(synthDef.name ++ metadata['order'][i]).asSymbol] + (mod * metadata['specs'][metadata['order'][i]].range)
								// Addition de la valeur du contrôle +/- le range du contrôle * (-1 à 1) -> puis clippé ou wrapé

								// Mode de calcul de la variation des paramètres entre les HP =
								// (valeur de contrôle + (modulateur HP allant de - 1 à +1) * range du contrôle).fold(minimum de la valeur de contrôle, maximum de la valeur de contrôle)
								// .clip / fold / wrap
							},
							unitWidth:0, initVal:envir[fxSynthDefNb][syni].controls[5+i], numberWidth:60*~xSizeMul, labelWidth:90*~xSizeMul, layout:\horz)
						.setColors(Color.blue(0.6),Color.white)
						.font_(Font("Helvetica",11*~fontSizeMul))
						.valueAction_(envir[fxSynthDefNb][syni].metadata['specsM'][envir[fxSynthDefNb][syni].metadata['orderM'][i]].default);


						// Initialisation des données HP Mod

						if (metadata['orderMod'].notNil, {
							~fxSynthDefHPModValues[serverNb][(synthDef.name ++ metadata['orderMod'][i]).asSymbol] = ((
								/*metadata['specs'][metadata['order'][i+2]].map(
								metadata['specs'][envir[metadata['order'][i+2]].unmap(*/
								~fxSynthDefValues[serverNb][(synthDef.name ++ metadata['order'][i+2]).asSymbol]/*)*/

								/*+ (mod.abs.lincurve(0, 1, 0, metadata['specs'][metadata['order'][i+2]].clipHi, metadata['specs'][metadata['order'][i+2]].warp) * mod.sign).postln*/
								+ ((metadata['specs'][metadata['order'][i+2]].map((mod.abs + (metadata['specs'][metadata['order'][i+2]].unmap( ~fxSynthDefValues[serverNb][(synthDef.name ++ metadata['order'][i+2]).asSymbol] ))).fold(0, 1) ) ) * mod.sign)
								// - metadata['specs'][metadata['order'][i+2]].clipLo

							).wrap /*clip*/(metadata['specs'][metadata['order'][i+2]].clipLo, metadata['specs'][metadata['order'][i+2]].clipHi));
						});

					};

				});


				/*
				~fxSynthDef[0].name
				~fxSynthDef[1].controls[5]
				~fxSynthDef[0].metadata['orderM']
				0.5.lincurve(0, 1, 0, 6, \exp /*~fxSynthDef[0].metadata['specs'][~fxSynthDef[0].metadata['order'][0]].warp.asSpecifier*/).postln
				~fxSynthDef[0].metadata['specs'][~fxSynthDef[0].metadata['order'][0]].warp.asSpecifier
				CurveWarp
				.map(0)
				.clipLo
				.keys.asArray
				ControlSpec
				~fxTabComp[syni].decorator.nextLine;
				~fxSynthDefValues[(~fxSynthDef1[1].name ++ ~fxSynthDef1[1].metadata['order'][3]).asSymbol]
				~numChannelsFX.collect { |i| i.postln; ( ( ((i) / (~numChannelsFX-1) - 0.5) * 2) ).clip(-1,1) } // wrap(-1,1)
				~numChannelsFX.collect { |i| i.postln; ( ( ((i) / (~numChannelsFX-1) ) * (1)) ) }
				[-1, 0, 1].sign
				[0, 2, 6].fold(0, 5)
				[0, 2, 6].clip(0, 5)
				[0, 2, 6].wrap(0, 5)
				*/


			}, {

				envir[fxSynthDefNb][syni].metadata['specs'].keys.size.do { |i|

					envir[fxTabCompNb][serverNb][syni].decorator.nextLine;

					~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['order'][i]).asSymbol] =
					EZSlider.new2(envir[fxTabCompNb][serverNb][syni], (375*~xSizeMul)@(18*~ySizeMul), envir[fxSynthDefNb][syni].metadata['order'][i].asString, envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i]],
						{ |ez| var mixLagTime;
							~fxSynthDefValues[serverNb][(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['order'][i]).asSymbol] = ez.value;

							if ( ~lagMixSwitch[serverNb] == 0, { // Ajout pour le lag du mix
								mixLagTime = 1;
							},{
								// "hey".postln;
								mixLagTime = ~fxSynthDefValues[serverNb][(envir[fxSynthDefNb][syni].name ++ envir[fxSynthDefNb][syni].metadata['order'][1]).asSymbol];
								// mixLagTime = ~fxSynthDefValues[(synthDef.name ++ metadata['order'][1]).asSymbol];
								/*~fxSynthDefValues[(~fxSynthDef[fxNb].name ++ ~fxSynthDef[fxNb].metadata['order'][1]).asSymbol]*/ /*.postln*/
							});

							/*(ez.value.asString ++" is the value of " ++ ez).postln*/

							// Synth(~fxSynthDef[0].name).isPlaying.postln; // only if .register
							// Synth(~fxSynthDef[0].name).set(~fxSynthDef[0].metadata['specs'].keys.asArray[i], ez.value);
							// Check sur tous les synthés fx en cours parmi la liste pour actionner le controle d'un synthé spécifique repéré sur chacun des HP
							// ~fxSynth[0].defName == ~fxSynthDef[0].name
							// ~fxSynth[0].defName.asString.contains(~fxSynthDef[0].name.asString)
							~fxSynth[serverNb].do { |itemk, k| if (~fxSynth[serverNb][k] != 0 and: {~fxSynth[serverNb][k].defName.asString /*.contains(*/ == envir[fxSynthDefNb][syni].name.asString /*)*/ }, {itemk.set(envir[fxSynthDefNb][syni].metadata['order'][i], ez.value, \lagM, mixLagTime)} ) };
						},
						unitWidth:0, initVal:envir[fxSynthDefNb][syni].controls[5+i], numberWidth:60*~xSizeMul, labelWidth:68*~xSizeMul, layout:\horz)
					.setColors(Color.grey,Color.white)
					.font_(Font("Helvetica",11*~fontSizeMul))
					.valueAction_(envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i]].default);

				};

			});

		};
	};





	~makeFxAColumn = { | envir, nb, widthPos, heightPos, tab,
		fxSynthDefNb, fxSynthDefNbALL, fxTabCompNb, fxTabCompNameNbView, fxTabCompRandNbView, fxTabCompDefNbView, fxTabCompSelNbView, fxTabCompSelNbValues, numfxSynthDefNb,
		synthNameSize, fxSynthDefNbSwitchTypView, fxSynthDefNbSwitchTyp, serverNb
		|

		envir[numfxSynthDefNb].do { |item, syni|

			var lastHeight;

			if (envir[fxTabCompNb][serverNb][syni-1].isNil, {lastHeight = heightPos}, {lastHeight = envir[fxTabCompNb][serverNb][syni-1].bounds.top + envir[fxTabCompNb][serverNb][syni-1].bounds.height + 5} );

			// ~fxTabComp[syni] = CompositeView(tab, Rect(2, 2, 308, 6 + ((~fxSynthDef[syni].metadata['specs'].keys.size + 1) * 22))).background = Color.blue;


			if (nb == 8, {
				envir[fxTabCompNb][serverNb][syni] = CompositeView(tab, Rect(widthPos, lastHeight, 383*~xSizeMul, (100 + ((envir[fxSynthDefNb][syni].metadata['specs'].keys.size + 1) * 19))*~ySizeMul)).background = ~compFxBackgroundColors[0] /*~compFxBackgroundColors.wrapAt(syni)*/;
			},{
				envir[fxTabCompNb][serverNb][syni] = CompositeView(tab, Rect(widthPos, lastHeight, 383*~xSizeMul, (70 + ((envir[fxSynthDefNb][syni].metadata['specs'].keys.size + 1) * 19))*~ySizeMul)).background = ~compFxBackgroundColors[0] /*~compFxBackgroundColors.wrapAt(syni)*/;
			});


			envir[fxTabCompNb][serverNb][syni].decorator = FlowLayout(tab.view.bounds);
			envir[fxTabCompNb][serverNb][syni].decorator.gap = (1*~xSizeMul)@(1*~ySizeMul);

			envir[fxTabCompNameNbView][serverNb][syni] = StaticText(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 168*~xSizeMul, 20*~ySizeMul)).stringColor_(Color.yellow).background_(Color.grey(0.5)).font_(Font("Verdana",12*~fontSizeMul, bold: true)).align_(\center);


			envir[fxTabCompNameNbView][serverNb][syni].string = envir[fxSynthDefNb][syni].name.asString[0..synthNameSize] + (syni+1).asString; // Pour retirer le chiffre du nom du synthé


			~numEffects.do { |fx|
				envir[fxTabCompSelNbView][serverNb][syni][fx] = RoundButton(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
				.states_([[(fx+1).asString, Color.white, Color.grey(0.5)],[(fx+1).asString, Color.red, Color.yellow]])
				.font_(Font("Verdana",10*~fontSizeMul, bold: true))
				.action_({ |a| // fx.postln; syni.postln;
					envir[fxTabCompSelNbValues][serverNb][syni][fx] = a.value;
					if (a.value == 1, {
						~fxTabCompSelFunctions[nb-1].(fx,syni+1, serverNb);
					},{
						~fxASelectView[serverNb][fx].valueAction_(0);
					})
				})
			};


			envir[fxTabCompRandNbView][serverNb][syni] = RoundButton(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Rand", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				var listSpecR = envir[fxSynthDefNb][syni].metadata['specsR'];
				listSpecR.keys.size.do { |i|
					~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name.asString[0..synthNameSize /*(envir[fxSynthDefNb][syni].name.asString.size-2)*/] ++ syni.asSymbol ++ listSpecR.keys.asArray[i]).asSymbol].valueAction_(listSpecR[listSpecR.keys.asArray[i]].map(1.0.rand))};
			});

			envir[fxTabCompDefNbView][serverNb][syni] = RoundButton(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Def", Color.white, Color.blue]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[fxSynthDefNb][syni].metadata['specs'].keys.size.do { |i|
					~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name.asString[0..synthNameSize /*(envir[fxSynthDefNb][syni].name.asString.size-2)*/] ++ syni.asSymbol ++ envir[fxSynthDefNb][syni].metadata['order'][i]).asSymbol].valueAction_(envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i]].default);
				}
			});


			envir[fxTabCompNb][serverNb][syni].decorator.nextLine;

			envir[fxSynthDefNbSwitchTypView][serverNb][syni] = ListView.new(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 60*~xSizeMul, 60*~ySizeMul))
			.action_({|menu| envir[fxSynthDefNbSwitchTyp][serverNb][syni] = menu.value;
				envir[fxSynthDefNb] = envir[fxSynthDefNbSwitchTyp][serverNb].size.collect { |a| envir[fxSynthDefNbALL][envir[fxSynthDefNbSwitchTyp][serverNb][a]] };
				~fxSynthDefA = ~fxSynthDef5 ++ ~fxSynthDef6 ++ ~fxSynthDef7 ++ ~fxSynthDef8;
				// ~numEffects.do { |a| if (~fxASelect[a].inclusivelyBetween(~fxSynthDefA.size-3, ~fxSynthDefA.size), {~fxASelectView[a].valueAction_(~fxASelect[a]) }) }; // Redéclenchement du synthé si changement des paramètres de réverb
			})
			.background_(Color.gray(0.7) /*~popUpMenuBackgroundColor*/)
			.hiliteColor_(Color.yellow)
			.selectedStringColor_(Color.red)
			.font_(Font("Verdana",(11*~fontSizeMul).asInteger, bold: true));
			envir[fxSynthDefNbSwitchTypView][serverNb][syni].items_(~fxSynthDefASwitchTypViewItems)
			.valueAction_(syni);


			case
			{nb == 7}
			{
				~fxSynthDef7SwitchTypPCView[serverNb][syni] = ListView.new(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 70*~xSizeMul, 32*~ySizeMul))
				.action_({|menu| ~fxSynthDef7SwitchTypPC[serverNb][syni] = menu.value;
					~fxSynthDef7 = ~fxSynthDef7SwitchTyp[serverNb].size.collect { |a| ~fxSynthDef7ALL.clump(4)[~fxSynthDef7SwitchTypPC[serverNb][a]][~fxSynthDef7SwitchTyp[serverNb][a]] };
					~fxSynthDefA = ~fxSynthDef5 ++ ~fxSynthDef6 ++ ~fxSynthDef7 ++ ~fxSynthDef8;
				})
				.background_(Color.gray(0.7) /*~popUpMenuBackgroundColor*/)
				.hiliteColor_(Color.yellow)
				.selectedStringColor_(Color.red)
				.font_(Font("Verdana",(11*~fontSizeMul).asInteger, bold: true));
				~fxSynthDef7SwitchTypPCView[serverNb][syni].items_(["Polar", "Cartesian"])
				.valueAction_(0);
			}
			{nb == 8}
			{
				~fxSynthDef8SwitchTypPCView[serverNb][syni] = ListView.new(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 52*~xSizeMul, 32*~ySizeMul))
				.action_({|menu| ~fxSynthDef8SwitchTypPC[serverNb][syni] = menu.value;
					~fxSynthDef8 = ~fxSynthDef8SwitchTyp[serverNb].size.collect { |a| ~fxSynthDef8ALL.clump(4).clump(~ambATKSynthDefSDRevDelaytimes.size)[~fxSynthDef8SwitchTypPC[serverNb][0]][~fxSynthDef8SwitchRev[serverNb][0]][~fxSynthDef8SwitchTyp[serverNb][0]] };
					~fxSynthDefA = ~fxSynthDef5 ++ ~fxSynthDef6 ++ ~fxSynthDef7 ++ ~fxSynthDef8;
				})
				.background_(Color.gray(0.7) /*~popUpMenuBackgroundColor*/)
				.hiliteColor_(Color.yellow)
				.selectedStringColor_(Color.red)
				.font_(Font("Verdana",(11*~fontSizeMul).asInteger, bold: true));
				~fxSynthDef8SwitchTypPCView[serverNb][syni].items_(["Polar", "Cartes"])
				.valueAction_(0);

				~fxSynthDef8SwitchRevView[serverNb][syni] = ListView.new(envir[fxTabCompNb][serverNb][syni], Rect(2*~xSizeMul, 2*~ySizeMul, 260*~xSizeMul, 90*~ySizeMul))
				.action_({|menu| ~fxSynthDef8SwitchRev[serverNb][syni] = menu.value;
					~fxSynthDef8 = ~fxSynthDef8SwitchTyp[serverNb].size.collect { |a| ~fxSynthDef8ALL.clump(4).clump(~ambATKSynthDefSDRevDelaytimes.size)[~fxSynthDef8SwitchTypPC[serverNb][a]][~fxSynthDef8SwitchRev[serverNb][a]][~fxSynthDef8SwitchTyp[serverNb][a]] };
					~fxSynthDefA = ~fxSynthDef5 ++ ~fxSynthDef6 ++ ~fxSynthDef7 ++ ~fxSynthDef8;
				})
				.background_(Color.gray(0.7) /*~popUpMenuBackgroundColor*/)
				.hiliteColor_(Color.yellow)
				.selectedStringColor_(Color.red)
				.font_(Font("Verdana",(11*~fontSizeMul).asInteger, bold: true));
				~fxSynthDef8SwitchRevView[serverNb][syni].items_(~fxSynthDefASwitchRevViewItems)
				.valueAction_(0);
			};


			envir[fxSynthDefNb][syni].metadata['specs'].keys.size.do { |i|

				envir[fxTabCompNb][serverNb][syni].decorator.nextLine;

				~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name.asString[0..synthNameSize /*(envir[fxSynthDefNb][syni].name.asString.size-2)*/] ++ syni.asSymbol ++ envir[fxSynthDefNb][syni].metadata['order'][i]).asSymbol] =
				EZSlider.new2(envir[fxTabCompNb][serverNb][syni], (375*~xSizeMul)@(18*~ySizeMul), envir[fxSynthDefNb][syni].metadata['order'][i].asString, envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i]],
					{ |ez| ~fxSynthDefValues[serverNb][(envir[fxSynthDefNb][syni].name.asString[0..synthNameSize /*(envir[fxSynthDefNb][syni].name.asString.size-2)*/] ++ syni.asSymbol ++ envir[fxSynthDefNb][syni].metadata['order'][i]).asSymbol] = ez.value;

						~fxSynthA[serverNb].do { |itemk, k| if (~fxSynthA[serverNb][k] != 0 and: {~fxSynthA[serverNb][k].defName.asString /*.contains(*/ == envir[fxSynthDefNb][syni].name.asString /*)*/ }, {itemk.set(envir[fxSynthDefNb][syni].metadata['order'][i], ez.value)} ) };
					},
					unitWidth:0, initVal:envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i]].default /*envir[fxSynthDefNb][syni].controls[5+i]*/, numberWidth:60*~xSizeMul, labelWidth:58*~xSizeMul, layout:\horz)
				.setColors(Color.grey,Color.white)
				.font_(Font("Helvetica",11*~fontSizeMul))
				.valueAction_(envir[fxSynthDefNb][syni].metadata['specs'][envir[fxSynthDefNb][syni].metadata['order'][i]].default);

				if (envir[fxSynthDefNb][syni].metadata['order'][i].asSymbol == \angle, {
					~fxSynthDefViews[serverNb][(envir[fxSynthDefNb][syni].name.asString[0..synthNameSize] ++ syni.asSymbol ++ envir[fxSynthDefNb][syni].metadata['order'][i]).asSymbol].setColors(stringBackground: Color.red);
				});

			};

		};
	};



	// currentEnvironment[\fxSynthDef8][0].controls[5+i]
	// currentEnvironment[\fxSynthDef8][0].metadata['specs'][currentEnvironment[\fxSynthDef8][0].metadata['order'][0]].default

	~nbOfServers.do { |s|

		~makeFxColumn.(currentEnvironment, 1, 2*~xSizeMul, 4*~ySizeMul, ~tabFx[s], \fxSynthDef1, \fxTabComp1, \fxTabCompName1View, \fxTabCompRandM1View, \fxTabCompRandL1View, \fxTabCompRand1View, \fxTabCompRandA1View, \fxTabCompRandH1View, \fxTabCompDef1View, \fxTabCompSel1View, \fxTabCompSel1Values, s);
		~makeFxColumn.(currentEnvironment, 2, 395*~xSizeMul, 4*~ySizeMul, ~tabFx[s], \fxSynthDef2, \fxTabComp2, \fxTabCompName2View, \fxTabCompRandM2View, \fxTabCompRandL2View, \fxTabCompRand2View, \fxTabCompRandA2View, \fxTabCompRandH2View, \fxTabCompDef2View, \fxTabCompSel2View, \fxTabCompSel2Values, s);
		~makeFxColumn.(currentEnvironment, 3, 790*~xSizeMul, 167*~ySizeMul, ~tabFx[s], \fxSynthDef3, \fxTabComp3, \fxTabCompName3View, \fxTabCompRandM3View, \fxTabCompRandL3View, \fxTabCompRand3View, \fxTabCompRandA3View, \fxTabCompRandH3View, \fxTabCompDef3View, \fxTabCompSel3View, \fxTabCompSel3Values, s);
		~makeFxColumn.(currentEnvironment, 4, 1185*~xSizeMul, 4*~ySizeMul, ~tabFx[s], \fxSynthDef4, \fxTabComp4, \fxTabCompName4View, \fxTabCompRandM4View, \fxTabCompRandL4View, \fxTabCompRand4View, \fxTabCompRandA4View, \fxTabCompRandH4View, \fxTabCompDef4View, \fxTabCompSel4View, \fxTabCompSel4Values, s);

		~makeFxAColumn.(currentEnvironment, 5, 2*~xSizeMul, 4*~ySizeMul, ~tabAmb[s], \fxSynthDef5, \fxSynthDef5ALL, \fxTabComp5, \fxTabCompName5View, \fxTabCompRand5View, \fxTabCompDef5View, \fxTabCompSel5View, \fxTabCompSel5Values, \numFxSynthDef5, 2, \fxSynthDef5SwitchTypView, \fxSynthDef5SwitchTyp, s);
		~makeFxAColumn.(currentEnvironment, 6, 395*~xSizeMul, 4*~ySizeMul, ~tabAmb[s], \fxSynthDef6, \fxSynthDef6ALL, \fxTabComp6, \fxTabCompName6View, \fxTabCompRand6View, \fxTabCompDef6View, \fxTabCompSel6View, \fxTabCompSel6Values, \numFxSynthDef6, 2, \fxSynthDef6SwitchTypView, \fxSynthDef6SwitchTyp, s);
		~makeFxAColumn.(currentEnvironment, 7, 790*~xSizeMul, 4*~ySizeMul, ~tabAmb[s], \fxSynthDef7, \fxSynthDef7ALL, \fxTabComp7, \fxTabCompName7View, \fxTabCompRand7View, \fxTabCompDef7View, \fxTabCompSel7View, \fxTabCompSel7Values, \numFxSynthDef7, 1, \fxSynthDef7SwitchTypView, \fxSynthDef7SwitchTyp, s);
		~makeFxAColumn.(currentEnvironment, 8, 1185*~xSizeMul, 4*~ySizeMul, ~tabAmb[s], \fxSynthDef8, \fxSynthDef8ALL, \fxTabComp8, \fxTabCompName8View, \fxTabCompRand8View, \fxTabCompDef8View, \fxTabCompSel8View, \fxTabCompSel8Values, \numFxSynthDef8, 4, \fxSynthDef8SwitchTypView, \fxSynthDef8SwitchTyp, s);

	};







	// Slider2D de positionnement et transformation du champ sonore
	// Check also ParaSpace to show all on 1 GUI
	// file:///Users/Xon77/Library/Application Support/SuperCollider/quarks/ixiViews/help/ParaSpace.html
	// TabletSlider2D -> not available in Qt

	~fxA56TabCompSelValues = 0 ! 2;
	~nbOfServers.do { |s| ~fxA56TabCompSelValues[s] = ~fxTabCompSel5Values[s]++ ~fxTabCompSel6Values[s]; };

	~fxACompView = 0 ! 6 /*~numEffects*/ ! 2;
	~fxASliderMulView = 0 ! 6 /*~numEffects*/ ! 2;
	~fxASlider2DView = 0 ! 6 /*~numEffects*/ ! 2;
	~fxASlider2DViewView = 0 ! 6 /*~numEffects*/ ! 2;
	~fxASlider2DUserView = 0 ! 6 /*~numEffects*/ ! 2;

	~fxASlider2DX = 0 ! 6 /*~numEffects*/ ! 2;
	~fxASlider2DY = 0 ! 6 /*~numEffects*/ ! 2;
	// ~fxASlider2DPoint = 0 ! 6 /*~numEffects*/; // Plus nécessaire avec version JD - seulement pour les test de conversion cartesian to Polar
	~fxASlider2DPointAng = 0 ! 6 /*~numEffects*/ ! 2;
	~fxASlider2DPointDist = 0 ! 6 /*~numEffects*/ ! 2;
	~fxASliderMul = 0 ! 6 /*~numEffects*/ ! 2;
	~fxASliderMulName = ["Mul P1", "Mul P2", "Mul P3", "Mul R1", "Mul R2", "Mul R3"] /*0 ! 6*/ /*~numEffects*/;

	~fxACompViewPosH = [2, 197, 2, 197, 197+195, 197+(195*2)]*~xSizeMul;
	~fxACompViewPosV = [580, 580, 800, 800, 800, 800]*~ySizeMul;

	~fxASynthDefSlider2D = 0 ! 2; // nécessaire d'être déclaré sinon erreur

	~distMinAllFxA = 0 ! 2; // déclaré plus haut

	~nbOfServers.do { |s|

		/*~numEffects*/ 6.do { |i|

			~fxACompView[s][i] = CompositeView(~tabAmb[s], Rect(~fxACompViewPosH[i], ~fxACompViewPosV[i], 190*~xSizeMul, 210*~ySizeMul)).background = ~compFxBackgroundColors[0];
			~fxACompView[s][i].decorator = FlowLayout(~fxACompView[s][i].bounds);
			~fxACompView[s][i].decorator.gap = (1*~xSizeMul)@(1*~ySizeMul);

			~fxASliderMulView[s][i] = EZSlider.new2(~fxACompView[s][i], (182*~xSizeMul)@(20*~ySizeMul), ~fxASliderMulName[i] /*("Mul"+(i+1).asString)*/, ControlSpec(0.1, 1, \lin, 0.01, 0.8),
				{ |ez| ~fxASliderMul[s][i] = ez.value; ~fxASlider2DView[s][i].setXYActive(~fxASlider2DView[s][i].x, ~fxASlider2DView[s][i].y) },
				unitWidth:0, initVal:0.8, numberWidth:30*~xSizeMul, labelWidth:35*~xSizeMul, layout:\horz,)
			.setColors(Color.grey,Color.white)
			.font_(Font("Helvetica",11*~fontSizeMul));

			~fxASlider2DViewView[s][i] = View(~fxACompView[s][i], (182*~xSizeMul)@(182*~ySizeMul));

			~fxASlider2DView[s][i] = Slider2D(bounds:(182*~xSizeMul)@(182*~ySizeMul))
			// .x_(0.5) // initial location of x
			// .y_(1)   // initial location of y
			.background_(Color.blue(0.5, 0))
			.knobColor_(Color.magenta)
			.action_({|sl| var delta/*, spher*/;

				// ~fxASlider2DX[i] = sl.x; ~fxASlider2DY[i] = sl.y;
				// [\sliderX, sl.x, \sliderY, sl.y].postln;

				// converting signal azimuth to pi to -pi for ATK -> see pesudoUgen in Quark GameLoop
				// https://github.com/miguel-negrao/Quarks/blob/master/GameLoop/Classes/PseudoUGens/Space.sc

				// OLD Version CL -> 0.01
				/*~fxASlider2DPoint[i] = Point(~fxASlider2DX[i].linlin(0, 1, -1, 1) * ~fxASliderMul[i], ~fxASlider2DY[i].linlin(0, 1, -1, 1) * ~fxASliderMul[i])/*.postln*/;
				// ~fxA1Slider2DPointAng = ((~fxA1Slider2DPoint.theta + 0.5pi) * -1).postln;
				~fxASlider2DPoint[i] = ~fxASlider2DPoint[i].asPolar.rotate(-0.5pi).neg.asPoint;
				~fxASlider2DPointAng[i] = ~fxASlider2DPoint[i].theta/*.postln*/;
				~fxASlider2DPointDist[i] = ~fxASlider2DPoint[i].dist(Point(0, 0)).max(~distMinAllFxA).min(1)/*.postln*/;*/

				// Version Joseph Adersen pratiquement 2x plus rapide que version CL -> 0.0055
				/*~fxASlider2DPoint[i] = Cartesian(~fxASlider2DY[i].linlin(0,1,-1,1), ~fxASlider2DX[i].linlin(0,1,1,-1));
				spher = ~fxASlider2DPoint[i].asSpherical;
				delta = spher.theta;
				case
				{ delta > 0 } { ~fxASlider2DPointAng[i] = -pi + (delta % 2pi) }
				{ delta < 0 } { ~fxASlider2DPointAng[i] = pi - (-1 * delta % 2pi) };
				// ~fxASlider2DPointAng[i].postln;
				~fxASlider2DPointDist[i] = spher.rho.clip(~distMinAllFxA, 1)/*.postln*/;*/

				// Version JD pratiquement 2x plus rapide que version Joseph Adersen -> 0.003 / voire 4x plus rapide en retirant la classe Point
				~fxASlider2DX[s][i] = sl.x.linlin(0, 1, -1, 1) * ~fxASliderMul[s][i]; ~fxASlider2DY[s][i] = sl.y.linlin(0, 1, -1, 1) * ~fxASliderMul[s][i];
				// [~fxASlider2DX[i], ~fxASlider2DY[i]]/*.postln*/;
				delta = atan2(~fxASlider2DX[s][i], ~fxASlider2DY[s][i]);
				// delta.postln;
				case
				{ delta > 0 } { ~fxASlider2DPointAng[s][i] = pi - (delta % 2pi) } // Ajout de pi -
				{ delta < 0 } { ~fxASlider2DPointAng[s][i] = -pi + (-1 * delta % 2pi) }; // Ajout de -pi +
				// { delta == 0 } { ~fxASlider2DPointAng[i] = -pi }; // Pas vraiment obligatoire car sinon reste sur la valeur précédente
				// ~fxASlider2DPointAng[i].postln;
				~fxASlider2DPointDist[s][i] = abs(hypot(~fxASlider2DX[s][i], ~fxASlider2DY[s][i])).clip(0 /*~distMinAllFxA*/, 1)/*.postln*/;


				/*
				( // Version Joseph Adersen :
				// http://new-supercollider-mailing-lists-forums-use-these.2681727.n2.nabble.com/ATK-problems-with-binaural-FoaDecoderKernel-td7583873.html#a7583922
				// -> Résultat différent de ma version car choix du changement du slider d'angle de pi vers - pi donc dans le sens horaire
				// donc nécessité d'ajouter -pi et pi-
				f = { | x = 0.5, y = 0.5 | var delta, thetau = 0.0;
				a = Cartesian.new;
				a.x_(y.linlin(0,1,-1,1)).y_(x.linlin(0,1,1,-1));
				delta = a.asSpherical.theta - thetau;
				delta = delta.wrap(-pi, pi).postln;
				case
				{ delta > 0 } { thetau = -pi + thetau + (delta % 2pi) } // Ajout de -pi
				{ delta < 0 } { thetau = pi - (thetau - (-1 * delta % 2pi)) }; // Ajout de pi-
				c = thetau.postln;
				d = a.asSpherical.rho.clip(0.05, 1)
				};
				);

				y = 0.6; z = 0.2; // 0.5 pour le centre

				( // Version Joseph Adersen optimisé
				f = { | x = 0.5, y = 0.5 | var delta, spher;
				a = Cartesian.new;
				a.x_(y.linlin(0,1,-1,1)).y_(x.linlin(0,1,1,-1))/*.postln*/;
				spher = a.asSpherical;
				delta = spher.theta/*.postln*/;
				// delta = delta.wrap(-pi, pi).postln;
				case
				{ delta > 0 } { c = -pi + (delta % 2pi) } // Ajout de -pi
				{ delta < 0 } { c = pi - (-1 * delta % 2pi) }; // Ajout de pi-
				c/*.postln*/;
				d = spher.rho.clip(0.05, 1)
				};
				);
				{1000.do {f.(-0.5, -0.5)} }.bench;
				f.(y, z);

				( // Version Joseph Adersen avec distance modifié selon JD - pratiquement la même chose qu'au dessus
				f = { | x = 0.5, y = 0.5 | var delta;
				a = Cartesian.new;
				a.x_(y.linlin(0,1,-1,1)).y_(x.linlin(0,1,1,-1))/*.postln*/;
				delta = a.asSpherical.theta/*.postln*/;
				// delta = delta.wrap(-pi, pi).postln;
				case
				{ delta > 0 } { c = -pi + (delta % 2pi) } // Ajout de -pi
				{ delta < 0 } { c = pi - (-1 * delta % 2pi) }; // Ajout de pi-
				c/*.postln*/;
				d = abs(hypot(a.x, a.y)).clip(0.05, 1)
				};
				);
				{1000.do {f.(-0.5, -0.5)} }.bench;
				f.(y, z);

				( // Version CL
				g = { | x = 0.5, y = 0.5 | var delta;
				a = Point(x.linlin(0,1,-1,1), y.linlin(0,1,-1,1))/*.postln*/;
				a = a.asPolar.rotate(-0.5pi).neg.asPoint;
				c = a.theta.postln;
				d = a.dist(Point(0, 0)).clip(0.05, 1)
				};
				);
				{1000.do {g.(-0.5, -0.5)} }.bench;
				g.(y, z);

				( // Version JD
				// http://new-supercollider-mailing-lists-forums-use-these.2681727.n2.nabble.com/Synthdef-not-working-as-expected-td7438111.html#a7438381
				h = { | x = 0.5, y = 0.5 | var delta;
				a = x.linlin(0,1,-1,1); b = y.linlin(0,1,-1,1)/*.postln*/;
				delta = atan2(a, b);
				/*case
				{ a.x > 0 } { delta = atan2(a.y, a.x) }
				{ a.x < 0 and: {a.y >= 0} } { delta = atan2(a.y, a.x) + pi }
				{ a.x < 0 and: {a.y < 0} } { delta = atan2(a.y, a.x) - pi; }
				{ a.x == 0 } { delta = 0.5pi };*/
				// delta.wrap(-pi, pi).postln;
				// delta.postln;
				case
				{ delta > 0 } { c = pi - (delta % 2pi) } // Ajout de pi -
				{ delta < 0 } { c = -pi + (-1 * delta % 2pi) }; // Ajout de -pi +
				c.postln;
				d = abs(hypot(a, b)).clip(0.05, 1)
				};
				);
				{1000.do {h.(-0.5, -0.5)} }.bench;
				h.(y, z);

				y = 0.6; z = 0.4; // 0.5 pour le centre
				*/


				if (~fxA56TabCompSelValues[s][i].includes(1), {
					var num = ~fxA56TabCompSelValues[s][i].indexOf(1);

					// if (~fxSynthA[i] != 0 and: {~fxASynthDefSlider2D.includes(~fxSynthA[i].defName)}, {
					// ~fxSynthA[0].set(\azim, ~fxA1Slider2DPointAng, \dist, ~fxA1Slider2DPointDist); // Pas d'action sur le synthé, mais directement sur les sliders

					// num.postln;
					~fxSynthA[s][num].set(\lag, 0.001); // Action sur le lag car problème de transition lorsque passage instantané entre pi et - pi devant
					// Apparemment 0.01 pas suffisant car l'on peut entendre un saut ??? -> 0.1
					// voire comment ne pas relancer le lag au synthé si pas nécessaire ??????????????????
				});


				// ~fxASynthDefSlider2D à distinguer pour les 2 serveurs ??????????????????????
				// ?????????????????????????????????????
				// ?????????????????????????????????????
				// ?????????????????????????????????????
				// ?????????????????????????????????????
				// ?????????????????????????????????????
				~fxASynthDefSlider2D[s] = [~fxSynthDef5, ~fxSynthDef6].deepCollect(~numFxSynthDef5-1, { |a| a.name }).flatten;
				~fxSynthDefViews[s][(~fxASynthDefSlider2D[s][i].asString[0..2]++i.wrap(0,2).asString++'azim').asSymbol].valueAction_(~fxASlider2DPointAng[s][i]);
				~fxSynthDefViews[s][(~fxASynthDefSlider2D[s][i].asString[0..2]++i.wrap(0,2).asString++'dist').asSymbol].valueAction_(~fxASlider2DPointDist[s][i]);

			});

			~fxASlider2DUserView[s][i] = UserView( bounds: (182*~xSizeMul)@(182*~ySizeMul))
			.drawFunc_({|uview| var height = uview.bounds.height-(2*~ySizeMul); // donne aussi la hauteur
				Pen.width_(4);
				/*Pen.moveTo(0@uview.bounds.height.rand);
				Pen.lineTo(uview.bounds.width@uview.bounds.height.rand);*/
				Pen.strokeColor = Color.green;
				Pen.addOval(Rect(75*~xSizeMul,75*~ySizeMul,30*~xSizeMul,30*~ySizeMul));
				Pen.stroke;
				Pen.strokeColor = Color.yellow;
				Pen.line(2@height/2, height*2@height/2); // Pourquoi pas height et obligé de mettre height*2 ???
				Pen.line(height/2@2, height/2@height);
				Pen.addOval(Rect(5*~xSizeMul,5*~ySizeMul,height-(8*~xSizeMul),height-(8*~ySizeMul)));
				Pen.stroke;
			});

			~fxASlider2DViewView[s][i].layout_(StackLayout(~fxASlider2DView[s][i], ~fxASlider2DUserView[s][i]).mode_(\stackAll));

			~distMinAllFxA[s] = 0.08;
			~fxASliderMulView[s][i].valueAction_(0.6);
			~fxASlider2DView[s][i].setXYActive(0.5, 0.75);

		};

	};





	/*~fxSynthDef1.do { |item, syni|

	var lastHeight;
	if (~fxTabComp1[syni-1].isNil, {lastHeight = 4}, {lastHeight = ~fxTabComp1[syni-1].bounds.top + ~fxTabComp1[syni-1].bounds.height + 5} );

	// ~fxTabComp[syni] = CompositeView(~tabFx, Rect(2, 2, 308, 6 + ((~fxSynthDef[syni].metadata['specs'].keys.size + 1) * 22))).background = Color.blue;
	~fxTabComp1[syni] = CompositeView(~tabFx, Rect(2, lastHeight, 383, 8 + ((~fxSynthDef1[syni].metadata['specs'].keys.size + 1) * 19))).background = Color.blue /*~compFxBackgroundColors.wrapAt(syni)*/;
	~fxTabComp1[syni].decorator = FlowLayout(~tabFx.view.bounds);
	~fxTabComp1[syni].decorator.gap = 1@1;
	~fxTabCompName1View[syni] = StaticText(~fxTabComp1[syni], Rect(2, 2, 275, 20)).stringColor_(Color.yellow).background_(Color.grey(0.4)).font_(Font("Verdana",12, bold: true)).align_(\center);
	~fxTabCompName1View[syni].string = ~alphabet[syni] ++ ". " ++ ~fxSynthDef1[syni].name;

	~fxTabCompRand1View[syni] = RoundButton(~fxTabComp1[syni], Rect(2, 2, 50, 18))
	.states_([["Rand", Color.white, Color.red]])
	.font_(Font("Verdana",10, bold: true))
	.action_({ |a|
	/*(~fxSynthDef1[syni].metadata['specsR'].keys.size).do { |i|
	~fxSynthDefViews[(~fxSynthDef1[syni].name ++ ~fxSynthDef1[syni].metadata['specsR'].keys.asArray[i]).asSymbol].valueAction_(~fxSynthDef1[syni].metadata['specsR'][~fxSynthDef1[syni].metadata['specsR'].keys.asArray[i]].map(1.0.rand))};*/
	var listSpecR = ~fxSynthDef1[syni].metadata['specsR'];
	listSpecR.keys.size.do { |i|
	~fxSynthDefViews[(~fxSynthDef1[syni].name ++ listSpecR.keys.asArray[i]).asSymbol].valueAction_(listSpecR[listSpecR.keys.asArray[i]].map(1.0.rand))};
	});

	~fxTabCompDef1View[syni] = RoundButton(~fxTabComp1[syni], Rect(2, 2, 50, 18))
	.states_([["Def", Color.black, Color.green]])
	.font_(Font("Verdana",10, bold: true))
	.action_({ |a|
	~fxSynthDef1[syni].metadata['specs'].keys.size.do { |i|
	~fxSynthDefViews[(~fxSynthDef1[syni].name ++ ~fxSynthDef1[syni].metadata['order'][i]).asSymbol].valueAction_(~fxSynthDef1[syni].metadata['specs'][~fxSynthDef1[syni].metadata['order'][i]].default);
	}
	});

	~fxSynthDef1[syni].metadata['specs'].keys.size.do { |i|

	~fxTabComp1[syni].decorator.nextLine;

	~fxSynthDefViews[(~fxSynthDef1[syni].name ++ ~fxSynthDef1[syni].metadata['order'][i]).asSymbol] =
	EZSlider.new2(~fxTabComp1[syni], 375@18, ~fxSynthDef1[syni].metadata['order'][i].asString, ~fxSynthDef1[syni].metadata['specs'][~fxSynthDef1[syni].metadata['order'][i]],
	{ |ez| ~fxSynthDefValues[(~fxSynthDef[syni].name ++ ~fxSynthDef[syni].metadata['order'][i]).asSymbol] = ez.value;
	/*(ez.value.asString ++" is the value of " ++ ez).postln*/

	// Synth(~fxSynthDef[0].name).isPlaying.postln; // only if .register
	// Synth(~fxSynthDef[0].name).set(~fxSynthDef[0].metadata['specs'].keys.asArray[i], ez.value);
	// Check sur tous les synthés fx en cours parmi la liste pour actionner le controle d'un synthé spécifique repéré sur chacun des HP
	// ~fxSynth[0].defName == ~fxSynthDef[0].name
	// ~fxSynth[0].defName.asString.contains(~fxSynthDef[0].name.asString)
	~fxSynth.do { |itemk, k| if (~fxSynth[k] != 0 and: {~fxSynth[k].defName.asString /*.contains(*/ == ~fxSynthDef1[syni].name.asString /*)*/ }, {itemk.set(~fxSynthDef1[syni].metadata['order'][i], ez.value)} ) };
	},
	unitWidth:0, initVal:~fxSynthDef1[syni].controls[5+i], numberWidth:60, layout:\horz)
	.setColors(Color.grey,Color.white)
	.font_(Font("Helvetica",11))
	.valueAction_(~fxSynthDef1[syni].metadata['specs'][~fxSynthDef1[syni].metadata['order'][i]].default);

	};
	// ~fxTabComp[syni].decorator.nextLine;
	};*/















	// EQ Effects

	~fxTabCompSel2bView = {0 ! ~numEffects} ! ~numFxSynthDef2b ! 2;
	~fxTabCompSel2bValues = {0 ! ~numEffects} ! ~numFxSynthDef2b ! 2;

	~makeEQWindow = { | envir, nb, widthPos, heightPos,
		fxTabEQCompNb, fxTabCompNameEQNbView, fxTabCompRand1EQNbView, fxTabCompRand2EQNbView, fxTabCompRand3EQNbView, fxTabCompDefEQNbView, fxTabCompSelNbView, fxTabCompSelNbValues,
		eQViewNb, lagEQNbView, lagEQNb, /*apparemment non utilisé*/ lagTimeEQNb, channel, fxSynthDef, eqUnitLib, serverNb, serverNb2
		// serverNb2 juste pour les EQ channels qui sont sur la 1ere vue, mais dont les EQ settings peuvent être sur des serveurs différents
		|

		envir[fxTabEQCompNb][serverNb] = CompositeView(~tabEq[serverNb], Rect(widthPos, heightPos, 383*~xSizeMul, 265*~ySizeMul)).background = Color.gray(0.2).alpha_(0.175);

		envir[fxTabCompNameEQNbView][serverNb] = StaticText(envir[fxTabEQCompNb][serverNb], Rect(2*~xSizeMul, 2*~ySizeMul, 72*~xSizeMul, 20*~ySizeMul)).stringColor_(Color.yellow).background_(Color.grey(0.5)).font_(Font("Verdana",12*~fontSizeMul, bold: true)).align_(\center);
		envir[fxTabCompNameEQNbView][serverNb].string = envir[fxSynthDef][nb].name;

		case
		{channel == 0} // EQ Normaux
		{
			~numEffects.do { |fx|
				envir[fxTabCompSelNbView][serverNb][nb][fx] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect((76 + (fx*20))*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
				.states_([[(fx+1).asString, Color.white, Color.grey(0.5)],[(fx+1).asString, Color.red, Color.yellow]])
				.font_(Font("Verdana",10*~fontSizeMul, bold: true))
				.action_({ |a| // fx.postln; nb.postln;
					envir[fxTabCompSelNbValues][serverNb][nb][fx] = a.value;
					if (a.value == 1, {
						~fxSelectView[serverNb][fx].valueAction_(~numFxSynthDef+nb+1);
					},{
						~fxSelectView[serverNb][fx].valueAction_(0);
					})
				})
			};

			envir[fxTabCompRand1EQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(180*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Rand1", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb][nb].setting = [[100, 1, 12.rand2], [250, 1, 12.rand2], [1000, 1, 12.rand2], [3500, 1, 12.rand2], [6000, 1, 12.rand2]];
				~fxSynth[serverNb].do { |itemk, k| if (~fxSynth[serverNb][k] != 0 and: {~fxSynth[serverNb][k].defName.asString /*.contains(*/ == envir[fxSynthDef][nb].name.asString /*)*/ }, {itemk.set( \eqSetting, envir[eqUnitLib][serverNb][nb].setting, \lag, envir[lagTimeEQNb][serverNb] )} ) }
			});

			envir[fxTabCompRand2EQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(230*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Rand2", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb][nb].setting = [[100, exprand(0.2, 6), 12.rand2], [250, exprand(0.2, 6), 12.rand2], [1000, exprand(0.2, 6), 12.rand2], [3500, exprand(0.2, 6), 12.rand2], [6000, exprand(0.2, 6), 12.rand2]];
				~fxSynth[serverNb].do { |itemk, k| if (~fxSynth[serverNb][k] != 0 and: {~fxSynth[serverNb][k].defName.asString /*.contains(*/ == envir[fxSynthDef][nb].name.asString /*)*/ }, {itemk.set( \eqSetting, envir[eqUnitLib][serverNb][nb].setting, \lag, envir[lagTimeEQNb][serverNb] )} ) }
			});

			envir[fxTabCompRand3EQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(280*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Rand3", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb][nb].setting = [[20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2]];
				~fxSynth[serverNb].do { |itemk, k| if (~fxSynth[serverNb][k] != 0 and: {~fxSynth[serverNb][k].defName.asString /*.contains(*/ == envir[fxSynthDef][nb].name.asString /*)*/ }, {itemk.set( \eqSetting, envir[eqUnitLib][serverNb][nb].setting, \lag, envir[lagTimeEQNb][serverNb] )} ) }
			});

			envir[fxTabCompDefEQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(330*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Def", Color.white, Color.blue]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb][nb].setting = [ [ 100, 1, 0 ], [ 250, 1, 0 ], [ 1000, 1, 0 ], [ 3500, 1, 0 ], [ 6000, 1, 0 ], [ 0 ] ];
				~fxSynth[serverNb].do { |itemk, k| if (~fxSynth[serverNb][k] != 0 and: {~fxSynth[serverNb][k].defName.asString /*.contains(*/ == envir[fxSynthDef][nb].name.asString /*)*/ }, {itemk.set( \eqSetting, envir[eqUnitLib][serverNb][nb].setting, \lag, envir[lagTimeEQNb][serverNb] )} ) }
			});

			envir[eqUnitLib][serverNb][nb].setting = [ [ 100, 1, 0 ], [ 250, 1, 0 ], [ 1000, 1, 0 ], [ 3500, 1, 0 ], [ 6000, 1, 0 ], [ 0 ] ];

		}
		{channel == 1} // EQ Channel
		{

			envir[fxTabCompRand1EQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(180*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Rand1", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb2][nb].setting = [[150, 1, 12.rand2], [1500, 1, 12.rand2], [5000, 1, 12.rand2]];
				if (~eqChaActivate[nb] == 1, { ~eqChaSynth[nb].set(\eqSetting, ~eqChannelUnitLib[serverNb2][nb], \lag, envir[lagTimeEQNb][0/*serverNb*/]) });
				~eqChaLoView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[0][2])); ~eqChaMiView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[1][2])); ~eqChaHiView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[2][2]))
			});

			envir[fxTabCompRand2EQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(230*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Rand2", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb2][nb].setting = [[150, exprand(0.2, 6), 12.rand2], [1500, exprand(0.2, 6), 12.rand2], [5000, exprand(0.2, 6), 12.rand2]];
				if (~eqChaActivate[nb] == 1, { ~eqChaSynth[nb].set(\eqSetting, ~eqChannelUnitLib[serverNb2][nb], \lag, envir[lagTimeEQNb][0/*serverNb*/]) });
				~eqChaLoView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[0][2])); ~eqChaMiView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[1][2])); ~eqChaHiView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[2][2]))
			});

			envir[fxTabCompRand3EQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(280*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Rand3", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb2][nb].setting = [[20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2]];
				if (~eqChaActivate[nb] == 1, { ~eqChaSynth[nb].set(\eqSetting, ~eqChannelUnitLib[serverNb2][nb], \lag, envir[lagTimeEQNb][0/*serverNb*/]) });
				~eqChaLoView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[0][2])); ~eqChaMiView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[1][2])); ~eqChaHiView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[2][2]))
			});

			envir[fxTabCompDefEQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(330*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Def", Color.white, Color.blue]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb2][nb].setting = [ [ 150, 1, 0 ], [ 1500, 1, 0 ], [ 5000, 1, 0 ] ];
				if (~eqChaActivate[nb] == 1, { ~eqChaSynth[nb].set(\eqSetting, ~eqChannelUnitLib[serverNb2][nb], \lag, envir[lagTimeEQNb][0/*serverNb*/]) });
				~eqChaLoView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[0][2])); ~eqChaMiView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[1][2])); ~eqChaHiView[nb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb2][nb].setting[2][2]))
			});

		}
		{channel == 2} // EQ FX
		{

			envir[fxTabCompRand1EQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(180*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Rand1", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb][nb].setting = [[150, 1, 12.rand2], [1500, 1, 12.rand2], [5000, 1, 12.rand2]];
				if (~eqChaActivate[nb] == 1, {
					~numEffects.do { |i|
						if (~eqChaFXSynth[serverNb][i] != 0, { ~eqChaFXSynth[serverNb][i].set(\eqSetting, ~eqChannelUnitLib[serverNb][nb], \lag, envir[lagTimeEQNb][serverNb]) })
					};
				});
				~eqChaLoView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[0][2])); ~eqChaMiView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[1][2])); ~eqChaHiView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[2][2]))
			});

			envir[fxTabCompRand2EQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(230*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Rand2", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb][nb].setting = [[150, exprand(0.2, 6), 12.rand2], [1500, exprand(0.2, 6), 12.rand2], [5000, exprand(0.2, 6), 12.rand2]];
				if (~eqChaActivate[nb] == 1, {
					~numEffects.do { |i|
						if (~eqChaFXSynth[serverNb][i] != 0, { ~eqChaFXSynth[serverNb][i].set(\eqSetting, ~eqChannelUnitLib[serverNb][nb], \lag, envir[lagTimeEQNb][serverNb]) })
					};
				});
				~eqChaLoView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[0][2])); ~eqChaMiView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[1][2])); ~eqChaHiView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[2][2]))
			});

			envir[fxTabCompRand3EQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(280*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Rand3", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb][nb].setting = [[20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2]];
				if (~eqChaActivate[nb] == 1, {
					~numEffects.do { |i|
						if (~eqChaFXSynth[serverNb][i] != 0, { ~eqChaFXSynth[serverNb][i].set(\eqSetting, ~eqChannelUnitLib[serverNb][nb], \lag, envir[lagTimeEQNb][serverNb]) })
					};
				});
				~eqChaLoView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[0][2])); ~eqChaMiView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[1][2])); ~eqChaHiView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[2][2]))
			});

			envir[fxTabCompDefEQNbView][serverNb] = RoundButton(envir[fxTabEQCompNb][serverNb], Rect(330*~xSizeMul, 2*~ySizeMul, 50*~xSizeMul, 18*~ySizeMul))
			.states_([["Def", Color.white, Color.blue]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a|
				envir[eqUnitLib][serverNb][nb].setting = [ [ 150, 1, 0 ], [ 1500, 1, 0 ], [ 5000, 1, 0 ] ];
				if (~eqChaActivate[nb] == 1, {
					~numEffects.do { |i|
						if (~eqChaFXSynth[serverNb][i] != 0, { ~eqChaFXSynth[serverNb][i].set(\eqSetting, ~eqChannelUnitLib[serverNb][nb], \lag, envir[lagTimeEQNb][serverNb]) })
					};
				});
				~eqChaLoView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[0][2])); ~eqChaMiView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[1][2])); ~eqChaHiView[nb][serverNb].value_(~eqChaSpec.unmap(envir[eqUnitLib][serverNb][nb].setting[2][2]))
			});

		};

		envir[lagEQNbView][serverNb] =
		EZSlider.new2(envir[fxTabEQCompNb][serverNb], Rect(2*~xSizeMul, 25*~ySizeMul, 375*~xSizeMul, 20*~ySizeMul), envir[lagEQNb][serverNb], ControlSpec(0, 30, 'lin', 0.1, 1),
			{ |ez| envir[lagTimeEQNb][serverNb] = ez.value;
				/*(ez.value.asString ++" is the value of " ++ ez).postln*/
			},
			unitWidth:0, initVal:1, numberWidth:60*~xSizeMul, label: "mix", layout:\horz)
		.setColors(Color.grey,Color.white)
		.font_(Font("Helvetica",11*~fontSizeMul))
		.valueAction_(1);

		case
		{channel == 0}
		{
			envir[eQViewNb][serverNb] = EQView(envir[fxTabEQCompNb][serverNb], Rect(5*~xSizeMul, 50*~ySizeMul, 373*~xSizeMul, 210*~ySizeMul), eqSetting: envir[eqUnitLib][serverNb][nb] ); // create a gui
			envir[eQViewNb][serverNb].action = { |view, setting|
				~fxSynth[serverNb].do { |itemk, k| if (~fxSynth[serverNb][k] != 0 and: {~fxSynth[serverNb][k].defName.asString /*.contains(*/ == envir[fxSynthDef][nb].name.asString /*)*/ }, {itemk.set( \eqSetting, setting, \lag, envir[lagTimeEQNb][serverNb] )} ) }
			};
		}
		{channel == 1}
		{
			envir[eQViewNb][serverNb] = EQView(envir[fxTabEQCompNb][serverNb], Rect(5*~xSizeMul, 50*~ySizeMul, 373*~xSizeMul, 210*~ySizeMul), eqSetting: envir[eqUnitLib][serverNb2][nb] ); // create a gui
			envir[eQViewNb][serverNb].action = { |view, setting|
				if (~eqChaActivate[nb] == 1, { ~eqChaSynth[nb].set(\eqSetting, ~eqChannelUnitLib[serverNb2][nb], \lag, envir[lagTimeEQNb][0/*serverNb*/]) });
				~eqChaLoView[nb].value_(~eqChaSpec.unmap(setting[0][2])); ~eqChaMiView[nb].value_(~eqChaSpec.unmap(setting[1][2])); ~eqChaHiView[nb].value_(~eqChaSpec.unmap(setting[2][2]))
			};
		}
		{channel == 2}
		{
			envir[eQViewNb][serverNb] = EQView(envir[fxTabEQCompNb][serverNb], Rect(5*~xSizeMul, 50*~ySizeMul, 373*~xSizeMul, 210*~ySizeMul), eqSetting: envir[eqUnitLib][serverNb][nb] ); // create a gui
			envir[eQViewNb][serverNb].action = { |view, setting|
				if (~eqChaActivate[nb] == 1, {
					~numEffects.do { |i|
						if (~eqChaFXSynth[serverNb][i] != 0, { ~eqChaFXSynth[serverNb][i].set(\eqSetting, ~eqChannelUnitLib[serverNb][nb], \lag, envir[lagTimeEQNb][serverNb]) })
					};
				});
				~eqChaLoView[nb].value_(~eqChaSpec.unmap(setting[0][2])); ~eqChaMiView[nb].value_(~eqChaSpec.unmap(setting[1][2])); ~eqChaHiView[nb].value_(~eqChaSpec.unmap(setting[2][2]))
			};
		}
		// ~eqChannelUnitLib[0].setting[0][2]

	};


	~fxTabEQComp1=0!2; ~fxTabCompNameEQ1View=0!2; ~fxTabCompRand1EQ1View=0!2; ~fxTabCompRand2EQ1View=0!2; ~fxTabCompRand3EQ1View=0!2; ~fxTabCompDefEQ1View=0!2; ~eQView1=0!2; ~lagEQ1View=0!2; ~lagEQ1=0!2; ~lagTimeEQ1=0!2; // ~fxSynthDef2b,
	~fxTabEQComp2=0!2; ~fxTabCompNameEQ2View=0!2; ~fxTabCompRand1EQ2View=0!2; ~fxTabCompRand2EQ2View=0!2; ~fxTabCompRand3EQ2View=0!2; ~fxTabCompDefEQ2View=0!2; ~eQView2=0!2; ~lagEQ2View=0!2; ~lagEQ2=0!2; ~lagTimeEQ2=0!2;
	~fxTabEQComp3=0!2; ~fxTabCompNameEQ3View=0!2; ~fxTabCompRand1EQ3View=0!2; ~fxTabCompRand2EQ3View=0!2; ~fxTabCompRand3EQ3View=0!2; ~fxTabCompDefEQ3View=0!2; ~eQView3=0!2; ~lagEQ3View=0!2; ~lagEQ3=0!2; ~lagTimeEQ3=0!2;

	~nbOfServers.do { |s|
		// EQ Effect 1
		~makeEQWindow.(currentEnvironment, 0, /*790, 800*/ 5*~xSizeMul, 5*~ySizeMul,
			\fxTabEQComp1, \fxTabCompNameEQ1View, \fxTabCompRand1EQ1View, \fxTabCompRand2EQ1View, \fxTabCompRand3EQ1View, \fxTabCompDefEQ1View, \fxTabCompSel2bView, \fxTabCompSel2bValues,
			\eQView1, \lagEQ1View, \lagEQ1, /* \lagEQ apparemment non utilisé*/ \lagTimeEQ1, 0, \fxSynthDef2b, \eqUnitLib, s
		);
		// EQ Effect 2
		~makeEQWindow.(currentEnvironment, 1, /*790, 1075*/ (5+395)*~xSizeMul, 5*~ySizeMul,
			\fxTabEQComp2, \fxTabCompNameEQ2View, \fxTabCompRand1EQ2View, \fxTabCompRand2EQ2View, \fxTabCompRand3EQ2View, \fxTabCompDefEQ2View, \fxTabCompSel2bView, \fxTabCompSel2bValues,
			\eQView2, \lagEQ2View, \lagEQ2, /* \lagEQ apparemment non utilisé*/ \lagTimeEQ2, 0, \fxSynthDef2b, \eqUnitLib, s
		);
		// EQ Effect 3
		~makeEQWindow.(currentEnvironment, 2, /*790, 1075*/ (400+395)*~xSizeMul, 5*~ySizeMul,
			\fxTabEQComp3, \fxTabCompNameEQ3View, \fxTabCompRand1EQ3View, \fxTabCompRand2EQ3View, \fxTabCompRand3EQ3View, \fxTabCompDefEQ3View, \fxTabCompSel2bView, \fxTabCompSel2bValues,
			\eQView3, \lagEQ3View, \lagEQ3, /* \lagEQ apparemment non utilisé*/ \lagTimeEQ3, 0, \fxSynthDef2b, \eqUnitLib, s
		);
	};

	~fxTabCompRandView = 0 ! 2;
	~fxTabCompRandView[0] = ~fxTabCompRand1View[0] ++ ~fxTabCompRand2View[0] ++ ~fxTabCompRand3View[0]++ ~fxTabCompRand4View[0] ++ ~fxTabCompRand3EQ1View[0] ++ ~fxTabCompRand3EQ2View[0] ++ ~fxTabCompRand3EQ3View[0];

	~fxTabCompRandLView = 0 ! 2;
	~fxTabCompRandMView = 0 ! 2;
	~fxTabCompRandHView = 0 ! 2;
	~fxTabCompRandLView[0] = ~fxTabCompRandL1View[0] ++ ~fxTabCompRandL2View[0] ++ ~fxTabCompRandL3View[0] ++ ~fxTabCompRandL4View[0];
	~fxTabCompRandMView[0] = ~fxTabCompRandM1View[0] ++ ~fxTabCompRandM2View[0] ++ ~fxTabCompRandM3View[0] ++ ~fxTabCompRandM4View[0];
	~fxTabCompRandHView[0] = ~fxTabCompRandH1View[0] ++ ~fxTabCompRandH2View[0] ++ ~fxTabCompRandH3View[0] ++ ~fxTabCompRandH4View[0];

	~fxATabCompRandView = 0 ! 2;
	~fxATabCompRandView[0] = ~fxTabCompRand5View[0] ++ ~fxTabCompRand6View[0] ++ ~fxTabCompRand7View[0] ++ ~fxTabCompRand8View[0];

	if (~server2.notNil, {

		~fxTabCompRandView[1] = ~fxTabCompRand1View[1] ++ ~fxTabCompRand2View[1] ++ ~fxTabCompRand3View [1]++ ~fxTabCompRand4View[1] ++ ~fxTabCompRand3EQ1View[1] ++ ~fxTabCompRand3EQ2View[1] ++ ~fxTabCompRand3EQ3View[1];

		~fxTabCompRandLView[1] = ~fxTabCompRandL1View[1] ++ ~fxTabCompRandL2View[1] ++ ~fxTabCompRandL3View[1] ++ ~fxTabCompRandL4View[1];
		~fxTabCompRandMView[1] = ~fxTabCompRandM1View[1] ++ ~fxTabCompRandM2View[1] ++ ~fxTabCompRandM3View[1] ++ ~fxTabCompRandM4View[1];
		~fxTabCompRandHView[1] = ~fxTabCompRandH1View[1] ++ ~fxTabCompRandH2View[1] ++ ~fxTabCompRandH3View[1] ++ ~fxTabCompRandH4View[1];

		~fxATabCompRandView[1] = ~fxTabCompRand5View[1] ++ ~fxTabCompRand6View[1] ++ ~fxTabCompRand7View[1] ++ ~fxTabCompRand8View[1];

	});




	/* Code à synthétiser
	~fxTabEQChaComp = 0 ! ~nbOfChannelEQ;
	~fxTabCompNameEQChaView = 0 ! ~nbOfChannelEQ;
	~fxTabCompRand1EQChaView = 0 ! ~nbOfChannelEQ;
	~fxTabCompRand2EQChaView = 0 ! ~nbOfChannelEQ;
	~fxTabCompRand3EQChaView = 0 ! ~nbOfChannelEQ;
	~fxTabCompDefEQChaView = 0 ! ~nbOfChannelEQ;
	~eQChaView = 0 ! ~nbOfChannelEQ;
	~lagEQChaView = 0 ! ~nbOfChannelEQ;
	~lagEQCha = 0 ! ~nbOfChannelEQ;
	~lagTimeEQCha = 0 ! ~nbOfChannelEQ;
	*/

	// EQ Channel Effect 1
	~fxTabEQChaComp1=0!2; ~fxTabCompNameEQCha1View=0!2; ~fxTabCompRand1EQCha1View=0!2; ~fxTabCompRand2EQCha1View=0!2; ~fxTabCompRand3EQCha1View=0!2; ~fxTabCompDefEQCha1View=0!2; ~eQChaView1=0!2; ~lagEQCha1View=0!2; ~lagEQCha1=0!2; ~lagTimeEQCha1=0!2;
	~makeEQWindow.(currentEnvironment, 0, /*790, 800*/ 5*~xSizeMul, 740*~ySizeMul,
		\fxTabEQChaComp1, \fxTabCompNameEQCha1View, \fxTabCompRand1EQCha1View, \fxTabCompRand2EQCha1View, \fxTabCompRand3EQCha1View, \fxTabCompDefEQCha1View, nil, nil,
		\eQChaView1, \lagEQCha1View, \lagEQCha1, /* \lagEQ apparemment non utilisé*/ \lagTimeEQCha1, 1, \fxSynthDef2Cha, \eqChannelUnitLib, 0, if (~server2.isNil or: {0 < ~serverTrackSwitch}, {0}, {1});
	);

	// EQ Channel Effect 2
	~fxTabEQChaComp2=0!2; ~fxTabCompNameEQCha2View=0!2; ~fxTabCompRand1EQCha2View=0!2; ~fxTabCompRand2EQCha2View=0!2; ~fxTabCompRand3EQCha2View=0!2; ~fxTabCompDefEQCha2View=0!2; ~eQChaView2=0!2; ~lagEQCha2View=0!2; ~lagEQCha2=0!2; ~lagTimeEQCha2=0!2;
	~makeEQWindow.(currentEnvironment, 1, 400*~xSizeMul, 740*~ySizeMul,
		\fxTabEQChaComp2, \fxTabCompNameEQCha2View, \fxTabCompRand1EQCha2View, \fxTabCompRand2EQCha2View, \fxTabCompRand3EQCha2View, \fxTabCompDefEQCha2View, nil, nil,
		\eQChaView2, \lagEQCha2View, \lagEQCha2, /* \lagEQ apparemment non utilisé*/ \lagTimeEQCha2, 1, \fxSynthDef2Cha, \eqChannelUnitLib, 0, if (~server2.isNil or: {1 < ~serverTrackSwitch}, {0}, {1});
	);

	// EQ Channel Effect 3
	~fxTabEQChaComp3=0!2; ~fxTabCompNameEQCha3View=0!2; ~fxTabCompRand1EQCha3View=0!2; ~fxTabCompRand2EQCha3View=0!2; ~fxTabCompRand3EQCha3View=0!2; ~fxTabCompDefEQCha3View=0!2; ~eQChaView3=0!2; ~lagEQCha3View=0!2; ~lagEQCha3=0!2; ~lagTimeEQCha3=0!2;
	~makeEQWindow.(currentEnvironment, 2, (400+395)*~xSizeMul, 740*~ySizeMul,
		\fxTabEQChaComp3, \fxTabCompNameEQCha3View, \fxTabCompRand1EQCha3View, \fxTabCompRand2EQCha3View, \fxTabCompRand3EQCha3View, \fxTabCompDefEQCha3View, nil, nil,
		\eQChaView3, \lagEQCha3View, \lagEQCha3, /* \lagEQ apparemment non utilisé*/ \lagTimeEQCha3, 1, \fxSynthDef2Cha, \eqChannelUnitLib, 0, if (~server2.isNil or: {2 < ~serverTrackSwitch}, {0}, {1});
	);

	// EQ Channel Effect 4
	~fxTabEQChaComp4=0!2; ~fxTabCompNameEQCha4View=0!2; ~fxTabCompRand1EQCha4View=0!2; ~fxTabCompRand2EQCha4View=0!2; ~fxTabCompRand3EQCha4View=0!2; ~fxTabCompDefEQCha4View=0!2; ~eQChaView4=0!2; ~lagEQCha4View=0!2; ~lagEQCha4=0!2; ~lagTimeEQCha4=0!2;
	~makeEQWindow.(currentEnvironment, 3, (400+395+395)*~xSizeMul, 740*~ySizeMul,
		\fxTabEQChaComp4, \fxTabCompNameEQCha4View, \fxTabCompRand1EQCha4View, \fxTabCompRand2EQCha4View, \fxTabCompRand3EQCha4View, \fxTabCompDefEQCha4View, nil, nil,
		\eQChaView4, \lagEQCha4View, \lagEQCha4, /* \lagEQ apparemment non utilisé*/ \lagTimeEQCha4, 1, \fxSynthDef2Cha, \eqChannelUnitLib, 0, if (~server2.isNil or: {3 < ~serverTrackSwitch}, {0}, {1});
	);

	// EQ Channel Effect 5
	~fxTabEQChaComp5=0!2; ~fxTabCompNameEQCha5View=0!2; ~fxTabCompRand1EQCha5View=0!2; ~fxTabCompRand2EQCha5View=0!2; ~fxTabCompRand3EQCha5View=0!2; ~fxTabCompDefEQCha5View=0!2; ~eQChaView5=0!2; ~lagEQCha5View=0!2; ~lagEQCha5=0!2; ~lagTimeEQCha5=0!2;
	~makeEQWindow.(currentEnvironment, 4, 5*~xSizeMul, 1010*~ySizeMul,
		\fxTabEQChaComp5, \fxTabCompNameEQCha5View, \fxTabCompRand1EQCha5View, \fxTabCompRand2EQCha5View, \fxTabCompRand3EQCha5View, \fxTabCompDefEQCha5View, nil, nil,
		\eQChaView5, \lagEQCha5View, \lagEQCha5, /* \lagEQ apparemment non utilisé*/ \lagTimeEQCha5, 1, \fxSynthDef2Cha, \eqChannelUnitLib, 0, if (~server2.isNil or: {4 < ~serverTrackSwitch}, {0}, {1});
	);

	// EQ Channel Effect 6
	~fxTabEQChaComp6=0!2; ~fxTabCompNameEQCha6View=0!2; ~fxTabCompRand1EQCha6View=0!2; ~fxTabCompRand2EQCha6View=0!2; ~fxTabCompRand3EQCha6View=0!2; ~fxTabCompDefEQCha6View=0!2; ~eQChaView6=0!2; ~lagEQCha6View=0!2; ~lagEQCha6=0!2; ~lagTimeEQCha6=0!2;
	~makeEQWindow.(currentEnvironment, 5, (5+395)*~xSizeMul, 1010*~ySizeMul,
		\fxTabEQChaComp6, \fxTabCompNameEQCha6View, \fxTabCompRand1EQCha6View, \fxTabCompRand2EQCha6View, \fxTabCompRand3EQCha6View, \fxTabCompDefEQCha6View, nil, nil,
		\eQChaView6, \lagEQCha6View, \lagEQCha6, /* \lagEQ apparemment non utilisé*/ \lagTimeEQCha6, 1, \fxSynthDef2Cha, \eqChannelUnitLib, 0, if (~server2.isNil or: {5 < ~serverTrackSwitch}, {0}, {1});
	);

	// EQ Channel Effect 7
	~fxTabEQChaComp7=0!2; ~fxTabCompNameEQCha7View=0!2; ~fxTabCompRand1EQCha7View=0!2; ~fxTabCompRand2EQCha7View=0!2; ~fxTabCompRand3EQCha7View=0!2; ~fxTabCompDefEQCha7View=0!2; ~eQChaView7=0!2; ~lagEQCha7View=0!2; ~lagEQCha7=0!2; ~lagTimeEQCha7=0!2;
	~makeEQWindow.(currentEnvironment, 6, (400+395)*~xSizeMul, 1010*~ySizeMul,
		\fxTabEQChaComp7, \fxTabCompNameEQCha7View, \fxTabCompRand1EQCha7View, \fxTabCompRand2EQCha7View, \fxTabCompRand3EQCha7View, \fxTabCompDefEQCha7View, nil, nil,
		\eQChaView7, \lagEQCha7View, \lagEQCha7, /* \lagEQ apparemment non utilisé*/ \lagTimeEQCha7, 1, \fxSynthDef2Cha, \eqChannelUnitLib, 0, if (~server2.isNil or: {6 < ~serverTrackSwitch}, {0}, {1});
	);

	// EQ Channel Effect 8
	~fxTabEQChaComp8=0!2; ~fxTabCompNameEQCha8View=0!2; ~fxTabCompRand1EQCha8View=0!2; ~fxTabCompRand2EQCha8View=0!2; ~fxTabCompRand3EQCha8View=0!2; ~fxTabCompDefEQCha8View=0!2; ~eQChaView8=0!2; ~lagEQCha8View=0!2; ~lagEQCha8=0!2; ~lagTimeEQCha8=0!2;
	~makeEQWindow.(currentEnvironment, 7, (400+395+395)*~xSizeMul, 1010*~ySizeMul,
		\fxTabEQChaComp8, \fxTabCompNameEQCha8View, \fxTabCompRand1EQCha8View, \fxTabCompRand2EQCha8View, \fxTabCompRand3EQCha8View, \fxTabCompDefEQCha8View, nil, nil,
		\eQChaView8, \lagEQCha8View, \lagEQCha8, /* \lagEQ apparemment non utilisé*/ \lagTimeEQCha8, 1, \fxSynthDef2Cha, \eqChannelUnitLib, 0, if (~server2.isNil or: {7 < ~serverTrackSwitch}, {0}, {1});
	);

	// EQ Channel Effect FX
	~fxTabEQChaCompFX=0!2; ~fxTabCompNameEQChaFXView=0!2; ~fxTabCompRand1EQChaFXView=0!2; ~fxTabCompRand2EQChaFXView=0!2; ~fxTabCompRand3EQChaFXView=0!2; ~fxTabCompDefEQChaFXView=0!2; ~eQChaViewFX=0!2; ~lagEQChaFXView=0!2; ~lagEQChaFX=0!2; ~lagTimeEQChaFX=0!2;
	~makeEQWindow.(currentEnvironment, 8, (400+395+395)*~xSizeMul, 5*~ySizeMul,
		\fxTabEQChaCompFX, \fxTabCompNameEQChaFXView, \fxTabCompRand1EQChaFXView, \fxTabCompRand2EQChaFXView, \fxTabCompRand3EQChaFXView, \fxTabCompDefEQChaFXView, nil, nil,
		\eQChaViewFX, \lagEQChaFXView, \lagEQChaFX, /* \lagEQ apparemment non utilisé*/ \lagTimeEQChaFX, 2, \fxSynthDef2Cha, \eqChannelUnitLib, 0
	);

	if (~server2.notNil, {
		~makeEQWindow.(currentEnvironment, 8, (400+395+395)*~xSizeMul, 5*~ySizeMul,
			\fxTabEQChaCompFX, \fxTabCompNameEQChaFXView, \fxTabCompRand1EQChaFXView, \fxTabCompRand2EQChaFXView, \fxTabCompRand3EQChaFXView, \fxTabCompDefEQChaFXView, nil, nil,
			\eQChaViewFX, \lagEQChaFXView, \lagEQChaFX, /* \lagEQ apparemment non utilisé*/ \lagTimeEQChaFX, 2, \fxSynthDef2Cha, \eqChannelUnitLib, 1
		);
	});

	~nbOfServers.do { |s|
		~eqChannelUnitLib[s].do { |i| i.set( \lowShelf, \freq, 150); i.set( \peak, \freq, 1500); i.set( \hiShelf, \freq, 5000); };
	};



	/*~fxTabEQComp1 = CompositeView(~tabFx, Rect(790, 800, 383, 265)).background = Color.gray(0.2).alpha_(0.175);

	~fxTabCompNameEQ1View = StaticText(~fxTabEQComp1, Rect(2, 2, 175, 20)).stringColor_(Color.yellow).background_(Color.grey(0.4)).font_(Font("Verdana",12, bold: true)).align_(\center);
	~fxTabCompNameEQ1View.string = ~fxSynthDef2b[0].name;

	~fxTabCompRand1EQ1View = RoundButton(~fxTabEQComp1, Rect(180, 2, 50, 18))
	.states_([["Rand1", Color.white, Color.red]])
	.font_(Font("Verdana",10, bold: true))
	.action_({ |a|
	~eqUnitLib1.setting = [[100, 1, 12.rand2], [250, 1, 12.rand2], [1000, 1, 12.rand2], [3500, 1, 12.rand2], [6000, 1, 12.rand2]];
	~fxSynth.do { |itemk, k| if (~fxSynth[k] != 0 and: {~fxSynth[k].defName.asString /*.contains(*/ == ~fxSynthDef2b[0].name.asString /*)*/ }, {itemk.set( \eqSetting, ~eqUnitLib1.setting, \lag, ~lagTimeEQ1 )} ) }
	});

	~fxTabCompRand2EQ1View = RoundButton(~fxTabEQComp1, Rect(230, 2, 50, 18))
	.states_([["Rand2", Color.white, Color.red]])
	.font_(Font("Verdana",10, bold: true))
	.action_({ |a|
	~eqUnitLib1.setting = [[100, exprand(0.2, 6), 12.rand2], [250, exprand(0.2, 6), 12.rand2], [1000, exprand(0.2, 6), 12.rand2], [3500, exprand(0.2, 6), 12.rand2], [6000, exprand(0.2, 6), 12.rand2]];
	~fxSynth.do { |itemk, k| if (~fxSynth[k] != 0 and: {~fxSynth[k].defName.asString /*.contains(*/ == ~fxSynthDef2b[0].name.asString /*)*/ }, {itemk.set( \eqSetting, ~eqUnitLib1.setting, \lag, ~lagTimeEQ1 )} ) }
	});

	~fxTabCompRand3EQ1View = RoundButton(~fxTabEQComp1, Rect(280, 2, 50, 18))
	.states_([["Rand3", Color.white, Color.red]])
	.font_(Font("Verdana",10, bold: true))
	.action_({ |a|
	~eqUnitLib1.setting = [[20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2], [20 exprand: 22000, exprand(0.2, 6), 12.rand2]];
	~fxSynth.do { |itemk, k| if (~fxSynth[k] != 0 and: {~fxSynth[k].defName.asString /*.contains(*/ == ~fxSynthDef2b[0].name.asString /*)*/ }, {itemk.set( \eqSetting, ~eqUnitLib1.setting, \lag, ~lagTimeEQ1 )} ) }
	});

	~fxTabCompDefEQ1View = RoundButton(~fxTabEQComp1, Rect(330, 2, 50, 18))
	.states_([["Def", Color.black, Color.green]])
	.font_(Font("Verdana",10, bold: true))
	.action_({ |a|
	~eqUnitLib1.setting = [ [ 100, 1, 0 ], [ 250, 1, 0 ], [ 1000, 1, 0 ], [ 3500, 1, 0 ], [ 6000, 1, 0 ], [ 0 ] ];
	~fxSynth.do { |itemk, k| if (~fxSynth[k] != 0 and: {~fxSynth[k].defName.asString /*.contains(*/ == ~fxSynthDef2b[0].name.asString /*)*/ }, {itemk.set( \eqSetting, ~eqUnitLib1.setting, \lag, ~lagTimeEQ1 )} ) }
	});

	~lagEQ1View =
	EZSlider.new2(~fxTabEQComp1, Rect(2, 25, 375, 20), ~lagEQ1, ControlSpec(0, 30, 'lin', 0.1, 1),
	{ |ez| ~lagTimeEQ1 = ez.value;
	/*(ez.value.asString ++" is the value of " ++ ez).postln*/
	},
	unitWidth:0, initVal:1, numberWidth:60, layout:\horz)
	.setColors(Color.grey,Color.white)
	.font_(Font("Helvetica",11))
	.valueAction_(1);

	~eQView1 = EQView(~fxTabEQComp1, Rect(5, 50, 373, 210), eqSetting: ~eqUnitLib1 ); // create a gui
	~eQView1.action = { |view, setting|
	~fxSynth.do { |itemk, k| if (~fxSynth[k] != 0 and: {~fxSynth[k].defName.asString /*.contains(*/ == ~fxSynthDef2b[0].name.asString /*)*/ }, {itemk.set( \eqSetting, setting, \lag, ~lagTimeEQ1 )} ) }
	};

	~eqUnitLib1.setting = [ [ 100, 1, 0 ], [ 250, 1, 0 ], [ 1000, 1, 0 ], [ 3500, 1, 0 ], [ 6000, 1, 0 ], [ 0 ] ];*/















	// Spectral Effects

	~fftFreqGrid = [0, 100, 250, 500, 1000, 2000, 3000, 4000, 5000, 6000, 8000, 12000, 16000, 22000 /*22050*/];
	~fftWrapFreqScale = 5; // try with a wrap of 7 or 'exp' (no 0 in this case)
	~fftFreqIntervals = [0, 100, 200, 400, 800, 1600, 3000, 5000, 8000, 12000, 16000, 22050]; // 11 levels
	~fftFreqIntervalsReduce = [0, 400, 1600, 5000]; // Sliders that will act on subsequent to have 4 zones : Low, Low medium, High medium, High

	~fftFreqSpec = ControlSpec(0, 22050, ~fftWrapFreqScale, 0.001, 0, " Hz");
	~fftFreqGridNorm = ~fftFreqSpec.unmap(~fftFreqGrid);
	~fftFreqGridLabel = ~fftFreqGrid.collect { |i| if (i == 0, {""}, {i/1000}) };
	~fftFreqIntervalsSize = ~fftFreqIntervals.size-1;
	~fftFreqIntervalsLabel = ~fftFreqIntervals / 1000; ~fftFreqIntervalsLabel[~fftFreqIntervalsSize] = 22;
	~fftFreqIntervalsReduce1 = ~fftFreqIntervals.collect {|i| if (~fftFreqIntervalsReduce.includes(i), {~fftFreqIntervals.indexOf(i)}) }; // for main sliders and also below
	~fftFreqIntervalsColors = ~fftFreqIntervalsReduce1.collect { |i| if (i.notNil, {Color.grey}, {Color.grey(0.7)} ) };
	~fftFreqIntervalsReduce2a = ~fftFreqIntervalsReduce1.reject{|x| x.isNil};
	~fftFreqIntervalsReduce2b = ~fftFreqIntervalsReduce2a ++ ~fftFreqIntervalsSize;
	~fftFreqIntervalsReduce3 = (~fftFreqIntervalsReduce2b.size-1).collect { |i| Array.series(~fftFreqIntervalsReduce2b[i+1] - ~fftFreqIntervalsReduce2b[i] - 1, ~fftFreqIntervalsReduce2b[i]+1) };

	// Grids Function
	~makeGrids = { | view, viewBounds, textView, nbLines, hGridNorm, hGridLabel, nbLines2, freqGridNorm, freqGridLabel |
		view.drawFunc_({
			nbLines.do{ |i| // dB horiz
				if (i == 0 or:{i == (nbLines-1)}, { Pen.strokeColor = Color.black }, { Pen.strokeColor = Color.blue });
				if (hGridLabel[i] == 0 or:{i == 0} or:{i == (nbLines-1)}, { Pen.width_(3) }, { Pen.width_(1) }); // for highlighting 0 dB
				Pen.line( // P1 & P2 (x,y)
					(26*~xSizeMul) // for left border
					@(viewBounds.height-(8*~ySizeMul) - ((viewBounds.height-(27*~ySizeMul)) * hGridNorm[i])), // for left and right borders
					(viewBounds.width+(3*~xSizeMul)) // for right border
					@(viewBounds.height-(8*~ySizeMul) - ((viewBounds.height-(27*~ySizeMul)) * hGridNorm[i])) // for left and right borders
				);
				Pen.stroke;
			};
			nbLines2.do{ |i| // Freq vert
				if (i == 0 or:{i == (nbLines2-1)}, { Pen.strokeColor = Color.black }, { Pen.strokeColor = Color./*red*/blue });
				if (freqGridLabel[i] == 1 or:{freqGridLabel[i] == 4} or:{freqGridLabel[i] == 8} or:{i == 0} or:{i == (nbLines2-1)}, { Pen.width_(3) }, { Pen.width_(1) }); // for highlighting freqs
				Pen.line(
					((viewBounds.width-(26*~xSizeMul)) * freqGridNorm[i] + (28*~xSizeMul)) // for borders above and below
					@(viewBounds.height-(8*~ySizeMul)), // for border above
					((viewBounds.width-(26*~xSizeMul)) * freqGridNorm[i] + (28*~xSizeMul)) // for borders above and below
					@(20*~ySizeMul) // for border below
				);
				Pen.stroke;
			};
		});
		// view.refresh;
		nbLines.do { |i| StaticText(textView, Rect((-7*~xSizeMul), (viewBounds.height - ((viewBounds.height-(26*~ySizeMul)) * hGridNorm[i])).asInteger - (18*~ySizeMul), 30*~xSizeMul, 20*~ySizeMul)).font_(Font("Helvetica", 10*~fontSizeMul)).stringColor_(Color.blue).align_(\right).string_(hGridLabel[i].asString) }; // dB
		nbLines2.do { |i| StaticText(textView, Rect(((viewBounds.width-(26*~xSizeMul)) * freqGridNorm[i]).asInteger+(9*~xSizeMul), 2*~ySizeMul, 40*~xSizeMul, 20*~ySizeMul)).font_(Font("Helvetica", 10*~fontSizeMul)).stringColor_(Color./*red*/blue).align_(\center).string_(freqGridLabel[i].asString) }; // Freq
	};





	// Spectral EQ

	~fftEQCompWidth = 480; // de 400 à 700 de compact à large
	~fftEQCompHeight = ~fftEQCompWidth * 0.57 /*280*/; // ~fftEQCompG.bounds
	~fftEQPlotColors = [Color.red, Color.yellow];

	// ~fftEQNbOfBins = ~fftEQSize / 2; // transféré dans Init Buffers & Synths pour lancer le synthé avant la GUI pour éviter les spikes & surtout éviter d'allouer des buffers quand relancement de la GUI
	~fftEQBinSpec = ControlSpec(0, ~fftEQNbOfBins-1, ~fftWrapFreqScale, 0.001, 0, "");

	~fftdBGridLabel = [ 6, 3, 0, -3, -6, -12, -24, -48, -120 ];
	~fftWrapdBScale = 'db'; // 5
	~fftAmpSpec = ControlSpec(0.000001, ~fftdBGridLabel[0].dbamp, ~fftWrapdBScale, 0.000001, 0, "");
	// ~fftdBSpec = ControlSpec(-inf, 6.0, 'db', 0.01, -inf, " dB"); // \db.asSpec
	~fftdBSpec = ControlSpec(-120, ~fftdBGridLabel[0], ~fftWrapdBScale, 0.000001, -120, " dB");
	~fftdBGridLabel2 = ~fftdBGridLabel.collect { |i| if (i == (-120), {""}, {i}) };
	~fftdBGrid = ~fftdBGridLabel.dbamp;
	~fftdBGridNorm = ~fftAmpSpec.unmap(~fftdBGrid);

	~fftEQBufsGet = { |fftEQCompChoose, serverNb|
		~fftEQBufValues[serverNb][fftEQCompChoose] = [~fftEQMagValues[serverNb][fftEQCompChoose], (0 ! (~fftEQNbOfBins))].flop.flat;
		~fftEQBufs[serverNb][fftEQCompChoose].setn(0, ~fftEQBufValues[serverNb][fftEQCompChoose]);
		~fftEQPlotterView[serverNb][fftEQCompChoose].setValue(~fftEQMagValues[serverNb][fftEQCompChoose], false); // why value_ does not work ? -> comulsory to use setValue and put findSpecs to false // Visuel
	};

	~fftEQBinResolution = (~server1.sampleRate / ~fftEQSize)/*.postln*/;
	~fftEQFreqIntervals = (~fftFreqIntervals / ~fftEQBinResolution).round.asInteger;
	~fftEQFreqIntervalsDif = ~fftEQFreqIntervals.differentiate;
	~fftEQFreqIntervalsNorm = ~fftEQBinSpec.unmap(~fftEQFreqIntervals);
	~fftEQFreqIntervalsDifNorm = ~fftEQFreqIntervalsNorm.differentiate;

	~fftEQMagValues = {0 ! ~fftEQNbOfBins} ! 2 ! 2; // initialize magnitude values

	// transféré dans Init Buffers & Synths pour lancer le synthé avant la GUI pour éviter les spikes & surtout éviter d'allouer des buffers quand relancement de la GUI
	/*~fftEQBufValues = 0 ! ~fftEQSize ! 2; // initialize FFT buffer values
	~fftEQBufs = 2.collect { Buffer.alloc(s, ~fftEQSize, 1) };
	~fftEQBufs.do { |buf, i| buf.loadCollection(~fftEQBufValues[i]) }; */// Allocate & Fill FFT-buffer



	// GUI Spectral EQ

	~fftEQPlotComp = 0 ! 2 ! 2;
	~fftEQPlotterView = 0 ! 2 ! 2;
	~fftEQMiniSliderView = 0 ! ~fftFreqIntervalsSize ! 2;
	~fftEQMiniSlider = 0 ! ~fftFreqIntervalsSize ! 2;
	~fftTabCompSelView = {0 ! ~numEffects} ! ~numFxSynthDef2c ! 2; // sert aussi pour les autres effets spectraux XXX
	~fftTabCompSelValues = {0 ! ~numEffects} ! ~numFxSynthDef2c ! 2; // sert aussi pour les autres effets spectraux XXX

	~fftEQCompG = 0 ! 2;
	~fftEQComp = 0 ! 2;
	~fftEQStackComp = 0 ! 2;
	~fftEQTabCompNameView = 0 ! 2;
	~fftEQGrid = 0 ! 2;
	~fftEQCompChooseView = 0 ! 2;
	~fftEQCompChoose = 0 ! 2;
	~fftEQBufChooseView = 0 ! 2;
	~fftEQBufChoose = 0 ! 2;
	~fftEQSliderView = 0 ! 2;
	~fftEQSlider = 0 ! 2;
	~fftEQSliderLagView = 0 ! 2;
	~fftEQSliderLag = 0 ! 2;
	~fftEQ0View = 0 ! 2;
	~fftEQClearView = 0 ! 2;
	~fftEQRandSlView = 0 ! 2;
	~fftEQRandInLView = 0 ! 2;
	~fftEQRandInView = 0 ! 2;
	~fftEQRandBinView = 0 ! 2;
	~fftEQFreqIntervalsReduceChooseView = 0 ! 2;
	~fftEQFreqIntervalsReduceChoose = 0 ! 2;
	~fftEQRoutRandView = 0 ! 2;
	~fftEQTask = 0 ! 2;
	~fftEQRoutRand = 0 ! 2;

	~nbOfServers.do { |s|

		~fftEQCompG[s] = CompositeView(~tabEq[s], Rect(5*~xSizeMul, 285*~ySizeMul, (~fftEQCompWidth-5)*~xSizeMul, ((~fftEQCompHeight*1.5)+30)*~ySizeMul)).background_(Color.grey(0.7)); // for all
		~fftEQComp[s] = CompositeView(~fftEQCompG[s], Rect(0, 20*~ySizeMul, ~fftEQCompWidth*~xSizeMul, ~fftEQCompHeight*~ySizeMul)).background_(Color.grey(0.7)); // for Plotter and Grid
		2.do { |a| ~fftEQPlotComp[s][a] = CompositeView(~fftEQComp[s], Rect(5*~xSizeMul, (5+20)*~ySizeMul, ~fftEQComp[s].bounds.width-(50*~xSizeMul), ~fftEQComp[s].bounds.height-(35*~ySizeMul)))/*.background_(Color.grey(0.2, 0))*/ };
		~fftEQStackComp[s] = StackLayout(~fftEQPlotComp[s][0], ~fftEQPlotComp[s][1]).mode_(\stackAll);
		~fftEQComp[s].layout_(~fftEQStackComp[s]);

		~fftEQTabCompNameView[s] = StaticText(~fftEQCompG[s], Rect(26*~xSizeMul, 2*~ySizeMul, 274*~xSizeMul, 20*~ySizeMul)).stringColor_(Color.yellow).background_(Color.grey(0.5)).font_(Font("Verdana",12*~fontSizeMul, bold: true)).align_(\center);
		~fftEQTabCompNameView[s].string = "Spectral Filter" /*~fxSynthDef2c[0].name*/;

		~numEffects.do { |fx|
			~fftTabCompSelView[s][0][fx] = RoundButton(~fftEQCompG[s], Rect((302 + (fx*20))*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
			.states_([[(fx+1).asString, Color.white, Color.grey(0.5)],[(fx+1).asString, Color.red, Color.yellow]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a| // fx.postln; nb.postln;
				~fftTabCompSelValues[s][0][fx] = a.value;
				if (a.value == 1, {
					~fxSelectView[s][fx].valueAction_(~numFxSynthDef+4);
				},{
					~fxSelectView[s][fx].valueAction_(0);
				})
			})
		};

		~fftEQGrid[s] = UserView(~fftEQComp[s], Rect(50*~xSizeMul, 5*~ySizeMul, ~fftEQComp[s].bounds.width-(50*~xSizeMul), ~fftEQComp[s].bounds.height-(50*~ySizeMul))).mouseDownAction_(false).mouseUpAction_(false).mouseMoveAction_(false);
		~makeGrids.(~fftEQGrid[s], Rect(15*~xSizeMul, (5+20)*~ySizeMul, ~fftEQComp[s].bounds.width-(50*~xSizeMul), ~fftEQComp[s].bounds.height-(50*~ySizeMul)) /*~fftEQPlotterView[a]*/, ~fftEQPlotComp[s][0], ~fftdBGrid.size, ~fftdBGridNorm, ~fftdBGridLabel2, ~fftFreqGrid.size, ~fftFreqGridNorm, ~fftFreqGridLabel);

		2.do { |a|
			// Plotter
			~fftEQPlotterView[s][a] = Plotter("FFT Filter", Rect(20*~xSizeMul, 17*~ySizeMul, ~fftEQComp[s].bounds.width-(52*~xSizeMul), ~fftEQComp[s].bounds.height-(60*~ySizeMul)), ~fftEQPlotComp[s][a])
			.value_(~fftEQMagValues[s][a])
			.editMode_(true)
			.resolution_(0.1)
			//.plotMode_(\points)
			//.plotMode_(\plines)
			.plotMode_(\steps)
			.specs_(~fftAmpSpec)
			.domainSpecs_(~fftEQBinSpec)
			.setProperties(\gridOnX, false, \gridOnY, false, \backgroundColor, Color.clear /*Color(0.3, 0.3, 0.3, 0)*/, \plotColor, ~fftEQPlotColors[a])
			.editFunc = { |plotter, plotIndex, i, val|
				// ("Bin index: "++ i ++" - from "++ (~fftEQBinResolution * i).asInteger ++ " to " ++ (~fftEQBinResolution * i + ~fftEQBinResolution).asInteger ++ " Hz : " ++ val.round(0.01) ++ " | " ++ val.ampdb.round(0.1)).postln;
				~fftEQMagValues[s][a][i] = val;
				~fftEQBufValues[s][a] = [~fftEQMagValues[s][a], (0 ! (~fftEQNbOfBins))].flop.flat; // (0 ! (~fftEQNbOfBins)) // pour la phase
				~fftEQBufs[s][a].setn(0, ~fftEQBufValues[s][a]);
				// ~fftEQbuf.set(i * 2, val); // why set is not sufficient and compulsory to use setn to act "correctly" ?
			};
		};

		~fftEQCompChooseView[s] = Button(~fftEQCompG[s], Rect(265*~xSizeMul, ~fftEQPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["\Act on 1", Color.white, Color.red], ["\Act on 2", Color.black, Color.yellow]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftEQCompChoose[s] = i.value; ~fftEQStackComp[s].index = ~fftEQCompChoose[s] });

		~fftEQBufChooseView[s] = Button(~fftEQCompG[s], Rect(325*~xSizeMul, ~fftEQPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["\Syn on 1", Color.white, Color.red], ["\Syn on 2", Color.black, Color.yellow]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftEQBufChoose[s] = i.value;
			if (~fftTabCompSelValues[s][0].indexOf(1).notNil, {
				if (~fftEQBufChoose[s] == 0, {~fxSynth[s][~fftTabCompSelValues[s][0].indexOf(1)].set(\fade, -1, \lag, ~fftEQSliderLag[s])}, {~fxSynth[s][~fftTabCompSelValues[s][0].indexOf(1)].set(\fade, 1, \lag, ~fftEQSliderLag[s])} )
			})
		})
		.value_(0).doAction;

		~fftEQSliderView[s] = EZSlider.new2(~fftEQCompG[s], Rect(~fftEQPlotterView[s][0].bounds.width+(11*~xSizeMul), (18+20)*~ySizeMul, 30*~xSizeMul, ~fftEQPlotterView[s][0].bounds.height+(10*~ySizeMul)), nil, ~fftdBSpec,
			{ |ez| ~fftEQSlider[s] = ez.value.dbamp;
				~fftEQMagValues[s][~fftEQCompChoose[s]] = ~fftEQSlider[s] ! ~fftEQNbOfBins;
				~fftEQBufsGet.(~fftEQCompChoose[s], s);
				~fftFreqIntervalsSize.do { |b| ~fftEQMiniSliderView[s][b].value_(ez.value) }; },
			unitWidth:0, initVal:0, numberWidth:80*~xSizeMul, layout:\vert)
		.setColors(Color.grey,Color.white)
		.font_(Font("Verdana", 10*~fontSizeMul));

		~fftEQSliderLagView[s] = EZSlider.new2(~fftEQCompG[s], Rect(145*~xSizeMul, ~fftEQPlotterView[s][0].bounds.height+((25+30)*~ySizeMul), ~fftEQPlotterView[s][0].bounds.width-(142*~xSizeMul), 20*~ySizeMul), " Xfade Time ", ControlSpec(0, 30, \lin, 0.1, 1),
			{ |ez| ~fftEQSliderLag[s] = ez.value },
			labelWidth: /*70*/64*~xSizeMul, unitWidth:0, initVal:0, numberWidth:30*~xSizeMul, layout:\horz)
		.setColors(Color.grey,Color.white)
		.font_(Font("Verdana", 10*~fontSizeMul))
		.valueAction_(1);

		// Buttons
		~fftEQ0View[s] = Button(~fftEQCompG[s], Rect(26*~xSizeMul, ~fftEQPlotterView[s][0].bounds.height+((25+30)*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["0 dB", Color.white, Color.blue/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({ ~fftEQSliderView[s].value_(0).doAction });

		~fftEQClearView[s] = Button(~fftEQCompG[s], Rect(85*~xSizeMul, ~fftEQPlotterView[s][0].bounds.height+((25+30)*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["- inf", Color.white, Color.red]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({ ~fftEQSliderView[s].value_(-120).doAction });

		~fftEQRandSlView[s] = Button(~fftEQCompG[s], Rect(26*~xSizeMul, ~fftEQPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Rand Sl", Color.white, Color.magenta/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({ if (~fftEQFreqIntervalsReduceChoose[s] == 0,
			{~fftFreqIntervalsSize.do { |b| ~fftEQMiniSliderView[s][b].valueAction_(rrand(-120,6)) } },
			{~fftFreqIntervalsReduce2a.do { |b| ~fftEQMiniSliderView[s][b].valueAction_(rrand(-120,6)) } })
		});

		/*
		( // Rand exponentiel
		~fftEQMagValues[~fftEQCompChoose] = ~fftEQFreqIntervalsDif.collect { |b| Array.interpolation(b, 0.0001.exprand(2.0), 0.0001.exprand(2.0)) }.flat;
		~fftEQBufsGet.(~fftEQCompChoose);
		)
		*/

		~fftEQRandInLView[s] = Button(~fftEQCompG[s], Rect(85*~xSizeMul, ~fftEQPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Rand InL", Color.white, Color.magenta/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({
			~fftEQMagValues[s][~fftEQCompChoose[s]] = ~fftEQFreqIntervalsDif.collect { |b| Array.interpolation(b, linrand(2.0), linrand(2.0)) }.flat;
			~fftEQBufsGet.(~fftEQCompChoose[s], s);
		});

		~fftEQRandInView[s] = Button(~fftEQCompG[s], Rect(145*~xSizeMul, ~fftEQPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Rand In", Color.white, Color.magenta/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({
			~fftEQMagValues[s][~fftEQCompChoose[s]] = ~fftEQFreqIntervalsDif.collect { |b| Array.interpolation(b, 2.0.rand, 2.0.rand) }.flat;
			~fftEQBufsGet.(~fftEQCompChoose[s], s);
		});

		~fftEQRandBinView[s] = Button(~fftEQCompG[s], Rect(205*~xSizeMul, ~fftEQPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Rand Bin", Color.white, Color.magenta/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({
			~fftEQMagValues[s][~fftEQCompChoose[s]] = /*{rrand(0.0, 2)}*/ {0.000001.exprand(2)} ! ~fftEQNbOfBins;
			~fftEQBufsGet.(~fftEQCompChoose[s], s);
		});

		~fftEQFreqIntervalsReduceChooseView[s] = Button(~fftEQCompG[s], Rect(~fftEQPlotterView[s][0].bounds.width+(8*~xSizeMul), ~fftEQPlotterView[s][0].bounds.height+((52+30)*~ySizeMul), 35*~xSizeMul, 40*~ySizeMul))
		.states_([["\All", Color.white, Color.grey(0.7)], ["\Main", Color.white, Color.grey]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftEQFreqIntervalsReduceChoose[s] = i.value })
		.value_(0).doAction;

		// Routine Version graphique - faire aussi une version non graphique XXXXXXXXX
		~fftEQTask[s] = Task{
			inf.do{
				{
					if (~fftTabCompSelValues[s][0].indexOf(1).notNil, {
						if (~fftEQBufChoose[s] == 0, {
							~fftEQCompChooseView[s].valueAction_(1);
							[~fftEQRandSlView[s], ~fftEQRandInLView[s]].choose.valueAction_(1);
							~fftEQBufChooseView[s].valueAction_(1);
						}, { ~fftEQCompChooseView[s].valueAction_(0);
							[~fftEQRandSlView[s], ~fftEQRandInLView[s]].choose.valueAction_(1);
							~fftEQBufChooseView[s].valueAction_(0);
						})
					})
				}.defer;
				~fftEQSliderLag[s].max(1).wait;
			};
		};

		~fftEQRoutRandView[s] = Button(~fftEQCompG[s], Rect(~fftEQPlotterView[s][0].bounds.width+(8*~xSizeMul), ~fftEQPlotterView[s][0].bounds.height+((52+30+45)*~ySizeMul), 35*~xSizeMul, 40*~ySizeMul))
		.states_([["Rand\nRout", Color.black, Color.green], ["Rand\nRout", Color.white, Color.red]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftEQRoutRand[s] = i.value;
			if (~fftEQRoutRand[s] == 1, {
				~fftEQTask[s].play(doReset:true); // clock spécifique ???
			},{
				~fftEQTask[s].stop;
			})
		})
		.value_(0).doAction;

		~fftFreqIntervalsSize.do { |b|

			~fftEQMiniSliderView[s][b] = EZSlider.new2(~fftEQCompG[s], Rect(((~fftEQComp[s].bounds.width-(62*~xSizeMul)) * ~fftEQFreqIntervalsNorm[b])+(24*~xSizeMul), ~fftEQPlotterView[s][0].bounds.height+((55+26)*~ySizeMul), ((~fftEQComp[s].bounds.width-(70*~xSizeMul)) * ~fftEQFreqIntervalsDifNorm[b+1]).floor, ~fftEQPlotterView[s][0].bounds.height * 0.52), nil /*~fftFreqIntervalsLabel[b].asString++"-"++~fftFreqIntervalsLabel[b+1].asString*/, ~fftdBSpec /*.step_(0.01)*/,
				{ |ez|
					~fftEQMiniSlider[s][b] = ez.value.dbamp;
					~fftEQMagValues[s][~fftEQCompChoose[s]][~fftEQFreqIntervals[b]..(~fftEQFreqIntervals[b+1]-1)] = ~fftEQMiniSlider[s][b];
					~fftEQBufsGet.(~fftEQCompChoose[s], s);
					// for main sliders
					if (~fftEQFreqIntervalsReduceChoose[s] == 1, {
						if (~fftFreqIntervalsReduce2a.includes(b), { ~fftFreqIntervalsReduce3[~fftFreqIntervalsReduce2a.indexOf(b)].do{ |a| ~fftEQMiniSliderView[s][a].valueAction_(ez.value) } } );
					});
				},
				unitWidth:0, initVal:0, numberWidth:20*~xSizeMul, layout:/*\horz*/ \vert)
			.setColors(/*Color.grey,Color.white*/ sliderBackground: ~fftFreqIntervalsColors[b])
			.font_(Font("Verdana", 10*~fontSizeMul));
			//.valueAction_(-120);

			StaticText(~fftEQCompG[s], Rect(((~fftEQComp[s].bounds.width-(62*~xSizeMul)) * ~fftEQFreqIntervalsNorm[b])+(25*~xSizeMul), ~fftEQPlotterView[s][0].bounds.height + (~fftEQPlotterView[s][0].bounds.height * 0.52)+((55+28)*~ySizeMul), ((~fftEQComp[s].bounds.width-(70*~xSizeMul)) * ~fftEQFreqIntervalsDifNorm[b+1]-1).floor, 25*~ySizeMul)).string_(~fftFreqIntervalsLabel[b].asString++"\n"++~fftFreqIntervalsLabel[b+1].asString).font_(Font("Verdana", 10*~fontSizeMul)).align_(\center).background_(Color.grey).stringColor_(Color.white);

		};

		~fftEQCompChooseView[s].valueAction_(1); // Pour agir sur le 2ème PLotter et le mettre à 0
		~fftEQSliderView[s].valueAction_(0/*-120*/);
		~fftEQCompChooseView[s].valueAction_(0); // Pour agir sur le 1er PLotter et le mettre à 0
		~fftEQSliderView[s].valueAction_(0/*-120*/);

		// ~fftEQBufs.free; // Reste à libérer les buffers à un moment XXXXXXXXXXXXXXXXXXXXXXXXXXX
		// s.cachedBuffersDo({ |buf| buf.postln }); // affiche tous les buffers

	};










	// Spectral Delay

	~fftDelCompWidth = 480; // de 400 à 700 de compact à large
	~fftDelCompHeight = ~fftDelCompWidth * 0.57 /*280*/; // ~fftDelCompG.bounds
	~fftDelPlotColors = [Color.red, Color.white, Color.yellow, Color.green];

	// ~fftDelNbOfBins = ~fftDelSize / 2; // transféré dans Init Buffers & Synths pour lancer le synthé avant la GUI pour éviter les spikes & surtout éviter d'allouer des buffers quand relancement de la GUI
	~fftDelBinSpec = ControlSpec(0, ~fftDelNbOfBins-1, ~fftWrapFreqScale, 0.001, 0, "");

	~fftDelGridLabel = [ 0, 0.01, 0.1, 0.5, 1 ];
	~fftWrapDelScale = 4; // 5
	~fftDelSpec = ControlSpec(0, 1, ~fftWrapDelScale, 0.001, 0);
	~fftDelGridNorm = ~fftDelSpec.unmap(~fftDelGridLabel);

	~fftDelBufsGet = { |fftDelCompChoose, serverNb|
		~fftDelfbBufs[serverNb][fftDelCompChoose].setn(0, ~fftDelfbValues[serverNb][fftDelCompChoose]);
		~fftDelPlotterView[serverNb][fftDelCompChoose].setValue(~fftDelfbValues[serverNb][fftDelCompChoose], false); // why value_ does not work ? -> comulsory to use setValue and put findSpecs to false // Visuel
	};

	~fftDelBinResolution = (~server1.sampleRate / ~fftDelSize)/*.postln*/;
	~fftDelFreqIntervals = (~fftFreqIntervals / ~fftDelBinResolution).round.asInteger;
	~fftDelFreqIntervalsDif = ~fftDelFreqIntervals.differentiate;
	~fftDelFreqIntervalsNorm = ~fftDelBinSpec.unmap(~fftDelFreqIntervals);
	~fftDelFreqIntervalsDifNorm = ~fftDelFreqIntervalsNorm.differentiate;

	// transféré dans Init Buffers & Synths pour lancer le synthé avant la GUI pour éviter les spikes & surtout éviter d'allouer des buffers quand relancement de la GUI
	/*~fftDelfbValues = 0 ! ~fftDelNbOfBins ! 4; // initialize delay and feedback values
	~fftDelfbBufs = Array.fill(4, {Buffer.alloc(s, ~fftDelNbOfBins, 1)}); // initialize delay and feedback buffer
	~fftDelfbBufs.do { |buf, i| buf.setn(0, ~fftDelfbValues[i]) };*/ // Allocate & Fill ranges of sample value(s)



	// GUI Spectral Delay

	~fftDelPlotComp = 0 ! 4 ! 2;
	~fftDelPlotterView = 0 ! 4 ! 2;
	~fftDelMiniSliderView = 0 ! ~fftFreqIntervalsSize ! 2;
	~fftDelMiniSlider = 0 ! ~fftFreqIntervalsSize ! 2;

	~fftDelCompG = 0 ! 2;
	~fftDelComp = 0 ! 2;
	~fftDelStackComp = 0 ! 2;
	~fftDelTabCompNameView = 0 ! 2;
	~fftDelChooseCompView = 0 ! 2;
	~fftDelChooseComp = 0 ! 2; // XXX
	~fftDelGrid = 0 ! 2;
	~fftDelCompChooseView = 0 ! 2;
	~fftDelCompChoose = 0 ! 2;
	~fftDelBufChooseView = 0 ! 2;
	~fftDelBufChoose = 0 ! 2;
	~fftDelSliderView = 0 ! 2;
	~fftDelSlider = 0 ! 2;
	~fftDelSliderLagView = 0 ! 2;
	~fftDelSliderLag = 0 ! 2;
	~fftDelClearView = 0 ! 2;
	~fftDel0View = 0 ! 2;
	~fftDelRandSlView = 0 ! 2;
	~fftDelfbRandSlView = 0 ! 2;
	~fftDelfbRandInView = 0 ! 2;
	~fftDelRandBinView = 0 ! 2;
	~fftDelFreqIntervalsReduceChooseView = 0 ! 2;
	~fftDelFreqIntervalsReduceChoose = 0 ! 2;
	~fftDelTask = 0 ! 2;
	~fftDelRoutRandView = 0 ! 2;
	~fftDelRoutRand = 0 ! 2;

	~nbOfServers.do { |s|

		~fftDelCompG[s] = CompositeView(~tabEq[s], Rect(495*~xSizeMul, 285*~ySizeMul, (~fftDelCompWidth-5)*~xSizeMul, ((~fftDelCompHeight*1.5)+30)*~ySizeMul)).background_(Color.grey(0.7)); // for all
		~fftDelComp[s] = CompositeView(~fftDelCompG[s], Rect(0, 20*~ySizeMul, ~fftDelCompWidth*~xSizeMul, ~fftDelCompHeight*~ySizeMul)).background_(Color.grey(0.7)); // for Plotter and Grid
		4.do { |a| ~fftDelPlotComp[s][a] = CompositeView(~fftDelComp[s], Rect(5*~xSizeMul, (5+20)*~ySizeMul, ~fftDelComp[s].bounds.width-(50*~xSizeMul), ~fftDelComp[s].bounds.height-(35*~ySizeMul)))/*.background_(Color.grey(0.2, 0))*/ };
		~fftDelStackComp[s] = StackLayout(~fftDelPlotComp[s][0], ~fftDelPlotComp[s][1], ~fftDelPlotComp[s][2], ~fftDelPlotComp[s][3]).mode_(\stackAll);
		~fftDelComp[s].layout_(~fftDelStackComp[s]);

		~fftDelTabCompNameView[s] = StaticText(~fftDelCompG[s], Rect(26*~xSizeMul, 2*~ySizeMul, 274*~xSizeMul, 20*~ySizeMul)).stringColor_(Color.yellow).background_(Color.grey(0.5)).font_(Font("Verdana",12*~fontSizeMul, bold: true)).align_(\center);
		~fftDelTabCompNameView[s].string = "Spectral Delay" /*~fxSynthDef2c[1].name*/;

		~numEffects.do { |fx|
			~fftTabCompSelView[s][1][fx] = RoundButton(~fftDelCompG[s], Rect((302 + (fx*20))*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
			.states_([[(fx+1).asString, Color.white, Color.grey(0.5)],[(fx+1).asString, Color.red, Color.yellow]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a| // fx.postln; nb.postln;
				~fftTabCompSelValues[s][1][fx] = a.value;
				if (a.value == 1, {
					~fxSelectView[s][fx].valueAction_(~numFxSynthDef+5);
				},{
					~fxSelectView[s][fx].valueAction_(0);
				})
			})
		};

		~fftDelChooseCompView[s] = Button(~fftDelCompG[s], Rect(405*~xSizeMul, 2*~ySizeMul, 66*~xSizeMul, 20*~ySizeMul) /*Rect(376, ~fftDelPlotterView[0].bounds.height+20, 55, 20)*/)
		.states_([["View All", Color.white, Color.grey], ["1 View", Color.white, Color.grey]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|a| ~fftDelChooseComp[s] = a.value;
			case
			{~fftDelChooseComp[s] == 0}
			{4.do { |i| ~fftDelPlotComp[s][i].visible_(1)} }
			{~fftDelChooseComp[s] == 1 and: {~fftDelCompChoose[s] < 2}}
			{2.do { |i| ~fftDelPlotComp[s][i].visible_(1)}; 2.do { |i| ~fftDelPlotComp[s][i+2].visible_(0)} }
			{~fftDelChooseComp[s] == 1 and: {~fftDelCompChoose[s] > 1}}
			{2.do { |i| ~fftDelPlotComp[s][i].visible_(0)}; 2.do { |i| ~fftDelPlotComp[s][i+2].visible_(1)} }
		});

		~fftDelGrid[s] = UserView(~fftDelComp[s], Rect(50*~xSizeMul, 5*~ySizeMul, ~fftDelComp[s].bounds.width-(50*~xSizeMul), ~fftDelComp[s].bounds.height-(50*~ySizeMul))).mouseDownAction_(false).mouseUpAction_(false).mouseMoveAction_(false);
		~makeGrids.(~fftDelGrid[s], Rect(15*~xSizeMul, (5+20)*~ySizeMul, ~fftDelComp[s].bounds.width-(50*~xSizeMul), ~fftDelComp[s].bounds.height-(50*~ySizeMul)) /*~fftDelPlotterView[a]*/, ~fftDelPlotComp[s][0], ~fftDelGridLabel.size, ~fftDelGridNorm, ~fftDelGridLabel, ~fftFreqGrid.size, ~fftFreqGridNorm, ~fftFreqGridLabel);
		~makeGrids.(~fftDelGrid[s], Rect(15*~xSizeMul, (5+20)*~ySizeMul, ~fftDelComp[s].bounds.width-(50*~xSizeMul), ~fftDelComp[s].bounds.height-(50*~ySizeMul)) /*~fftDelPlotterView[a]*/, ~fftDelPlotComp[s][2], ~fftDelGridLabel.size, ~fftDelGridNorm, ~fftDelGridLabel, ~fftFreqGrid.size, ~fftFreqGridNorm, ~fftFreqGridLabel);

		4.do { |a|
			// Plotter
			~fftDelPlotterView[s][a] = Plotter("FFT Delay", Rect(10*~xSizeMul, 17*~ySizeMul, ~fftDelComp[s].bounds.width-(42*~xSizeMul), ~fftDelComp[s].bounds.height-(60*~ySizeMul)), ~fftDelPlotComp[s][a])
			.value_(~fftDelfbValues[s][a])
			.editMode_(true)
			.resolution_(0.1)
			//.plotMode_(\points)
			//.plotMode_(\plines)
			.plotMode_(\steps)
			.specs_(~fftDelSpec)
			.domainSpecs_(~fftDelBinSpec)
			.setProperties(\gridOnX, false, \gridOnY, false, \backgroundColor, Color.clear /*Color(0.3, 0.3, 0.3, 0)*/, \plotColor, ~fftDelPlotColors[a])
			.editFunc = { |plotter, plotIndex, i, val|
				// ("Bin index: "++ i ++" - from "++ (~fftDelBinResolution * i).asInteger ++ " to " ++ (~fftDelBinResolution * i + ~fftDelBinResolution).asInteger ++ " Hz : " ++ val.round(0.01)).postln;
				~fftDelfbValues[s][a][i] = val;
				~fftDelfbBufs[s][a].setn(0, ~fftDelfbValues[s][a]);
			};
		};

		~fftDelCompChooseView[s] = Button(~fftDelCompG[s], Rect(265*~xSizeMul, ~fftDelPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["\Delay 1", Color.white, Color.red], ["\FB 1", Color.black, Color.white], ["\Delay 2", Color.black, Color.yellow], ["\FB 2", Color.black, Color.green]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftDelCompChoose[s] = i.value; ~fftDelStackComp[s].index = ~fftDelCompChoose[s];
			~fftDelChooseCompView[s].valueAction_(~fftDelChooseComp[s]);
		});

		~fftDelBufChooseView[s] = Button(~fftDelCompG[s], Rect(325*~xSizeMul, ~fftDelPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["\Syn on 1", Color.white, Color.red], ["\Syn on 2", Color.black, Color.yellow]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftDelBufChoose[s] = i.value;
			if (~fftTabCompSelValues[s][1].indexOf(1).notNil, {
				if (~fftDelBufChoose[s] == 0, {~fxSynth[s][~fftTabCompSelValues[s][1].indexOf(1)].set(\fade, 0, \lag, ~fftDelSliderLag[s])}, {~fxSynth[s][~fftTabCompSelValues[s][1].indexOf(1)].set(\fade, 1, \lag, ~fftDelSliderLag[s])} )
			})
		})
		.value_(0).doAction;

		~fftDelSliderView[s] = EZSlider.new2(~fftDelCompG[s], Rect(~fftDelPlotterView[s][0].bounds.width+(1*~xSizeMul), (18+20)*~ySizeMul, 30*~xSizeMul, ~fftDelPlotterView[s][0].bounds.height+(10*~ySizeMul)), nil, ~fftDelSpec,
			{ |ez| ~fftDelSlider[s] = ez.value;
				~fftDelfbValues[s][~fftDelCompChoose[s]] = ~fftDelSlider[s] ! ~fftDelNbOfBins;
				~fftDelBufsGet.(~fftDelCompChoose[s], 0);
				~fftFreqIntervalsSize.do { |b| ~fftDelMiniSliderView[s][b].value_(ez.value) } },
			unitWidth:0, initVal:0, numberWidth:80*~xSizeMul, layout:\vert)
		.setColors(Color.grey,Color.white)
		.font_(Font("Verdana", 10*~fontSizeMul));

		~fftDelSliderLagView[s] = EZSlider.new2(~fftDelCompG[s], Rect(145*~xSizeMul, ~fftDelPlotterView[s][0].bounds.height+((25+30)*~ySizeMul), ~fftDelPlotterView[s][0].bounds.width-(142*~xSizeMul), 20*~ySizeMul), " Xfade Time ", ControlSpec(0, 30, \lin, 0.1, 1),
			{ |ez| ~fftDelSliderLag[s] = ez.value },
			labelWidth: /*70*/64*~xSizeMul, unitWidth:0, initVal:0, numberWidth:30*~xSizeMul, layout:\horz)
		.setColors(Color.grey,Color.white)
		.font_(Font("Verdana", 10*~fontSizeMul))
		.valueAction_(1);

		// Buttons
		~fftDelClearView[s] = Button(~fftDelCompG[s], Rect(26*~xSizeMul, ~fftDelPlotterView[s][0].bounds.height+((25+30)*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["0s", Color.white, Color.blue]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({
			// ~fftDelSliderView.valueAction_(0)
			// ci-dessous pour remettre à 0 non seulement les temps de délai, mais aussi le feedback
			case {~fftDelCompChoose[s] == 1} {~fftDelCompChooseView[s].valueAction_(0)} {~fftDelCompChoose[s] == 3} {~fftDelCompChooseView[s].valueAction_(2)};
			~fftDelSliderView[s].value_(0).doAction; ~fftDelCompChooseView[s].valueAction_(~fftDelCompChoose[s]+1); ~fftDelSliderView[s].value_(0).doAction; ~fftDelCompChooseView[s].valueAction_(~fftDelCompChoose[s]-1)
		});

		~fftDel0View[s] = Button(~fftDelCompG[s], Rect(85*~xSizeMul, ~fftDelPlotterView[s][0].bounds.height+((25+30)*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["1s", Color.white, Color.red/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({ ~fftDelSliderView[s].value_(1).doAction });

		~fftDelRandSlView[s] = Button(~fftDelCompG[s], Rect(26*~xSizeMul, ~fftDelPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Rand Sl", Color.white, Color.magenta/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({ if (~fftDelFreqIntervalsReduceChoose[s] == 0,
			{ ~fftFreqIntervalsSize.do { |b| ~fftDelMiniSliderView[s][b].valueAction_(exprand(0.001,1)) } },
			{ ~fftFreqIntervalsReduce2a.do { |b| ~fftDelMiniSliderView[s][b].valueAction_(exprand(0.001,1)) } })
		});

		~fftDelfbRandSlView[s] = Button(~fftDelCompG[s], Rect(85*~xSizeMul, ~fftDelPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Rand DFb", Color.white, Color.magenta/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({
			case {~fftDelCompChoose[s] == 1} {~fftDelCompChooseView[s].valueAction_(0)} {~fftDelCompChoose[s] == 3} {~fftDelCompChooseView[s].valueAction_(2)};
			~fftDelRandSlView[s].valueAction_(1); ~fftDelCompChooseView[s].valueAction_(~fftDelCompChoose[s]+1); ~fftDelRandSlView[s].valueAction_(1); ~fftDelCompChooseView[s].valueAction_(~fftDelCompChoose[s]-1)
		});

		~fftDelfbRandInView[s] = Button(~fftDelCompG[s], Rect(145*~xSizeMul, ~fftDelPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Rand In", Color.white, Color.magenta/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({
			~fftDelfbValues[s][~fftDelCompChoose[s]] = ~fftDelFreqIntervalsDif.collect { |b| Array.interpolation(b, 1.0.rand, 1.0.rand) }.flat;
			~fftDelBufsGet.(~fftDelCompChoose[s], s);
		});

		~fftDelRandBinView[s] = Button(~fftDelCompG[s], Rect(205*~xSizeMul, ~fftDelPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Rand Bin", Color.white, Color.magenta/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({
			~fftDelfbValues[s][~fftDelCompChoose[s]] = /*{rrand(0.0, 2)}*/ {0.001.exprand(1)} ! ~fftDelNbOfBins;
			~fftDelBufsGet.(~fftDelCompChoose[s], s);
		});

		~fftDelFreqIntervalsReduceChooseView[s] = Button(~fftDelCompG[s], Rect(~fftDelPlotterView[s][0].bounds.width+((-1)*~xSizeMul), ~fftDelPlotterView[s][0].bounds.height+((52+30)*~ySizeMul), 35*~xSizeMul, 40*~ySizeMul))
		.states_([["\All", Color.white, Color.grey(0.7)], ["\Main", Color.white, Color.grey]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftDelFreqIntervalsReduceChoose[s] = i.value })
		.value_(0).doAction;

		// Routine Version graphique - faire aussi une version non graphique XXXXXXXXX
		~fftDelTask[s] = Task{
			inf.do{
				{
					if (~fftTabCompSelValues[s][1].indexOf(1).notNil, {
						if (~fftDelBufChoose[s] == 0, {
							~fftDelCompChooseView[s].valueAction_(2);
							~fftDelfbRandSlView[s].valueAction_(1);
							~fftDelBufChooseView[s].valueAction_(1);
						}, { ~fftDelCompChooseView[s].valueAction_(0);
							~fftDelfbRandSlView[s].valueAction_(1);
							~fftDelBufChooseView[s].valueAction_(0);
						})
					})
				}.defer;
				~fftDelSliderLag[s].max(1).wait;
			};
		};

		~fftDelRoutRandView[s] = Button(~fftDelCompG[s], Rect(~fftDelPlotterView[s][0].bounds.width+((-1)*~xSizeMul), ~fftDelPlotterView[s][0].bounds.height+((52+30+45)*~ySizeMul), 35*~xSizeMul, 40*~ySizeMul))
		.states_([["Rand\nRout", Color.black, Color.green], ["Rand\nRout", Color.white, Color.red]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftDelRoutRand[s] = i.value;
			if (~fftDelRoutRand[s] == 1, {
				~fftDelTask[s].play(doReset:true); // clock spécifique ???
			},{
				~fftDelTask[s].stop;
			})
		})
		.value_(0).doAction;

		~fftFreqIntervalsSize.do { |b|

			~fftDelMiniSliderView[s][b] = EZSlider.new2(~fftDelCompG[s], Rect(((~fftDelComp[s].bounds.width-(62*~xSizeMul)) * ~fftDelFreqIntervalsNorm[b])+(24*~xSizeMul), ~fftDelPlotterView[s][0].bounds.height+((55+26)*~ySizeMul), ((~fftDelComp[s].bounds.width-(70*~xSizeMul)) * ~fftDelFreqIntervalsDifNorm[b+1]).floor, ~fftDelPlotterView[s][0].bounds.height * 0.52), nil /*~fftFreqIntervalsLabel[b].asString++"-"++~fftFreqIntervalsLabel[b+1].asString*/, ~fftDelSpec /*.step_(0.01)*/,
				{ |ez|
					~fftDelMiniSlider[s][b] = ez.value;
					~fftDelfbValues[s][~fftDelCompChoose[s]][~fftDelFreqIntervals[b]..(~fftDelFreqIntervals[b+1]-1)] = ~fftDelMiniSlider[s][b];
					~fftDelBufsGet.(~fftDelCompChoose[s], s);
					// for main sliders
					if (~fftDelFreqIntervalsReduceChoose[s] == 1, {
						if (~fftFreqIntervalsReduce2a.includes(b), { ~fftFreqIntervalsReduce3[~fftFreqIntervalsReduce2a.indexOf(b)].do{ |a| ~fftDelMiniSliderView[s][a].valueAction_(ez.value) } } );
					});
				},
				unitWidth:0, initVal:0, numberWidth:20*~xSizeMul, layout:/*\horz*/ \vert)
			.setColors(/*Color.grey,Color.white*/ sliderBackground: ~fftFreqIntervalsColors[b])
			.font_(Font("Verdana", 10*~fontSizeMul));
			//.valueAction_(-120);

			StaticText(~fftDelCompG[s], Rect(((~fftDelComp[s].bounds.width-(62*~xSizeMul)) * ~fftDelFreqIntervalsNorm[b])+(25*~xSizeMul), ~fftDelPlotterView[s][0].bounds.height + (~fftDelPlotterView[s][0].bounds.height * 0.52)+((55+28)*~ySizeMul), ((~fftDelComp[s].bounds.width-(70*~xSizeMul)) * ~fftDelFreqIntervalsDifNorm[b+1]-1).floor, 25*~ySizeMul)).string_(~fftFreqIntervalsLabel[b].asString++"\n"++~fftFreqIntervalsLabel[b+1].asString).font_(Font("Verdana", 10*~fontSizeMul)).align_(\center).background_(Color.grey).stringColor_(Color.white);

		};

		~fftDelCompChooseView[s].valueAction_(2); // Pour agir sur le 2ème PLotter et le mettre à 0
		~fftDelClearView[s].valueAction_(1);
		~fftDelCompChooseView[s].valueAction_(0); // Pour agir sur le 1er PLotter et le mettre à 0
		~fftDelClearView[s].valueAction_(1);

		~fftDelChooseCompView[s].valueAction_(1);

		// ~fftDelfbBufs.free; // Reste à libérer les buffers à un moment XXXXXXXXXXXXXXXXXXXXXXXXXXX

	};










	// Spectral Diffusion

	~fftOutCompWidth = 480; // de 400 à 700 de compact à large
	~fftOutCompHeight = ~fftOutCompWidth * 0.57 /*280*/; // ~fftOutCompG.bounds
	~fftOutPlotColors = [Color.red, Color.yellow];

	// ~fftOutNbOfBins = ~fftOutSize / 2; // transféré dans Init Buffers & Synths pour lancer le synthé avant la GUI pour éviter les spikes & surtout éviter d'allouer des buffers quand relancement de la GUI
	~fftOutBinSpec = ControlSpec(0, ~fftOutNbOfBins-1, ~fftWrapFreqScale, 1, 0, "");

	// ~fftOutGridLabel = Array.series(~numChannelsFX16, 0, 1);
	~fftOutGridLabel = Array.series(~numChannelsFX16+1, 0, 1); // TEST
	~fftWrapOutScale = \lin; // 0
	/*~fftOut1Spec = ControlSpec(0, ~numChannelsFX16-1, ~fftWrapOutScale, 1, 0);
	~fftOutPanSpec = ControlSpec(0, ~numChannelsFX16-1, ~fftWrapOutScale, 0.01, 0);*/
	~fftOut1Spec = ControlSpec(0, ~numChannelsFX16, ~fftWrapOutScale, 1, 0); // TEST
	~fftOutPanSpec = ControlSpec(0, ~numChannelsFX16, ~fftWrapOutScale, 0.01, 0); // TEST
	// ~fftOutGridLabel2 = ~fftOutGridLabel + 1;
	~fftOutGridLabel2 = ~fftOutGridLabel; // TEST
	~fftOutGridNorm = ~fftOut1Spec.unmap(~fftOutGridLabel);

	~fftOutBinResolution = (~server1.sampleRate / ~fftOutSize)/*.postln*/;
	~fftOutFreqIntervals = (~fftFreqIntervals / /*~fftOutBinResolution*/ (44100 / ~fftOutSize) ).round.asInteger;
	~fftOutFreqIntervalsDif = ~fftOutFreqIntervals.differentiate;
	~fftOutFreqIntervalsNorm = ~fftOutBinSpec.unmap(~fftOutFreqIntervals);
	~fftOutFreqIntervalsDifNorm = ~fftOutFreqIntervalsNorm.differentiate;

	// transféré dans Init Buffers & Synths pour lancer le synthé avant la GUI pour éviter les spikes & surtout éviter d'allouer des buffers quand relancement de la GUI
	// Array initialization
	/*~fftOut1MagValues = {0 ! ~fftOutNbOfBins ! ~numChannelsFX16} ! 2;

	// ~fftOutPanMagValues = {0.0 ! ~fftOutNbOfBins ! ~numChannelsFX16} ! 2; // OLD version for multiple outputs
	// ~fftOutPanBinMagValues = {0.0 ! ~numChannelsFX16 ! ~fftOutNbOfBins} ! 2; // OLD version for multiple outputs
	// ~fftOutPanMultiMagValues = {0.0 ! ~fftOutNbOfBins ! ~numChannelsFX16} ! 2; // OLD version for multiple outputs

	~fftOutMagPhaValues = {0 ! ~fftOutSize ! ~numChannelsFX16} ! 2;

	~fftOutChannelValues = 0 ! ~fftOutNbOfBins ! 2;
	// ~fftOutChannelValues[0] = Array.fill(~fftOutNbOfBins, {~numChannelsFX16.rand});
	// ~fftOutChannelValues.cs; // Random Selection of a bin to a specific channel
	// ~fftOutChannelValues[0].indicesOfEqual(0);

	2.do { |a| ~numChannelsFX16.do { |ch| ~fftOut1MagValues[a][ch].do { |item, i| if (~fftOutChannelValues[a][i] == ch, {~fftOut1MagValues[a][ch][i] = 1}, {~fftOut1MagValues[a][ch][i] = 0}) } } };
	// ~fftOut1MagValues[0].cs; // Amplitude of bins for each channel
	2.do { |a| ~numChannelsFX16.do { |ch| ~fftOutMagPhaValues[a][ch] = [~fftOut1MagValues[a][ch], (0 ! (~fftOutNbOfBins))].flop.flat } };
	// ~fftOutMagPhaValues[0].cs; // Amplitude and phases (at 0) of bins for each channel

	~fftOutBufs = 2.collect { |a| ~numChannelsFX16.collect { |i| Buffer.loadCollection(s, ~fftOutMagPhaValues[a][i]) } };*/ // Pourquoi temp ???



	/*~getBinChannelsPan1Out = { |val, comp|
	~numChannelsFX16.do { |ch|
	~fftOut1MagValues[comp][ch].do { |item, i|
	if (val[i] == ch, {~fftOut1MagValues[comp][ch][i] = 1}, {~fftOut1MagValues[comp][ch][i] = 0});
	};
	~fftOutMagPhaValues[comp][ch] = [~fftOut1MagValues[comp][ch], (0 ! (~fftOutNbOfBins))].flop.flat;
	~fftOutBufs[comp][ch].sendCollection(~fftOutMagPhaValues[comp][ch]);
	}
	};

	~getBinChannelsPanMulOuts = { |comp|
	// ~fftOutPanBinMagValues[0] = ~fftOutPanMagValues[0].flop;
	~fftOutPanBinMagValues[comp] = ~fftOutPanMultiMagValues[comp].flop;
	~fftOutNbOfBins.do { |i| if (~fftOutPanBinMagValues[comp][i].sum != 0, {~fftOutPanBinMagValues[comp][i] = ~fftOutPanBinMagValues[comp][i].normalizeSum}) };
	~fftOutPanMagValues[comp] = ~fftOutPanBinMagValues[comp].flop;
	~fftOutPanMagValues[comp] = ~fftOutPanMagValues[comp].sqrt;
	~numChannelsFX16.do { |ch|
	~fftOutMagPhaValues[comp][ch] = [~fftOutPanMagValues[comp][ch], (0 ! (~fftOutNbOfBins))].flop.flat;
	~fftOutBufs[comp][ch].sendCollection(~fftOutMagPhaValues[comp][ch]);
	}
	};*/
	/*
	~fftOutMagPhaValues[0].cs
	~fftOutPanMagValues[0].cs
	~fftOutPanBinMagValues[0].cs
	0.38.pow(2)
	0.92.pow(2)
	*/

	(
		case // To adapt according the number of channels - To do -> 7 / 16 channels and do automatically for any nb of channels XXXXXXXXXXXXXXXXXXXXXXXXXXX
		{~numChannelsFX16 == 2}
		{~getBinChannelsPan2Outs = { |val, comp, serverNb|
			~fftOutNbOfBins.do { |i|
				if (val[i]<1, {
					~fftOut1MagValues[serverNb][comp][0][i] = val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = 0;
				},{
					~fftOut1MagValues[serverNb][comp][0][i] = 1-val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = val[i];
				});
			};
			~numChannelsFX16.do { |ch|
				~fftOutMagPhaValues[serverNb][comp][ch] = [~fftOut1MagValues[serverNb][comp][ch].sqrt, (0 ! (~fftOutNbOfBins))].flop.flat;
				~fftOutBufs[serverNb][comp][ch].sendCollection(~fftOutMagPhaValues[serverNb][comp][ch]);
			};
		}}
		/*{~numChannelsFX16 == 2} ~fftOutChannelValues[~fftOutCompChoose], ~fftOutCompChoose
		{~getBinChannelsPan2Outs = { |val, comp|
		~fftOutNbOfBins.do { |i| ~fftOut1MagValues[~fftOutCompChoose][0][i] = 1-~fftOutChannelValues[~fftOutCompChoose][i]; ~fftOut1MagValues[~fftOutCompChoose][1][i] = ~fftOutChannelValues[~fftOutCompChoose][i]};
		~numChannelsFX16.do { |ch|
		~fftOutMagPhaValues[~fftOutCompChoose][ch] = [~fftOut1MagValues[~fftOutCompChoose][ch].sqrt, (0 ! (~fftOutNbOfBins))].flop.flat;
		~fftOutBufs[~fftOutCompChoose][ch].sendCollection(~fftOutMagPhaValues[~fftOutCompChoose][ch]);
		};
		}}*/
		{~numChannelsFX16 == 4}
		{~getBinChannelsPan2Outs = { |val, comp, serverNb|
			~fftOutNbOfBins.do { |i|
				case
				{val[i]<1}
				{~fftOut1MagValues[serverNb][comp][0][i] = val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0;}
				{val[i].inRange(1, 2)}
				{~fftOut1MagValues[serverNb][comp][0][i] = 2-val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = val[i]-1; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0;}
				{val[i].inRange(2, 3)}
				{~fftOut1MagValues[serverNb][comp][1][i] = 3-val[i]; ~fftOut1MagValues[serverNb][comp][2][i] = val[i]-2; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0;}
				{val[i]>3}
				{~fftOut1MagValues[serverNb][comp][2][i] = 4-val[i]; ~fftOut1MagValues[serverNb][comp][3][i] = val[i]-3; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0;}
			};
			~numChannelsFX16.do { |ch|
				~fftOutMagPhaValues[serverNb][comp][ch] = [~fftOut1MagValues[serverNb][comp][ch].sqrt, (0 ! (~fftOutNbOfBins))].flop.flat;
				~fftOutBufs[serverNb][comp][ch].sendCollection(~fftOutMagPhaValues[serverNb][comp][ch]);
			};
		}}
		{~numChannelsFX16 == 5}
		{~getBinChannelsPan2Outs = { |val, comp, serverNb|
			~fftOutNbOfBins.do { |i|
				case
				{val[i]<1}
				{~fftOut1MagValues[serverNb][comp][0][i] = val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0;}
				{val[i].inRange(1, 2)}
				{~fftOut1MagValues[serverNb][comp][0][i] = 2-val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = val[i]-1; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0;}
				{val[i].inRange(2, 3)}
				{~fftOut1MagValues[serverNb][comp][1][i] = 3-val[i]; ~fftOut1MagValues[serverNb][comp][2][i] = val[i]-2; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0;}
				{val[i].inRange(3, 4)}
				{~fftOut1MagValues[serverNb][comp][2][i] = 4-val[i]; ~fftOut1MagValues[serverNb][comp][3][i] = val[i]-3; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0;}
				{val[i]>4}
				{~fftOut1MagValues[serverNb][comp][3][i] = 5-val[i]; ~fftOut1MagValues[serverNb][comp][4][i] = val[i]-4; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0;};
			};
			~numChannelsFX16.do { |ch|
				~fftOutMagPhaValues[serverNb][comp][ch] = [~fftOut1MagValues[serverNb][comp][ch].sqrt, (0 ! (~fftOutNbOfBins))].flop.flat;
				~fftOutBufs[serverNb][comp][ch].sendCollection(~fftOutMagPhaValues[serverNb][comp][ch]);
			};
		}}
		{~numChannelsFX16 == 8}
		{~getBinChannelsPan2Outs = { |val, comp, serverNb|
			~fftOutNbOfBins.do { |i|
				case
				{val[i]<1}
				{~fftOut1MagValues[serverNb][comp][0][i] = val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0;}
				{val[i].inRange(1, 2)}
				{~fftOut1MagValues[serverNb][comp][0][i] = 2-val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = val[i]-1; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0;}
				{val[i].inRange(2, 3)}
				{~fftOut1MagValues[serverNb][comp][1][i] = 3-val[i]; ~fftOut1MagValues[serverNb][comp][2][i] = val[i]-2; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0;}
				{val[i].inRange(3, 4)}
				{~fftOut1MagValues[serverNb][comp][2][i] = 4-val[i]; ~fftOut1MagValues[serverNb][comp][3][i] = val[i]-3; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0;}
				{val[i].inRange(4, 5)}
				{~fftOut1MagValues[serverNb][comp][3][i] = 5-val[i]; ~fftOut1MagValues[serverNb][comp][4][i] = val[i]-4; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0;}
				{val[i].inRange(5, 6)}
				{~fftOut1MagValues[serverNb][comp][4][i] = 6-val[i]; ~fftOut1MagValues[serverNb][comp][5][i] = val[i]-5; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0;}
				{val[i].inRange(6, 7)}
				{~fftOut1MagValues[serverNb][comp][5][i] = 7-val[i]; ~fftOut1MagValues[serverNb][comp][6][i] = val[i]-6; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0;}
				{val[i]>7}
				{~fftOut1MagValues[serverNb][comp][6][i] = 8-val[i]; ~fftOut1MagValues[serverNb][comp][7][i] = val[i]-7; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0;};
			};
			~numChannelsFX16.do { |ch|
				~fftOutMagPhaValues[serverNb][comp][ch] = [~fftOut1MagValues[serverNb][comp][ch].sqrt, (0 ! (~fftOutNbOfBins))].flop.flat;
				~fftOutBufs[serverNb][comp][ch].sendCollection(~fftOutMagPhaValues[serverNb][comp][ch]);
			};
		}}
		{~numChannelsFX16 == 14}
		{~getBinChannelsPan2Outs = { |val, comp, serverNb|
			~fftOutNbOfBins.do { |i|
				case
				{val[i]<1}
				{~fftOut1MagValues[serverNb][comp][0][i] = val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(1, 2)}
				{~fftOut1MagValues[serverNb][comp][0][i] = 2-val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = val[i]-1; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(2, 3)}
				{~fftOut1MagValues[serverNb][comp][1][i] = 3-val[i]; ~fftOut1MagValues[serverNb][comp][2][i] = val[i]-2; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(3, 4)}
				{~fftOut1MagValues[serverNb][comp][2][i] = 4-val[i]; ~fftOut1MagValues[serverNb][comp][3][i] = val[i]-3; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(4, 5)}
				{~fftOut1MagValues[serverNb][comp][3][i] = 5-val[i]; ~fftOut1MagValues[serverNb][comp][4][i] = val[i]-4; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(5, 6)}
				{~fftOut1MagValues[serverNb][comp][4][i] = 6-val[i]; ~fftOut1MagValues[serverNb][comp][5][i] = val[i]-5; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(6, 7)}
				{~fftOut1MagValues[serverNb][comp][5][i] = 7-val[i]; ~fftOut1MagValues[serverNb][comp][6][i] = val[i]-6; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(7, 8)}
				{~fftOut1MagValues[serverNb][comp][6][i] = 8-val[i]; ~fftOut1MagValues[serverNb][comp][7][i] = val[i]-7; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(8, 9)}
				{~fftOut1MagValues[serverNb][comp][7][i] = 9-val[i]; ~fftOut1MagValues[serverNb][comp][8][i] = val[i]-8; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(9, 10)}
				{~fftOut1MagValues[serverNb][comp][8][i] = 10-val[i]; ~fftOut1MagValues[serverNb][comp][9][i] = val[i]-9; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(10, 11)}
				{~fftOut1MagValues[serverNb][comp][9][i] = 11-val[i]; ~fftOut1MagValues[serverNb][comp][10][i] = val[i]-10; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(11, 12)}
				{~fftOut1MagValues[serverNb][comp][10][i] = 12-val[i]; ~fftOut1MagValues[serverNb][comp][11][i] = val[i]-11; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i].inRange(12, 13)}
				{~fftOut1MagValues[serverNb][comp][11][i] = 13-val[i]; ~fftOut1MagValues[serverNb][comp][12][i] = val[i]-12; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;}
				{val[i]>13}
				{~fftOut1MagValues[serverNb][comp][12][i] = 14-val[i]; ~fftOut1MagValues[serverNb][comp][13][i] = val[i]-13; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0;};
			};
			{
				~numChannelsFX16.do { |ch| 0.01.wait; // wait nécessaire sinon génération de lates
					~fftOutMagPhaValues[serverNb][comp][ch] = [~fftOut1MagValues[serverNb][comp][ch].sqrt, (0 ! (~fftOutNbOfBins))].flop.flat;
					~fftOutBufs[serverNb][comp][ch].sendCollection(~fftOutMagPhaValues[serverNb][comp][ch]);
				};
			}.fork;
		}}
		{~numChannelsFX16 == 16}
		// ~getBinChannelsPan2Outs.(~fftOutChannelValues[s][~fftOutCompChoose[s]], ~fftOutCompChoose[s], s);
		{~getBinChannelsPan2Outs = { |val, comp, serverNb|
			~fftOutNbOfBins.do { |i| // i.postln;
				case
				{val[i]<1}
				{~fftOut1MagValues[serverNb][comp][0][i] = val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(1, 2)}
				{~fftOut1MagValues[serverNb][comp][0][i] = 2-val[i]; ~fftOut1MagValues[serverNb][comp][1][i] = val[i]-1; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(2, 3)}
				{~fftOut1MagValues[serverNb][comp][1][i] = 3-val[i]; ~fftOut1MagValues[serverNb][comp][2][i] = val[i]-2; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(3, 4)}
				{~fftOut1MagValues[serverNb][comp][2][i] = 4-val[i]; ~fftOut1MagValues[serverNb][comp][3][i] = val[i]-3; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(4, 5)}
				{~fftOut1MagValues[serverNb][comp][3][i] = 5-val[i]; ~fftOut1MagValues[serverNb][comp][4][i] = val[i]-4; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(5, 6)}
				{~fftOut1MagValues[serverNb][comp][4][i] = 6-val[i]; ~fftOut1MagValues[serverNb][comp][5][i] = val[i]-5; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(6, 7)}
				{~fftOut1MagValues[serverNb][comp][5][i] = 7-val[i]; ~fftOut1MagValues[serverNb][comp][6][i] = val[i]-6; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(7, 8)}
				{~fftOut1MagValues[serverNb][comp][6][i] = 8-val[i]; ~fftOut1MagValues[serverNb][comp][7][i] = val[i]-7; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(8, 9)}
				{~fftOut1MagValues[serverNb][comp][7][i] = 9-val[i]; ~fftOut1MagValues[serverNb][comp][8][i] = val[i]-8; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(9, 10)}
				{~fftOut1MagValues[serverNb][comp][8][i] = 10-val[i]; ~fftOut1MagValues[serverNb][comp][9][i] = val[i]-9; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(10, 11)}
				{~fftOut1MagValues[serverNb][comp][9][i] = 11-val[i]; ~fftOut1MagValues[serverNb][comp][10][i] = val[i]-10; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(11, 12)}
				{~fftOut1MagValues[serverNb][comp][10][i] = 12-val[i]; ~fftOut1MagValues[serverNb][comp][11][i] = val[i]-11; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(12, 13)}
				{~fftOut1MagValues[serverNb][comp][11][i] = 13-val[i]; ~fftOut1MagValues[serverNb][comp][12][i] = val[i]-12; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(13, 14)}
				{~fftOut1MagValues[serverNb][comp][12][i] = 14-val[i]; ~fftOut1MagValues[serverNb][comp][13][i] = val[i]-13; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][14][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i].inRange(14, 15)}
				{~fftOut1MagValues[serverNb][comp][13][i] = 15-val[i]; ~fftOut1MagValues[serverNb][comp][14][i] = val[i]-14; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][15][i] = 0;}
				{val[i]>15}
				{~fftOut1MagValues[serverNb][comp][14][i] = 16-val[i]; ~fftOut1MagValues[serverNb][comp][15][i] = val[i]-15; ~fftOut1MagValues[serverNb][comp][0][i] = 0; ~fftOut1MagValues[serverNb][comp][1][i] = 0; ~fftOut1MagValues[serverNb][comp][2][i] = 0; ~fftOut1MagValues[serverNb][comp][3][i] = 0; ~fftOut1MagValues[serverNb][comp][4][i] = 0; ~fftOut1MagValues[serverNb][comp][5][i] = 0; ~fftOut1MagValues[serverNb][comp][6][i] = 0; ~fftOut1MagValues[serverNb][comp][7][i] = 0; ~fftOut1MagValues[serverNb][comp][8][i] = 0; ~fftOut1MagValues[serverNb][comp][9][i] = 0; ~fftOut1MagValues[serverNb][comp][10][i] = 0; ~fftOut1MagValues[serverNb][comp][11][i] = 0; ~fftOut1MagValues[serverNb][comp][12][i] = 0; ~fftOut1MagValues[serverNb][comp][13][i] = 0;};
			};
			{
				~numChannelsFX16.do { |ch| 0.01.wait; // wait nécessaire sinon génération de lates
					~fftOutMagPhaValues[serverNb][comp][ch] = [~fftOut1MagValues[serverNb][comp][ch].sqrt, (0 ! (~fftOutNbOfBins))].flop.flat;
					~fftOutBufs[serverNb][comp][ch].sendCollection(~fftOutMagPhaValues[serverNb][comp][ch]);
				};
			}.fork;
		}};
	);
	/*
	{100.do {~getBinChannels.(~channelSpec.map(~outMultiSliderView.value))}}.bench
	{100.do {~getBinChannels2.() }}.bench
	{100.do {~getBinChannels3.((~channelSpec2.map(~outMultiSliderView2.value)))}}.bench
	*/



	// GUI Spectral Diffusion

	~fftOutPlotComp = 0 ! 2 ! 2;
	~fftOutPlotterView = 0 ! 2 ! 2;
	~fftOutMiniSliderView = 0 ! ~fftFreqIntervalsSize ! 2;
	~fftOutMiniSlider = 0 ! ~fftFreqIntervalsSize ! 2;

	~fftOutCompG = 0 ! 2;
	~fftOutComp = 0 ! 2;
	~fftOutStackComp = 0 ! 2;
	~fftOutTabCompNameView = 0 ! 2;
	~fftOutPanChooseView = 0 ! 2;
	~fftOutPanChoose = 0 ! 2;
	~fftOutGrid = 0 ! 2;
	~fftOutCompChooseView = 0 ! 2;
	~fftOutCompChoose = 0 ! 2;
	~fftOutBufChooseView = 0 ! 2;
	~fftOutBufChoose = 0 ! 2;
	~fftOutSliderView = 0 ! 2;
	~fftOutSlider = 0 ! 2;
	~fftOutSliderLagView = 0 ! 2;
	~fftOutSliderLag = 0 ! 2;
	~fftOut0View = 0 ! 2;
	~fftOut0RView = 0 ! 2;
	~fftOutClearView = 0 ! 2;
	~fftOutRandSlView = 0 ! 2;
	~fftOutRandInView = 0 ! 2;
	~fftOutRandBinView = 0 ! 2;
	~fftOutFreqIntervalsReduceChooseView = 0 ! 2;
	~fftOutFreqIntervalsReduceChoose = 0 ! 2;
	~fftOutTask = 0 ! 2;
	~fftOutRoutRandView = 0 ! 2;
	~fftOutRoutRand = 0 ! 2;

	~nbOfServers.do { |s|

		~fftOutCompG[s] = CompositeView(~tabEq[s], Rect(985*~xSizeMul, 285*~ySizeMul, (~fftOutCompWidth-5)*~xSizeMul, ((~fftOutCompHeight*1.5)+30)*~ySizeMul)).background_(Color.grey(0.7)); // for all
		~fftOutComp[s] = CompositeView(~fftOutCompG[s], Rect(0, 20*~ySizeMul, ~fftOutCompWidth*~xSizeMul, ~fftOutCompHeight*~ySizeMul)).background_(Color.grey(0.7)); // for Plotter and Grid
		2.do { |a| ~fftOutPlotComp[s][a] = CompositeView(~fftOutComp[s], Rect(5*~xSizeMul, 5*~ySizeMul, ~fftOutComp[s].bounds.width-(50*~xSizeMul), ~fftOutComp[s].bounds.height-(35*~ySizeMul)))/*.background_(Color.grey(0.2, 0))*/ };
		~fftOutStackComp[s] = StackLayout(~fftOutPlotComp[s][0], ~fftOutPlotComp[s][1]).mode_(\stackAll);
		~fftOutComp[s].layout_(~fftOutStackComp[s]);

		~fftOutTabCompNameView[s] = StaticText(~fftOutCompG[s], Rect(26*~xSizeMul, 2*~ySizeMul, 274*~xSizeMul, 20*~ySizeMul)).stringColor_(Color.yellow).background_(Color.grey(0.5)).font_(Font("Verdana",12*~fontSizeMul, bold: true)).align_(\center);
		~fftOutTabCompNameView[s].string = "Spectral Diffusion" /*~fxSynthDef2c[2].name*/;

		~numEffects.do { |fx|
			~fftTabCompSelView[s][2][fx] = RoundButton(~fftOutCompG[s], Rect((302 + (fx*20))*~xSizeMul, 2*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
			.states_([[(fx+1).asString, Color.white, Color.grey(0.5)],[(fx+1).asString, Color.red, Color.yellow]])
			.font_(Font("Verdana",10*~fontSizeMul, bold: true))
			.action_({ |a| // fx.postln; nb.postln;
				~fftTabCompSelValues[s][2][fx] = a.value;
				if (a.value == 1, {
					~fxSelectView[s][fx].valueAction_(~numFxSynthDef+6);
				},{
					~fxSelectView[s][fx].valueAction_(0);
				})
			})
		};

		~fftOutPanChooseView[s] = Button(~fftOutCompG[s], Rect(405*~xSizeMul, 2*~ySizeMul, 66*~xSizeMul, 20*~ySizeMul) /*Rect(380, ~fftOutPlotterView[0].bounds.height+20, 50, 20)*/)
		.states_([["1 Out", Color.white, Color.grey], ["Pan", Color.white, Color.grey]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|a| ~fftOutPanChoose[s] = a.value;
			if (~fftOutPanChoose[s] == 0, {
				~fftOutChannelValues[s][~fftOutCompChoose[s]] = ~fftOutChannelValues[s][~fftOutCompChoose[s]].round(1);
				~getBinChannelsPan2Outs.(~fftOutChannelValues[s][~fftOutCompChoose[s]], ~fftOutCompChoose[s], s);
				~fftOutPlotterView[s][~fftOutCompChoose[s]].setValue(~fftOutChannelValues[s][~fftOutCompChoose[s]], false);
				~fftOutPlotterView[s][~fftOutCompChoose[s]].specs_(~fftOut1Spec); ~fftOutSliderView[s].controlSpec_(~fftOut1Spec).adaptToControlStep;
				~fftFreqIntervalsSize.do { |b| ~fftOutMiniSliderView[s][b].controlSpec_(~fftOut1Spec).adaptToControlStep };
			}, {
				~fftOutPlotterView[s][~fftOutCompChoose[s]].specs_(~fftOutPanSpec); ~fftOutSliderView[s].controlSpec_(~fftOutPanSpec).adaptToControlStep;
				~fftFreqIntervalsSize.do { |b| ~fftOutMiniSliderView[s][b].controlSpec_(~fftOutPanSpec).adaptToControlStep };
			});
		});

		~fftOutGrid[s] = UserView(~fftOutComp[s], Rect(50*~xSizeMul, 5*~ySizeMul, ~fftOutComp[s].bounds.width-(50*~xSizeMul), ~fftOutComp[s].bounds.height-(50*~ySizeMul))).mouseDownAction_(false).mouseUpAction_(false).mouseMoveAction_(false);
		~makeGrids.(~fftOutGrid[s], Rect(15*~xSizeMul, (5+20)*~ySizeMul, ~fftOutComp[s].bounds.width-(50*~xSizeMul), ~fftOutComp[s].bounds.height-(50*~ySizeMul)) /*~fftOutPlotterView[a]*/, ~fftOutPlotComp[s][0], ~fftOutGridLabel.size, ~fftOutGridNorm, ~fftOutGridLabel2, ~fftFreqGrid.size, ~fftFreqGridNorm, ~fftFreqGridLabel);

		2.do { |a| // Plotter
			~fftOutPlotterView[s][a] = Plotter("FFT Diffusion", Rect(16*~xSizeMul, 17*~ySizeMul, ~fftOutComp[s].bounds.width-(52*~xSizeMul), ~fftOutComp[s].bounds.height-(60*~ySizeMul)), ~fftOutPlotComp[s][a])
			.value_(~fftOutChannelValues[s][a])
			.editMode_(true)
			.resolution_(0.1)
			//.plotMode_(\points)
			//.plotMode_(\plines)
			.plotMode_(\steps)
			.specs_(~fftOut1Spec)
			.domainSpecs_(~fftOutBinSpec)
			.setProperties(\gridOnX, false, \gridOnY, false, \backgroundColor, Color.clear /*Color(0.3, 0.3, 0.3, 0)*/, \plotColor, ~fftOutPlotColors[a])
			.editFunc = { |plotter, plotIndex, i, val|
				// ("Bin index: "++ i ++" - from "++ (~fftOutBinResolution * i).asInteger ++ " to " ++ (~fftOutBinResolution * i + ~fftOutBinResolution).asInteger ++ " Hz : " ++ val.round(0.01)).postln;
				~fftOutChannelValues[s][a][i] = val;
				// ~getBinChannelsPan1Out.(plotter.value); // Pourquoi plotter.value ne renvoit pas obligatoirement des entiers ???
				~getBinChannelsPan2Outs.(~fftOutChannelValues[s][a], ~fftOutCompChoose[s], s);
			};
		};

		~fftOutCompChooseView[s] = Button(~fftOutCompG[s], Rect(265*~xSizeMul, ~fftOutPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["\Act on 1", Color.white, Color.red], ["\Act on 2", Color.black, Color.yellow]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftOutCompChoose[s] = i.value; ~fftOutStackComp[s].index = ~fftOutCompChoose[s];
			~fftOutPanChooseView[s].valueAction_(~fftOutPanChoose[s])
		});

		~fftOutBufChooseView[s] = Button(~fftOutCompG[s], Rect(325*~xSizeMul, ~fftOutPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["\Syn on 1", Color.white, Color.red], ["\Syn on 2", Color.black, Color.yellow]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftOutBufChoose[s] = i.value;
			if (~fftTabCompSelValues[s][2].indexOf(1).notNil, {
				if (~fftOutBufChoose[s] == 0, {/*~fftOutSyn*/~fxSynth[s][~fftTabCompSelValues[s][2].indexOf(1)].set(\fade, -1, \lag, ~fftOutSliderLag[s])}, {/*~fftOutSyn*/~fxSynth[s][~fftTabCompSelValues[s][2].indexOf(1)].set(\fade, 1, \lag, ~fftOutSliderLag[s])} )
			})
		})
		.value_(0).doAction;

		~fftOutSliderView[s] = EZSlider.new2(~fftOutCompG[s], Rect(~fftOutPlotterView[s][0].bounds.width+(11*~xSizeMul), (18+20)*~ySizeMul, 30*~xSizeMul, ~fftOutPlotterView[s][0].bounds.height+(10*~ySizeMul)), nil, ~fftOut1Spec,
			{ |ez| ~fftOutSlider[s] = ez.value;
				~fftOutChannelValues[s][~fftOutCompChoose[s]] = ~fftOutSlider[s] ! ~fftOutNbOfBins;
				~getBinChannelsPan2Outs.(~fftOutChannelValues[s][~fftOutCompChoose[s]], ~fftOutCompChoose[s], s);
				~fftOutPlotterView[s][~fftOutCompChoose[s]].setValue(~fftOutChannelValues[s][~fftOutCompChoose[s]], false); // why value_ does not work ? -> comulsory to use setValue and put findSpecs to false
				~fftFreqIntervalsSize.do { |b| ~fftOutMiniSliderView[s][b].value_(ez.value) } },
			unitWidth:0, initVal:0, numberWidth:80*~xSizeMul, layout:\vert)
		.setColors(Color.grey,Color.white)
		.font_(Font("Verdana", 10*~fontSizeMul));

		~fftOutSliderLagView[s] = EZSlider.new2(~fftOutCompG[s], Rect(145*~xSizeMul, ~fftOutPlotterView[s][0].bounds.height+((25+30)*~ySizeMul), ~fftOutPlotterView[s][0].bounds.width-(142*~xSizeMul), 20*~ySizeMul), " Xfade Time ", ControlSpec(0, 30, \lin, 0.1, 1),
			{ |ez| ~fftOutSliderLag[s] = ez.value },
			labelWidth: /*70*/64*~xSizeMul, unitWidth:0, initVal:1, numberWidth:30*~xSizeMul, layout:\horz)
		.setColors(Color.grey,Color.white)
		.font_(Font("Verdana", 10*~fontSizeMul))
		.valueAction_(1);

		// Buttons
		~fftOut0View[s] = Button(~fftOutCompG[s], Rect(26*~xSizeMul, ~fftOutPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Diffuse", Color.white, Color.blue/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({
			~fftOutLinePerInterval = Array.interpolation(~fftFreqIntervalsSize-1, 0, ~numChannelsFX16-1) ++ (~numChannelsFX16-1);
			~fftOutMiniSliderView[s].do { |b, bindex| b.valueAction_(~fftOutLinePerInterval[bindex]) };
		});

		~fftOut0RView[s] = Button(~fftOutCompG[s], Rect(26*~xSizeMul, ~fftOutPlotterView[s][0].bounds.height+((25+30)*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["DiffuseIn", Color.white, Color.blue/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({
			~fftOutLinePerInterval = Array.interpolation(~fftFreqIntervalsSize-1, ~numChannelsFX16-1, 0) ++ 0;
			~fftOutMiniSliderView[s].do { |b, bindex| b.valueAction_(~fftOutLinePerInterval[bindex]) };
		});

		/*( // Diffuse
		~fftOutLinePerInterval = Array.interpolation(~fftFreqIntervalsSize-1, 0, ~numChannelsFX16-1) ++ (~numChannelsFX16-1); // XXX
		~fftOutFreqIntervalsDif = ~fftOutFreqIntervals.differentiate;
		~fftOutFreqIntervalsDif.removeFirst; // .removeLast .removeFirst // in SamPotter extension // XXX
		~fftOutChannelValues[~fftOutCompChoose] = ~fftOutFreqIntervalsDif.collect { |b, bindex| Array.interpolation(b, ~fftOutLinePerInterval[bindex], ~fftOutLinePerInterval[bindex]) }.flat;
		~fftOutPlotterView[~fftOutCompChoose].setValue(~fftOutChannelValues[~fftOutCompChoose], false);
		~getBinChannelsPan2Outs.(~fftOutChannelValues[~fftOutCompChoose], ~fftOutCompChoose);
		)

		( // Diffuse en agissant sur les mini-sliders
		~fftOutLinePerInterval = Array.interpolation(~fftFreqIntervalsSize-1, 0, ~numChannelsFX16-1) ++ (~numChannelsFX16-1); // XXX
		~fftOutMiniSliderView.do { |b, bindex| b.valueAction_(~fftOutLinePerInterval[bindex]) };
		)*/

		~fftOutClearView[s] = Button(~fftOutCompG[s], Rect(85*~xSizeMul, ~fftOutPlotterView[s][0].bounds.height+((25+30)*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Centered", Color.white, Color.blue/*red*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({ ~fftOutSliderView[s].value_(1.5).doAction });

		~fftOutRandSlView[s] = Button(~fftOutCompG[s], Rect(85*~xSizeMul, ~fftOutPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Rand Sl", Color.white, Color.magenta/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({ if (~fftOutFreqIntervalsReduceChoose[s] == 0,
			{~fftFreqIntervalsSize.do { |b| ~fftOutMiniSliderView[s][b].valueAction_((~numChannelsFX16-1).asFloat.rand) } },
			{~fftFreqIntervalsReduce2a.do { |b| ~fftOutMiniSliderView[s][b].valueAction_((~numChannelsFX16-1).asFloat.rand) } })
		});

		~fftOutRandInView[s] = Button(~fftOutCompG[s], Rect(145*~xSizeMul, ~fftOutPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Rand In", Color.white, Color.magenta/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({ // Interpolation aléatoire sur le nb de canaux entre chaque bande de fréquences
			~fftOutChannelValues[s][~fftOutCompChoose[s]] = ~fftOutFreqIntervalsDif.collect { |b| Array.interpolation(b,  (~numChannelsFX16-1).asFloat.rand, (~numChannelsFX16-1).asFloat.rand) }.flat;
			~fftOutPlotterView[s][~fftOutCompChoose[s]].setValue(~fftOutChannelValues[s][~fftOutCompChoose[s]], false);
			~getBinChannelsPan2Outs.(~fftOutChannelValues[s][~fftOutCompChoose[s]], ~fftOutCompChoose[s], s);
		});

		/*
		( // Interpolation sur le nb de canaux entre chaque bande de fréquences
		~fftOutChannelValues[~fftOutCompChoose] = ~fftOutFreqIntervalsDif.collect { |b| Array.interpolation(b, 0, ~numChannelsFX16-1) }.flat;
		~fftOutPlotterView[~fftOutCompChoose].setValue(~fftOutChannelValues[~fftOutCompChoose], false);
		~getBinChannelsPan2Outs.(~fftOutChannelValues[~fftOutCompChoose], ~fftOutCompChoose);
		)
		*/

		~fftOutRandBinView[s] = Button(~fftOutCompG[s], Rect(205*~xSizeMul, ~fftOutPlotterView[s][0].bounds.height+(30*~ySizeMul), 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Rand Bin", Color.white, Color.magenta/*grey*/]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({
			~fftOutChannelValues[s][~fftOutCompChoose[s]] = {(~numChannelsFX16-1).asFloat.rand} ! ~fftOutNbOfBins;
			~getBinChannelsPan2Outs.(~fftOutChannelValues[s][~fftOutCompChoose[s]], ~fftOutCompChoose[s], s);
			~fftOutPlotterView[s][~fftOutCompChoose[s]].setValue(~fftOutChannelValues[s][~fftOutCompChoose[s]], false);
		});

		~fftOutFreqIntervalsReduceChooseView[s] = Button(~fftOutCompG[s], Rect(~fftOutPlotterView[s][0].bounds.width+(8*~xSizeMul), ~fftOutPlotterView[s][0].bounds.height+((52+30)*~ySizeMul), 35*~xSizeMul, 40*~ySizeMul))
		.states_([["\All", Color.white, Color.grey(0.7)], ["\Main", Color.white, Color.grey]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftOutFreqIntervalsReduceChoose[s] = i.value })
		.value_(0).doAction;

		// Routine Version graphique - faire aussi une version non graphique XXXXXXXXX
		~fftOutTask[s] = Task{
			inf.do{
				{
					if (~fftTabCompSelValues[s][2].indexOf(1).notNil, {
						if (~fftOutBufChoose[s] == 0, {
							~fftOutCompChooseView[s].valueAction_(1);
							[~fftOutRandSlView[s], ~fftOutRandInView[s]].choose.valueAction_(1);
							~fftOutBufChooseView[s].valueAction_(1);
						}, { ~fftOutCompChooseView[s].valueAction_(0);
							[~fftOutRandSlView[s], ~fftOutRandInView[s]].choose.valueAction_(1);
							~fftOutBufChooseView[s].valueAction_(0);
						})
					})
				}.defer;
				~fftOutSliderLag[s].max(1).wait;
			};
		};

		~fftOutRoutRandView[s] = Button(~fftOutCompG[s], Rect(~fftOutPlotterView[s][0].bounds.width+(8*~xSizeMul), ~fftOutPlotterView[s][0].bounds.height+((52+30+45)*~ySizeMul), 35*~xSizeMul, 40*~ySizeMul))
		.states_([["Rand\nRout", Color.black, Color.green], ["Rand\nRout", Color.white, Color.red]])
		.font_(Font("Verdana", 10*~fontSizeMul))
		.action_({|i| ~fftOutRoutRand[s] = i.value;
			if (~fftOutRoutRand[s] == 1, {
				~fftOutTask[s].play(doReset:true); // clock spécifique ???
			},{
				~fftOutTask[s].stop;
			})
		})
		.value_(0).doAction;

		~fftFreqIntervalsSize.do { |b|

			~fftOutMiniSliderView[s][b] = EZSlider.new2(~fftOutCompG[s], Rect(((~fftOutComp[s].bounds.width-(70*~xSizeMul)) * ~fftOutFreqIntervalsNorm[b])+(24*~xSizeMul), ~fftOutPlotterView[s][0].bounds.height+((55+26)*~ySizeMul), ((~fftOutComp[s].bounds.width-(70*~xSizeMul)) * ~fftOutFreqIntervalsDifNorm[b+1]).floor, ~fftOutPlotterView[s][0].bounds.height * 0.52), nil /*~fftFreqIntervalsLabel[b].asString++"-"++~fftFreqIntervalsLabel[b+1].asString*/, ~fftOut1Spec /*.step_(0.01)*/,
				{ |ez|
					~fftOutMiniSlider[s][b] = ez.value;
					~fftOutChannelValues[s][~fftOutCompChoose[s]][~fftOutFreqIntervals[b]..(~fftOutFreqIntervals[b+1]-1)] = ~fftOutMiniSlider[s][b];
					~getBinChannelsPan2Outs.(~fftOutChannelValues[s][~fftOutCompChoose[s]], ~fftOutCompChoose[s], s);
					~fftOutPlotterView[s][~fftOutCompChoose[s]].setValue(~fftOutChannelValues[s][~fftOutCompChoose[s]], false);
					// for main sliders
					if (~fftOutFreqIntervalsReduceChoose[s] == 1, {
						if (~fftFreqIntervalsReduce2a.includes(b), { ~fftFreqIntervalsReduce3[~fftFreqIntervalsReduce2a.indexOf(b)].do{ |a| ~fftOutMiniSliderView[s][a].valueAction_(ez.value) } } );
					});
				},
				unitWidth:0, initVal:0, numberWidth:20*~xSizeMul, layout:/*\horz*/ \vert)
			.setColors(/*Color.grey,Color.white*/ sliderBackground: ~fftFreqIntervalsColors[b])
			.font_(Font("Verdana", 10*~fontSizeMul));
			//.valueAction_(0);

			StaticText(~fftOutCompG[s], Rect(((~fftOutComp[s].bounds.width-(70*~xSizeMul)) * ~fftOutFreqIntervalsNorm[b])+(25*~xSizeMul), ~fftOutPlotterView[s][0].bounds.height + (~fftOutPlotterView[s][0].bounds.height * 0.52)+((55+28)*~ySizeMul), ((~fftOutComp[s].bounds.width-(70*~xSizeMul)) * ~fftOutFreqIntervalsDifNorm[b+1]-1).floor, 25*~ySizeMul)).string_(~fftFreqIntervalsLabel[b].asString++"\n"++~fftFreqIntervalsLabel[b+1].asString).font_(Font("Verdana", 10*~fontSizeMul)).align_(\center).background_(Color.grey).stringColor_(Color.white);

		};

		~fftOutCompChooseView[s].valueAction_(1); // Pour agir sur le 2ème PLotter et le mettre à 0
		~fftOutPanChooseView[s].valueAction_(1);
		~fftOutClearView[s].valueAction_(1);
		~fftOutCompChooseView[s].valueAction_(0); // Pour agir sur le 1er PLotter et le mettre à 0
		~fftOutPanChooseView[s].valueAction_(1);
		~fftOutClearView[s].valueAction_(1);
		~fftOutClearView[s].value_(1).doAction; // juste pour

		// ~fftOutBufs.free  // Reste à libérer les buffers à un moment XXXXXXXXXXXXXXXXXXXXXXXXXXX

	};
















	// Controle Global sur les effets en haut de la GUI

	~mixFXTriggerView = 0 ! 2;
	~mixFXTrigger = 0 ! 2;
	~fxRandLParametersAllView = 0 ! 2;
	~fxRandMParametersAllView = 0 ! 2;
	~lagMixSwitchView = 0 ! 2;
	// ~lagMixSwitch = 0 ! 2; // nécessaire d'être déclaré plus haut avec ~makeFxColumn
	~mixAllFxView2 = 0 ! 2;
	~mixAllFx = 0 ! 2;
	~lagTimeAllFxView2 = 0 ! 2;
	~lagTimeAllFx = 0 ! 2;
	~fadeTimeSynthFxView2 = 0 ! 2;
	// ~fadeTimeSynthFx = 0 ! 2; // déclaré plus haut
	~fxTimePresetView = 0 ! 2;

	~fxATabAllComp = 0 ! 2;
	~fxATabCompRandAllView = 0 ! 2;
	~fxATabCompDefAllView = 0 ! 2;
	~fxAMLXDefView = 0 ! 2;
	~lagTimeAllFxAView = 0 ! 2;
	~lagTimeAllFxA = 0 ! 2;
	~angleAllFxAView = 0 ! 2;
	~angleAllFxA = 0 ! 2;
	~elevAllFxAView = 0 ! 2;
	~elevAllFxA = 0 ! 2;
	~mulAllFxAView = 0 ! 2;
	~mulAllFxA = 0 ! 2;
	~distMinAllFxAView = 0 ! 2;
	// ~distMinAllFxA = 0 ! 2; // déclaré plus haut

	~angleAllFxAViewCollection = 0 ! 2;
	~elevAllFxAViewCollection = 0 ! 2;


	~nbOfServers.do { |s|

		~mixFXTriggerView[s] = RoundButton(~fxViewComp[s], Rect( 632*~xSizeMul, 1*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
		.states_([["MFX", Color.blue, Color.white], ["MGX", Color.white, Color.red]])
		.font_(Font("Verdana",9*~fontSizeMul, bold: true))
		.action_({ |i| ~mixFXTrigger[s] = i.value;
			if (~mixFXTrigger[s] == 1, { "Mix of global mix (GFX) overwrites those of FX".postln }, { "Mix of each FX overwrites GFX".postln } );
		})
		.valueAction_(0);

		~fxRandLParametersAllView[s] = RoundButton(~fxViewComp[s], Rect( 482*~xSizeMul, 1*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
		.states_([["L", Color.black, Color.white]])
		.font_(Font("Verdana",9*~fontSizeMul, bold: true))
		.action_({
			~fxTabCompRandLView[s].do { |i| i.valueAction_(1) };
			"FX Lag randomized".postln;
			~fxSelect[s].do { |a, i|
				if ( a.inclusivelyBetween(1, ~numFxSynthDef), {
					// ~fxTabCompRandLView[a-1].valueAction_(1)
					// (~fxSynthDef[a-1].name ++ \lag/*~fxSynthDef[a].name.metadata['order'][1]*/).postln;
					("FX"+(i+1)+"Lag ->"+~fxSynthDefValues[s][(~fxSynthDef[a-1].name ++ \lag/*~fxSynthDef[a].name.metadata['order'][1]*/).asSymbol]).postln
				})
			};
		});

		~fxRandMParametersAllView[s] = RoundButton(~fxViewComp[s], Rect( 504*~xSizeMul, 1*~ySizeMul, 20*~xSizeMul, 18*~ySizeMul))
		.states_([["M", Color.black, Color.white]])
		.font_(Font("Verdana",9*~fontSizeMul, bold: true))
		.action_({
			// ~numEffects.do {|a| /*~fxRandMParametersView*/~fxTabCompRandMView[a].valueAction_(1) };
			~fxTabCompRandMView[s].do { |i| i.valueAction_(1) };
			"FX Mix randomized".postln;
			~fxSelect[s].do { |a, i|
				if ( a.inclusivelyBetween(1, ~numFxSynthDef), {
					// ~fxTabCompRandMView[a-1].valueAction_(1)
					("FX"+(i+1)+"Mix ->"+(~fxSynthDefValues[s][(~fxSynthDef[a-1].name ++ \mix/*~fxSynthDef[a].name.metadata['order'][1]*/).asSymbol]).round(0.01)).postln
				})
			};
		});

		~lagMixSwitchView[s] = RoundButton(~fxViewComp[s], Rect( 526*~xSizeMul, 1*~ySizeMul, 28*~xSizeMul, 18*~ySizeMul))
		.states_([["LM1", Color.white, Color.red], ["LMF", Color.blue, Color.white]])
		.font_(Font("Verdana",9*~fontSizeMul, bold: true))
		.action_({ |i| ~lagMixSwitch[s] = i.value;
			if (~lagMixSwitch[s] == 1, {
				~fxSelect[s].do { |item, i| if (~fxSynth[s][i] != 0 and: { item.inclusivelyBetween(1, ~numFxSynthDef) }, { ~fxSynth[s][i].set(\lagM, ~fxSynthDefValues[s][(~fxSynth[s][i].defName++\lag).asSymbol]) }); };
				/*~fxSynthDefValues.cs
				~fxSynthDefValues[(~fxSynth[i].defName++\lag).asSymbol]
				~fxSynthDefValues['DisTanhlag']*/
				"Lag of Mix independent for each FX".postln;
			}, {
				~fxSynth[s].do { |item, i| if (~fxSynth[s][i] != 0, { item.set(\lagM, 1) }); };
				"Lag of Mix global = 1 sec.".postln;
			});
		})
		// .valueAction_(1);
		.value_(1); ~lagMixSwitch[s] = 1; // Pas de valueAction, juste pour éviter le postln "Lag of Mix global = 1 sec."

		~mixAllFxViewSpec = ControlSpec(-1, 1, 'lin', 0.01, -1);
		~mixAllFxView2[s] = SmoothSlider(~fxViewComp[s], Rect(/*482*/ 556*~xSizeMul, 1*~ySizeMul, /*148*/ 74*~xSizeMul, 18*~ySizeMul))
		.action_({ |view| ~mixAllFx[s] = ~mixAllFxViewSpec.map(view.value);
			view.string = "MGX : %".format(~mixAllFx[s]);
			~mixAllFxView[s].valueAction_(~mixAllFx[s]);
		})
		.font_(Font("Verdana", 11*~fontSizeMul))
		.background_(~sliderBackgroundColor)
		.stringColor_(Color.white)
		.border_(~border)
		.borderColor_(~borderColor);

		~lagTimeAllFxSpec = ControlSpec(0, 30, 'lin', 0.01, 1);
		~lagTimeAllFxView2[s] = SmoothSlider(~fxViewComp[s], Rect(482*~xSizeMul, 19*~ySizeMul, 74*~xSizeMul, 18*~ySizeMul))
		.action_({ |view| ~lagTimeAllFx[s] = ~lagTimeAllFxSpec.map(view.value);
			view.string = "Lag : %".format(~lagTimeAllFx[s]);
			~lagTimeAllFxView[s].valueAction_(~lagTimeAllFx[s]); ~lagEQ1View[s].valueAction_(~lagTimeAllFx[s]); ~lagEQ2View[s].valueAction_(~lagTimeAllFx[s]); ~lagEQ3View[s].valueAction_(~lagTimeAllFx[s]);
			~fftEQSliderLagView[s].valueAction_(~lagTimeAllFx[s]); ~fftDelSliderLagView[s].valueAction_(~lagTimeAllFx[s]); ~fftOutSliderLagView[s].valueAction_(~lagTimeAllFx[s]);
		})
		.font_(Font("Verdana", 11*~fontSizeMul))
		.background_(~sliderBackgroundColor)
		.stringColor_(Color.white)
		.border_(~border)
		.borderColor_(~borderColor);

		~fadeTimeSynthFxSpec = ControlSpec(0.01, 30, 'lin', 0.01, 1);
		~fadeTimeSynthFxView2[s] = SmoothSlider(~fxViewComp[s], Rect(556*~xSizeMul, 19*~ySizeMul, 74*~xSizeMul, 18*~ySizeMul))
		.action_({ |view| ~fadeTimeSynthFx[s] = ~fadeTimeSynthFxSpec.map(view.value);
			view.string = "XF : %".format(~fadeTimeSynthFx[s]);
			~fadeTimeSynthFxView[s].valueAction_(~fadeTimeSynthFx[s]);
		})
		.font_(Font("Verdana", 11*~fontSizeMul))
		.background_(~sliderBackgroundColor)
		.stringColor_(Color.white)
		.border_(~border)
		.borderColor_(~borderColor);

		~fxTimePresetView[s] = RoundButton(~fxViewComp[s], Rect(632*~xSizeMul, 19*~ySizeMul, 30*~xSizeMul, 20*~ySizeMul))
		.states_([["1", Color.black, Color.green], ["2", Color.red, Color.white], ["3", Color.white, Color.red]])
		.font_(Font("Verdana",10*~fontSizeMul, bold: true))
		.action_({ |menu|
			case
			{menu.value == 0}
			{ ~lagTimeAllFxView[s].valueAction_(1); ~fadeTimeSynthFxView[s].valueAction_(0.6) }
			{menu.value == 1}
			{ ~lagTimeAllFxView[s].valueAction_(4); ~fadeTimeSynthFxView[s].valueAction_(3) }
			{menu.value == 2}
			{ ~lagTimeAllFxView[s].valueAction_(7); ~fadeTimeSynthFxView[s].valueAction_(6) }
		})
		.value_(2);





		// Controle Global sur les effets Ambisoniques

		~fxATabAllComp[s] = CompositeView(~tabAmb[s], Rect(1185*~xSizeMul, 850*~ySizeMul, 383*~xSizeMul, 157*~ySizeMul)).background = ~compFxBackgroundColors[0];

		~fxATabCompRandAllView[s] = RoundButton(~fxATabAllComp[s], Rect(5*~xSizeMul, 4*~ySizeMul, 80*~xSizeMul, 22*~ySizeMul))
		.states_([["Rand", Color.white, Color.red]])
		.font_(Font("Verdana",12*~fontSizeMul, bold: true))
		.action_({ |a|

			~numFxSynthDef5.do { |i| ~fxSynthDef5SwitchTypView[s][i].valueAction_(4.rand) };
			~numFxSynthDef6.do { |i| ~fxSynthDef6SwitchTypView[s][i].valueAction_(4.rand) };
			~numFxSynthDef7.do { |i| ~fxSynthDef7SwitchTypView[s][i].valueAction_(4.rand) };
			~numFxSynthDef7.do { |i| ~fxSynthDef7SwitchTypPCView[s][i].valueAction_(2.rand) };
			~numFxSynthDef8.do { |i| ~fxSynthDef8SwitchTypView[s][i].valueAction_(4.rand) };
			~numFxSynthDef8.do { |i| ~fxSynthDef8SwitchTypPCView[s][i].valueAction_(2.rand) };
			~numFxSynthDef8.do { |i| ~fxSynthDef8SwitchRevView[s][i].valueAction_(6.rand) };

			~fxTabCompRand5View[s].do { |i| i.valueAction_(1) };
			~fxTabCompRand6View[s].do { |i| i.valueAction_(1) };
			~fxTabCompRand7View[s].do { |i| i.valueAction_(1) };
			~fxTabCompRand8View[s].do { |i| i.valueAction_(1) };
		});

		~fxATabCompDefAllView[s] = RoundButton(~fxATabAllComp[s], Rect(90*~xSizeMul, 4*~ySizeMul, 80*~xSizeMul, 22*~ySizeMul))
		.states_([["Def", Color.white, Color.blue]])
		.font_(Font("Verdana",12*~fontSizeMul, bold: true))
		.action_({ |a|
			/*~numEffects*/ 6.do { |i|
				~fxASlider2DView[s][i].setXYActive(0.5, 0.75);
			};

			~numFxSynthDef5.do { |i| ~fxSynthDef5SwitchTypView[s][i].valueAction_(i) };
			~numFxSynthDef6.do { |i| ~fxSynthDef6SwitchTypView[s][i].valueAction_(i) };
			~numFxSynthDef7.do { |i| ~fxSynthDef7SwitchTypView[s][i].valueAction_(i) };
			~numFxSynthDef7.do { |i| ~fxSynthDef7SwitchTypPCView[s][i].valueAction_(0) };
			~numFxSynthDef8.do { |i| ~fxSynthDef8SwitchTypView[s][i].valueAction_(i) };
			~numFxSynthDef8.do { |i| ~fxSynthDef8SwitchTypPCView[s][i].valueAction_(0) };
			~numFxSynthDef8.do { |i| ~fxSynthDef8SwitchRevView[s][i].valueAction_(0) };

			~fxTabCompDef5View[s].do { |i| i.valueAction_(1) };
			~fxTabCompDef6View[s].do { |i| i.valueAction_(1) };
			~fxTabCompDef7View[s].do { |i| i.valueAction_(1) };
			~fxTabCompDef8View[s].do { |i| i.valueAction_(1) };
		});

		~fxAMLXDefView[s] = RoundButton(~fxATabAllComp[s], Rect(318*~xSizeMul, 4*~ySizeMul, 60*~xSizeMul, 22*~ySizeMul))
		.states_([["Def LAEM", Color.white, Color.blue]])
		.font_(Font("Verdana",11*~fontSizeMul, bold: true))
		.action_({ |a|
			~lagTimeAllFxAView[s].valueAction_(0.7);
			~angleAllFxAView[s].valueAction_(-pi);
			~elevAllFxAView[s].valueAction_(0);

			// ~mulAllFxAView.valueAction_(0.6); // retiré car déclenche Azim = -pi
			// redondant mais Pour éviter que Azim = -pi mais soit = pi
			//~fxTabCompDef5View.do { |i| i.valueAction_(1) };
			//~fxTabCompDef6View.do { |i| i.valueAction_(1) };

			~distMinAllFxAView[s].valueAction_(0.08);
		});

		~angleAllFxAViewCollection[s] = List.new;
		~elevAllFxAViewCollection[s] = List.new;

		~fxSynthDefViews[s].keys.do {|i| if (i.asString.contains("angle"), {~angleAllFxAViewCollection[s].add(i) } ) };
		~fxSynthDefViews[s].keys.do {|i| if (i.asString.contains("elev"), {~elevAllFxAViewCollection[s].add(i) } ) };

		~lagTimeAllFxAView[s] = EZSlider.new2(~fxATabAllComp[s], Rect(4*~xSizeMul, 30*~ySizeMul, 375*~xSizeMul, 22*~ySizeMul), "LagTime Amb", ControlSpec(0, 5, 'lin', 0.01, 1),
			{ |ez| ~lagTimeAllFxA[s] = ez.value;
				~lagTimeAllFxAViewCollection[s].do { |i| ~fxSynthDefViews[s][i].valueAction_(~lagTimeAllFxA[s]) };
			},
			labelWidth:80*~xSizeMul, unitWidth:0, initVal:0.7, numberWidth:60*~xSizeMul, layout:\horz)
		.setColors(Color.grey,Color.white)
		.font_(Font("Helvetica",11*~fontSizeMul));

		~angleAllFxAView[s] = EZSlider.new2(~fxATabAllComp[s], Rect(4*~xSizeMul, 55*~ySizeMul, 375*~xSizeMul, 22*~ySizeMul), "Angle Amb", ControlSpec(-pi/2, 0, 'lin', 0.001, -pi),
			{ |ez| ~angleAllFxA[s] = ez.value;
				~angleAllFxAViewCollection[s].do { |i| ~fxSynthDefViews[s][i].valueAction_(~angleAllFxA[s]) };
			},
			labelWidth:80*~xSizeMul, unitWidth:0, initVal:-pi, numberWidth:60*~xSizeMul, layout:\horz)
		.setColors(Color.red,Color.white)
		.font_(Font("Helvetica",11*~fontSizeMul));

		~elevAllFxAView[s] = EZSlider.new2(~fxATabAllComp[s], Rect(4*~xSizeMul, 80*~ySizeMul, 375*~xSizeMul, 22*~ySizeMul), "Elevation Amb", ControlSpec(0, pi/2, 'lin', 0.001, 0),
			{ |ez| ~elevAllFxA[s] = ez.value;
				~elevAllFxAViewCollection[s].do { |i| ~fxSynthDefViews[s][i].valueAction_(~elevAllFxA[s]) };
			},
			labelWidth:80*~xSizeMul, unitWidth:0, initVal:0, numberWidth:60*~xSizeMul, layout:\horz)
		.setColors(Color.grey,Color.white)
		.font_(Font("Helvetica",11*~fontSizeMul));

		~mulAllFxAView[s] = EZSlider.new2(~fxATabAllComp[s], Rect(4*~xSizeMul, 105*~ySizeMul, 375*~xSizeMul, 22*~ySizeMul), "Mul Amb", ControlSpec(0.1, 1, 'lin', 0.01, 0.6),
			{ |ez| ~mulAllFxA[s] = ez.value;
				/*~numEffects*/ 6.do { |i|~fxASliderMulView[s][i].valueAction_(~mulAllFxA[s]) };
			},
			labelWidth:80*~xSizeMul, unitWidth:0, initVal:0.6, numberWidth:60*~xSizeMul, layout:\horz)
		.setColors(Color.grey,Color.white)
		.font_(Font("Helvetica",11*~fontSizeMul));

		~distMinAllFxAView[s] = EZSlider.new2(~fxATabAllComp[s], Rect(4*~xSizeMul, 130*~ySizeMul, 375*~xSizeMul, 22*~ySizeMul), "Dist Min Amb", ControlSpec(0.05, 0.3, 'lin', 0.01, 0.06),
			{ |ez| ~distMinAllFxA[s] = ez.value;
				~fxSynthA[s].do { |itemk, k| if (~fxSynthA[s][k] != 0, {itemk.set(\distMin, ~distMinAllFxA[s])} ) };
			},
			labelWidth:80*~xSizeMul, unitWidth:0, initVal:0.08, numberWidth:60*~xSizeMul, layout:\horz)
		.setColors(Color.red,Color.white)
		.font_(Font("Helvetica",11*~fontSizeMul));

	};















	/*
	( // random settings
	5.collect({ 20 exprand: 22000 }).sort.do({ |item,i|
	~eq2.set( ("peak" ++ i).asSymbol, \freq, item );
	~eq2.set( ("peak" ++ i).asSymbol, \db, 9.rand2 );
	~eq2.set( ("peak" ++ i).asSymbol, \rq, 0.2 exprand: 5);
	});
	~synth2.set( \eqSetting, ~eq2.setting ); // update synth
	)
	*/


	/*
	// Master EQ

	~settings = [[100, 0, 1], [250, 0, 1], [1000, 0, 1], [3500, 0, 1], [6000, 0, 1]];
	~smooth = 0.1; // smoothing factor
	~eqVisualUpdate = 1;
	~timeEqArray = [0.1, 0.2, 0.5, 1, 2, 4];
	~curTrack = 0;

	~masterEQUpdate = Task({
	var currentSettings= ~settings.copy;
	inf.do{
	currentSettings = currentSettings-(currentSettings-~settings*~smooth);
	MasterEQ.eq[\frdb] = currentSettings;
	MasterEQ.eq[\send_current].value;
	// MasterEQ.eq[\uvw].refresh;
	if (~eqVisualUpdate == 0, {}, {MasterEQ.eq[\uvw].refresh});
	0.1.wait; //update rate
	};
	});


	~settingsEqTypeChangeF = { |selTypeEq| var freqs = {rrand(50,10000)}; var db = {10.rand2}; var q = {exprand(0.2, 6)};
	switch (selTypeEq,
	\flat, {~settingsEqTypeChange = {~settings = [[100, 0, 1], [250, 0, 1], [1000, 0, 1], [3500, 0, 1], [6000, 0, 1]]}},
	\db, {~settingsEqTypeChange = {~settings = [[100, db.value, 1], [250, db.value, 1], [1000, db.value, 1], [3500, db.value, 1], [6000, db.value, 1]]}},
	\freqdb, {~settingsEqTypeChange = {~settings = [[freqs.value, db.value, 1], [freqs.value, db.value, 1], [freqs.value, db.value, 1], [freqs.value, db.value, 1], [freqs.value, db.value, 1]]}},
	\all, {~settingsEqTypeChange = {~settings = [[freqs.value, db.value, q.value], [freqs.value, db.value, q.value], [freqs.value, db.value, q.value], [freqs.value, db.value, q.value], [freqs.value, db.value, q.value]]}});
	};
	~settingsEqTypeChangeF.value(\db);


	~settingsEqTimeChangeF = { |selTimeEq|
	switch (selTimeEq,
	\timeEqArrayChoose, {~settingsEqTimeChange = {~timeEqArray.choose}},
	\timeEqTrack, {~settingsEqTimeChange = {~lastEvent[~curTrack][\dur]}});
	};
	~settingsEqTimeChangeF.value(\timeEqArrayChoose);

	~masterEQChangeSettings = Task({
	inf.do{
	~settingsEqTypeChange.value;
	~settingsEqTimeChange.value.wait;
	};
	});

	// OLD
	/*~settingsChange = {var db = {10.rand2}; ~settings = [[100, db.value, 1], [250, db.value, 1], [1000, db.value, 1], [3500, db.value, 1], [6000, db.value, 1]]};
	~settingsChange = {var freqs = {rrand(50,10000)}; var db = {10.rand2}; ~settings = [[freqs.value, db.value, 1], [freqs.value, db.value, 1], [freqs.value, db.value, 1], [freqs.value, db.value, 1], [freqs.value, db.value, 1]]};
	~settingsChange = {var freqs = {rrand(50,10000)}; var db = {10.rand2}; var q = {exprand(0.2, 6)}; ~settings = [[freqs, db, q], [freqs, db, q], [freqs, db, q], [freqs, db, q], [freqs, db, q]]};*/
	*/















	// GUI Mise en place des effets en série et en parallèle

	/*
	~numEffects.do { |i| ~fxSynth2[i] = Synth.tail(s, \inout, [\in, (i+1)*10, \out, 0]).register };
	~numEffects.do { |i| ~fxSynth2[i].set(s, \inout, [\in, (i+1)*10, \out, 0]).register };
	(~numEffects-1).do { |i| ((i+1)*10+10).postln }
	(~numEffects-1).do { |i| ~fxSynth2[i].set( \out, (i+1)*10+10, \fadeTime, 1 )}; // Mise en place des effets en série FX1 -> FX2 -> ... -> FX5 -> 0
	(~numEffects-1).do { |i| ~fxSynth2[i].set( \out, 0, \fadeTime, 1 )}; // Réinitialisation des effets en parallèle
	*/

	~fxTabSerieComp = 0 ! 2;
	~fxInSerieListView = 0 ! 2;

	~fxInSerieChooseButtonView = 0 ! (~numEffects-1) ! 2;
	~fxInSerieChoose = 0 ! (~numEffects-1) ! 2;

	// Initialisation Données
	~fxInSerieListItems = ["FX 1", "FX 2", "FX 3", "FX 4", "FX 5"];
	~fxInSerie = 0 ! 2;
	~fxInSerieOrder = ~fxInSerieListItems.collect { |i| i.split($ )[1].asInteger -1 } ! 2;
	~fxInSerieOrder2 = ~fxInSerieListItems.collect { |i| i.split($ )[1].asInteger -1 } ! 2;
	~fxInSerieOutsPrep = (~fxInSerieListItems[1..~fxInSerieListItems.size-1]).collect { |i| (i+1).split($ )[1].asInteger }.add(0)  ! 2;
	~fxInSerieOuts = (~fxInSerieListItems[1..~fxInSerieListItems.size-1]).collect { |i, index|
		if (~fxInSerieChoose[0][index] == 0, {0}, {(i+1).split($ )[1].asInteger} )
	}.add(0) ! 2;


	~nbOfServers.do { |s|

		~fxTabSerieComp[s] = CompositeView(~tabFx[s], Rect(790*~xSizeMul, 4*~ySizeMul, 382*~xSizeMul, 158*~ySizeMul)).background = ~compFxBackgroundColors[0] /*Color.grey*/;

		~fxInSerieListView[s] = ListView(~fxTabSerieComp[s], Rect(5*~xSizeMul, 45*~ySizeMul, 55*~xSizeMul, 90*~ySizeMul))
		.background_(Color./*clear*/grey(0.3, alpha: 0.8))
		.hiliteColor_(Color.yellow(alpha: 1))
		.selectedStringColor_(Color.black)
		.stringColor_(Color.white)
		.font_(Font("Verdana",(14*~fontSizeMul).asInteger, bold: true))
		.items_(~fxInSerieListItems /*["FX 1", "FX 2", "FX 3", "FX 4", "FX 5"]*/)
		.action_({ |menu|
			// ~fxInSerie = menu.item.split($ )[1].asInteger.postln
			~fxInSerie[s] = menu.value/*.postln*/;

			~fxInSerieOrder[s] = menu.items.collect { |i| i.split($ )[1].asInteger -1 };
			~fxInSerieOrder2[s] = ~fxInSerieListView[s].items.collect { |i| i.split($ )[1].asInteger }.order;

			~fxInSerieOutsPrep[s] = (menu.items[1..menu.items.size-1]).collect { |i| (i+1).split($ )[1].asInteger }.add(0);

			~fxInSerieOuts[s] = (menu.items[1..menu.items.size-1]).collect { |i, index|
				if (~fxInSerieChoose[s][index] == 0, {0}, {(i+1).split($ )[1].asInteger} )
			}.add(0);

			// ne sert plus car action directement sur les effets et non sur les synthés inout
			// ~numEffects.do { |i| ~fxSynth2[~fxInSerieOrder[i]].set( \out, ~fxInSerieOuts[i]*10, \fadeTime, ~fadeTimeSynthFx.min(3) )}; // Mise en place des effets en série selon ordre de la liste
		});

		/*~privateBus = 0 ! ~numEffects;
		~numEffects.collect { |i| ~privateBus[i] = Bus.audio(s, ~numChannels) };
		~privateBus.cs*/



		(~numEffects-1).do { |i|

			~fxInSerieChooseButtonView[s][i] = RoundButton(~fxTabSerieComp[s], Rect(60*~xSizeMul, (45+(18*i)*~ySizeMul), 55*~xSizeMul, 18*~ySizeMul))
			.states_([["to Outs", Color.black, Color.green], ["to FX", Color.white, Color.red]])
			.font_(Font("Verdana",10*~fontSizeMul))
			.action_({ |menu| ~fxInSerieChoose[s][i] = menu.value/*.postln*/;

				if (~fxInSerieChoose[s][i] == 0, {~fxInSerieOuts[s][i] = 0}, { ~fxInSerieOuts[s][i] = ~fxInSerieOutsPrep[s][i] } );
				// ~fxSynth2[~fxInSerieOrder[i]].set( \out, ~fxInSerieOuts[i] * ~fxMulChannel /*, \fadeTime, ~fadeTimeSynthFx.min(3)*/ ); // Mise en place des effets en série selon ordre de la liste XXX
				// ~fxSynth2[~fxInSerieOrder2[i]].set( \out, ~fxInSerieOuts[~fxInSerieOrder2[i]]*10, \fadeTime, 1 ); // Mise en place des effets en série selon ordre de la liste
				// ~fxSynth2.reverse[i].set( \out, ~fxInSerieOuts[~fxInSerieOrder2.reverse[i]]*10, \fadeTime, 1 ); // Mise en place des effets en série selon ordre de la liste

				// Changement des sorties et de l'amplitude quand changement entre serie et parallele
				// ~fxSynth2[i].set( \out, ~fxInSerieOuts[i] * ~fxMulChannel, \amp, ~fxVolume );
				if (~fxInSerieChoose[s][i] == 0, {
					~fxSynth2[s][i].set( \out, (~fxInSerieOuts[s][i] * ~fxMulChannel)+~fxSeverChannelAdd, \amp, ~fxVolume );
				}, {
					~fxSynth2[s][i].set( \out, (~fxInSerieOuts[s][i] * ~fxMulChannel)+~fxSeverChannelAdd, \amp, /*1*/ (~fxVolume * ~fxMulVolume /*2*/ /*1.6*/).sqrt );
				});

				if (~fxSynth2[s][4] != 0, { if (~fxInSerieChoose[s][3] == 0, { ~fxSynth2[s][4].set( \amp, ~fxVolume ) }, { ~fxSynth2[s][4].set( \amp, (~fxVolume * ~fxMul2Volume /*2*/ /*1.6*/).sqrt ) }) }); // comme dans ~trackFXVolView

				~eqChaUpdate1Function.(i, s); // Mise à jour des EQ FX si on modifie la Série / Parallèle  // 0 pour le serveur

				// if (~fxInSerieChoose[i] == 0, { ~fxSynth2[/*~fxInSerieOrder[*/i/*]*/].set( \amp, ~fxVolume /*, \ampFadeTime, ~fadeTimeSynthFx*/ ); /*~fxSynth2[(~numEffects-1)].set( \amp, ~fxVolume )*/ }, { ~fxSynth2[/*~fxInSerieOrder[*/i/*]*/].set( \amp, 1 /*~fxVolume*/ /*, \ampFadeTime, ~fadeTimeSynthFx*/ ); /*~fxSynth2[(~numEffects-1)].set( \amp, 1 )*/ }) // Pour appliquer le volume si renvoie vers les sorties directes

				/*if (~fxInSerieChoose[i] == 0, { ~fxSynth2[/*~fxInSerieOrder[*/i/*]*/].set( \amp, ~fxVolume /*, \ampFadeTime, ~fadeTimeSynthFx*/ ); ~fxSynth2[(~numEffects-1)].set( \amp, ~fxVolume ) }, { ~fxSynth2[/*~fxInSerieOrder[*/i/*]*/].set( \amp, 1 /*, \ampFadeTime, ~fadeTimeSynthFx*/ ); ~fxSynth2[(~numEffects-1)].set( \amp, ~fxVolume ) }) // Pour appliquer le volume si renvoie vers les sorties directes*/

			})
		};

	};

	/*
	0.2.sqrt
	(0.2*4).sqrt
	*/




	~fxInSerieChooseAllButtonView = 0 ! 2;
	~fxInSerieChoose2AllButtonView = 0 ! 2;
	~fxInSerieRandButtonView = 0 ! 2;
	~fxInSerieUpButtonView = 0 ! 2;
	~fxInSerieDownButtonView = 0 ! 2;

	~nbOfServers.do { |s|

		~fxInSerieChooseAllButtonView[s] = RoundButton(~fxTabSerieComp[s], Rect(5*~xSizeMul, 5*~ySizeMul, 55*~xSizeMul, 40*~ySizeMul))
		.states_([["Par\nto Outs", Color.black, Color.green], ["Ser\nto FX", Color.white, Color.red]])
		.font_(Font("Verdana",12*~fontSizeMul, bold: true))
		.action_({ |menu|

			// (~numEffects-1).do { |i| ~fxInSerieChooseButtonView[i].valueAction_(menu.value) };
			// ~fxInSerieChoose2AllButtonView.value_(menu.value);
			// { ("Try to Wait" + ( ~fadeTimeSynthFx /*/ ~toTempo*/) ++ "s - end of FX Xfade !!!").warn; ~fadeTimeSynthFx.wait; "End of FX Xfade - OK to retrigger".inform }.fork;

			// ci-dessous pour ne pas déclencher un changement du FX Inout si un Xfade est en cours
			var preset = ~presets[~presetSelection[~tracksValue][~seqSeq[~tracksValue]].asSymbol];
			// ~presets[~presetSelection[~tracksValue][~seqSeq[~tracksValue]].asSymbol][\fxSynthSerPar]
			if (~fxSelect[s].sum > 0, {
				(~numEffects-1).do { |i|

					// if (~fxInSerieChoose[s][i] != preset[\fxSynthSerPar][i], {

					if (~fxXIOfadePlaying[s][i] == 0 and: {~fxXIOfadePlayingT[s][i].isPlaying == false}, {

						~fxInSerieChooseButtonView[s][i].valueAction_( menu.value /*preset[\fxSynthSerPar][i]*/ /* préférer y ??? */ );
						// ~presets[~presetSelection[0][~seqSeq[0]].asSymbol][\fxSynthSerPar]
						{
							~fxXIOfadePlayingF.value(i, s);
							("FX INOUT Xfade begins - End in" + ( ~fadeTimeSynthFx[s].min(6) /*/ ~toTempo*/) ++ "s !!!").warn; (~fadeTimeSynthFx[s].min(6)+0.01).wait; "End of FX INOUT Xfade - OK to retrigger".inform;
							if (~fxXIOfadePlayingT[s][i].isPlaying == false, { ~fxXIOfadePlaying[s][i] = 0 } );
						}.fork;
					},{
						("Could not send FX INOUT of Preset" + (~seqSeq[~tracksValue]+1)).postln;
					});
					// });
				};
			});

			// if (~fxSelect.sum > 0, { "FX Parallel / Serie Switch ".postln; });

			/*
			if (~fxInSerieChoose == #[ 1, 1, 1, 1 ], { ~fxInSerieChooseAllButtonView.value_(1); ~fxInSerieChoose2AllButtonView.value_(1);
			},{
			if (~fxInSerieChoose == #[ 0, 0, 0, 0 ], { ~fxInSerieChooseAllButtonView.value_(0); ~fxInSerieChoose2AllButtonView.value_(0); });
			});
			*/

			if (~fxInSerieChoose[s].sum == 4, {
				~fxInSerieChooseAllButtonView[s].value_(1); ~fxInSerieChoose2AllButtonView[s].value_(1)
			}, {
				~fxInSerieChooseAllButtonView[s].value_(0); ~fxInSerieChoose2AllButtonView[s].value_(0);
			});

			// juste pour indiquer que certains effets sont en parallèle
			// Mais PROBLEME car dès qu'il y en a un, celà l'indique pour tout le monde XXX
		});

		// Pour une vision globale en haut
		~fxInSerieChoose2AllButtonView[s] = RoundButton(~fxViewComp[s], Rect( 445*~xSizeMul, 21*~ySizeMul, 30*~xSizeMul, 18*~ySizeMul))
		.states_([["Par", Color.black, Color.green], ["Ser", Color.white, Color.red]])
		.font_(Font("Verdana",9*~fontSizeMul, bold: true))
		.action_({ |menu|

			// (~numEffects-1).do { |i| ~fxInSerieChooseButtonView[i].valueAction_(menu.value) };
			// ~fxInSerieChooseAllButtonView.value_(menu.value);
			// { ("Try to Wait" + ( ~fadeTimeSynthFx /*/ ~toTempo*/) ++ "s - end of FX Xfade !!!").warn; ~fadeTimeSynthFx.wait; "End of FX Xfade - OK to retrigger".inform }.fork;

			// ci-dessous pour ne pas déclencher un changement du FX Inout si un Xfade est en cours
			var preset = ~presets[~presetSelection[~tracksValue][~seqSeq[~tracksValue]].asSymbol];
			// ~presets[~presetSelection[~tracksValue][~seqSeq[~tracksValue]].asSymbol][\fxSynthSerPar]
			(~numEffects-1).do { |i|

				// if (~fxInSerieChoose[s][i] != preset[\fxSynthSerPar][i], {

				if (~fxXIOfadePlaying[s][i] == 0 and: {~fxXIOfadePlayingT[s][i].isPlaying == false}, {

					~fxInSerieChooseButtonView[s][i].valueAction_( menu.value /*preset[\fxSynthSerPar][i]*/ /* préférer y ??? */ );
					// ~presets[~presetSelection[0][~seqSeq[0]].asSymbol][\fxSynthSerPar]
					{
						~fxXIOfadePlayingF.value(i, s);
						("FX INOUT Xfade begins - End in" + ( ~fadeTimeSynthFx[s].min(6) /*/ ~toTempo*/) ++ "s !!!").warn; (~fadeTimeSynthFx[s].min(6)+0.01).wait; "End of FX INOUT Xfade - OK to retrigger".inform;
						if (~fxXIOfadePlayingT[s][i].isPlaying == false, { ~fxXIOfadePlaying[s][i] = 0 } );
					}.fork;
				},{
					("Could not send FX INOUT of Preset" + (~seqSeq[~tracksValue]+1)).postln;
				});
				// });
			};

			/*
			if (~fxInSerieChoose == #[ 1, 1, 1, 1 ], { ~fxInSerieChooseAllButtonView.value_(1); ~fxInSerieChoose2AllButtonView.value_(1);
			},{
			if (~fxInSerieChoose == #[ 0, 0, 0, 0 ], { ~fxInSerieChooseAllButtonView.value_(0); ~fxInSerieChoose2AllButtonView.value_(0); });
			});
			*/

			if (~fxInSerieChoose[s].sum == 4, {
				~fxInSerieChooseAllButtonView[s].value_(1); ~fxInSerieChoose2AllButtonView[s].value_(1)
			}, {
				~fxInSerieChooseAllButtonView[s].value_(0); ~fxInSerieChoose2AllButtonView[s].value_(0);
			});

			// juste pour indiquer que certains effets sont en parallèle
			// Mais PROBLEME car dès qu'il y en a un, celà l'indique pour tout le monde XXX
		});

		~fxInSerieRandButtonView[s] = RoundButton(~fxTabSerieComp[s], Rect(60*~xSizeMul, 117*~ySizeMul, 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Shuf", Color.white, Color.red]])
		.font_(Font("Verdana",10*~fontSizeMul))
		.action_({ var list = ~fxSelect[s].scramble;

			// {~numEffects.do {|a| ~fxSelectView[a].valueAction_(list[a]) ; ~fxSynthWaitTime.wait; } }.fork(AppClock)

			// ci-dessous pour ne pas déclencher un changement du FX si un Xfade est en cours
			var preset = ~presets[~presetSelection[~tracksValue][~seqSeq[~tracksValue]].asSymbol];
			if (~fxSelect[s].sum > 0, {
				~fxSelect[s].do { |y, yi|
					if (~fxXfadePlaying[s][yi] == 0 and: {~fxXfadePlayingT[s][yi].isPlaying == false}, {
						~fxSelectView[s][yi].valueAction_( list[yi] /*preset[\fxSynthNum][i]*/ );
						{
							~fxXfadePlayingF.value(yi, s);
							("FX shuffled Xfade begins - End in" + ( ~fadeTimeSynthFx[s] /*/ ~toTempo*/) ++ "s !!!").warn; (~fadeTimeSynthFx[s]+0.01).wait; "End of FX Xfade - OK to retrigger".inform;
							if (~fxXfadePlayingT[s][yi].isPlaying == false, { ~fxXfadePlaying[s][yi] = 0 } );
							// while ( { ~fxXfadePlaying[yi] == 1 }, { loop { if (~fxXfadePlayingT[yi].isPlaying == false, { ~fxXfadePlaying[yi] = 0 } ); 0.2.wait; ~fxXfadePlayingT[yi].isPlaying.postln; } } );
						}.fork;
					},{
						("Could not send FX shuffled of Preset" + (~seqSeq[~tab]+1)).postln;
					}); /*"ok".postln;*/ // permet d'éviter le redéclenchement du même effet et d'en déclencher un nouveau si le Xfade n'est pas fini
				};
				// "FX shuffled".postln;
			});

			// if (~fxSelect.sum > 0, { "FX shuffled".postln; });
			// Action sur les synthés FX car pas de son lorsque les synthé inout sont réordonnés ???????????????????????????????????????????????????????????????
			// Mais provoque une surcharge de CPU car XF avec 2 synthés d'effets alors que le synthé inout, utile seulement lors du passage de la série au Parallèle, devait faire seul le XF ???
			// Pourquoi le signal ne passe que si les synthés sont dans l'ordre 10 -> 20 ... ???????????????????????????????????????????????????????????????
			/*var list = ["FX 1", "FX 2", "FX 3", "FX 4", "FX 5"].scramble;
			~fxInSerieListView.items_(list); ~fxInSerieListView.valueAction_(0)*/
		});

		/*~fxInSerieDefButtonView = RoundButton(~fxTabSerieComp, Rect(130, 30, 50, 20))
		.states_([["Def", Color.black, Color.green]])
		.font_(Font("Verdana",10))
		.action_({
		var list = ["FX 1", "FX 2", "FX 3", "FX 4", "FX 5"];
		~fxInSerieListView.items_(list); ~fxInSerieListView.valueAction_(0)
		});*/

		~fxInSerieUpButtonView[s] = RoundButton(~fxTabSerieComp[s], Rect(60*~xSizeMul, 5*~ySizeMul, 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Up", Color.white, Color.blue]])
		.font_(Font("Verdana",10*~fontSizeMul))
		.action_({
			var currentItemIndex, prevItemIndex, prevList;
			prevList = ~fxSelect[s];
			if (~fxInSerie[s] > 0, {
				currentItemIndex = prevList[~fxInSerie[s] -1];
				prevItemIndex = prevList[~fxInSerie[s]];
				~fxSelectView[s][~fxInSerie[s] -1].valueAction_(prevItemIndex);
				~fxSelectView[s][~fxInSerie[s]].valueAction_(currentItemIndex);
				~fxInSerieListView[s].valueAction_(~fxInSerie[s] -1);
				// ~fxInSerieListView.items_(~fxInSerieListView.items.swap(~fxInSerie, currentItemIndex));
			});
		});

		~fxInSerieDownButtonView[s] = RoundButton(~fxTabSerieComp[s], Rect(60*~xSizeMul, 25*~ySizeMul, 55*~xSizeMul, 20*~ySizeMul))
		.states_([["Down", Color.white, Color.blue]])
		.font_(Font("Verdana",10*~fontSizeMul))
		.action_({
			var currentItemIndex, prevItemIndex, prevList;
			prevList = ~fxSelect[s];
			if (~fxInSerie[s] < 4, {
				currentItemIndex = prevList[~fxInSerie[s] +1];
				prevItemIndex = prevList[~fxInSerie[s]];
				~fxSelectView[s][~fxInSerie[s] +1].valueAction_(prevItemIndex);
				~fxSelectView[s][~fxInSerie[s]].valueAction_(currentItemIndex);
				~fxInSerieListView[s].valueAction_(~fxInSerie[s] +1);
			});
		});

	};





	// Controle Global dans le Tab FX

	~mixAllFxViewCollection = 0 ! 2;
	~mixAllFxView = 0 ! 2;
	~lagTimeAllFxViewCollection = 0 ! 2;
	~lagTimeAllFxOViewCollection = 0 ! 2;
	~lagTimeAllFxAViewCollection = 0 ! 2;
	~lagTimeAllFxView = 0 ! 2;
	~fadeTimeSynthFxView = 0 ! 2;
	~fxTabCompRandMAllView = 0 ! 2;
	~fxTabCompRandLAllView = 0 ! 2;
	~fxTabCompRandPAllView = 0 ! 2;
	~fxTabCompRandAllView = 0 ! 2;
	~fxTabCompRandHAllView = 0 ! 2;
	~fxTabCompDefAllView = 0 ! 2;
	~fxMLXDefView = 0 ! 2;

	~nbOfServers.do { |s|

		~mixAllFxViewCollection[s] = List.new;
		~fxSynthDefViews[s].keys.do {|i| if (i.asString.contains("mix"), {~mixAllFxViewCollection[s].add(i) } ) };

		~mixAllFxView[s] = EZSlider.new2(~fxTabSerieComp[s], Rect(120*~xSizeMul, 30*~ySizeMul, 250*~xSizeMul, 40*~ySizeMul), "Mix Fx", ControlSpec(-1, 1, 'lin', 0.01, -1),
			{ |ez| ~mixAllFx[s] = ez.value;
				/*(ez.value.asString ++" is the value of " ++ ez).postln*/
				// Temps de changement Xfade des synthés d'effets
				~mixAllFxViewCollection[s].do { |i| ~fxSynthDefViews[s][i].valueAction_(~mixAllFx[s]) };
				~mixAllFxView2[s].value_(~mixAllFxViewSpec.unmap(~mixAllFx[s]));
				~mixAllFxView2[s].string = "MGX : %".format(~mixAllFx[s]);
			},
			labelWidth:80*~xSizeMul, labelHeight:20*~ySizeMul, unitWidth:0, initVal:1, numberWidth:60*~xSizeMul, layout:\line2)
		.setColors(Color.grey,Color.white)
		.font_(Font("Helvetica",11*~fontSizeMul));

		~lagTimeAllFxViewCollection[s] = List.new; // ALL lag time EZSlider // ~lagTimeAllFxViewCollection.cs
		~lagTimeAllFxOViewCollection[s] = List.new; // Only FX lag time EZSlider // ~lagTimeAllFxOViewCollection.cs
		~lagTimeAllFxAViewCollection[s] = List.new; // Only Ambi lag time EZSlider // ~lagTimeAllFxAViewCollection.cs

		~fxSynthDefViews[s].keys.do {|i| if (i.asString.contains("lag"), {~lagTimeAllFxViewCollection[s].add(i) } ) };
		~lagTimeAllFxOViewCollection[s] = ~lagTimeAllFxViewCollection[s].reject({ arg item, i; var string = item.asString; string.beginsWith("SD") or: {string.beginsWith("Pos")} or: {string.beginsWith("Rot")} });
		~lagTimeAllFxAViewCollection[s] = ~lagTimeAllFxViewCollection[s].select({ arg item, i; var string = item.asString; string.beginsWith("SD") or: {string.beginsWith("Pos")} or: {string.beginsWith("Rot")} });

		~lagTimeAllFxView[s] = EZSlider.new2(~fxTabSerieComp[s], Rect(120*~xSizeMul, 72*~ySizeMul, 250*~xSizeMul, 40*~ySizeMul), "LagTime Fx", ControlSpec(0, 30, 'lin', 0.01, 1),
			{ |ez| ~lagTimeAllFx[s] = ez.value;
				/*(ez.value.asString ++" is the value of " ++ ez).postln*/
				// Temps de changement Xfade des synthés d'effets
				~lagTimeAllFxOViewCollection[s].do { |i| ~fxSynthDefViews[s][i].valueAction_(~lagTimeAllFx[s]) };
				~lagTimeAllFxView2[s].value_(~lagTimeAllFxSpec.unmap(~lagTimeAllFx[s]));
				~lagTimeAllFxView2[s].string = "Lag : %".format(~lagTimeAllFx[s]);
				~lagEQ1View[s].valueAction_(~lagTimeAllFx[s]); ~lagEQ2View[s].valueAction_(~lagTimeAllFx[s]); ~lagEQ3View[s].valueAction_(~lagTimeAllFx[s]);
				~fftEQSliderLagView[s].valueAction_(~lagTimeAllFx[s]); ~fftDelSliderLagView[s].valueAction_(~lagTimeAllFx[s]); ~fftOutSliderLagView[s].valueAction_(~lagTimeAllFx[s]);
			},
			labelWidth:80*~xSizeMul, labelHeight:20*~ySizeMul, unitWidth:0, initVal:1, numberWidth:60*~xSizeMul, layout:\line2)
		.setColors(Color.grey,Color.white)
		.font_(Font("Helvetica",11*~fontSizeMul));

		~fadeTimeSynthFxView[s] = EZSlider.new2(~fxTabSerieComp[s], Rect(120*~xSizeMul, 114*~ySizeMul, 250*~xSizeMul, 40*~ySizeMul), "XFadeTime Fx", ControlSpec(0.01, 30, 'lin', 0.01, 1),
			{ |ez| ~fadeTimeSynthFx[s] = ez.value;
				/*(ez.value.asString ++" is the value of " ++ ez).postln*/
				// Temps de changement Xfade des synthés d'effets
				~fxSynth[s].do { |itemk, k| if (~fxSynth[s][k] != 0, {itemk.set(\fadeTime, ~fadeTimeSynthFx[s])} ) };
				~fadeTimeSynthFxView2[s].value_(~fadeTimeSynthFxSpec.unmap(~fadeTimeSynthFx[s]));
				~fadeTimeSynthFxView2[s].string = "XF : %".format(~fadeTimeSynthFx[s]);
				~numEffects.do { |i|  if (~fxSynth2[s][i] != 0, { ~fxSynth2[s][~fxInSerieOrder[s][i]].set( \fadeTime, ~fadeTimeSynthFx[s] /*.min(3)*/ /*, \ampFadeTime, ~fadeTimeSynthFx*/ ) }) }; // Pour les synthés inout
			},
			labelWidth:80*~xSizeMul, labelHeight:20*~ySizeMul, unitWidth:0, initVal:1, numberWidth:60*~xSizeMul, layout:\line2)
		.setColors(Color.grey,Color.white)
		.font_(Font("Helvetica",11*~fontSizeMul));



		~mixAllFxView2[s].value_(~mixAllFxViewSpec.unmap(~mixAllFxDefault)).doAction;
		~lagTimeAllFxView2[s].valueAction_(~lagTimeAllFxSpec.unmap(~lagTimeAllFxDefault));
		~fadeTimeSynthFxView2[s].valueAction_(~fadeTimeSynthFxSpec.unmap(~fadeTimeSynthFxDefault));



		// Controle Global sur les effets

		// ~fxTabAllComp = CompositeView(~tabFx, Rect(395, 960, 383, 106)).background = ~compFxBackgroundColors[0]; // à supprimer

		~fxTabCompRandMAllView[s] = RoundButton(~fxTabSerieComp[s], Rect(120*~xSizeMul, 4*~ySizeMul, 20*~xSizeMul, 22*~ySizeMul))
		.states_([["M", Color.black, Color.white/*grey*/]])
		.font_(Font("Verdana",12*~fontSizeMul, bold: true))
		.action_({ |a|
			~fxTabCompRandMView[s].do { |i| i.valueAction_(1) };
			/*~fxTabCompRandM2View.do { |i| i.valueAction_(1) };
			~fxTabCompRandM3View.do { |i| i.valueAction_(1) };
			~fxTabCompRandM4View.do { |i| i.valueAction_(1) };*/
		});

		~fxTabCompRandLAllView[s] = RoundButton(~fxTabSerieComp[s], Rect(145*~xSizeMul, 4*~ySizeMul, 20*~xSizeMul, 22*~ySizeMul))
		.states_([["L", Color.black, Color.white/*grey*/]])
		.font_(Font("Verdana",12*~fontSizeMul, bold: true))
		.action_({ |a|
			~fxTabCompRandLView[s].do { |i| i.valueAction_(1) };
			/*~fxTabCompRandL2View.do { |i| i.valueAction_(1) };
			~fxTabCompRandL3View.do { |i| i.valueAction_(1) };
			~fxTabCompRandL4View.do { |i| i.valueAction_(1) };*/
		});

		~fxTabCompRandPAllView[s] = RoundButton(~fxTabSerieComp[s], Rect(170*~xSizeMul, 4*~ySizeMul, 40*~xSizeMul, 22*~ySizeMul))
		.states_([["RP", Color.red, Color.white]])
		.font_(Font("Verdana",12*~fontSizeMul, bold: true))
		.action_({ |a|
			~fxTabCompRandView[s].do { |i| i.valueAction_(1) };
			/*~fxTabCompRand2View.do { |i| i.valueAction_(1) };
			~fxTabCompRand3View.do { |i| i.valueAction_(1) };
			~fxTabCompRand4View.do { |i| i.valueAction_(1) };*/
		});

		~fxTabCompRandAllView[s] = RoundButton(~fxTabSerieComp[s], Rect(215*~xSizeMul, 4*~ySizeMul, 30*~xSizeMul, 22*~ySizeMul))
		.states_([["A", Color.white, Color.blue(0.6)]])
		.font_(Font("Verdana",12*~fontSizeMul, bold: true))
		.action_({ |a|
			~fxTabCompRandA1View[s].do { |i, id| if (i != 0, {i.valueAction_(1)}, {~fxTabCompRand1View[s][id].valueAction_(1)}) };
			~fxTabCompRandA2View[s].do { |i, id| if (i != 0, {i.valueAction_(1)}, {~fxTabCompRand2View[s][id].valueAction_(1)}) };
			~fxTabCompRandA3View[s].do { |i, id| if (i != 0, {i.valueAction_(1)}, {~fxTabCompRand3View[s][id].valueAction_(1)}) };
			~fxTabCompRandA4View[s].do { |i, id| if (i != 0, {i.valueAction_(1)}, {~fxTabCompRand4View[s][id].valueAction_(1)}) };
		});

		~fxTabCompRandHAllView[s] = RoundButton(~fxTabSerieComp[s], Rect(250*~xSizeMul, 4*~ySizeMul, 40*~xSizeMul, 22*~ySizeMul))
		.states_([["RH", Color.white, Color.blue(0.6)]])
		.font_(Font("Verdana",12*~fontSizeMul, bold: true))
		.action_({ |a|
			~fxTabCompRandH1View[s].do { |i| if (i != 0, {i.valueAction_(1)}) };
			~fxTabCompRandH2View[s].do { |i| if (i != 0, {i.valueAction_(1)}) };
			~fxTabCompRandH3View[s].do { |i| if (i != 0, {i.valueAction_(1)}) };
			~fxTabCompRandH4View[s].do { |i| if (i != 0, {i.valueAction_(1)}) };
		});

		~fxTabCompDefAllView[s] = RoundButton(~fxTabSerieComp[s], Rect(295*~xSizeMul, 4*~ySizeMul, 35*~xSizeMul, 22*~ySizeMul))
		.states_([["Def", Color.white, Color.blue]])
		.font_(Font("Verdana",12*~fontSizeMul, bold: true))
		.action_({ |a|
			~fxTabCompDef1View[s].do { |i| i.valueAction_(1) };
			~fxTabCompDef2View[s].do { |i| i.valueAction_(1) };
			~fxTabCompDef3View[s].do { |i| i.valueAction_(1) };
			~fxTabCompDef4View[s].do { |i| i.valueAction_(1) };
			~mixAllFxView2[s].value_(~mixAllFxViewSpec.unmap(-1)).doAction; // .doAction au lieu de .valueAction pour avoir un effet sur les children si le global n'a pas changé
			~lagTimeAllFxView2[s].value_(~lagTimeAllFxSpec.unmap(1)).doAction;
			~fadeTimeSynthFxView2[s].value_(~fadeTimeSynthFxSpec.unmap(1)).doAction;
		});

		~fxMLXDefView[s] = RoundButton(~fxTabSerieComp[s], Rect(335*~xSizeMul, 4*~ySizeMul, 35*~xSizeMul, 22*~ySizeMul))
		.states_([["Def X", Color.white, Color.blue]])
		.font_(Font("Verdana",10*~fontSizeMul, bold: true))
		.action_({ |a|
			~mixAllFxView2[s].value_(~mixAllFxViewSpec.unmap(~mixAllFxDefault)).doAction; // .doAction au lieu de .valueAction pour avoir un effet sur les children si le global n'a pas changé
			~lagTimeAllFxView2[s].value_(~lagTimeAllFxSpec.unmap(~lagTimeAllFxDefault)).doAction;
			~fadeTimeSynthFxView2[s].value_(~fadeTimeSynthFxSpec.unmap(~fadeTimeSynthFxDefault)).doAction;
		}).valueAction_(0);

	};











	// EQ sur les canaux d'effets

	~eqChaFXSynth = {0 ! ~numEffects} ! 2;

	~fxEQViewComp = 0 ! 2;
	~eqChaLoView[8] = 0 ! 2;
	~eqChaMiView[8] = 0 ! 2;
	~eqChaHiView[8] = 0 ! 2;
	~eqChaActivateView[8] = 0 ! 2;
	~eqChaFXDefAllView = 0 ! 2;
	~eqChaFXRandAllView = 0 ! 2;

	~nbOfServers.do { |s|

		~fxEQViewComp[s] = CompositeView(~fxComp[s] /*~globalWindow*/, Rect(2*~xSizeMul, 0, 80*~xSizeMul, 40*~ySizeMul) /*Rect(395, 2, 80, 40)*/).background = Color.black/*~sliderHilightNoColor*/ /*Color.magenta*/;

		~eqChaLoView[8][s] = Knob(~fxEQViewComp[s], Rect(2*~xSizeMul, 1*~ySizeMul, 20*~xSizeMul, 20*~ySizeMul)).mode_(\horiz).centered_(true).color_([Color.red, Color.white, Color.grey, Color.white])
		.action_({ |v| ~eqChaLo[8] = ~eqChaSpec.map(v.value); ~eqChannelUnitLib[s][8].set( \lowShelf, \db, ~eqChaLo[8]);
			if (~eqChaActivate[8] == 1, {
				~numEffects.do { |i|
					if (~eqChaFXSynth[s][i] != 0, { ~eqChaFXSynth[s][i].set(\fadeTime, ~fadeTimeSynthFx[s], \eqSetting, ~eqChannelUnitLib[s][8], \lag, ~lagTimeEQChaFX) });
				};
			})
		})
		.valueAction_(0.5);

		~eqChaMiView[8][s] = Knob(~fxEQViewComp[s], Rect(26*~xSizeMul, 1*~ySizeMul, 20*~xSizeMul, 20*~ySizeMul)).mode_(\horiz).centered_(true).color_([Color.red(0.6), Color.white, Color.grey, Color.white])
		.action_({ |v| ~eqChaMi[8] = ~eqChaSpec.map(v.value); ~eqChannelUnitLib[s][8].set( \peak, \db, ~eqChaMi[8]);
			if (~eqChaActivate[8] == 1, {
				~numEffects.do { |i|
					if (~eqChaFXSynth[s][i] != 0, { ~eqChaFXSynth[s][i].set(\fadeTime, ~fadeTimeSynthFx[s], \eqSetting, ~eqChannelUnitLib[s][8], \lag, ~lagTimeEQChaFX) });
				};
			})
		})
		.valueAction_(0.5);

		~eqChaHiView[8][s] = Knob(~fxEQViewComp[s], Rect(2*~xSizeMul, 21*~ySizeMul, 20*~xSizeMul, 20*~ySizeMul)).mode_(\horiz).centered_(true).color_([Color.blue, Color.white, Color.grey, Color.white])
		.action_({ |v| ~eqChaHi[8] = ~eqChaSpec.map(v.value); ~eqChannelUnitLib[s][8].set( \hiShelf, \db, ~eqChaHi[8]);
			if (~eqChaActivate[8] == 1, {
				~numEffects.do { |i|
					if (~eqChaFXSynth[s][i] != 0, { ~eqChaFXSynth[s][i].set(\fadeTime, ~fadeTimeSynthFx[s], \eqSetting, ~eqChannelUnitLib[s][8], \lag, ~lagTimeEQChaFX) });
				};
			})
		})
		.valueAction_(0.5);
		// envir[readView].palette = envir[readView].palette.button_(Color.yellow);

		~eqChaActivateView[8][s] = RoundButton(~fxEQViewComp[s], Rect(26*~xSizeMul, 22*~ySizeMul, 20*~xSizeMul, 17*~ySizeMul))
		.states_([["FxQ", Color.white, Color.red], ["FxQ", Color.black, Color.green]])
		.font_(Font("Verdana", 9*~fontSizeMul))
		.action_({ |v| var syn;
			~eqChaActivate[8] = v.value;
			if (~eqChaActivate[8] == 1, {
				(~numEffects -1).do { |i|
					if (~fxSelect[s][i] != 0 and: { ~fxInSerieChoose[s][i] == 0 }, {
						syn = if (~fxSynthA[s][i] == 0, { ~fxSynth2[s][i] }, { ~fxSynthA[s][i] } );
						~eqChaFXSynth[s][i] = Synth.before(syn, ~fxSynthDef2Cha[8].name, [\in_bus, ((i+1)*~fxMulChannel)+~fxSeverChannelAdd /*20*/, \fadeTime, ~fadeTimeSynthFx[s], \eqSetting, ~eqChannelUnitLib[s][8]] )
					});
				};
				if (~fxSelect[s].indexOfGreaterThan(0).notNil and: {~fxInSerieChoose[s][3] == 1} or: { ~fxSelect[s][4] != 0 }, {
					syn = if (~fxSynthA[s][4] == 0, { ~fxSynth2[s][4] }, { ~fxSynthA[s][4] } );
					~eqChaFXSynth[s][4] = Synth.before(syn, ~fxSynthDef2Cha[8].name, [\in_bus, (~fxMulChannel*5)+~fxSeverChannelAdd /*100*/, \fadeTime, ~fadeTimeSynthFx[s], \eqSetting, ~eqChannelUnitLib[s][8]] )
				});
			},{
				~numEffects.do { |i|
					if (~eqChaFXSynth[s][i] != 0, {
						~eqChaFXSynth[s][i].set(\fadeTime, ~fadeTimeSynthFx[s]);
						~eqChaFXSynth[s][i].release;
						~eqChaFXSynth[s][i] = 0;
					})
				};
			});
			(~numEffects.collect{ |i| if (~eqChaFXSynth[s][i] != 0, {1}, {0} ) }.sum + "EQ FX Triggered").postln; // indique le nb de EQ FX déclenchées
		});

		~eqChaFXDefAllView[s] = RoundButton(~fxEQViewComp[s], Rect(50*~xSizeMul, 2*~ySizeMul, 27*~xSizeMul, 17*~ySizeMul))
		.states_([["Eq D", Color.white, Color.blue]])
		.font_(Font("Verdana", 9*~fontSizeMul))
		.action_({|i| ~fxTabCompDefEQChaFXView[s].valueAction_(1) });

		~eqChaFXRandAllView[s] = RoundButton(~fxEQViewComp[s], Rect(50*~xSizeMul, 21*~ySizeMul, 27*~xSizeMul, 17*~ySizeMul))
		.states_([["Eq R", Color.white, Color.red]])
		.font_(Font("Verdana", 9*~fontSizeMul))
		.action_({|i| ~fxTabCompRand1EQChaFXView[s].valueAction_(1) });

	};

	~eqChaUpdateAllFunction = { |serverNb| var syn;
		if (~eqChaActivate[8] == 1, {
			(~numEffects -1).do { |i|
				if (~fxSelect[serverNb][i] != 0 and: { ~fxInSerieChoose[serverNb][i] == 0 } and: { ~eqChaFXSynth[serverNb][i] == 0 }, {
					syn = if (~fxSynthA[serverNb][i] == 0, { ~fxSynth2[serverNb][i] }, { ~fxSynthA[serverNb][i] } );
					~eqChaFXSynth[serverNb][i] = Synth.before(syn, ~fxSynthDef2Cha[8].name, [\in_bus, ((i+1)*~fxMulChannel)+~fxSeverChannelAdd /*20*/, \fadeTime, ~fadeTimeSynthFx[serverNb], \eqSetting, ~eqChannelUnitLib[serverNb][8]] );
					("triggering New EQ FX" + (i+1)).postln;
				},{
					if (~fxSelect[serverNb][i] == 0 or: { ~fxInSerieChoose[serverNb][i] == 1 } and: {~eqChaFXSynth[serverNb][i] != 0}, {
						~eqChaFXSynth[serverNb][i].set(\fadeTime, ~fadeTimeSynthFx[serverNb]);
						~eqChaFXSynth[serverNb][i].release;
						~eqChaFXSynth[serverNb][i] = 0;
						("deleting EQ FX" + (i+1)).postln;
					})
				});
			};
			/*
			var a = 2; ~fxSelect[a] == 0 and: { ~fxInSerieChoose[a] == 1 } and: {~eqChaFXSynth[a] != 0}
			~eqChaUpdateFunction.();
			*/
			if (~fxSelect[serverNb].indexOfGreaterThan(0).notNil and: {~fxInSerieChoose[serverNb][3] == 1} or: { ~fxSelect[serverNb][4] != 0 } and: { ~eqChaFXSynth[serverNb][4] == 0 }, {
				syn = if (~fxSynthA[serverNb][4] == 0, { ~fxSynth2[serverNb][4] }, { ~fxSynthA[serverNb][4] } );
				~eqChaFXSynth[serverNb][4] = Synth.before(syn, ~fxSynthDef2Cha[8].name, [\in_bus, (~fxMulChannel*5)+~fxSeverChannelAdd /*100*/, \fadeTime, ~fadeTimeSynthFx[serverNb], \eqSetting, ~eqChannelUnitLib[serverNb][8]] );
				("triggering New EQ FX" + 5).postln;
			},{
				if (~fxSelect[serverNb][4] == 0 and: {~fxInSerieChoose[serverNb][3] != 1} and: {~eqChaFXSynth[serverNb][4] != 0}, {
					~eqChaFXSynth[serverNb][4].set(\fadeTime, ~fadeTimeSynthFx[serverNb]);
					~eqChaFXSynth[serverNb][4].release;
					~eqChaFXSynth[serverNb][4] = 0;
					("deleting EQ FX" + 5).postln;
				})
			});
		});
		// (~numEffects.collect{ |i| if (~eqChaFXSynth[i] != 0, {1}, {0} ) }.sum + "EQ FX Triggered").postln; // indique le nb de EQ FX déclenchées
	};

	~eqChaUpdate1Function = { |tr, serverNb| var syn;
		if (~eqChaActivate[8] == 1, {
			if (~fxSelect[serverNb][tr] != 0 and: { ~fxInSerieChoose[serverNb][tr] == 0 } and: { ~eqChaFXSynth[serverNb][tr] == 0 }, {
				syn = if (~fxSynthA[serverNb][tr] == 0, { ~fxSynth2[serverNb][tr] }, { ~fxSynthA[serverNb][tr] } );
				~eqChaFXSynth[serverNb][tr] = Synth.before(syn, ~fxSynthDef2Cha[8].name, [\in_bus, ((tr+1)*~fxMulChannel)+~fxSeverChannelAdd /*20*/, \fadeTime, ~fadeTimeSynthFx[serverNb], \eqSetting, ~eqChannelUnitLib[serverNb][8]] );
				("triggering New EQ FX" + (tr+1)).postln;
			},{
				if (~fxSelect[serverNb][tr] == 0 or: { ~fxInSerieChoose[serverNb][tr] == 1 } and:{ tr != 4 } and: {~eqChaFXSynth[serverNb][tr] != 0}, {
					~eqChaFXSynth[serverNb][tr].set(\fadeTime, ~fadeTimeSynthFx[serverNb]);
					~eqChaFXSynth[serverNb][tr].release;
					~eqChaFXSynth[serverNb][tr] = 0;
					("deleting EQ FX" + (tr+1)).postln;
				})
			});
			if (~fxSelect[serverNb].indexOfGreaterThan(0).notNil and: {~fxInSerieChoose[serverNb][3] == 1} or: { ~fxSelect[4] != 0 } and: { ~eqChaFXSynth[serverNb][4] == 0 }, {
				syn = if (~fxSynthA[serverNb][4] == 0, { ~fxSynth2[serverNb][4] }, { ~fxSynthA[serverNb][4] } );
				~eqChaFXSynth[serverNb][4] = Synth.before(syn, ~fxSynthDef2Cha[8].name, [\in_bus, (~fxMulChannel*5)+~fxSeverChannelAdd /*100*/, \fadeTime, ~fadeTimeSynthFx[serverNb], \eqSetting, ~eqChannelUnitLib[serverNb][8]] );
				("triggering New EQ FX" + 5).postln;
			},{
				if (~fxSelect[serverNb][4] == 0 and: {~fxInSerieChoose[serverNb][3] != 1} and: {~eqChaFXSynth[serverNb][4] != 0}, {
					~eqChaFXSynth[serverNb][4].set(\fadeTime, ~fadeTimeSynthFx[serverNb]);
					~eqChaFXSynth[serverNb][4].release;
					~eqChaFXSynth[serverNb][4] = 0;
					("deleting EQ FX" + 5).postln;
				})
			});
		});
	};


}.value;





























{

	( // Quark AutomationGui

		~automationLoad = {

			if (~automation.notNil, {~automationWindow.close});

			~automationWindow = Window(border:false, bounds:Rect(/*720 + ~windowWidth - 1920*/ /*~windowWidth - ((604+600)*~xSizeMul)*/ /*350*/ ~windowWidth-(1605*~xSizeMul), /*1125 + ~windowHeight - 1200*/ 0, 604*~xSizeMul, 30*~ySizeMul)).background_(Color.black).alwaysOnTop_(true).front;
			WindowHandleView(~automationWindow, Rect(0, 0, 602*~xSizeMul, 5*~ySizeMul));
			~automation = Automation(/*30*/).front(~automationWindow, bounds: Rect(2*~xSizeMul, 5*~ySizeMul, 600*~xSizeMul, 22*~ySizeMul));
			~automation.onPlay = 0;
			// ~automation.verbose = false; // ne retire pas Unknown GUI value kind: Array for SmoothRangeSlider de toute façon
			// ~automationWindow.view.children.do { |i| i.canFocus = false; /*i./*view.*/focus(false);*/ }; // pour retirer le focus de tous
			~automationWindow.view.children.last.canFocus = false; // mais juste besoin de retirer le focus du slider car certaines touches
			~automationWindow.view./*global*/keyDownAction_(~keyActions);
			// AutomationClient ???

			(
				// AutomationGui -> Assignation des éléments de la GUI -> This can be done automatically:
				// control.findAndDock(win.view.children);
				// ...or manually with specific names for safer save/load filenames:
				// control.dock(button, "theButton");

				// ne sont pas assignés :
				// - les Rand routines des FX spectraux ou autres éléments des pages FX
				// - les focus sur les Tabbed View (global, FX & Preset)
				// - les éléments Ordre et Durée pour chaque séquence (modifiées par le Preset Slider -> ~presetVarsSliderView)
				// - le changement de piste A & B dans la vue globale
				// - les manipulations de volume (line & sine)
				// - les éléments de la séquence

				// ~automation.dock(~fxTabbedView, "FxTabbedView"); // ne marche pas - Comment intégrer les focus sur les TabbedView ????????? // ~fxTabbedView.focus(0)
				// AutomationClient(~currentServerTab, {~fxTabbedView.focus(~currentServerTab)}.(), "1")

				~automationStringList = ["1A", "1B", "2A", "2B", "3A", "3B", "4A", "4B", "5A", "5B", "6A", "6B", "7A", "7B", "8A", "8B"];
				~automationStringTrList = ["1", "2", "3", "4", "5", "6", "7", "8"];

				// Eléments de la View Séquence
				~automation.dock(~gblSeqView, "GblSeqView");
				~automation.dock(~gblSeqIndexView, "GblSeqIndexView");

				// Eléments du Top View
				// ~automation.dock(~fxTabbedView, "FxTabbedView"); // ne marche pas - Comment intégrer les focus sur les TabbedView ????????? // ~fxTabbedView.focus(0)
				~automation.dock(~keyControlView, "KeyControlView");
				~automation.dock(~fxServerSwitchView, "FxServerSwitchView");
				~automation.dock(~trigAllView, "TrigAllView");
				~automation.dock(~controlBusSynth5FadeTimeView, "ControlBusSynth5FadeTimeView");
				~automation.dock(~controlBusTypeArgView, "ControlBusTypeArgView");
				~automation.dock(~controlRandFuncView, "ControlRandFuncView");
				~automation.dock(~controlBusTypeSignView, "ControlBusTypeSignView");

				~automation.dock(~nbEventView, "NbEventView");
				~automation.dock(~curEventTrigView, "CurEventTrigView");
				~automation.dock(~lastEventTrigView, "LastEventTrigView");
				~automation.dock(~curSeqTrigView, "CurSeqTrigView");
				~automation.dock(~updatePresetSelectionView, "UpdatePresetSelectionView");
				~automation.dock(~readTypeView, "ReadTypeView");

				~eqChaLoView[8].do { |it, i| ~automation.dock(~eqChaLoView[8][i], "EqChaLoViewFX"++i); };
				~eqChaMiView[8].do { |it, i| ~automation.dock(~eqChaMiView[8][i], "EqChaMiViewFX"++i); };
				~eqChaHiView[8].do { |it, i| ~automation.dock(~eqChaHiView[8][i], "EqChaHiViewFX"++i); };
				~eqChaActivateView[8].do { |it, i| ~automation.dock(~eqChaActivateView[8][i], "EqChaActivateViewFX"++i); };
				~eqChaFXDefAllView.do { |it, i| ~automation.dock(~eqChaFXDefAllView[i], "EqChaFXDefAllViewFX"++i); };
				~eqChaFXRandAllView.do { |it, i| ~automation.dock(~eqChaFXRandAllView[i], "EqChaFXRandAllViewFX"++i); };

				2.do { |s| 5.do { |i| ~automation.dock(~fxSelectView[s][i], "FxSelectView"++s++i); }};
				2.do { |s| 5.do { |i| ~automation.dock(~fxDefaultView[s][i], "FxDefaultView"++s++i); }};
				2.do { |s| 5.do { |i| ~automation.dock(~fxRandView[s][i], "FxRandView"++s++i); }};
				2.do { |s| 5.do { |i| ~automation.dock(~fxRandParametersView[s][i], "FxRandParametersView"++s++i); }};
				if ( ~hpModulation == 1, { ~fxDefaultAllView.do { |it, i| ~automation.dock(~fxDefaultAllView[i], "FxDefaultAllView"++i) }; }); /*RHP*/
				~fxInSerieChooseAllButtonView.do { |it, i| ~automation.dock(~fxInSerieChooseAllButtonView[i], "FxInSerieChooseAllButtonView"++i) }; // Par / Ser
				~fxInSerieChoose2AllButtonView.do { |it, i| ~automation.dock(~fxInSerieChoose2AllButtonView[i], "FxInSerieChoose2AllButtonView"++i) }; // Par / Ser

				~fxRandLParametersAllView.do { |it, i| ~automation.dock(~fxRandLParametersAllView[i], "FxRandLParametersAllView"++i) };
				~fxRandMParametersAllView.do { |it, i| ~automation.dock(~fxRandMParametersAllView[i], "FxRandMParametersAllView"++i) };
				~lagMixSwitchView.do { |it, i| ~automation.dock(~lagMixSwitchView[i], "LagMixSwitchView"++i) };
				~mixAllFxView2.do { |it, i| ~automation.dock(~mixAllFxView2[i], "MixAllFxView2"++i) };
				~lagTimeAllFxView2.do { |it, i| ~automation.dock(~lagTimeAllFxView2[i], "LagTimeAllFxView2"++i) };
				~fadeTimeSynthFxView2.do { |it, i| ~automation.dock(~fadeTimeSynthFxView2[i], "FadeTimeSynthFxView2"++i) };
				~mixFXTriggerView.do { |it, i| ~automation.dock(~mixFXTriggerView[i], "MixFXTriggerView"++i) };
				~fxTimePresetView.do { |it, i| ~automation.dock(~fxTimePresetView[i], "FxTimePresetView"++i) };

				// Ambisonique Top
				2.do { |s| 5.do { |i| ~automation.dock(~fxASelectView[s][i], "FxASelectView"++s++i); }};
				2.do { |s| 5.do { |i| ~automation.dock(~fxADefaultView[s][i], "FxADefaultView"++s++i); }};
				2.do { |s| 5.do { |i| ~automation.dock(~fxARandView[s][i], "FxARandView"++s++i); }};
				2.do { |s| 5.do { |i| ~automation.dock(~fxARandParametersView[s][i], "FxARandParametersView"++s++i); }};
				// ~fxARandAllView // pas necessaire puisqu'action sur ~fxARandView
				// ~fxARandParametersAllView // pas necessaire puisqu'action sur ~fxARandParametersView
				// ~fxADefaultAllView // pas necessaire puisqu'action sur ~fxASelectView
				// ~fxADefaultAll2View // pas necessaire puisqu'action sur ~fxASelectView

				// Ambisonique Tab FX Amb bas
				~fxATabCompRandAllView.do { |it, i| ~automation.dock(~fxATabCompRandAllView[i], "FxATabCompRandAllView"++i) };
				~fxATabCompDefAllView.do { |it, i| ~automation.dock(~fxATabCompDefAllView[i], "FxATabCompDefAllView"++i) };
				~fxAMLXDefView.do { |it, i| ~automation.dock(~fxAMLXDefView[i], "FxAMLXDefView"++i) };
				~lagTimeAllFxAView.do { |it, i| ~automation.dock(~lagTimeAllFxAView[i], "LagTimeAllFxAView"++i) };
				~angleAllFxAView.do { |it, i| ~automation.dock(~angleAllFxAView[i], "AngleAllFxAView"++i) };
				~elevAllFxAView.do { |it, i| ~automation.dock(~elevAllFxAView[i], "ElevAllFxAView"++i) };
				~mulAllFxAView.do { |it, i| ~automation.dock(~mulAllFxAView[i], "MulAllFxAView"++i) };
				~distMinAllFxAView.do { |it, i| ~automation.dock(~distMinAllFxAView[i], "DistMinAllFxAView"++i) };

				// Eléments du Global View
				~automationStringList.do { |it, i| ~automation.dock(~presetSeqRangeViewG[i], "PresetSeqRangeViewG"++it); }; // On ne voit pas les séquences changer si elles ne sont pas visibles dans la vue globale
				~automationStringList.do { |it, i| ~automation.dock(~positionRandSeqViewG[i], "PositionRandSeqViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~xqViewG[i], "XqViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~playViewG[i], "PlayViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~play2ViewG[i], "Play2ViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~retriggerPresetViewG[i], "RetriggerPresetViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~retriggerPreset1ViewG[i], "RetriggerPreset1ViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~retriggerPresetPreViewG[i], "RetriggerPresetPreViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~folRandViewG[i], "FolRandViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~ratRandViewG[i], "RatRandViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~strRandViewG[i], "StrRandViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~bufRandViewG[i], "BufRandViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~offRandViewG[i], "OffRandViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~spaRandViewG[i], "SpaRandViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~outRandViewG[i], "OutRandViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~pFadeViewG[i], "PFadeViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~quantViewG[i], "QuantViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~spaRangePresetViewG[i], "SpaRangePresetViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~spaPatSelViewG[i], "SpaPatSelViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~spaPatViewG[i], "SpaPatViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~panRangePresetViewG[i], "PanRangePresetViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~bufFolderViewG[i], "BufFolderViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~rtmMulViewG[i], "RtmMulViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~proPatViewG[i], "ProPatViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~proBjorViewG[i], "ProBjorViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~proBjor2ViewG[i], "ProBjor2ViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~proSelectViewG[i], "ProSelectViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~proMulViewG[i], "ProMulViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~ratMulViewG[i], "RatMulViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~legMulViewG[i], "LegMulViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~strMulViewG[i], "StrMulViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~cenMulViewG[i], "CenMulViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~bufMulViewG[i], "BufMulViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~offMulViewG[i], "OffMulViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~triggerAllSeqsViewG[i], "TriggerAllSeqsViewG"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~seqChangeViewG[i], "SeqChangeViewG"++it); };

				// Eléments du Control Panel - Volume & Pistes
				~automation.dock(~trackInVolView, "TrackInVolView");
				~automation.dock(~trackFXVolView, "TrackFXVolView");
				~automation.dock(~trackAllVolView, "TrackAllVolView");

				~automation.dock(~tracksView, "TracksView"); // Pas d'automatisation du changement de piste A & B dans la vue globale
				~automationStringList.do { |it, i| ~automation.dock(~xqControlView[i], "XqControlView"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~playControlView[i], "PlayControlView"++it); };
				~automationStringList.do { |it, i| ~automation.dock(~play2ControlView[i], "Play2ControlView"++it); };
				~automationStringTrList.do { |it, i| ~automation.dock(~multiStereoControlView[i], "MultiStereoControlView"++it); };
				~automationStringTrList.do { |it, i| ~automation.dock(~outsConfigControlView[i], "OutsConfigControlView"++it); };
				~automationStringTrList.do { |it, i| ~automation.dock(~trackVolView[i], "TrackVolView"++it); };
				~automationStringTrList.do { |it, i| ~automation.dock(~fxSelControlView[i], "FxSelControlView"++it); };
				~automationStringTrList.do { |it, i| ~automation.dock(~eqChaLoView[i], "EqChaLoView"++it); };
				~automationStringTrList.do { |it, i| ~automation.dock(~eqChaMiView[i], "EqChaMiView"++it); };
				~automationStringTrList.do { |it, i| ~automation.dock(~eqChaHiView[i], "EqChaHiView"++it); };
				~automationStringTrList.do { |it, i| ~automation.dock(~eqChaActivateView[i], "EqChaActivateView"++it); };

				// A voir si intégrer les manipulations de volume ???
				// ~freqVolView, ~durVolView, ~ampVolView ~toVolView, ~sineControlView, ~lineControlView

				// Eléments du Control Panel - Pistes rythmiques
				~automation.dock(~presetVarsVolFocusView, "PresetVarsVolFocusView");
				// ~defaultPresetVarsMenu // pas necessaire puisqu'action sur ~presetVarsSpaTimeRandSlider & ~presetVarsRatTimeRandSlider
				~automation.dock(~triggerSpaSeqsView, "TriggerSpaSeqsView");
				~automation.dock(~multiStereoRyView, "MultiStereoRyView");
				~automation.dock(~folderRyRandView, "FolderRyRandView");
				// ~folRandViewRy // pas necessaire puisqu'action sur ~folRandViewG
				// ~retriggerPresetViewRy // pas necessaire puisqu'action sur ~retriggerPresetViewG
				~automation.dock(~presetVarsVol2SliderView, "PresetVarsVol2SliderView"); // même si action sur ~trackVolView
				~automation.dock(~presetVarsVolSliderView, "PresetVarsVolSliderView"); // même si action sur ~trackVolView
				~automation.dock(~multiStereoRandRy1View, "MultiStereoRandRy1View");
				~automation.dock(~multiStereoRandRy2View, "MultiStereoRandRy2View");
				~automation.dock(~multiStereoRandRy3View, "MultiStereoRandRy3View");
				~automation.dock(~multiStereoRandRy4View, "MultiStereoRandRy4View");
				~automation.dock(~multiStereoRandRy5View, "MultiStereoRandRy5View");
				~automation.dock(~multiStereoRandRy6View, "MultiStereoRandRy6View");
				~automation.dock(~multiStereoRandRy7View, "MultiStereoRandRy7View");
				~automation.dock(~multiStereoRandRy8View, "MultiStereoRandRy8View");
				~automation.dock(~multiStereoRandRy9View, "MultiStereoRandRy9View");
				~automation.dock(~multiStereoRandRy10View, "MultiStereoRandRy10View");

				if (~acousItems.notNil, {
					~automation.dock(~multiStereoRandRy1AcView, "MultiStereoRandRy1AcView");
					~automation.dock(~multiStereoRandRy2AcView, "MultiStereoRandRy2AcView");
					~automation.dock(~multiStereoRandRy3AcView, "MultiStereoRandRy3AcView");
					~automation.dock(~multiStereoRandRy4AcView, "MultiStereoRandRy4AcView");
					~automation.dock(~multiStereoRandRy5AcView, "MultiStereoRandRy5AcView");
					~automation.dock(~multiStereoRandRy6AcView, "MultiStereoRandRy6AcView");
					~automation.dock(~multiStereoRandRy7AcView, "MultiStereoRandRy7AcView");
					~automation.dock(~multiStereoRandRy8AcView, "MultiStereoRandRy8AcView");
					~automation.dock(~multiStereoRandRy9AcView, "MultiStereoRandRy9AcView");
					~automation.dock(~multiStereoRandRy10AcView, "MultiStereoRandRy10AcView");
					~automation.dock(~multiStereoRandRy11AcView, "MultiStereoRandRy11AcView");
					~automation.dock(~multiStereoRandRy12AcView, "MultiStereoRandRy12AcView");
					~automation.dock(~multiStereoRandRy13AcView, "MultiStereoRandRy13AcView");
					~automation.dock(~multiStereoRandRy14AcView, "MultiStereoRandRy14AcView");
					~automation.dock(~multiStereoRandRy15AcView, "MultiStereoRandRy15AcView");
					~automation.dock(~multiStereoRandRy16AcView, "MultiStereoRandRy16AcView");
					~automation.dock(~acousTypeSensView, "AcousTypeSensView");
					~automation.dock(~multiStereoRandRyAc1View, "MultiStereoRandRyAc1View");
					~automation.dock(~multiStereoRandRyAcView, "MultiStereoRandRyAcView");
					~automation.dock(~multiStereoRandRyMView, "MultiStereoRandRyMView");
					~automation.dock(~multiStereoRandRy3EView, "MultiStereoRandRy3EView");
					~automation.dock(~multiStereoRandRyALLView, "MultiStereoRandRyALLView");
				},{
					~automation.dock(~multiStereoRandRyMView, "MultiStereoRandRyMView");
					~automation.dock(~multiStereoRandRy16AcView, "MultiStereoRandRy16AcView");
				});

				~automation.dock(~multiStereoRandRyRout2View, "MultiStereoRandRyRout2View");
				~automation.dock(~stereoRandSelectView, "StereoRandSelectView");
				~automation.dock(~multiStereoRandRyRoutView, "MultiStereoRandRyRoutView");
				~automation.dock(~spaRoutTypeView, "SpaRoutTypeView");
				~automation.dock(~rySpaTypeTrackView, "RySpaTypeTrackView");
				~automation.dock(~multiStereoPanDefView, "MultiStereoPanDefView");
				~automation.dock(~multiStereoSwapView, "MultiStereoSwapView");
				~automation.dock(~presetVarsSpaTimeRandSlider, "PresetVarsSpaTimeRandSlider");
				~automation.dock(~presetVarsRatTimeRandSlider, "PresetVarsRatTimeRandSlider");
				~automation.dock(~presetVarsSpa1SwitchSlider, "PresetVarsSpa1SwitchSlider"); // même si agit sur des éléments déjà enregistrés
				~automation.dock(~presetRatSwitchView, "PresetRatSwitchView");
				~automation.dock(~presetRatSwitch2View, "PresetRatSwitch2View");
				~automation.dock(~presetRatRoutView, "PresetRatRoutView");
				~automation.dock(~presetVarsRatSliderView, "PresetVarsRatSliderView");

				// Eléments du Control Panel - Rat sur les bus non intégré XXX
				~automation.dock(~toTempoView, "ToTempoView");
				~automation.dock(~toSecView, "ToSecView");
				~automation.dock(~doNextTempo, "DoNextTempo");

		)};

		if (~automationActive == 1, {~automationLoad.()});

	);

}.value;





























// Pour l'instant suppression de l'interaction avec le clavier mais objectif de le supprimer seulement lorsque mod.isCaps
// Problème car capslock n'a aucune action lorsque déselectionné ??????

/*
Post << w.view.children // éléments GUI dans w
w.view.children[0].children // éléments GUI dans le TabbedView
w.view.children[0].children // éléments GUI dans le TabbedView
w.view.children[0].children[1].children // éléments GUI dans le TabbedView
w.view.children[0].children[1].children // éléments GUI dans le TabbedView

w.view.children[0].children[1].children.do { |i| i.visible = false } // Affichage ou non éléments GUI rééls dans le TabbedView
w.view.children[0].children[1].children.do { |i| i.visible = true } // Affichage ou non éléments GUI rééls dans le TabbedView

w.view.children[0].children[1].children[0].children.do { |i| i.visible = false } // Affichage ou non éléments GUI rééls de chaque ComositeView dans le TabbedView
w.view.children[0].children[1].children[0].children.do { |i| i.visible = true } // Affichage ou non éléments GUI rééls de chaque ComositeView dans le TabbedView

Window.allWindows[0].view
*/

// trop fastidieux de récupérer touts les éléments de la GUI pour sélectionner que les PopUpMenus ???
// préférable de les spécifier directement



// Comment faire pour que même avec la sélection d'un PopUpMenu, il ne déclenche pas les KeyActions lorsque mod.isCaps (voire à la fin du code de la GUI) ?????????
/*
PopUpMenu.defaultKeyDownAction
~bufMulPresetView.defaultKeyDownAction
~bufMulPresetView.focus(flag: false);
~bufMulPresetView.hasFocus
~bufMulPresetView.canFocus = true
~bufMulPresetView.focusColor = Color.clear
*/


/*~tracksView.canFocus = false;
~seqsView.canFocus = false;
~bufFolderView.canFocus = false;
~presetSelectionView.canFocus = false;
~cpuStopView.canFocus = false;
~aliveThreadPeriodView.canFocus = false;
~spaRangePresetView.canFocus = false;
[~outsConfigControlView, ~outsConfigView].flat.do {|i| i.canFocus = false};*/


{

	// Fonction pour une action sur tous les PopUpMenus -> action ou non des touches du clavier sur les PopUpMenus ???, PopUpTreeMenus & ListView & EZSliders empêchant ou non des actions globales
	~disableFocusPopUpMenu = { |focus|
		[
			~tracksView, ~seqsView, if ( ~presetsFileName2.isNil, {~presetSelectionView},{ [~presetSelectionView, ~presetSelection2View] }), ~selectBeatView,
			// Problème avec le PopUpTreeMenu ~selectBeatView car désélectionne la fenêtre w ??????

			~outsConfigControlView /*x tracks*/, ~outsConfigView, ~configBeatsView, ~presetSortView, ~cpuStopView, ~aliveThreadPeriodView, ~nbOfServers.collect {|s| ~fxSelectView[s]}, ~presetRandomTypeView, ~fxSelControlView, ~fxSelAllControlView, ~nbOfServers.collect {|s| ~fxASelectView[s]},

			~nbOfServers.collect {|s| ~fxSynthDef5SwitchTypView[s]}, ~nbOfServers.collect {|s| ~fxSynthDef6SwitchTypView[s]}, ~nbOfServers.collect {|s| ~fxSynthDef7SwitchTypView[s]}, ~nbOfServers.collect {|s| ~fxSynthDef8SwitchTypView[s]},
			~nbOfServers.collect {|s| ~fxSynthDef7SwitchTypPCView[s]}, ~nbOfServers.collect {|s| ~fxSynthDef8SwitchTypPCView[s]}, ~nbOfServers.collect {|s| ~fxSynthDef8SwitchRevView[s]},

			~rtmMulPresetView, ~proMulPresetView, ~synMulPresetView, ~spaMulPresetView, ~legMulPresetView, ~envMulPresetView, ~bufMulPresetView, ~offMulPresetView, ~off2MulPresetView, ~off3MulPresetView, ~off4MulPresetView, ~ratMulPresetView, ~ampMulPresetView, ~strMulPresetView, ~cenMulPresetView, ~panMulPresetView, ~outLMulPresetView, ~outRMulPresetView, ~fxLMulPresetView, ~fxRMulPresetView, ~rat2MulPresetView, ~str2MulPresetView, ~cen2MulPresetView, ~delMulPresetView,

			~rtmRoundView, ~proRoundView, ~synRoundView, ~spaRoundView, ~legRoundView, ~envRoundView, ~bufFolderView, ~offRoundView, ~off2RoundView, ~off3RoundView, ~off4RoundView, ~ratRoundView, ~ampRoundView, ~strRoundView, ~cenRoundView, ~panRoundView, ~outLRoundView, ~outRRoundView, ~fxLRoundView, ~fxRRoundView, ~rat2RoundView, ~str2RoundView, ~cen2RoundView, ~delRoundView,

			~bufFolderViewG,

			~rtmRangePresetView, ~proRangePresetView, ~synRangePresetView, ~spaRangePresetView, ~legRangePresetView, ~envRangePresetView, ~bufRangePresetView, ~offRangePresetView, ~off2RangePresetView, ~off3RangePresetView, ~off4RangePresetView, ~ratRangePresetView, ~ampRangePresetView, ~strRangePresetView, ~cenRangePresetView, ~panRangePresetView, ~outLRangePresetView, ~outRRangePresetView, ~fxLRangePresetView, ~fxRRangePresetView, ~rat2RangePresetView,  ~str2RangePresetView, ~cen2RangePresetView, ~delRangePresetView,

			~rtmPatSelView, ~proPatSelView, ~synPatSelView, ~spaPatSelView, ~legPatSelView, ~envPatSelView, ~bufPatSelView, ~offPatSelView, ~off2PatSelView, ~off3PatSelView, ~off4PatSelView, ~ratPatSelView, ~ampPatSelView, ~strPatSelView, ~cenPatSelView, ~panPatSelView, ~outLPatSelView, ~outRPatSelView, ~fxLPatSelView, ~fxRPatSelView, ~rat2PatSelView, ~str2PatSelView, ~cen2PatSelView, ~delPatSelView,

			~spaRangePresetViewG, ~panRangePresetViewG, ~rtmMulPresetViewG, ~legMulPresetViewG, ~presetSeqVisuViewG,

			// Vue des modules de détail de :
			// BUF :
			~delFolderOfSoundsView, ~addFolderOfSoundsView, ~folderOfSoundsSizeView, ~grainSizeView.sliderView, ~grain2SizeView.sliderView, ~lehmerInit1View.sliderView, ~lehmerA1View.sliderView, ~lehmerB1View.sliderView, ~lehmerInit2View.sliderView, ~lehmerA2View.sliderView, ~lehmerB2View.sliderView, ~lehmerReInit1View, ~lehmerReInit2View,
			// ENV :
			~atkView[0].sliderView, ~atkView[1].sliderView, ~relView[0].sliderView, ~relView[1].sliderView, ~atkCurveView[0].sliderView, ~atkCurveView[1].sliderView, ~relCurveView[0].sliderView, ~relCurveView[1].sliderView, 			~w1View.sliderView, ~w2View.sliderView, ~envPlotShowView, // selon ~envNum
			// SPA (Dans le CompositeView de spatialisation 2) :
			~spaRangePresetItemsLV1Buttons, ~spaRangePresetItemsLV2Buttons, ~spaRangePresetItemsLV3Buttons, ~spaRangePresetItemsLV4Buttons,
			~stereoSpatTypeView, /*~spaRangePresetItemsListView,*/ ~trajSpatTimeTypeView, ~trajSpatTypeView, ~circSpatTypeView, ~sdSpatTypeView,
			// MUL / miroirs :
			~dbRollOffView.sliderView, /*~virtualMSpatTypeRandView, ~virtualMSpatTypeDefView,*/ ~speakRadView.sliderView, ~orientationView.sliderView, ~vmPointScaleView.sliderView, ~ambPointScaleView.sliderView, ~vbPointScaleView.sliderView, ~vbapSpreadView.sliderView, ~vbapX2OffView.sliderView, ~circSpreadView.sliderView, ~circSpeedRangeView.rangeSlider, ~spec2spaCurveView.sliderView, ~trajSpatTimeTypeView, /*ListView*/ /*~trajSpatLoopView,*/ ~trajSpatRateView.sliderView, ~spaLagTimeView.sliderView, ~spaLagCurveView.sliderView, ~sdFreqRangeView.rangeSlider, ~sdDbRangeView.rangeSlider,
			// ~nbEventView.sliderView, // plus nécessaire - transformé en EZNumber
			~grainSizeView.sliderView, ~grain2SizeView.sliderView, ~lehmerInit1View.sliderView, ~lehmerA1View.sliderView, ~lehmerB1View.sliderView, ~lehmerInit2View.sliderView, ~lehmerA2View.sliderView, ~lehmerB2View.sliderView,
			~nbOfServers.collect {|s| ~fxSynthDefViews[s].asArray.collect { |i| i.sliderView }}, ~nbOfServers.collect {|s| ~mixAllFxView[s].sliderView}, ~nbOfServers.collect {|s| ~lagTimeAllFxView[s].sliderView}, ~nbOfServers.collect {|s| ~fadeTimeSynthFxView[s].sliderView}, // ~fxSynthDefViews.flatten(2) // Pour les EZSlider aussi
			~outLHarSpatTypeView, ~outRHarSpatTypeView,

			// ~nbOfServers.collect { |s| ~fxSynthDefViews[s].asArray.collect { |i| i.sliderView } };


			// CompositeView des effets spectraux // pourquoi des boutons ???
			~nbOfServers.collect {|s| ~fftEQCompChooseView[s]}, ~nbOfServers.collect {|s| ~fftEQBufChooseView[s]}, ~nbOfServers.collect {|s| ~fftEQ0View[s]}, ~nbOfServers.collect {|s| ~fftEQClearView[s]}, ~nbOfServers.collect {|s| ~fftEQRandSlView[s]}, ~nbOfServers.collect {|s| ~fftEQRandBinView[s]}, ~nbOfServers.collect {|s| ~fftEQFreqIntervalsReduceChooseView[s]},
			~nbOfServers.collect {|s| ~fftDelCompChooseView[s]}, ~nbOfServers.collect {|s| ~fftDelChooseCompView[s]}, ~nbOfServers.collect {|s| ~fftDelBufChooseView[s]}, ~nbOfServers.collect {|s| ~fftDel0View[s]}, ~nbOfServers.collect {|s| ~fftDelClearView[s]}, ~nbOfServers.collect {|s| ~fftDelRandSlView[s]}, ~nbOfServers.collect {|s| ~fftDelRandBinView[s]}, ~nbOfServers.collect {|s| ~fftDelFreqIntervalsReduceChooseView[s]},
			~nbOfServers.collect {|s| ~fftOutCompChooseView[s]}, ~nbOfServers.collect {|s| ~fftOutPanChooseView[s]}, ~nbOfServers.collect {|s| ~fftOutBufChooseView[s]}, ~nbOfServers.collect {|s| ~fftOut0View[s]}, ~nbOfServers.collect {|s| ~fftOutClearView[s]}, ~nbOfServers.collect {|s| ~fftOutRandSlView[s]}, ~nbOfServers.collect {|s| ~fftOutRandBinView[s]}, ~nbOfServers.collect {|s| ~fftOutFreqIntervalsReduceChooseView[s]},

			// Dans le Tab d'effets
			~nbOfServers.collect {|s| ~fxInSerieListView[s]},

			~rySpaTypeTrackView, if (~acousItems.notNil, {~acousTypeSensView}, {~rySpaTypeTrackView}), // ListView

			~proDrumTypeView

		].flatten(2).do {|i| i.canFocus = focus; i.focus(false); /*pour désélectionner le dernier*/
			// i.acceptsMouseOver = focus; i.mouseOverAction = {};
		};
	};

	~disableFocusPopUpMenu.(false);
	// ~disableFocusPopUpMenu.(true);



	~disableFocusSmoothSlider = {  |focus|
		[~trackAllVolView, ~trackInVolView, ~trackFXVolView, ~trackVolView,
			~toTempoView, ~toSecView, ~gblSeqIndexView, ~gblSeqView, ~nbTotalBeatsView,
			~seqIndexView, ~harIndexView, ~nbEventView,
			~proBjorView, ~proBjor2View, ~proBjor3View, ~proBjor4View, ~proWeightView, ~offRateSecondBufView, ~ampRatView, ~aAmpView, ~offThreshView, ~freqRatView, ~fAmpView, ~psPitchDispersView, ~psTimeDispersView, ~psWindowSizeView, ~pAmpView, ~panRatView,
			~pFadeView, ~pFadeViewG, ~quantView, ~quantViewG,
			// ~mixAllFxView2[0], ~lagTimeAllFxView2[0], ~fadeTimeSynthFxView2[0], ~nbOfServers.collect {|s|
			~nbOfServers.collect {|s| ~mixAllFxView2[s]}, ~nbOfServers.collect {|s| ~lagTimeAllFxView2[s]}, ~nbOfServers.collect {|s| ~fadeTimeSynthFxView2[s]},
			~presetSeqRangeView, ~presetSeqRangeViewG,
			~rtmRangeView, ~proRangeView, ~synRangeView, ~spaRangeView, ~legRangeView, ~envRangeView, ~bufRangeView, ~offRangeView, ~off2RangeView, ~off3RangeView, ~off4RangeView, ~ratRangeView, ~ampRangeView, ~strRangeView, ~cenRangeView, ~panRangeView, ~outLRangeView, ~outRRangeView, ~fxLRangeView, ~fxRRangeView, ~rat2RangeView,  ~str2RangeView, ~cen2RangeView, ~delRangeView,
			~rtmSeqView, ~proSeqView, ~synSeqView, ~spaSeqView, ~legSeqView, ~envSeqView, ~bufSeqView, ~offSeqView, ~off2SeqView, ~off3SeqView, ~off4SeqView, ~ratSeqView, ~ampSeqView, ~strSeqView, ~cenSeqView, ~panSeqView, ~outLSeqView, ~outRSeqView, ~fxLSeqView, ~fxRSeqView, ~rat2SeqView,  ~str2SeqView, ~cen2SeqView, ~delSeqView,
			~rtmIndexView, ~proIndexView, ~synIndexView, ~spaIndexView, ~legIndexView, ~envIndexView, ~bufIndexView, ~offIndexView, ~off2IndexView, ~off3IndexView, ~off4IndexView, ~ratIndexView, ~ampIndexView, ~strIndexView, ~cenIndexView, ~panIndexView, ~outLIndexView, ~outRIndexView, ~fxLIndexView, ~fxRIndexView, ~rat2IndexView,  ~str2IndexView, ~cen2IndexView, ~delIndexView,
			~rtmMulView, ~proMulView, ~synMulView, ~spaMulView, ~legMulView, ~envMulView, ~bufMulView, ~offMulView, ~off2MulView, ~off3MulView, ~off4MulView, ~ratMulView, ~ampMulView, ~strMulView, ~cenMulView, ~panMulView, ~outLMulView, ~outRMulView, ~fxLMulView, ~fxRMulView, ~rat2MulView, ~str2MulView, ~cen2MulView, ~delMulView,
			~rtmMulViewG, ~proMulViewG,  ~proBjorViewG, ~proBjor2ViewG, ~legMulViewG, ~ratMulViewG, ~strMulViewG, ~cenMulViewG, ~bufMulViewG, ~offMulViewG,
			~presetVarsVolSliderView, ~presetVarsVol2SliderView, ~presetVarsSpa1SwitchSlider, ~presetVarsSpaTimeRandSlider, ~presetVarsRatSliderView, ~presetVarsRatTimeRandSlider, ~presetVarsSliderView,
			~presetVarsChangeView
		].flat.do {|i| i.view.canFocus = focus; i.view.focus(focus/*false*/) /*pour désélectionner le dernier*/ };
	};

	~disableFocusSmoothSlider.(false);



	// délenche l'update de la main View incluant les effets, donc doit être en dernier - A étudier ??????
	// Plus nécessaire de mettre ~visuelLocView.valueAction_(1); en dernier car l'update incluant les effets a été supprimé puisqu'ils sont globaux
	// ~visuelLocView.valueAction_(1);



	~trackFXVolView.valueAction_(0.12);
	~visibleSeqView.value_(0).doAction;



	// Ci-dessous pour obliger le slider lag & mix des fx ambisoniques avec reverb à prendre la valeur de défaut -> Pourquoi cela n'est pas fait automatiquement, même quand cette ligne est pas mise en dessous de ~makeFxColumn ?????????
	~nbOfServers.do { |s|
		(~fxTabCompDef5View[s]++~fxTabCompDef6View[s]++~fxTabCompDef7View[s]++~fxTabCompDef8View[s]).do { |i| i.valueAction_(1) };
	};



	// ~tabbedView.focus(/*1*/ if (~initSeqOrPerfMode == 0, {0}, {1}) );
	if (~initSeqOrPerfMode == 0, {~tabbedView.focus(0); ~currentTab = 0}, {~tabbedView.focus(1); ~currentTab = 3});



	~rtmDefault.(0,0); // Pour initialiser la protection sur le multiplicateur du rythme afin d'éviter qu'il soit trop bas; Voire une meilleure façon de l'initialiser...

	~configBeatsView.valueAction_(0);



	{

		if (~twister.notNil, {

			// {
			if (~twisterIndex2.isNil, {
				~twister.connect(TwisterDevice(\twister, MIDIClient.sources[~twisterIndex1]));  ~twisterInterface = 0;
				~seqABVisibleAllViewG.valueAction_(1); // ~tracksView.value_(0).doAction;

			},{
				if (~twisterIndex3.isNil, {
					~twister.connect(TwisterDevice(\twister, MIDIClient.sources[~twisterIndex1]));  ~twisterInterface = 0;
					~seqABVisibleAllViewG.valueAction_(1); // ~tracksView.value_(0).doAction;
					~twister2.connect(TwisterDevice(\twister2, MIDIClient.sources[~twisterIndex2])); ~twisterInterface2 = 1;
					if (~connectionsBuf.notNil, {~connectionsBuf.disconnect}); ~connectionsBufMake.(); ~connectionsBuf.connect;
				},{
					~twister.connect(TwisterDevice(\twister, MIDIClient.sources[~twisterIndex1]));  ~twisterInterface = 0;
					~seqABVisibleAllViewG.valueAction_(1); // ~tracksView.value_(0).doAction;
					~twister2.connect(TwisterDevice(\twister2, MIDIClient.sources[~twisterIndex2]));
					if (~connectionsBuf.notNil, {~connectionsBuf.disconnect}); ~connectionsBufMake.(); ~connectionsBuf.connect;
					~twister3.connect(TwisterDevice(\twister3, MIDIClient.sources[~twisterIndex3])); ~twisterInterface2 = 2;
					if (~connectionsLeg.notNil, {~connectionsLeg.disconnect}); ~connectionsLegMake.(); ~connectionsLeg.connect;
				});
			});

			~twister.knobs[8..15].do { |i, id|
				if (id > 2, {i.ledColor_(Color.magenta)}, {i.ledColor_(Color.green)});
			};
			~twister.knobs[8+(~tracksValue/2).asInteger].ledColor_(Color.red);

			// }.fork(AppClock);
		});



		// ~tracks.do { |tr| ~retriggerPresetViewG[tr].valueAction_(1) }; ~tracksView.valueAction_(0);
		// Hack Pour éviter que le textView du 1er preset des pistes du global soit coloré en rouge
		0.01.wait;
		~tracks.do { |tr| ~presetSeqTextViewG[tr][0].background_(Color.grey(0.3))/*.stringColor_(Color.white)*/ };



		~lemurConnected1 = ~prevLemurConnected1; ~lemurConnected2 = ~prevLemurConnected2; //  ~twister = ~prevTwister;



		// INIT PATTERN XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		~updateTime = 0.2 /*0.1*/; /*"_3_Init_Pattern_184.scd".loadRelative;*/ "_3_Init_Pattern_185.scd".loadRelative;



	}.fork(AppClock);

	"Be patient !!! GUI will show in a few seconds !!!";

	// }.bench; // à décommenter pour mesurer la rapidité d'affichage de la GUI et réorganistion des sons

}.value;

);
