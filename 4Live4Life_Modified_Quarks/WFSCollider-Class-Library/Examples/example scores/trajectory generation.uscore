UScore(
	UScore(
	UChain(0, 0.0, 20.0, 'grayNoise', [ 'klank', [ 'range', [ 220.0, 330.0 ], 'variation', [ 'lfo_sine', [ 'freq', 0.25 ] ], 'ringTime', [ 0.999999999995, 0.999999999995 ] ] ], [ 'wfsSource', [ 'point', [ 'expand', [ 'x', [ 'lfo_sine', [ 'freq', 0.1, 'range', [ -10.0, 10.0 ] ] ], 'y', [ 'lfo_sine', [ 'freq', 0.225, 'phase', 1.5707963267949, 'range', [ -10.0, 10.0 ] ] ] ] ], 'quality', 'better', 'u_fadeIn', 0.1, 'u_fadeOut', 1.0 ] ]), 
	UChain(0, 1.0, 20.0, 'grayNoise', [ 'klank', [ 'range', [ 330.0, 440.0 ], 'variation', [ 'lfo_sine', [ 'freq', 0.36056239257685 ] ], 'ringTime', [ 0.999999999995, 0.999999999995 ], 'seed', 12346 ] ], [ 'wfsSource', [ 'point', [ 'expand', [ 'x', [ 'lfo_sine', [ 'freq', 0.15, 'phase', 3.1415926535898, 'range', [ -10.0, 10.0 ] ] ], 'y', [ 'lfo_sine', [ 'freq', 0.075, 'phase', -1.5707963267949, 'range', [ -10.0, 10.0 ] ] ] ] ], 'quality', 'better', 'u_fadeIn', 0.1, 'u_fadeOut', 1.0 ] ]), 
	UChain(0, 2.0, 20.0, 'grayNoise', [ 'klank', [ 'range', [ 440.0, 660.0 ], 'variation', [ 'lfo_sine', [ 'freq', 0.52002095576298 ] ], 'ringTime', [ 0.999999999995, 0.999999999995 ], 'seed', 12347 ] ], [ 'wfsSource', [ 'point', [ 'expand', [ 'x', [ 'lfo_sine', [ 'freq', 0.2, 'phase', -0.78539816339745, 'range', [ -10.0, 10.0 ] ] ], 'y', [ 'lfo_sine', [ 'freq', 0.175, 'phase', -1.5707963267949, 'range', [ -10.0, 10.0 ] ] ] ] ], 'quality', 'better', 'u_fadeIn', 0.1, 'u_fadeOut', 1.0 ] ]), 
	UChain(0, 3.0, 20.0, 'grayNoise', [ 'klank', [ 'range', [ 660.0, 880.0 ], 'variation', [ 'lfo_sine', [ 'freq', 0.75 ] ], 'ringTime', [ 0.999999999995, 0.999999999995 ], 'seed', 12348 ] ], [ 'wfsSource', [ 'point', [ 'expand', [ 'x', [ 'lfo_sine', [ 'freq', 0.125, 'phase', -2.3561944901923, 'range', [ -10.0, 10.0 ] ] ], 'y', [ 'lfo_sine', [ 'freq', 0.25, 'phase', 2.3561944901923, 'range', [ -10.0, 10.0 ] ] ] ] ], 'quality', 'better', 'u_fadeIn', 0.1, 'u_fadeOut', 1.0 ] ]), 
	UMarker(0, 5.0, "about", nil, "The trajectories of the four events in this folder are created by combining sine wave functions for the x and y axes. This is done via the 'expand' UMap, which in turn are fed by 'lfo_sine' UMaps, each with different settings to create unique lissajous curves. The sound in this example is generated by feeding a 'grayNoise' unit to a 'klank' (resonant filter bank) unit.")).name_("lissajous"), 
	UScore(19.000000, 1.000000, 
	UChain(0, 0.0, 20.0, [ 'formant', [ 'freq', [ 'lfo_noise', [ 'freq', 20.0, 'type', 0, 'range', [ 5.0, 100.0 ] ] ], 'formant', [ 'lfo_noise', [ 'freq', 10.0, 'type', 0, 'range', [ 200.0, 1000.0 ] ] ], 'bw', [ 'line', [ 'a', 2.0000000000599, 'duration', 20.0 ] ], 'amp', 0.087076480723393 ] ], [ 'wfsSource', [ 'point', [ 'motion_trajectory', [ 'startPoint', Point(0.0, 5.0), 'startSpeed', [ 'random_trajectory', [ 'speed', 5.0, 'type', 0, 'lag', 0.0 ] ] ] ], 'quality', 'better', 'u_fadeIn', 0.1, 'u_fadeOut', 0.1 ] ]), 
	UChain(0, 1.0, 20.0, [ 'formant', [ 'freq', [ 'lfo_noise', [ 'freq', 20.0, 'type', 0, 'range', [ 5.0, 100.0 ] ] ], 'formant', [ 'lfo_noise', [ 'freq', 10.0, 'type', 0, 'range', [ 200.0, 1000.0 ] ] ], 'bw', [ 'line', [ 'a', 2.0000000000399, 'duration', 20.0 ] ], 'amp', 0.087076480723393 ] ], [ 'wfsSource', [ 'point', [ 'motion_trajectory', [ 'startPoint', Point(5.0, 6.1232339957368e-16), 'startSpeed', [ 'random_trajectory', [ 'speed', 5.0, 'type', 0, 'lag', 0.0 ] ] ] ], 'quality', 'better', 'u_fadeIn', 0.1, 'u_fadeOut', 0.1 ] ]), 
	UChain(0, 2.0, 20.0, [ 'formant', [ 'freq', [ 'lfo_noise', [ 'freq', 20.0, 'type', 0, 'range', [ 5.0, 100.0 ] ] ], 'formant', [ 'lfo_noise', [ 'freq', 10.0, 'type', 0, 'range', [ 200.0, 1000.0 ] ] ], 'bw', [ 'line', [ 'a', 2.00000000002, 'duration', 20.0 ] ], 'amp', 0.087076480723393 ] ], [ 'wfsSource', [ 'point', [ 'motion_trajectory', [ 'startPoint', Point(6.1232339957368e-16, -5.0), 'startSpeed', [ 'random_trajectory', [ 'speed', 5.0, 'type', 0, 'lag', 0.0 ] ] ] ], 'quality', 'better', 'u_fadeIn', 0.1, 'u_fadeOut', 0.1 ] ]), 
	UChain(0, 3.0, 20.0, [ 'formant', [ 'freq', [ 'lfo_noise', [ 'freq', 20.0, 'type', 0, 'range', [ 5.0, 100.0 ] ] ], 'formant', [ 'lfo_noise', [ 'freq', 10.0, 'type', 0, 'range', [ 200.0, 1000.0 ] ] ], 'bw', [ 'line', [ 'a', 2.0, 'duration', 20.0 ] ], 'amp', 0.087076480723393 ] ], [ 'wfsSource', [ 'point', [ 'motion_trajectory', [ 'startPoint', Point(-5.0, -1.2246467991474e-15), 'startSpeed', [ 'random_trajectory', [ 'speed', 5.0, 'type', 0, 'lag', 0.0 ] ] ] ], 'quality', 'better', 'u_fadeIn', 0.1, 'u_fadeOut', 0.1 ] ]), 
	UMarker(0.051253304380665, 5.0, "about", nil, "This example shows how to implement a random walk trajectory. It is done by feeding a normal 'random_trajectory' into the 'startSpeed' input of a 'motion_trajectory'. The 'startSpeed' input applies mathematical integration to the 'startSpeed', converting the normal random into a brownian motion. The 'motion_trajectory' also features a bouncing algorithm, which makes sure the positions stay within a confined area of 10x10m. You can experiment with the curvature by changing the 'type' of the 'random_trajectory'.
")).name_("random_walk"), 
	UScore(38.000000, 2.000000, 
	UChain(0.0, 0.0, 20.0, [ 'grainSoundFile', [ 'soundFile', MonoBufSndFile.newBasic("@resources/sounds/a11wlk01-44_1.aiff", 107520, 1, 44100, 0, nil, 1, false), 'pos', [ 'center_range', [ 'center', [ 'line', [ 'loop', 1 ] ], 'range', 0.001 ] ], 'density', 200.0, 'timeVar', 0.25, 'rateVar', 1.0, 'rateScale', 0.99956220806791, 'level', 0.01 ] ], [ 'combFilter', [ 'freq', 880.0 ] ], [ 'wfsSource', [ 'point', [ 'random_trajectory', [ 'speed', [ 'amp_follow', [ 'fromRange', [ 0.0, 0.01 ], 'toRange', [ 0.0, 0.5 ], 'curve', -1.3787465940055 ] ], 'lag', 0.0 ] ], 'quality', 'better', 'u_fadeIn', 1.0 ] ]), 
	UChain(0.0, 1.0, 20.0, [ 'grainSoundFile', [ 'soundFile', MonoBufSndFile.newBasic("@resources/sounds/a11wlk01-44_1.aiff", 107520, 1, 44100, 0, nil, 1, false), 'pos', [ 'center_range', [ 'center', [ 'line', [ 'duration', 12.0, 'loop', 1 ] ], 'range', 0.001 ] ], 'density', 200.0, 'timeVar', 0.25, 'rateVar', 1.0, 'rateScale', 0.99956220806791, 'level', 0.01 ] ], [ 'combFilter', [ 'freq', 1108.7305239075 ] ], [ 'wfsSource', [ 'point', [ 'random_trajectory', [ 'speed', [ 'amp_follow', [ 'fromRange', [ 0.0, 0.01 ], 'toRange', [ 0.0, 0.5 ], 'curve', -1.3787465940055 ] ], 'lag', 0.0 ] ], 'quality', 'better', 'u_fadeIn', 1.0 ] ]), 
	UChain(0.0, 2.0, 20.0, [ 'grainSoundFile', [ 'soundFile', MonoBufSndFile.newBasic("@resources/sounds/a11wlk01-44_1.aiff", 107520, 1, 44100, 0, nil, 1, false), 'pos', [ 'center_range', [ 'center', [ 'line', [ 'duration', 16.0, 'loop', 1 ] ], 'range', 0.001 ] ], 'density', 200.0, 'timeVar', 0.25, 'rateVar', 1.0, 'rateScale', 0.99956220806791, 'level', 0.01 ] ], [ 'combFilter', [ 'freq', 1396.912925732 ] ], [ 'wfsSource', [ 'point', [ 'random_trajectory', [ 'speed', [ 'amp_follow', [ 'fromRange', [ 0.0, 0.01 ], 'toRange', [ 0.0, 0.5 ], 'curve', -1.3787465940055 ] ], 'lag', 0.0 ] ], 'quality', 'better', 'u_fadeIn', 1.0 ] ]), 
	UChain(0.0, 3.0, 20.0, [ 'grainSoundFile', [ 'soundFile', MonoBufSndFile.newBasic("@resources/sounds/a11wlk01-44_1.aiff", 107520, 1, 44100, 0, nil, 1, false), 'pos', [ 'center_range', [ 'center', [ 'line', [ 'duration', 20.0, 'loop', 1 ] ], 'range', 0.001 ] ], 'density', 200.0, 'timeVar', 0.25, 'rateVar', 1.0, 'rateScale', 0.99956220806791, 'level', 0.01 ] ], [ 'combFilter', [ 'freq', 1567.981743927 ] ], [ 'wfsSource', [ 'point', [ 'random_trajectory', [ 'speed', [ 'amp_follow', [ 'fromRange', [ 0.0, 0.01 ], 'toRange', [ 0.0, 0.5 ], 'curve', -1.3787465940055 ] ], 'lag', 0.0 ] ], 'quality', 'better', 'u_fadeIn', 1.0 ] ]), 
	UMarker(0, 5.0, "about", nil, "In this example the amplitude of the sound source is measured and used to determine the speed of the movement. This is done by connection a 'amp_follow' UMap to the 'speed' input of a 'random_trajectory'. The source sound is a combination of granular synthesis and a comb filter. The sources in each of the four events have amplitude peaks at different moments. When the sound level of a source exceeds the minimum of 'fromRange' in the 'amp_follow' UMap, the speed will start increasing. When it is below this value, the point will stand still. So the points only move when there is a certain amount of sound.
")).name_("amp_to_speed"), 
	UScore(57.750000, 3.000000, 
	UChain(0.0, 0.0, 20.0, [ 'sync_saw', [ 'syncFreq', [ 'lfo_sine', [ 'freq', 15.0, 'phase', -1.6634864731735, 'range', [ 220.0, 440.0 ] ] ], 'sawFreq', [ 'lfo_sine', [ 'freq', 10.0, 'range', [ 2.0, 1000.0 ] ] ], 'amp', 0.074491936212939 ] ], [ 'highPass', [ 'freq', [ 'lfo_sine', [ 'freq', 0.08, 'phase', -1.5707963267949, 'range', [ 200.0, 4000.0 ] ] ], 'rq', 0.5 ] ], [ 'lowPass', [ 'freq', [ 'lfo_sine', [ 'freq', 4.0, 'range', [ 500.0, 1500.0 ] ] ], 'rq', 0.5 ] ], [ 'wfsSource', [ 'point', [ 'line_trajectory', [ 'a', Point(8.4852813742386, 8.4852813742386), 'b', [ 'circle_trajectory', [ 'speed', 0.8, 'clockwise', false, 'center', Point(1.836970198721e-16, -3.0), 'radius', Point(2, 2) ] ], 'easeIn', 0.5, 'loop', 2 ] ], 'quality', 'better' ] ]), 
	UChain(0.0, 1.0, 20.0, [ 'sync_saw', [ 'syncFreq', [ 'lfo_sine', [ 'freq', 17.78446652245, 'phase', -1.6634864731735, 'range', [ 220.0, 440.0 ] ] ], 'sawFreq', [ 'lfo_sine', [ 'freq', 12.599210498949, 'range', [ 2.0, 1000.0 ] ] ], 'amp', 0.074491936212939 ] ], [ 'highPass', [ 'freq', [ 'lfo_sine', [ 'freq', 0.091577139404267, 'range', [ 200.0, 4000.0 ] ] ], 'rq', 0.5 ] ], [ 'lowPass', [ 'freq', [ 'lfo_sine', [ 'freq', 4.5788569702133, 'phase', 1.0471975511966, 'range', [ 500.0, 1500.0 ] ] ], 'rq', 0.5 ] ], [ 'wfsSource', [ 'point', [ 'line_trajectory', [ 'a', Point(8.4852813742386, -8.4852813742386), 'b', [ 'circle_trajectory', [ 'speed', 0.91594838757863, 'startAngle', 1.5707963267949, 'clockwise', false, 'center', Point(-3.0, -1.836970198721e-16), 'radius', Point(2, 2) ] ], 'easeIn', 0.50000000000667, 'loop', 2 ] ], 'quality', 'better' ] ]), 
	UChain(0.0, 2.0, 20.0, [ 'sync_saw', [ 'syncFreq', [ 'lfo_sine', [ 'freq', 21.085816632544, 'phase', -1.6634864731735, 'range', [ 220.0, 440.0 ] ] ], 'sawFreq', [ 'lfo_sine', [ 'freq', 15.874010519682, 'range', [ 2.0, 1000.0 ] ] ], 'amp', 0.074491936212939 ] ], [ 'highPass', [ 'freq', [ 'lfo_sine', [ 'freq', 0.10482965576836, 'phase', 1.5707963267949, 'range', [ 200.0, 4000.0 ] ] ], 'rq', 0.5 ] ], [ 'lowPass', [ 'freq', [ 'lfo_sine', [ 'freq', 5.2414827884178, 'phase', 2.0943951023932, 'range', [ 500.0, 1500.0 ] ] ], 'rq', 0.5 ] ], [ 'wfsSource', [ 'point', [ 'line_trajectory', [ 'a', Point(-8.4852813742386, -8.4852813742386), 'b', [ 'circle_trajectory', [ 'speed', 1.0484901605608, 'startAngle', 3.1415926535898, 'clockwise', false, 'center', Point(-1.0718754395722e-15, 3.0), 'radius', Point(2, 2) ] ], 'easeIn', 0.50000000001333, 'loop', 2 ] ], 'quality', 'better' ] ]), 
	UChain(0.0, 3.0, 20.0, [ 'sync_saw', [ 'syncFreq', [ 'lfo_sine', [ 'freq', 25.0, 'phase', -1.6634864731735, 'range', [ 220.0, 440.0 ] ] ], 'sawFreq', [ 'lfo_sine', [ 'freq', 20.0, 'range', [ 2.0, 1000.0 ] ] ], 'amp', 0.074491936212939 ] ], [ 'highPass', [ 'freq', [ 'lfo_sine', [ 'freq', 0.12, 'phase', 3.1415926535898, 'range', [ 200.0, 4000.0 ] ] ], 'rq', 0.5 ] ], [ 'lowPass', [ 'freq', [ 'lfo_sine', [ 'freq', 6.0, 'phase', 3.1415926535898, 'range', [ 500.0, 1500.0 ] ] ], 'rq', 0.5 ] ], [ 'wfsSource', [ 'point', [ 'line_trajectory', [ 'a', Point(-8.4852813742386, 8.4852813742386), 'b', [ 'circle_trajectory', [ 'speed', 1.2, 'startAngle', -1.5707963267949, 'clockwise', false, 'center', Point(3.0, 1.0718754395722e-15), 'radius', Point(2, 2) ] ], 'easeIn', 0.50000000002, 'loop', 2 ] ], 'quality', 'better' ] ]), 
	UMarker(0.0, 5.0, "about", nil, "In this example an interpolation is made between a circular path and a fixed position. Each of the four points start at a fixed position in the corner, then change into a circular motion in the center, and then change back again to the fixed position. It is done with the 'line_trajectory' UMap. The start and end positions ('a' and 'b') of this UMap can be UMaps themselves, resulting in a linear interpolation between the two. In this case the 'b' input receives a 'circle_trajectory' UMap. The 'line_trajectory' is set to 'alternate' between 'a' and 'b'  in 10 seconds. Since the duration of each event in this example is exactly 20 seconds, the points are all back at 'a' at the end. The sound sources in this example are a combination of a 'sync_saw' and 'highPass' / 'lowPass' units, all modulated with various 'lfo_sine' UMaps.")).name_("interpolate"), 
	UMarker(0, 3.0, "about", nil, "This score contains four examples of generating trajectories, using various UMap combinations. Before playing the score please choose \"WFS Position tracker\" from the \"View\" menu, to see the generated movement displayed in realtime.

Each of the four (white) folder events contains a set of events, and a marker with an explanation. Double click a folder event to see the contents.")).name_("trajectory generation")
